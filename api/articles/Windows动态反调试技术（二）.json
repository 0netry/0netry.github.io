{"title":"Windows动态反调试技术（二）","uid":"bd414604d17df76b597f4081d3f02f14","slug":"Windows动态反调试技术（二）","date":"2025-06-11T13:05:26.000Z","updated":"2025-06-09T21:26:58.273Z","comments":true,"path":"api/articles/Windows动态反调试技术（二）.json","keywords":null,"cover":[],"content":"<h1 id=\"单步执行\"><a href=\"#单步执行\" class=\"headerlink\" title=\"单步执行\"></a>单步执行</h1><p>TF值设置为1时，CPU将进入单步执行（Single Step）模式。单步执行模式中，CPU执行1条指令后即触发1个EXCEPTION_SINGLE_STEP异常，然后陷阱标志会自动清零（0）。该EXCEPTION_SINGLE_STEP异常可以与SEH技法结合，在反调试技术中用于探测调试器。</p>\n<h2 id=\"基于Windows10的练习\"><a href=\"#基于Windows10的练习\" class=\"headerlink\" title=\"基于Windows10的练习\"></a><strong>基于Windows10的练习</strong></h2><p>1.使用ollydbg打开DynAD_SingleStep.exe(调试前先取消ollydbg忽略的异常选项)，并转到401000处，下面是程序反调试的代码流</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00401000     push ebp                                                   </span><br><span class=\"line\">00401001     mov ebp,esp                                                </span><br><span class=\"line\">00401003     push ebx                                                   </span><br><span class=\"line\">00401004     push dynad_singlestep.4099A0                               </span><br><span class=\"line\">00401009     call dynad_singlestep.401087                               </span><br><span class=\"line\">0040100E     add esp,4 </span><br><span class=\"line\"></span><br><span class=\"line\">; 注册SEH                                                 </span><br><span class=\"line\">00401011     push dynad_singlestep.401036                               </span><br><span class=\"line\">00401016     push dword ptr fs:[0]                                      </span><br><span class=\"line\">0040101D     mov dword ptr fs:[0],esp </span><br><span class=\"line\"></span><br><span class=\"line\">; 因无法直接修改EFLAGS，故通过栈修改                                   </span><br><span class=\"line\">00401024     pushfd                          ; 将EFLAGS寄存器的值压入栈                            </span><br><span class=\"line\">00401025     or dword ptr ss:[esp],100       ; 将TF位设置为1                          </span><br><span class=\"line\">0040102D     popfd                           ; 将修改后的TF值存入EFLAGS     </span><br><span class=\"line\"></span><br><span class=\"line\">; 执行下列指令后触发EXCEPTION_SINGLE_STEP异常</span><br><span class=\"line\">; 若为正常运行，则运行前面注册的SEH（401036）</span><br><span class=\"line\">; 若为调试运行，则继续执行以下指令                      </span><br><span class=\"line\">0040102E     nop</span><br><span class=\"line\"></span><br><span class=\"line\">; 调试运行时继续执行以下指令                                                        </span><br><span class=\"line\">0040102F     mov eax,FFFFFFFF                                           </span><br><span class=\"line\">00401034     jmp eax</span><br><span class=\"line\"></span><br><span class=\"line\">;SEH</span><br><span class=\"line\">00401036     mov eax,dword ptr ss:[esp+C]      ; [esp+C] = pContext                       </span><br><span class=\"line\">0040103B     mov ebx,dynad_singlestep.40104A                            </span><br><span class=\"line\">00401040     mov dword ptr ds:[eax+B8],ebx     ; pContext-&gt;EIP=40104A                      00401047     xor eax,eax                                                </span><br><span class=\"line\">00401049     ret                                                        </span><br><span class=\"line\">0040104A     pop dword ptr fs:[0]                                       </span><br><span class=\"line\">00401051     add esp,4                                                  </span><br><span class=\"line\">00401054     push dynad_singlestep.4099BC                               </span><br><span class=\"line\">00401059     call dynad_singlestep.401087                               </span><br><span class=\"line\">0040105E     add esp,4                                                  </span><br><span class=\"line\">00401061     pop ebx                                                    </span><br><span class=\"line\">00401062     pop ebp                                                    </span><br><span class=\"line\">00401063     ret                                                        </span><br></pre></td></tr></table></figure>\n\n<p>2.不能直接修改EFLAGS，需要借助PUSHFD&#x2F;POPFD指令与OR运算指令修改陷阱标志的值。如下图中原先EFLAGS的值为212，经过OR运算后编程312，陷阱标志TF的值被设置为1，此时CPU进入单步执行模式，下面执行40102E处的nop指令（StepInto、StepOver、Run中任一个）</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%BA%8C%EF%BC%89/%E9%99%B7%E9%98%B1%E6%A0%87%E5%BF%97/%E5%8D%95%E6%AD%A5%E6%89%A7%E8%A1%8C/Win10_DynAD_SingleStep_%E4%BF%AE%E6%94%B9EFLAGS.png\"></p>\n<p>3.CPU在单步执行模式（陷阱标志TF为1）下执行1条指令（不管何种指令）就会触发EXCEPTION_SINGLE_STEP异常。若为调试运行时，发生异常时则不会跳到SEH执行，而是继续执行40102F处的代码，进程非正常终止。若为非调试运行，程序就会跳转到401036处执行SEH代码，在SEH中修改EIP为40104A，当SEH处理结束后就会跳转到40104A执行。</p>\n<p>1）调试运行时</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%BA%8C%EF%BC%89/%E9%99%B7%E9%98%B1%E6%A0%87%E5%BF%97/%E5%8D%95%E6%AD%A5%E6%89%A7%E8%A1%8C/Win10_DynAD_SingleStep_%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8C%E6%97%B6.png\"></p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%BA%8C%EF%BC%89/%E9%99%B7%E9%98%B1%E6%A0%87%E5%BF%97/%E5%8D%95%E6%AD%A5%E6%89%A7%E8%A1%8C/Win10_DynAD_SingleStep_%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8C%E6%97%B6%E8%BF%9B%E7%A8%8B%E9%9D%9E%E6%AD%A3%E5%B8%B8%E7%BB%88%E6%AD%A2.png\"></p>\n<p>2）非调试运行时</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%BA%8C%EF%BC%89/%E9%99%B7%E9%98%B1%E6%A0%87%E5%BF%97/%E5%8D%95%E6%AD%A5%E6%89%A7%E8%A1%8C/Win10_DynAD_SingleStep_%E9%9D%9E%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8C%E6%97%B6.png\"></p>\n<p>4.破解方法：修改调试器选项（忽略EXCEPTION_SINGLE_STEP异常）</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%BA%8C%EF%BC%89/%E9%99%B7%E9%98%B1%E6%A0%87%E5%BF%97/%E5%8D%95%E6%AD%A5%E6%89%A7%E8%A1%8C/Win10_DynAD_SingleStep_%E4%BF%AE%E6%94%B9%E5%BF%BD%E7%95%A5EXCEPTION_SINGLE_STEP%E5%BC%82%E5%B8%B8.png\"></p>\n<h1 id=\"INT-2D\"><a href=\"#INT-2D\" class=\"headerlink\" title=\"INT 2D\"></a>INT 2D</h1><p>INT 2D原为内核模式中用来触发断点异常的指令，也可以在用户模式下触发异常。但程序调试运行时不会触发异常，只是忽略。这种在正常运行与调试运行中表现出的不同可以很好地应用于反调试技术。下面调试INT2D指令，了解其几个有趣的特征。</p>\n<p>1）忽略下条指令的第一个字节</p>\n<p>在调试模式中执行完INT 2D指令后（Steplnt&#x2F;StepOver），下条指令的第一个字节将被忽略，后一个字节会被识别为新的指令继续执行。</p>\n<p>![](.&#x2F;陷阱标志&#x2F;INT_2D&#x2F;执行INT 2D前的正常指令.png)</p>\n<p>在上图中40101E地址处的INT 2D指令（CD 2D）行完后，401020地址处的MOV EAX,5DEB指令（B8 EB5D0000）中，第一个字节B8将被忽略</p>\n<p>![](.&#x2F;陷阱标志&#x2F;INT_2D&#x2F;执行INT 2D后变化的指令.png)</p>\n<p>执行INT 2D指令后，401021地址处的指令被重新解析为2条指令：JMP 401080（EB 5D）、ADD BYTE PTR DS:[EAX],AL（0000），它们完全不同于原指令MOV EAX,5DEB（B8 EB5D0000）。像这样，基于INT 2D的反调试技术能够形成较强的代码混淆（Obfuscated Code）效果，从而在一定程度上防止代码逆向分析人员调试程序。</p>\n<p>2）一直运行到断点处</p>\n<p>INT 2D指令的另一个特征是，使用StepInto或StepOver命令跟踪INT 2D指令时，程序不会停在其下条指令开始的地方，而是一直运行，直到遇到断点，就像使用RUN命令运行程序一样。</p>\n<p>原因在于执行完INT 2D指令后，原有的代码字节顺序被打乱了，也就是说，若指令在程序执行过程中改变，则程序不能单步暂停，而是一直执行，可以将其视为一种BUG。所以执行完INT 2D指令后，要想停止跟踪代码，需要事先在相应地址处设置断点。</p>\n<h2 id=\"基于Windows10的练习-1\"><a href=\"#基于Windows10的练习-1\" class=\"headerlink\" title=\"基于Windows10的练习\"></a><strong>基于Windows10的练习</strong></h2><p>1.用ollydbg打开DynAD_INT2D.exe，并转到401000处，代码流程如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00401000 | 55                       | push ebp                                </span><br><span class=\"line\">00401001 | 8BEC                     | mov ebp,esp                             </span><br><span class=\"line\">00401003 | 51                       | push ecx                                </span><br><span class=\"line\">00401004 | C745 FC 00000000         | mov dword ptr ss:[ebp-4],0 </span><br><span class=\"line\"></span><br><span class=\"line\">; 安装SEH             </span><br><span class=\"line\">0040100B | 68 2A104000              | push dynad_int2d.40102A                 </span><br><span class=\"line\">00401010 | 64:FF35 00000000         | push dword ptr fs:[0]                   </span><br><span class=\"line\">00401017 | 64:8925 00000000         | mov dword ptr fs:[0],esp </span><br><span class=\"line\"></span><br><span class=\"line\">; 触发异常</span><br><span class=\"line\">; 若非调试运行，则会转去运行SEH(40102A)               </span><br><span class=\"line\">0040101E | CD 2D                    | int 2D</span><br><span class=\"line\"></span><br><span class=\"line\">; 若调试运行，则跳过一个字节，此处会跳过nop(90)指令运行401021处的指令                             </span><br><span class=\"line\">00401020 | 90                       | nop</span><br><span class=\"line\">; 调试中dword ptr ss:[ebp-4]被设置为1</span><br><span class=\"line\">00401021 | C745 FC 01000000         | mov dword ptr ss:[ebp-4],1                         </span><br><span class=\"line\">00401028 | EB 1A                    | jmp dynad_int2d.401044</span><br><span class=\"line\"></span><br><span class=\"line\">; SEH   </span><br><span class=\"line\">; [esp+C]=pContext</span><br><span class=\"line\">0040102A | 36:8B4424 0C             | mov eax,dword ptr ss:[esp+C]                    </span><br><span class=\"line\">; [eax+B8]=pContext-&gt;EIP=dynad_int2d.401044</span><br><span class=\"line\">0040102F | 3E:C780 B8000000 4410400 | mov dword ptr ds:[eax+B8],dynad_int2d.401044</span><br><span class=\"line\">; 正常运行dword ptr ss:[ebp-4]被设置为0</span><br><span class=\"line\">0040103A | C745 FC 00000000         | mov dword ptr ss:[ebp-4],0                     </span><br><span class=\"line\">00401041 | 33C0                     | xor eax,eax                             </span><br><span class=\"line\">00401043 | C3                       | ret</span><br><span class=\"line\">                                     </span><br><span class=\"line\">00401044 | 64:8F05 00000000         | pop dword ptr fs:[0]                    </span><br><span class=\"line\">0040104B | 83C4 04                  | add esp,4         </span><br><span class=\"line\">; 4099A0:&quot;Trap Flag (INT 2D)\\n&quot;</span><br><span class=\"line\">0040104E | 68 A0994000              | push dynad_int2d.4099A0                        </span><br><span class=\"line\">00401053 | E8 4F000000              | call dynad_int2d.4010A7                        </span><br><span class=\"line\">00401058 | 83C4 04                  | add esp,4</span><br><span class=\"line\"></span><br><span class=\"line\">;根据dword ptr ss:[ebp-4]的值来判断是否被调试                                      </span><br><span class=\"line\">0040105B | 837D FC 00               | cmp dword ptr ss:[ebp-4],0                     </span><br><span class=\"line\">0040105F | 74 0F                    | je dynad_int2d.401070</span><br><span class=\"line\">; 4099B4:&quot;  =&gt; Debugging!!!\\n\\n&quot;</span><br><span class=\"line\">00401061 | 68 B4994000              | push dynad_int2d.4099B4                        </span><br><span class=\"line\">00401066 | E8 3C000000              | call dynad_int2d.4010A7                        </span><br><span class=\"line\">0040106B | 83C4 04                  | add esp,4                                      </span><br><span class=\"line\">0040106E | EB 0D                    | jmp dynad_int2d.40107D </span><br><span class=\"line\">; 4099C8:&quot;  =&gt; Not debugging...\\n\\n&quot;</span><br><span class=\"line\">00401070 | 68 C8994000              | push dynad_int2d.4099C8                        </span><br><span class=\"line\">00401075 | E8 2D000000              | call dynad_int2d.4010A7                        </span><br><span class=\"line\">0040107A | 83C4 04                  | add esp,4                                      </span><br><span class=\"line\">0040107D | 8BE5                     | mov esp,ebp                                    </span><br><span class=\"line\">0040107F | 5D                       | pop ebp                                        </span><br><span class=\"line\">00401080 | C3                       | ret                                            </span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%BA%8C%EF%BC%89/%E9%99%B7%E9%98%B1%E6%A0%87%E5%BF%97/INT_2D/Win10_DynAD_INT2D_%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E4%B8%8E%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B5%81.png\"></p>\n<p>1）从上面代码和流程图可以看出，程序正常运行（非调试运行）时，执行完40101E地址处的INT 2D指令后，发生异常，转去运行SEH （40102A）。在异常处理器中先把EIP值修改为401044，然后将［EBP-41]变量（局部变量[EBP-4]是BOOL类型变量，用来检测是否存在调试器）的值设置为0（FALSE）。然后转到401044地址处继续执行，最后执行40105B地址处的CMP&#x2F;JE条件分支指令，向控制台输出字符串（Not debugging）</p>\n<p>2）程序调试运行时，执行INT 2D指令后不会运行SEH， 而是跳过1个字节（90），继续执行401021地址处的MOV指令，将［EBP-4］变量设置为1（TRUE），然后跳转到401044地址处继续执行，向控制台输出 “Debugging” 字符串。</p>\n<p>2.破解方法</p>\n<p>在程序调试过程中有时需要跟进SEH逐行分析代码，此时就想要一种方法使程序执行到SEH。利用陷阱标志能使程序轻松进入SEH执行。</p>\n<p>1）首先 ，修改调试器选项使之忽略EXCEPTION_SINGLE_STEP异常，然后在40101E处的INT 2D下断点并运行，此时调试器就会在INT 2D指令处暂停，然后在已注册过的SEH（40102A）处设置断点</p>\n<p>![](.&#x2F;陷阱标志&#x2F;INT_2D&#x2F;Win10_DynAD_INT2D_暂停于INT 2D指令处.png)</p>\n<p>2）将TF的值设置为1，此时CPU进入单步模式。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%BA%8C%EF%BC%89/%E9%99%B7%E9%98%B1%E6%A0%87%E5%BF%97/INT_2D/Win10_DynAD_INT2D_%E8%AE%BE%E7%BD%AETF%E4%B8%BA1%E4%BD%BFCPU%E8%BF%9B%E5%85%A5%E5%8D%95%E6%AD%A5%E6%A8%A1%E5%BC%8F.png\"></p>\n<p>3）在单步模式下，CPU执行1条指令即触发异常，然后进入SEH处理。接着按StepInto或StepOver执行40101E处的INT 2D指令，但是此时并不能触发异常（在前面的DynAD_SingleStep.exe示例中我们知道，CPU在单步模式下执行1条指令即触发异常，且TF值会清零），原因在于，INT 2D指令原为内核指令，在用户模式的调试器中不会被识别为正常指令。因此调试器在401020地址处的NOP指令处暂停。TF&#x3D;0时，跟踪INT 2D指令后，其下条指令的第一个字节会被忽略，程序继续执行；但TF&#x3D;1时，其后面的1个字节不会被忽略，代码仍被正常识别。接下来，设置TF为1，然后按F7键（StepInto）或F8键（StepOver）执行NOP指令。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%BA%8C%EF%BC%89/%E9%99%B7%E9%98%B1%E6%A0%87%E5%BF%97/INT_2D/Win10_DynAD_INT2D_%E6%89%A7%E8%A1%8C%E5%88%B0NOP%E6%97%B6%E8%AE%BE%E7%BD%AETF%E4%B8%BA1%E4%BD%BFCPU%E5%86%8D%E6%AC%A1%E8%BF%9B%E5%85%A5%E5%8D%95%E6%AD%A5%E6%A8%A1%E5%BC%8F.png\"></p>\n<p>4）在单步模式下执行正常指令NOP后，就会触发异常，调试暂停在设有断点的SEH处，同时TF清零。这样就能进入SEH进行逐行分析了。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%BA%8C%EF%BC%89/%E9%99%B7%E9%98%B1%E6%A0%87%E5%BF%97/INT_2D/Win10_DynAD_INT2D_%E8%BF%9B%E5%85%A5SEH.png\"></p>\n<h1 id=\"0xCC\"><a href=\"#0xCC\" class=\"headerlink\" title=\"0xCC\"></a>0xCC</h1><p>在程序调试过程中，一般会设置许多软件断点。断点对应的x86指令为”0xCC”。若能检测到该指令，即可判断程序是否处于调试状态。基于这一想法的反调试技术称为”0xCC探测”技术。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>但0xCC既可以用作操作码，也可以用作移位值、立即数、数据、地址等，所以，在进程内存的代码区域中只扫描0xCC的做法并不可靠。</p></blockquote>\n<h2 id=\"API断点\"><a href=\"#API断点\" class=\"headerlink\" title=\"API断点\"></a>API断点</h2><p>若只调试程序中的某个局部功能，一个比较快的方法是先在程序要调用的API处设置好断点，再运行程序。运行暂停在相应断点处后，再查看存储在栈中的返回地址。“跟踪返回地址调试相应部分”的方式能够大幅缩小代码调试范围。反调试技术中，探测这些设置在API上的断点就能准确判断当前进程是否处于调试状态。一般而言，断点都没置在API代码的开始部分，所以，只要检测API代码的第一个字节是否为CC即可判断出当前进程是否处于调试之中。</p>\n<p><strong>破解之法</strong></p>\n<p>针对这种反调试技术的行之有效的方法是，向系统API设置断点时尽量避开第一个字节，将之设置在代码的中间部分。此外，设置硬件断点也能避开该反调试技术。</p>\n<h2 id=\"比较校验和\"><a href=\"#比较校验和\" class=\"headerlink\" title=\"比较校验和\"></a>比较校验和</h2><p>检测代码中设置的软件断点的另一个方法是，比较特定代码区域的校验和（Checksum）值。<br>比如，假定程序中401000~401070地址区域的校验和值为0x12345678，在该代码区域中调试时，必然会设置一些断点（0xCC），如此一来，新的校验和值就与原值不一样了。像这样，比较校验和值即可判断进程是否处于调试状态。</p>\n<h3 id=\"基于Windows10的练习-2\"><a href=\"#基于Windows10的练习-2\" class=\"headerlink\" title=\"基于Windows10的练习\"></a><strong>基于Windows10的练习</strong></h3><p>1.用x32dbg打开DynAD_Checksum.exe，并转到401000处，代码流程如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00401000      push ebp                                       </span><br><span class=\"line\">00401001      mov ebp,esp                                    </span><br><span class=\"line\">00401003      push ecx                                       </span><br><span class=\"line\">00401004      push ebx                                       </span><br><span class=\"line\">00401005      push esi</span><br><span class=\"line\">; 4099A0:&quot;Checksum\\n&quot;                                        </span><br><span class=\"line\">00401006      push dynad_checksum.4099A0      </span><br><span class=\"line\">; dword ptr ss:[ebp-4]用于判断是否处于调试中的标志              </span><br><span class=\"line\">0040100B      mov dword ptr ss:[ebp-4],0                     </span><br><span class=\"line\">00401012      call dynad_checksum.401087                     </span><br><span class=\"line\">00401017      add esp,4  </span><br><span class=\"line\">; 求校验和值的循环                                    </span><br><span class=\"line\">0040101A      mov ecx,dynad_checksum.401070                  </span><br><span class=\"line\">0040101F      mov esi,dynad_checksum.401000                  </span><br><span class=\"line\">00401024      sub ecx,esi                                    </span><br><span class=\"line\">00401026      xor eax,eax                                    </span><br><span class=\"line\">00401028      xor ebx,ebx                                    </span><br><span class=\"line\">0040102A      movzx ebx,byte ptr ds:[esi]                    </span><br><span class=\"line\">0040102E      add eax,ebx                                    </span><br><span class=\"line\">00401030      rol eax,1                                      </span><br><span class=\"line\">00401032      inc esi                                        </span><br><span class=\"line\">00401033      loop dynad_checksum.40102A</span><br><span class=\"line\"></span><br><span class=\"line\">; 求得的校验和值与原值比较                     </span><br><span class=\"line\">00401035      cmp eax,dword ptr ds:[40BDC0]</span><br><span class=\"line\">; 校验和值一致，则跳转到401044                  </span><br><span class=\"line\">0040103B      je dynad_checksum.401044</span><br><span class=\"line\">; 校验和值不一致，则设置dword ptr ss:[ebp-4]为1                       </span><br><span class=\"line\">0040103D      mov dword ptr ss:[ebp-4],1</span><br><span class=\"line\"></span><br><span class=\"line\">;根据dword ptr ss:[ebp-4]的值来判断是否被调试，0表示没有被调试，1表示在调试中                     </span><br><span class=\"line\">00401044      cmp dword ptr ss:[ebp-4],0                     </span><br><span class=\"line\">00401048      pop esi                                        </span><br><span class=\"line\">00401049      pop ebx                                        </span><br><span class=\"line\">0040104A      je dynad_checksum.40105D                       </span><br><span class=\"line\">; 4099AC:&quot;  =&gt; Debugging!!!\\n\\n&quot;</span><br><span class=\"line\">0040104C      push dynad_checksum.4099AC                     </span><br><span class=\"line\">00401051      call dynad_checksum.401087                     </span><br><span class=\"line\">00401056      add esp,4                                      </span><br><span class=\"line\">00401059      mov esp,ebp                                    </span><br><span class=\"line\">0040105B      pop ebp                                        </span><br><span class=\"line\">0040105C      ret                                            </span><br><span class=\"line\">; 4099C0:&quot;  =&gt; Not debugging...\\n\\n&quot;</span><br><span class=\"line\">0040105D      push dynad_checksum.4099C0                     </span><br><span class=\"line\">00401062      call dynad_checksum.401087                     </span><br><span class=\"line\">00401067      add esp,4                                      </span><br><span class=\"line\">0040106A      mov esp,ebp                                    </span><br><span class=\"line\">0040106C      pop ebp                                        </span><br><span class=\"line\">0040106D      ret                                            </span><br></pre></td></tr></table></figure>\n\n<p>40102A地址处ESI的初始值为401000（参考40101F地址处的MOV指令），而ECX被用作LoopCount（循环计数），其值为70（参考401024地址处的SUB指令）。代码中的循环用来计算401000<del>40106F区域的校验和值，先读取1个字节值，再执行ADD与ROL指令计算，然后将值保存到EAX寄存器（循环次数就是循环计数）。然后与原值（代码开发时计算的校验和值保存在[40BDC0]中）比较，若不同，则表明401000</del>40106F代码区域中设有断点，或者代码已被修改。</p>\n<p><strong>破解之法</strong></p>\n<p>从理论上讲，只要不在计算CRC的代码区域中设置断点或修改其中代码，基于校验和的反调试技术就会失效。但这本身也可能成反调试技术觊觎的地方（因为调试变得更加困难）。因此，极好的破解方法是修改CRC比较语句。比如在前面的示例中，只要将40103B地址处的指令修改为JMP 40105D即可。当然也可以在调试器中强制修改要跳转（JMP）的地址。与其他反调试技术类似，基于校验和比校的反调试代码会巧妙隐藏于程序各处，可能存在数十个乃至数百个比较校验和的代码，这大大增加了破解难度，调试自然也变得困难多了。</p>\n<p>如下图通过修改ZF标志已实现比较检验和后跳转到401044从而绕过反调试：</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%BA%8C%EF%BC%89/0xCC%E6%8E%A2%E6%B5%8B/%E6%AF%94%E8%BE%83%E6%A0%A1%E9%AA%8C%E5%92%8C/Win10_DynAD_Checksum_%E4%BF%AE%E6%94%B9ZF%E6%A0%87%E5%BF%97%E5%B7%B2%E7%BB%95%E8%BF%87%E6%A0%A1%E9%AA%8C%E5%92%8C%E6%AF%94%E8%BE%83%E5%90%8E%E7%9A%84%E8%B7%B3%E8%BD%AC.png\"></p>\n","feature":true,"text":"单步执行TF值设置为1时，CPU将进入单步执行（Single Step）模式。单步执行模式中，CPU执行1条指令后即触发1个EXCEPTION_SINGLE_S...","permalink":"/post/Windows动态反调试技术（二）","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":14,"path":"api/tags/逆向.json"},{"name":"Windows动态反调试技术","slug":"Windows动态反调试技术","count":2,"path":"api/tags/Windows动态反调试技术.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E6%AD%A5%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">单步执行</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8EWindows10%E7%9A%84%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">基于Windows10的练习</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#INT-2D\"><span class=\"toc-text\">INT 2D</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8EWindows10%E7%9A%84%E7%BB%83%E4%B9%A0-1\"><span class=\"toc-text\">基于Windows10的练习</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0xCC\"><span class=\"toc-text\">0xCC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#API%E6%96%AD%E7%82%B9\"><span class=\"toc-text\">API断点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AF%94%E8%BE%83%E6%A0%A1%E9%AA%8C%E5%92%8C\"><span class=\"toc-text\">比较校验和</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8EWindows10%E7%9A%84%E7%BB%83%E4%B9%A0-2\"><span class=\"toc-text\">基于Windows10的练习</span></a></li></ol></li></ol></li></ol>","author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Windows动态反调试技术（一）","uid":"744ee437e256eacc7e89be203fb836fd","slug":"Windows动态反调试技术（一）","date":"2025-07-09T13:39:34.000Z","updated":"2025-06-09T21:26:29.686Z","comments":true,"path":"api/articles/Windows动态反调试技术（一）.json","keywords":null,"cover":[],"text":"异常SetUnhandledExceptionFilter()进程中发生异常时，若SEH未处理或注册的SEH根本不存在，此时会调用执行系统的kernel32!U...","permalink":"/post/Windows动态反调试技术（一）","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":14,"path":"api/tags/逆向.json"},{"name":"Windows动态反调试技术","slug":"Windows动态反调试技术","count":2,"path":"api/tags/Windows动态反调试技术.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"某白加黑木马样本分析","uid":"d8609f7faf5edcbbc1a1648becebe73e","slug":"某白加黑木马样本分析","date":"2025-05-28T05:39:13.000Z","updated":"2025-06-05T12:27:57.863Z","comments":true,"path":"api/articles/某白加黑木马样本分析.json","keywords":null,"cover":[],"text":"一、概述样本基本信息（4个文件）样本名称：a5c0Lm.exe、ClassicExplorer32.dll、ffff.pol、ffff.lop MD5：ae10...","permalink":"/post/某白加黑木马样本分析","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"恶意样本","slug":"恶意样本","count":2,"path":"api/tags/恶意样本.json"},{"name":"白加黑技术","slug":"白加黑技术","count":1,"path":"api/tags/白加黑技术.json"},{"name":"逆向","slug":"逆向","count":14,"path":"api/tags/逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}