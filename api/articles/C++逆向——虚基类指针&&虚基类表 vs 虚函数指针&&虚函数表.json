{"title":"C++逆向——虚基类指针&&虚基类表 vs 虚函数指针&&虚函数表","uid":"c3ef1bdebe04666f3d364f093474c8aa","slug":"C++逆向——虚基类指针&&虚基类表 vs 虚函数指针&&虚函数表","date":"2023-03-12T11:53:28.000Z","updated":"2025-06-07T18:59:17.248Z","comments":true,"path":"api/articles/C++逆向——虚基类指针&&虚基类表 vs 虚函数指针&&虚函数表.json","keywords":null,"cover":[],"content":"<h1 id=\"一、虚继承产生的虚基类表指针和虚基类表\"><a href=\"#一、虚继承产生的虚基类表指针和虚基类表\" class=\"headerlink\" title=\"一、虚继承产生的虚基类表指针和虚基类表\"></a>一、虚继承产生的虚基类表指针和虚基类表</h1><p>如下代码：写一个棱形继承，父类Father，子类Son1和Son2虚继承Base，又来一个类Grandson继承Son1和Son2。<br>代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Father</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> a;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> b;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Son1</span> :<span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> Father</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> a;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> b;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Son2</span> :<span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> Father</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> a;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> b;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Grandson</span> :<span class=\"keyword\">public</span> Son1, <span class=\"keyword\">public</span> Son2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> a;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> b;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\tGrandson grandson;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先对Father的内容是肯定的，三个整形变量，没有其它东西了，如下图：</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8%20vs%20%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88&&%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/%E8%99%9A%E7%BB%A7%E6%89%BF%E4%BA%A7%E7%94%9F%E7%9A%84%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8%E6%8C%87%E9%92%88%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8/%E8%99%9A%E5%9F%BA%E7%B1%BBFather%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png\" alt=\"虚基类Father的内存布局\"></p>\n<p>再来看看类Son1和Son2的东西，由于Son1和Son2的类本身内容相同，且都是虚继承Father类，所以Son1和Son2类的内容相同。如下两个图：</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8%20vs%20%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88&&%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/%E8%99%9A%E7%BB%A7%E6%89%BF%E4%BA%A7%E7%94%9F%E7%9A%84%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8%E6%8C%87%E9%92%88%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8/Son1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png\" alt=\"Son1的内存布局\"></p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8%20vs%20%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88&&%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/%E8%99%9A%E7%BB%A7%E6%89%BF%E4%BA%A7%E7%94%9F%E7%9A%84%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8%E6%8C%87%E9%92%88%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8/Son2%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png\" alt=\"Son2的内存布局\"></p>\n<p>上两个图是Son1类和Son2类的内容，这两个类创建的对象使用从Father类继承的内容就是委婉地通过vbptr到vbtale中找到继承的Father类内容的首地址访问的。<br>虚基类表中的16是相对于Son类vbptr地址的偏移量，即继承的Father类的内容在子类中存放的首地址相对于Son的vbptr的地址的偏移量。Son1和Son2都继承父类Father，本来类大小为sizeof(Son)+sizeof(Father)&#x3D;12+12&#x3D;24的，但是由于是虚继承，Son类内会多一个虚指针，所以类大小多了4字节，变成了28字节。</p>\n<p>再来看看Grandson类的内容：</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8%20vs%20%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88&&%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/%E8%99%9A%E7%BB%A7%E6%89%BF%E4%BA%A7%E7%94%9F%E7%9A%84%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8%E6%8C%87%E9%92%88%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8/%E5%AD%90%E7%B1%BBGrandsond%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png\" alt=\"image-20240403111535099\"></p>\n<p>从Son1继承的虚基类表里面的44是指Father类的内容到Son1的vbptr的地址偏移量为44（44-0）。同理，从Son2继承的虚基类表里面的28是指Father类的内容到Son1的vbptr地址偏移量为28（44-16）。这里可以看出，本来Son1和Son2类里面都有从Father继承的内容，但是由于Son1和Son2都是虚继承，Grandson继承Son1和Son2的时候，Father类的内容只有一份，避免了继承两份Father内容（Son1含一份，Son2含一份）而造成的资源浪费。不管Grandson是通过Son1还是通过Son2访问Father的内容，其实Son1和Son2都是通过自己的vbptr访问同一份Father的内容。</p>\n<p>如果Grandson也是以虚继承的方式继承Son1和Son2的呢？即把Grandson的继承代码改成以下方式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Father</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> a;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> b;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Son1</span> :<span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> Father</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> a;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> b;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Son2</span> :<span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> Father</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> a;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> b;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Grandson</span> :<span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> Son1, <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> Son2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> a;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> b;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\tGrandson grandson;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Son1和Son2以虚继承的方式继承Father造成的结果是Son1和Son2都多了一个虚基类指针指向虚基类表，虚基类表中记录着从Father继承过来的内容的首地址对Son1(Son2)类的vbptr的地址的偏移量。类比一下，不难想出，Grandson如果也以虚继承的方式继承Son1和Son2的话，那么Grandson本身肯定也会多一个虚基类指针，指向一个虚基类表，这个虚基类表中存放着从Son1继承过来的内容的首地址相对于Grandson类的vbprtr地址的偏移量，也存放着从Son2继承过来的内容的首地址相对于Grandson类的首地址的偏移量。除此之外还存放着一个东西，Father的内容的首地址相对于Grandson类的vbptr的地址的偏移量。所以Grandson的虚基类指针指向虚基类表，虚基类表中存放着三个地址偏移量：</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8%20vs%20%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88&&%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/%E8%99%9A%E7%BB%A7%E6%89%BF%E4%BA%A7%E7%94%9F%E7%9A%84%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8%E6%8C%87%E9%92%88%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8/%E5%AD%90%E7%B1%BBGrandsond%E8%99%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png\" alt=\"image-20240403113639936\"></p>\n<p>如上图（Son1和Son2的虚基类指针和虚基类表在上面分析过了，这里主要分析Grandson的虚基类指针和虚基类表），虚基类表中的16（16-0）、28（28-0）、44（44-0）分别对应着包含的Father、Son1、Son2的内容的首地址相对于Grandson的vbptr地址的偏移量。</p>\n<p>虚基类偏移&#x3D;虚基类首地址-虚继承子类的vbptr地址</p>\n<h1 id=\"二、虚函数产生的虚函数指针和虚函数表\"><a href=\"#二、虚函数产生的虚函数指针和虚函数表\" class=\"headerlink\" title=\"二、虚函数产生的虚函数指针和虚函数表\"></a>二、虚函数产生的虚函数指针和虚函数表</h1><p><strong>注：</strong> 在这里不讨论动态多态和静态多态，只讨论分析虚指针和虚表的问题。</p>\n<p>首先，vbptr(virtual base pointer)虚基类指针和vfptr(virtual function pointer)虚函数指针是两个不同的东西，是可以共存的，上面已经说明vbptr是对于虚继承而言的产物，vfptr则是对于虚函数的产物。以下代码说明vbptr和vfptr可以共存：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#pragma warning(disable : 4996)</span><br><span class=\"line\"></span><br><span class=\"line\">class Father</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tint b;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Son1 :virtual public Father //虚继承(产生虚基类指针vbptr)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tvirtual void fun() &#123;&#125;//虚函数(产生虚函数指针vfptr)</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tint b;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char* argv[]) &#123;</span><br><span class=\"line\">\t//Grandson grandson;</span><br><span class=\"line\">\tSon1 son1;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看一下Son1的结构：</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8%20vs%20%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88&&%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/%E8%99%9A%E5%87%BD%E6%95%B0%E4%BA%A7%E7%94%9F%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/Son1%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png\" alt=\"Son1的内存结构\"></p>\n<p>可以看出vbptr和vfptr是两个不同的指针，而且可以共存。<br>vbptr指向的是虚基类表，虚基类表中放着Father内容的首地址相对于Son1 vbptr指针的地址的偏移量。<br>vfbptr指向的是虚函数表，虚函数表中放着Son1的虚函数的地址。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里Son1的vbtable第0项是-4</p>\n<p>因为child_addr&#x3D;&amp;this-&gt;vbtable+this-&gt;vbtable[count]计算出来的，vbtable[0]是OffsetOf(class.vbtable)的相反数</p>\n<p>vbtable上面有vtable所以对象指针相对于vbtable的指针偏移为-4</p></blockquote>\n<p>由于虚基类指针已经分析过，下面只针对虚函数指针展开分析。如下代码，父类函数虚函数，子类继承父类。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual void fun1() &#123;&#125;</span><br><span class=\"line\">\tvirtual void fun2() &#123;&#125;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tint b;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Son1 :public Base </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tint b;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>看一下Base类的结构：</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8%20vs%20%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88&&%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/%E8%99%9A%E5%87%BD%E6%95%B0%E4%BA%A7%E7%94%9F%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/Base%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84.png\" alt=\"在这里插入图片描述\"></p>\n<p>可以看出，由于Base类内函数虚函数，所以Base类会多一个虚函数指针，虚函数指针指向虚函数表，虚函数表中存放着虚函数的地址。<br>再来看看Son1类里面的东西：</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8%20vs%20%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88&&%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/%E8%99%9A%E5%87%BD%E6%95%B0%E4%BA%A7%E7%94%9F%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/Son1%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%842.png\" alt=\"在这里插入图片描述\"></p>\n<p>可以看见Base的虚函数指针被Son1继承下来了，虚函数指针指向一个虚函数表，虚函数表中放着的是Base的两个虚函数的地址。那么如果Son1对Base的虚函数进行重写呢？比如对fun1函数进行重写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual void fun1() &#123;&#125;</span><br><span class=\"line\">\tvirtual void fun2() &#123;&#125;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tint b;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Son1 :public Base </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid fun1() &#123;&#125;//对Base的虚函数fun1函数进行重写</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tint b;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8%20vs%20%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88&&%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/%E8%99%9A%E5%87%BD%E6%95%B0%E4%BA%A7%E7%94%9F%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/Son1%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%843.png\" alt=\"在这里插入图片描述\"></p>\n<p>可以发现，虚函数表中本来存放Base的虚函数fun1()的地址，Son1对Base的fun1函数进行重写后，虚函数表中原本存放Base的虚函数fun1的地址，现在存放了被Son1重写后的fun1函数的地址。这也就是我们说的当子类重写父类的某一个虚函数时，父类的这个虚函数会被重写后的函数覆盖。<br>再想一下，如果Son1本身也有虚函数呢？和vbptr类比一下，会觉得如果Son1本身有虚函数的话，那么Son1本身也会有一个虚函数指针，指向一个虚函数表，虚函数表中放着Son1的虚函数的地址。但是事实并非如此！<br>如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual void fun1() &#123;&#125;//对Base的虚函数fun1函数进行重写</span><br><span class=\"line\">\tvirtual void fun2() &#123;&#125;//Son1自己的虚函数</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tint b;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Son1 :public Base </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid fun1() &#123;&#125;</span><br><span class=\"line\">\tvirtual void fun3() &#123;&#125;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tint b;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>看一下Son1的结构：</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8%20vs%20%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88&&%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/%E8%99%9A%E5%87%BD%E6%95%B0%E4%BA%A7%E7%94%9F%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/Son1%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%844.png\" alt=\"在这里插入图片描述\"></p>\n<p>可以看见，Son1本身还是没有vfptr，而是仍旧用从Base继承过来的vfptr，而且函数表也是只有一个，Son1的虚函数fun3的地址直接添加在虚函数表里面（在其他函数地址下面）。由此可见，一个类如果有虚函数，并且继承的有函数指针，那么这个类会继续用继承的vfptr，而且自己的虚函数地址会继续存放在同一个虚函数表中。但是不意味着每个类都只有一个虚函数指针和一个虚函数表，比如，两个类都有虚函数指针和虚函数表，又来一个”孙子”类继承这两个类，那么”孙子”类里面就会有两个虚函数指针，两个虚函数表。<br>如下代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual void fun1() &#123;&#125;</span><br><span class=\"line\">\tvirtual void fun2() &#123;&#125;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tint b;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Son1 :public Base </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual void fun3() &#123;&#125;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tint b;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Son2 :public Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvirtual void fun4() &#123;&#125;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tint b;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Grandson :public Son1,public Son2</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid fun1()&#123;&#125;</span><br><span class=\"line\">\tvirtual void fun5() &#123;&#125;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">protected:</span><br><span class=\"line\">\tint b;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Son1和Son2的结构不用看了，上面已经分析过了，用继承的base的vfptr，虚函数地址和base的虚函数地址也存放在同一个虚函数表中。看一下Grandson的结构：</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8%20vs%20%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88&&%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/%E8%99%9A%E5%87%BD%E6%95%B0%E4%BA%A7%E7%94%9F%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/Grandson%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png\" alt=\"在这里插入图片描述\"></p>\n<p>可以看见，Grandson从Son1和Son2分别都继承了一份虚函数表，和分别都继承了一个虚函数指针。总共两个虚函数指针和两个虚函数表。而Grandson重写后的fun1函数将从Son1继承过来的虚函数表中的fun1覆盖了，而Grandson自己的虚函数fun5()也存放在从Son1继承过来的虚函数表中。在这里有一个规则:<br>1.虚函数地址按照其声明顺序放于虚函数表中。<br>2.父类的虚函数在子类的虚函数前面。<br>3.被重写的函数放到了虚函数表中原来父类虚函数的位置。即原来的虚函数的地址直接被覆盖。</p>\n<p>发现从Son2继承过来的虚函数表中的fun1位置被<br>&amp;thunk: this-&#x3D;28;goto GrandSon::fun1替代<br>thunk我查了一下，说是一种thunk技术。thunk是一组动态生成的ASM指令，它记录了窗口类对象的this指针，这组指令既可以当作函数，也可以是窗口过程来使用。（如果真是这个知识的话，那么这里已经超出本人理解范围了）。猜测就是Son2的函数表里面的fun1并没有被覆盖，而是用了另一种技术调用Grand::fun1。this -&#x3D; 28这句代码中，this应该是Son2的vfptr，而Son2的vfptr -&#x3D; 28，那么就指向了Son1的vfptr，goto Grandson::fun1就是转到Grandson::fun1函数。<br>所以本人猜测，是通过回转到Son1的vfptr指向的虚函数表中找到Grandson::fun1函数的地址，然后调用。对于thunk，在其中不知道发挥着怎样的作用，已经超出本人知识范围了，网上搜了一下，也看的迷迷糊糊的。<br>总之，是通过某种方式调用Grand::fun1，而并不是简单的覆盖Son2的fun1就是了。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>1.如果基类有虚函数表，那么子类直接使用基类的虚函数表。且实例中虚函数表地址值存储顺序就是基类继承顺序。<br>2.继承类新增的虚函数排在第一个虚函数表中，且在基类虚函数后面。<br>3.子类重写父类的虚函数，只有按顺序第一个包含被重写的虚函数的地址的虚函数表中的原虚函数地址被覆盖，后面的虚函数表中如果也包含这个虚函数地址，那么就不是简简单单的覆盖，而是用更像是回调的方式调用重写后的函数。</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"https://blog.csdn.net/yi_chengyu/article/details/120856687\">C++中虚继承产生的虚基类指针和虚基类表，虚函数产生的虚函数指针和虚函数表</a></p>\n","text":"一、虚继承产生的虚基类表指针和虚基类表如下代码：写一个棱形继承，父类Father，子类Son1和Son2虚继承Base，又来一个类Grandson继承Son1和...","permalink":"/post/C++逆向——虚基类指针&&虚基类表 vs 虚函数指针&&虚函数表","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E8%99%9A%E7%BB%A7%E6%89%BF%E4%BA%A7%E7%94%9F%E7%9A%84%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8%E6%8C%87%E9%92%88%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8\"><span class=\"toc-text\">一、虚继承产生的虚基类表指针和虚基类表</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E4%BA%A7%E7%94%9F%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8\"><span class=\"toc-text\">二、虚函数产生的虚函数指针和虚函数表</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"恶意iso文件分析","uid":"0fa9719b9833354b768a1db954a5b0e7","slug":"恶意iso文件分析","date":"2023-04-08T02:22:11.000Z","updated":"2025-06-05T12:30:07.178Z","comments":true,"path":"api/articles/恶意iso文件分析.json","keywords":null,"cover":[],"text":"iso信息文件信息 文件内容 doc文档doc加密数据 WinWord.exe即Concept Note Strategic Dialog Version 30...","permalink":"/post/恶意iso文件分析","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"恶意样本","slug":"恶意样本","count":2,"path":"api/tags/恶意样本.json"},{"name":"逆向","slug":"逆向","count":14,"path":"api/tags/逆向.json"},{"name":"iso文件","slug":"iso文件","count":1,"path":"api/tags/iso文件.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"C++逆向——全局类对象","uid":"1329f4c6c2b96d3a354509a097c90b2b","slug":"C++逆向——全局类对象","date":"2023-03-09T13:44:59.000Z","updated":"2025-06-07T18:51:53.810Z","comments":true,"path":"api/articles/C++逆向——全局类对象.json","keywords":null,"cover":[],"text":"全局对象 生命周期: main 开始之前构造 ,main结束之后析构 因此在main函数之前初始化,构造属于初始化,因此在Inititem（c++) 中构造 先...","permalink":"/post/C++逆向——全局类对象","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}