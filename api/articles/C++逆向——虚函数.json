{"title":"虚函数","uid":"cff45971697c57c78d8a68c46a85aef2","slug":"C++逆向——虚函数","date":"2023-02-13T06:11:19.000Z","updated":"2025-06-07T18:09:49.856Z","comments":true,"path":"api/articles/C++逆向——虚函数.json","keywords":null,"cover":[],"content":"<p>虚函数是面向对象程序设计的关键组成部分。对于具有虚函数的类而言，构造函数和析构函数的识别过程更加简单。而且，在类中定义虚函数之后，如果没有提供构造函数，编译器会生成并提供默认的构造函数。</p>\n<p>对象的多态性需要通过虚表和虚表指针完成，虚表指针被定义在对象首地址处，因此虚函数必须作为成员函数使用。因为非成员函数没有this指针，所以无法获得虚表指针，进而无法获取虚表，也就无法访问虚函数。</p>\n<h1 id=\"虚函数的机制\"><a href=\"#虚函数的机制\" class=\"headerlink\" title=\"虚函数的机制\"></a>虚函数的机制</h1><p>在C++中，使用关键字virtual声明函数为虚函数。当类中定义有虚函数时，编译器会<strong>将该类中所有虚函数的首地址保存在一张地址表中，这张表被称为虚函数地址表，简称虚表</strong>。同时，编译器还会在<strong>类中添加一个隐藏数据成员，称为虚表指针。该指针保存着虚表的首地址，用于记录和查找虚函数。</strong></p>\n<h2 id=\"包含虚函数的类的定义及虚表指针的初始化过程\"><a href=\"#包含虚函数的类的定义及虚表指针的初始化过程\" class=\"headerlink\" title=\"包含虚函数的类的定义及虚表指针的初始化过程\"></a>包含虚函数的类的定义及虚表指针的初始化过程</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">//虚函数定义</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"type\">int</span> age)</span> </span>&#123; <span class=\"comment\">//虚函数定义</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;age = age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\tPerson person;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ida汇编及伪代码视图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//mian函数</span><br><span class=\"line\">.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:00401040 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:00401040</span><br><span class=\"line\">.text:00401040 var_C           = byte ptr -0Ch</span><br><span class=\"line\">.text:00401040 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401040 argc            = dword ptr  8</span><br><span class=\"line\">.text:00401040 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:00401040 envp            = dword ptr  10h</span><br><span class=\"line\">.text:00401040</span><br><span class=\"line\">.text:00401040                 push    ebp</span><br><span class=\"line\">.text:00401041                 mov     ebp, esp</span><br><span class=\"line\">.text:00401043                 sub     esp, 0Ch</span><br><span class=\"line\">.text:00401046                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:0040104B                 xor     eax, ebp</span><br><span class=\"line\">.text:0040104D                 mov     [ebp-4], eax</span><br><span class=\"line\">.text:00401050                 lea     ecx, [ebp-0Ch]  ; 获取对象首地址</span><br><span class=\"line\">.text:00401053                 call    sub_401070      ; 调用构造函数，类Person中并没有定义构造函数，此调用为默认构造函数</span><br><span class=\"line\">.text:00401058                 xor     eax, eax</span><br><span class=\"line\">.text:0040105A                 mov     ecx, [ebp+var_4]</span><br><span class=\"line\">.text:0040105D                 xor     ecx, ebp        ; StackCookie</span><br><span class=\"line\">.text:0040105F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class=\"line\">.text:00401064                 mov     esp, ebp</span><br><span class=\"line\">.text:00401066                 pop     ebp</span><br><span class=\"line\">.text:00401067                 retn</span><br><span class=\"line\">.text:00401067 _main           endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char v4[8]; // [esp+0h] [ebp-Ch] BYREF</span><br><span class=\"line\"></span><br><span class=\"line\">  sub_401070(v4);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//默认构造函数</span><br><span class=\"line\">.text:00401070 ; _DWORD *__thiscall sub_401070(_DWORD *this)</span><br><span class=\"line\">.text:00401070 sub_401070      proc near               ; CODE XREF: _main+13↑p</span><br><span class=\"line\">.text:00401070</span><br><span class=\"line\">.text:00401070 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401070</span><br><span class=\"line\">.text:00401070                 push    ebp             ; 默认构造函数分析</span><br><span class=\"line\">.text:00401071                 mov     ebp, esp</span><br><span class=\"line\">.text:00401073                 push    ecx</span><br><span class=\"line\">.text:00401074                 mov     [ebp-4], ecx    ; [ebp-4] 存储this指针</span><br><span class=\"line\">.text:00401077                 mov     eax, [ebp-4]    ; 取出this指针并保存到eax中，这个地址将会作为指针保存虚函数表的首地址中</span><br><span class=\"line\">.text:0040107A                 mov     dword ptr [eax], offset ??_7Person@@6B@ ; const Person::`vftable&#x27;，取虚表的首地址，保存到虚表指针中</span><br><span class=\"line\">.text:00401080                 mov     eax, [ebp-4]    ; 返回对象首地址</span><br><span class=\"line\">.text:00401083                 mov     esp, ebp</span><br><span class=\"line\">.text:00401085                 pop     ebp</span><br><span class=\"line\">.text:00401086                 retn</span><br><span class=\"line\">.text:00401086 sub_401070      endp</span><br><span class=\"line\"></span><br><span class=\"line\">_DWORD *__thiscall sub_401070(_DWORD *this)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  *this = &amp;Person::`vftable&#x27;;</span><br><span class=\"line\">  return this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中的类定义了两个虚函数和一个数据成员。如果这个类没有定义虚函数，则其长度为4，定义了虚函数后，因为还含有隐藏数据成员（虚表指针），所以32位程序大小为8，64程序大小为16</p>\n<p>类Person确实多出了一个指针大小数据，这个数据用于保存虚表指针。在虚表指针指向的函数指针数组中，保存着虚函数getAge和setAge的首地址。对于开发者而言，虚表和虚表指针都是隐藏的，在常规的开发过程中感觉不到它们的存在。对象中的虚表指针和虚表的关系如下图所示。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E9%92%88%E5%AD%98%E5%82%A8%E4%BF%A1%E6%81%AF.png\" alt=\"虚表指针存储信息\"></p>\n<p>所以有了虚表指针，就可以通过该指针得到类中所有虚函数的首地址。</p>\n<p>上面代码中编译器为类Person提供了默认的构造函数。该默认构造函数先取得虚表的首地址，然后赋值到虚表指针中。虚表信息如下图：</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E6%81%AF.png\" alt=\"虚表信息\"></p>\n<p>上图显示了虚表中的两个地址信息，分别为成员函数getAge和setAge的地址。因此，得到虚表指针就相当于得到了类中所有虚函数的首地址。对象的虚表指针初始化是通过编译器在构造函数内插入代码完成的。在用户没有编写构造函数时，因为必须初始化虚表指针，所以编译器会提供默认的构造函数，以完成虚表指针的初始化。</p>\n<p>因为虚表信息在编译后会被链接到对应的执行文件中，所以获得的虚表地址是一个相对固定的地址。虚表中虚函数的地址排列顺序因虚函数在类中的声明顺序而定，先声明的虚函数的地址会被排列在虚表靠前的位置。第一个被声明的虚函数的地址在虚表的首地址处。</p>\n<p>上面代码展示了默认构造函数初始化虚表指针的过程。对于含有构造函数的类而言，其虚表初始化过程和默认构造函数相同，都是在对象首地址处保存虚表的首地址。</p>\n<p>在虚表指针的初始化过程中，对象执行了构造函数后，就得到了虚表指针，当其他代码访问这个对象的虚函数时，会根据对象的首地址，取出对应的虚表元素。当函数被调用时，会间接访问虚表，得到对应的虚函数首地址并调用执行。这种调用方式是一个间接的调用过程，需要多次寻址才能完成。</p>\n<h2 id=\"调用自身类中的虚函数\"><a href=\"#调用自身类中的虚函数\" class=\"headerlink\" title=\"调用自身类中的虚函数\"></a>调用自身类中的虚函数</h2><p>上一节中通过虚表间接寻址访问的情况只有在使用对象的指针或引用调用虚函数的时候才会出现。当直接使用对象调用自身虚函数时，没有必要查表访问。这是因为已经明确调用的是自身成员函数，根本没有构成多态性，查询虚表只会画蛇添足，降低程序的执行效率，所以将这种情况处理为直接调用方式。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">//虚函数定义</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"type\">int</span> age)</span> </span>&#123; <span class=\"comment\">//虚函数定义</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;age = age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\tPerson person;</span><br><span class=\"line\">\tperson.<span class=\"built_in\">setAge</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, person.<span class=\"built_in\">getAge</span>());</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ida汇编及伪代码视图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//main函数</span><br><span class=\"line\">.text:004010C0 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:004010C0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:004010C0</span><br><span class=\"line\">.text:004010C0 var_C           = byte ptr -0Ch</span><br><span class=\"line\">.text:004010C0 var_4           = dword ptr -4</span><br><span class=\"line\">.text:004010C0 argc            = dword ptr  8</span><br><span class=\"line\">.text:004010C0 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:004010C0 envp            = dword ptr  10h</span><br><span class=\"line\">.text:004010C0</span><br><span class=\"line\">.text:004010C0                 push    ebp</span><br><span class=\"line\">.text:004010C1                 mov     ebp, esp</span><br><span class=\"line\">.text:004010C3                 sub     esp, 0Ch</span><br><span class=\"line\">.text:004010C6                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:004010CB                 xor     eax, ebp</span><br><span class=\"line\">.text:004010CD                 mov     [ebp-4], eax</span><br><span class=\"line\">.text:004010D0                 lea     ecx, [ebp-0Ch]  ; 传递this指针</span><br><span class=\"line\">.text:004010D3                 call    sub_401110      ; 调用默认构造函数</span><br><span class=\"line\">.text:004010D8                 push    14h</span><br><span class=\"line\">.text:004010DA                 lea     ecx, [ebp-0Ch]  ; 传递this指针</span><br><span class=\"line\">.text:004010DD                 call    sub_4010A0      ; 直接调用函数setAge</span><br><span class=\"line\">.text:004010E2                 lea     ecx, [ebp-0Ch]  ; 传递this指针</span><br><span class=\"line\">.text:004010E5                 call    unknown_libname_1 ; 直接调用函数getAge</span><br><span class=\"line\">.text:004010EA                 push    eax             ; char</span><br><span class=\"line\">.text:004010EB                 push    offset Format   ; &quot;%d\\n&quot;</span><br><span class=\"line\">.text:004010F0                 call    printf</span><br><span class=\"line\">.text:004010F5                 add     esp, 8</span><br><span class=\"line\">.text:004010F8                 xor     eax, eax</span><br><span class=\"line\">.text:004010FA                 mov     ecx, [ebp-4]</span><br><span class=\"line\">.text:004010FD                 xor     ecx, ebp        ; StackCookie</span><br><span class=\"line\">.text:004010FF                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class=\"line\">.text:00401104                 mov     esp, ebp</span><br><span class=\"line\">.text:00401106                 pop     ebp</span><br><span class=\"line\">.text:00401107                 retn</span><br><span class=\"line\">.text:00401107 _main           endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char v3; // al</span><br><span class=\"line\">  char v5[8]; // [esp+0h] [ebp-Ch] BYREF</span><br><span class=\"line\"></span><br><span class=\"line\">  sub_401110(v5);</span><br><span class=\"line\">  sub_4010A0(20);</span><br><span class=\"line\">  v3 = unknown_libname_1(v5);</span><br><span class=\"line\">  sub_401040(&quot;%d\\n&quot;, v3);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//setAge函数</span><br><span class=\"line\">.text:004010A0 ; _DWORD *__thiscall sub_4010A0(_DWORD *this, int)</span><br><span class=\"line\">.text:004010A0 sub_4010A0      proc near               ; CODE XREF: _main+1D↓p</span><br><span class=\"line\">.text:004010A0                                         ; DATA XREF: .rdata:00402114↓o</span><br><span class=\"line\">.text:004010A0</span><br><span class=\"line\">.text:004010A0 var_4           = dword ptr -4</span><br><span class=\"line\">.text:004010A0 arg_0           = dword ptr  8</span><br><span class=\"line\">.text:004010A0</span><br><span class=\"line\">.text:004010A0                 push    ebp             ; setAge函数</span><br><span class=\"line\">.text:004010A1                 mov     ebp, esp</span><br><span class=\"line\">.text:004010A3                 push    ecx</span><br><span class=\"line\">.text:004010A4                 mov     [ebp-4], ecx</span><br><span class=\"line\">.text:004010A7                 mov     eax, [ebp-4]    ; eax=this</span><br><span class=\"line\">.text:004010AA                 mov     ecx, [ebp+8]    ; [ebp+8]为age</span><br><span class=\"line\">.text:004010AD                 mov     [eax+4], ecx    ; this-&gt;age=age</span><br><span class=\"line\">.text:004010B0                 mov     esp, ebp</span><br><span class=\"line\">.text:004010B2                 pop     ebp</span><br><span class=\"line\">.text:004010B3                 retn    4               ; 分析显示，虚函数与其他非虚函数的成员函数的实现流程一致，函数内部无差别</span><br><span class=\"line\">.text:004010B3 sub_4010A0      endp</span><br><span class=\"line\"></span><br><span class=\"line\">_DWORD *__thiscall sub_4010A0(_DWORD *this, int a2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  _DWORD *result; // eax</span><br><span class=\"line\"></span><br><span class=\"line\">  result = this;</span><br><span class=\"line\">  this[1] = a2;</span><br><span class=\"line\">  return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码直接通过对象调用自身的成员虚函数，因此编译器使用了直接调用函数的方式，没有访问虚表指针，间接获取虚函数地址。对象的多态性常常体现在派生和继承关系中。</p>\n<p>仔细分析虚表指针的原理，我们会发现编译器隐藏了初始化虚表指针的实现代码，<strong>当类中出现虚函数时，必须在构造函数中对虚表指针执行初始化操作，而没有虚函数类对象构造时，不会进行初始化虚表指针的操作。</strong>由此可见，在分析构造函数时，又增加了一个新特征——虚表指针初始化。根据以上分析，如果排除开发者伪造编译器生成的代码误导分析人员的情况，我们就可以给出一个结论：<strong>对于单线继承的类结构，在某个成员函数中，将this指针的地址初始化为虚表首地址时，可以判定这个成员函数为构造函数。</strong></p>\n<h2 id=\"析构函数分析\"><a href=\"#析构函数分析\" class=\"headerlink\" title=\"析构函数分析\"></a>析构函数分析</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#pragma warning(disable : 4996)</span><br><span class=\"line\"></span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\t~Person() &#123;</span><br><span class=\"line\">\t\tprintf(&quot;~Person()\\n&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvirtual int getAge() &#123; //虚函数定义</span><br><span class=\"line\">\t\treturn age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvirtual void setAge(int age) &#123; //虚函数定义</span><br><span class=\"line\">\t\tthis-&gt;age = age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tint age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main(int argc, char* argv[]) &#123;</span><br><span class=\"line\">\tPerson person;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ida汇编及伪代码视图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//main函数</span><br><span class=\"line\">.text:004010F0 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:004010F0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:004010F0</span><br><span class=\"line\">.text:004010F0 var_10          = dword ptr -10h</span><br><span class=\"line\">.text:004010F0 var_C           = dword ptr -0Ch</span><br><span class=\"line\">.text:004010F0 var_4           = dword ptr -4</span><br><span class=\"line\">.text:004010F0 argc            = dword ptr  8</span><br><span class=\"line\">.text:004010F0 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:004010F0 envp            = dword ptr  10h</span><br><span class=\"line\">.text:004010F0</span><br><span class=\"line\">.text:004010F0                 push    ebp</span><br><span class=\"line\">.text:004010F1                 mov     ebp, esp</span><br><span class=\"line\">.text:004010F3                 sub     esp, 10h</span><br><span class=\"line\">.text:004010F6                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:004010FB                 xor     eax, ebp</span><br><span class=\"line\">.text:004010FD                 mov     [ebp-4], eax</span><br><span class=\"line\">.text:00401100                 lea     ecx, [ebp-0Ch]  ; 传递this指针</span><br><span class=\"line\">.text:00401103                 call    sub_401130      ; 调用默认构造函数</span><br><span class=\"line\">.text:00401108                 mov     dword ptr [ebp-10h], 0</span><br><span class=\"line\">.text:0040110F                 lea     ecx, [ebp-0Ch]  ; 传递this指针</span><br><span class=\"line\">.text:00401112                 call    sub_401080      ; 调用析构函数</span><br><span class=\"line\">.text:00401117                 mov     eax, [ebp-10h]</span><br><span class=\"line\">.text:0040111A                 mov     ecx, [ebp-4]</span><br><span class=\"line\">.text:0040111D                 xor     ecx, ebp        ; StackCookie</span><br><span class=\"line\">.text:0040111F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class=\"line\">.text:00401124                 mov     esp, ebp</span><br><span class=\"line\">.text:00401126                 pop     ebp</span><br><span class=\"line\">.text:00401127                 retn</span><br><span class=\"line\">.text:00401127 _main           endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  _DWORD v4[2]; // [esp+4h] [ebp-Ch] BYREF</span><br><span class=\"line\"></span><br><span class=\"line\">  sub_401130(v4);</span><br><span class=\"line\">  sub_401080((char)v4);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//析构函数</span><br><span class=\"line\">.text:00401080 ; int __fastcall sub_401080(_DWORD *)</span><br><span class=\"line\">.text:00401080 sub_401080      proc near               ; CODE XREF: _main+22↓p</span><br><span class=\"line\">.text:00401080</span><br><span class=\"line\">.text:00401080 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401080</span><br><span class=\"line\">.text:00401080                 push    ebp             ; 析构函数</span><br><span class=\"line\">.text:00401081                 mov     ebp, esp</span><br><span class=\"line\">.text:00401083                 push    ecx             ; char</span><br><span class=\"line\">.text:00401084                 mov     [ebp-4], ecx    ; [ebp-4]保存this指针</span><br><span class=\"line\">.text:00401087                 mov     eax, [ebp-4]    ; eax得到this指针，这是虚表的位置</span><br><span class=\"line\">.text:0040108A                 mov     dword ptr [eax], offset off_402118 ; 将当前类虚表首地址赋值到虚表指针中</span><br><span class=\"line\">.text:00401090                 push    offset Format   ; &quot;~Person()\\n&quot;</span><br><span class=\"line\">.text:00401095                 call    printf</span><br><span class=\"line\">.text:0040109A                 add     esp, 4</span><br><span class=\"line\">.text:0040109D                 mov     esp, ebp</span><br><span class=\"line\">.text:0040109F                 pop     ebp</span><br><span class=\"line\">.text:004010A0                 retn</span><br><span class=\"line\">.text:004010A0 sub_401080      endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __fastcall sub_401080(_DWORD *a1)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  *a1 = &amp;off_402118;</span><br><span class=\"line\">  return printf(&quot;~Person()\\n&quot;, (char)a1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过比较代码中构造函数与析构函数的流程可知，二者对虚表的操作几乎相同，都是将虚表指针设置为</p>\n<p>当前对象所属类中的虚表首地址。然而二者看似相同，事实上差别很大。</p>\n<p>构造函数中完成的是初始化虚表指针的工作，此时虚表指针并没有指向虚表地址，而执行析构函数时，对象的虚表指针已经指向了某个虚表首地址。</p>\n<p><strong>在析构函数中填写虚表是否没必要呢？</strong></p>\n<p>这里实际上是在还原虚表指针，让其指向自身的虚表首地址，防止在析构函数中调用虚函数时取到非自身虚表，从而导致函数调用错误。</p>\n<p>判定析构函数的依据和虚表指针相关，识别析构函数的充分条件是写入虚表指针，但是请注意，它与前面讨论的虚表指针初始化不同。所谓虚表指针初始化，是指对象原来的虚表指针位置不是有效的，经过初始化才指向了正确的虚函数表。而写入虚表指针，是指对象的虚表指针可能是有效的，已经指向了正确的虚函数表，将对象的虚表指针重新赋值后，其指针可能指向了另一个虚表，虚表的内容不一定和原来的一样。</p>\n<p>结合IDA中的引用参考可知，只要确定一个构造函数或者析构函数，我们就能顺藤摸瓜找到其他构造函数以及类之间的关系。</p>\n<h1 id=\"虚函数的识别\"><a href=\"#虚函数的识别\" class=\"headerlink\" title=\"虚函数的识别\"></a>虚函数的识别</h1><p>在判断是否为虚函数时，我们要做的是鉴别类中是否出现了以下特征。</p>\n<ul>\n<li><p>类中隐式定义了一个数据成员。</p>\n</li>\n<li><p>该数据成员在首地址处，占一个指针大小。</p>\n</li>\n<li><p>构造函数会将此数据成员初始化为某个数组的首地址。</p>\n</li>\n<li><p>这个地址属于数据区，是相对固定的地址。</p>\n</li>\n<li><p>在这个数组内，每个元素都是函数指针。</p>\n</li>\n<li><p>仔细观察这些函数，它们被调用时，第一个参数必然是this指针（要注意调用约定）。</p>\n</li>\n<li><p>在这些函数内部，很有可能对this指针使用相对间接的访问方式。</p>\n</li>\n</ul>\n<p>有了虚表，类中所有虚函数都被囊括其中。查找这个虚表需要得到指向它的虚表指针，虚表指针又在构造函数中被初始化为虚表首地址。由此可见，要想找到虚函数，就要得到虚表的首地址。</p>\n<p>经过层层分析，识别虚函数最终转变成识别构造函数或者析构函数。构造函数与虚表指针的初始化有依赖关系。对于构造函数而言，初始化虚表指针会简化识别构造函数的过程，而初始化虚表指针又必须在构造函数内完成，因此在分析构造函数时，应重点考察对象首地址处被赋予的值。</p>\n<p>查询this指针指向的地址处的内存数据，跟踪并分析其数据是否为地址信息，是否对这个指针的内容进行赋值操作，赋值后的数据是否指向了某个地址表，表中各单元项是否为函数首地址。有了这一系列的鉴定后，就可得知此成员函数是否为构造函数。识别出构造函数后，即可顺藤摸瓜找到所有的虚函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; 具有成员函数特征，传递对象首地址作为this指针</span><br><span class=\"line\">lea ecx,[ebp-8] ;获取对象首地址</span><br><span class=\"line\">call XXXXXXXXh ;调用函数</span><br><span class=\"line\">;调用函数的实现代码内</span><br><span class=\"line\">mov reg, this ;某寄存器得到对象首地址</span><br><span class=\"line\">;向对象首地址处写入地址数据，查看并确认此地址数据是否为函数地址表的首地址</span><br><span class=\"line\">mov dword ptr [reg], XXXXXXXXh</span><br></pre></td></tr></table></figure>\n\n<p>在分析过程中遇到上述代码时，应高度怀疑其为构造函数或者析构函数。查看并确认此地址数据是否为函数地址表的首地址，即可判断是否为构造或析构函数。</p>\n<p>在对构造函数和析构函数进行区分时，通过分析它们的特性可知：构造函数一定出现在析构函数之前，而且在构造函数执行前虚表指针没有指向虚表的首地址；而析构函数出现在所有成员函数之后，在实现过程中，虚表指针已经指向了某一个虚表的首地址。</p>\n<p>识别出虚表的首地址后，就可以利用IDA的引用参考功能得到所有引用此虚表首地址的函数所在的地址标号。只有构造函数和析构函数中存在对虚表指针的修改操作，等同于定位到了引用此虚表的所有构造函数和析构函数，这使得识别类中的构造函数和析构变得更为简单，也更为准确。</p>\n<h2 id=\"含有虚函数的全局对象\"><a href=\"#含有虚函数的全局对象\" class=\"headerlink\" title=\"含有虚函数的全局对象\"></a>含有虚函数的全局对象</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Global</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Global</span>() &#123; <span class=\"comment\">//无参构造函数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Global\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">Global</span>(<span class=\"type\">int</span> n) &#123; <span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Global(int n) %d\\n&quot;</span>, n);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">Global</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* s) &#123; <span class=\"comment\">//有参构造函数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Global(char *s) %s\\n&quot;</span>, s);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Global</span>() &#123; <span class=\"comment\">//虚析构函数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;~Global()\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Object Addr: 0x%p&quot;</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Global g_global1;</span><br><span class=\"line\"><span class=\"function\">Global <span class=\"title\">g_global2</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Global <span class=\"title\">g_global3</span><span class=\"params\">(<span class=\"string\">&quot;hello C++&quot;</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\tg_global<span class=\"number\">1.</span><span class=\"built_in\">show</span>();</span><br><span class=\"line\">\tg_global<span class=\"number\">2.</span><span class=\"built_in\">show</span>();</span><br><span class=\"line\">\tg_global<span class=\"number\">3.</span><span class=\"built_in\">show</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码定义了3个全局对象，分别调用了3种不同的构造函数。main()函数中使用全局对象调用了成员函数show。</p>\n<h3 id=\"定位全局对象\"><a href=\"#定位全局对象\" class=\"headerlink\" title=\"定位全局对象\"></a>定位全局对象</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401200 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:00401200 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:00401200</span><br><span class=\"line\">.text:00401200 argc            = dword ptr  8</span><br><span class=\"line\">.text:00401200 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:00401200 envp            = dword ptr  10h</span><br><span class=\"line\">.text:00401200</span><br><span class=\"line\">.text:00401200                 push    ebp</span><br><span class=\"line\">.text:00401201                 mov     ebp, esp</span><br><span class=\"line\">.text:00401203                 mov     ecx, offset unk_4033B8 ; 获取全局对象1首地址 ，&amp;g_global1</span><br><span class=\"line\">.text:00401208                 call    sub_4011B0      ; 调用show函数</span><br><span class=\"line\">.text:0040120D                 mov     ecx, offset unk_4033BC ; 获取对象2首地址，&amp;g_global2</span><br><span class=\"line\">.text:00401212                 call    sub_4011B0      ; 调用show函数</span><br><span class=\"line\">.text:00401217                 mov     ecx, offset unk_4033C0 ; 获取对象3首地址，&amp;g_global3</span><br><span class=\"line\">.text:0040121C                 call    sub_4011B0      ; 调用show函数</span><br><span class=\"line\">.text:00401221                 xor     eax, eax</span><br><span class=\"line\">.text:00401223                 pop     ebp</span><br><span class=\"line\">.text:00401224                 retn</span><br><span class=\"line\">.text:00401224 _main           endp</span><br></pre></td></tr></table></figure>\n\n<p>上面main函数汇编代码中，可以看到有三个全局地址标号：offset unk_4033B8、offset unk_4033BC、offset unk_4033C0，这些即为全局对象。</p>\n<p>有了全局对象的地址标号以后，接下来要对它们重新命名，如下所示。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">offset unk_4033B8 g_global1</span><br><span class=\"line\"></span><br><span class=\"line\">offset unk_4033BC g_global2</span><br><span class=\"line\"></span><br><span class=\"line\">offset unk_4033C0 g_global3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"atexit函数\"><a href=\"#atexit函数\" class=\"headerlink\" title=\"atexit函数\"></a>atexit函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构造代理函数</span></span><br><span class=\"line\">.text:<span class=\"number\">00401000</span> ; <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sub_401000</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">.text:<span class=\"number\">00401000</span> sub_401000      proc near               ;</span> DATA XREF: .rdata:<span class=\"number\">004020</span>D4↓o</span><br><span class=\"line\">.text:<span class=\"number\">00401000</span>                 push    ebp             ; 构造代理函数<span class=\"number\">1</span></span><br><span class=\"line\">.text:<span class=\"number\">00401001</span>                 mov     ebp, esp</span><br><span class=\"line\">.text:<span class=\"number\">00401003</span>                 mov     ecx, offset g_global1 ; <span class=\"type\">char</span></span><br><span class=\"line\">.text:<span class=\"number\">0040100</span>8                 call    sub_4010F0      ; 构造函数<span class=\"number\">1</span></span><br><span class=\"line\">.text:<span class=\"number\">0040100</span>D                 push    offset sub_401EF0 ; <span class=\"built_in\">void</span> (__cdecl *)()，析构代理函数<span class=\"number\">1</span></span><br><span class=\"line\">.text:<span class=\"number\">00401012</span>                 call    _atexit</span><br><span class=\"line\">.text:<span class=\"number\">00401017</span>                 add     esp, <span class=\"number\">4</span></span><br><span class=\"line\">.text:<span class=\"number\">0040101</span>A                 pop     ebp</span><br><span class=\"line\">.text:<span class=\"number\">0040101</span>B                 retn</span><br><span class=\"line\">.text:<span class=\"number\">0040101</span>B sub_401000      endp</span><br></pre></td></tr></table></figure>\n\n<p>根据上面的代码可见，在全局对象构造代理函数的分析中有个神秘的调用，这个函数的关键之处是调用atexit，查阅相关文档可知，该函数可以在退出main()函数后执行开发者自定义的函数（即注册终止函数），其函数声明如下。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> cdecl <span class=\"title\">atexit</span><span class=\"params\">(<span class=\"type\">void</span> ( cdecl *)(<span class=\"type\">void</span>))</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>只有一个无参且无返回值的函数指针作为atexit的参数，这个函数指针会添加在终止函数的数组中，在main()函数执行完毕后，由_execute_onexit_table函数倒序执行数组中的每个函数。</p>\n<p>了解这个函数后，atexit的参数sub_401EF0。将地址401EF0的内容反汇编之后不难发现，这个401EF0就是析构函数的代理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401EF0 ; void __cdecl sub_401EF0()</span><br><span class=\"line\">.text:00401EF0 sub_401EF0      proc near               ; DATA XREF: sub_401000+D↑o</span><br><span class=\"line\">.text:00401EF0                 push    ebp</span><br><span class=\"line\">.text:00401EF1                 mov     ebp, esp</span><br><span class=\"line\">.text:00401EF3                 mov     ecx, offset g_global1 ; char</span><br><span class=\"line\">.text:00401EF8                 call    sub_401180      ; 析构函数</span><br><span class=\"line\">.text:00401EFD                 pop     ebp</span><br><span class=\"line\">.text:00401EFE                 retn</span><br><span class=\"line\">.text:00401EFE sub_401EF0      endp</span><br></pre></td></tr></table></figure>\n\n<p>那么，atexit函数理所当然地成为我们寻找全局对象析构函数的指路灯。注意，在IDA的环境下，C的调用约定是在函数名前加上下划线“_”。查找函数<code>_atexit</code>，查看调用它的地址，如下图所示：</p>\n<p><img src=\"/./_atexit%E7%9A%84%E5%BC%95%E7%94%A8%E6%9F%A5%E7%9C%8B.png\" alt=\"_atexit的引用查看\"></p>\n<p>可以看到至少有两个地址调用这个函数，分别为0x00401000和0x00401020。双击0x00401000这个地址，找到</p>\n<p>_atexit的函数调用处：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401000 ; int sub_401000()</span><br><span class=\"line\">.text:00401000 sub_401000      proc near               ; DATA XREF: .rdata:004020D4↓o</span><br><span class=\"line\">.text:00401000                 push    ebp             ; 构造代理函数1</span><br><span class=\"line\">.text:00401001                 mov     ebp, esp</span><br><span class=\"line\">.text:00401003                 mov     ecx, offset g_global1 ; char</span><br><span class=\"line\">.text:00401008                 call    sub_4010F0      ; 构造函数1</span><br><span class=\"line\">.text:0040100D                 push    offset sub_401EF0 ; void (__cdecl *)()，析构代理函数1</span><br><span class=\"line\">.text:00401012                 call    _atexit</span><br><span class=\"line\">.text:00401017                 add     esp, 4</span><br><span class=\"line\">.text:0040101A                 pop     ebp</span><br><span class=\"line\">.text:0040101B                 retn</span><br><span class=\"line\">.text:0040101B sub_401000      endp</span><br><span class=\"line\"></span><br><span class=\"line\">.text:00401EF0 ; void __cdecl sub_401EF0()</span><br><span class=\"line\">.text:00401EF0 sub_401EF0      proc near               ; DATA XREF: sub_401000+D↑o</span><br><span class=\"line\">.text:00401EF0                 push    ebp</span><br><span class=\"line\">.text:00401EF1                 mov     ebp, esp</span><br><span class=\"line\">.text:00401EF3                 mov     ecx, offset g_global1 ; char</span><br><span class=\"line\">.text:00401EF8                 call    sub_401180      ; 析构函数</span><br><span class=\"line\">.text:00401EFD                 pop     ebp</span><br><span class=\"line\">.text:00401EFE                 retn</span><br><span class=\"line\">.text:00401EFE sub_401EF0      endp</span><br><span class=\"line\"></span><br><span class=\"line\">.text:00401180 ; int __fastcall sub_401180(_DWORD *)</span><br><span class=\"line\">.text:00401180 sub_401180      proc near               ; CODE XREF: sub_4011D0+A↓p</span><br><span class=\"line\">.text:00401180                                         ; sub_401EF0+8↓p ...</span><br><span class=\"line\">.text:00401180</span><br><span class=\"line\">.text:00401180 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401180</span><br><span class=\"line\">.text:00401180                 push    ebp</span><br><span class=\"line\">.text:00401181                 mov     ebp, esp</span><br><span class=\"line\">.text:00401183                 push    ecx             ; char</span><br><span class=\"line\">.text:00401184                 mov     [ebp-4], ecx</span><br><span class=\"line\">.text:00401187                 mov     eax, [ebp-4]</span><br><span class=\"line\">.text:0040118A                 mov     dword ptr [eax], offset off_402178</span><br><span class=\"line\">.text:00401190                 push    offset aGlobal_0 ; &quot;~Global()\\n&quot;</span><br><span class=\"line\">.text:00401195                 call    printf</span><br><span class=\"line\">.text:0040119A                 add     esp, 4</span><br><span class=\"line\">.text:0040119D                 mov     esp, ebp</span><br><span class=\"line\">.text:0040119F                 pop     ebp</span><br><span class=\"line\">.text:004011A0                 retn</span><br><span class=\"line\">.text:004011A0 sub_401180      endp</span><br></pre></td></tr></table></figure>\n\n<p>在调用_atexit函数前，压入了一个参数，这个参数为地址标号，此地址标号指向的地址正是全局对象g_global1的析构代理函数。进入析构代理函数，可以看到调用了一个函数sub_401180，这个函数正是全局对象的析构函数，在sub_401180 中 发 现 了 一 句 代 码 “mov     dword ptr [eax], offset off_402178”，这就是在析构函数中设置的虚表信息，offset off_402178是虚表首地址，将其重新命名为Global_vtable。</p>\n<p>使用快捷键x对Global_vtable使用交叉参考，如下图所示：</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/lobal_vtable%E7%9A%84%E4%BA%A4%E5%8F%89%E5%8F%82%E8%80%83.png\" alt=\"虚表Global_vtable的交叉参考\"></p>\n<p>从上图可知，共有4处引用此虚表。其中3处对应构造函数，另外1处对应析构函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x004010F0   无参构造函数</span><br><span class=\"line\">0x00401120   有参构造函数（int n）</span><br><span class=\"line\">0x00401150   有参构造函数（char *s）</span><br><span class=\"line\">0x00401180   析构函数</span><br></pre></td></tr></table></figure>\n\n<p>0x00401180这个地址便是析构函数写入虚表指令的 地 址  。 在 IDA 中 查 看 地 址0x004011下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401180 ; int __fastcall sub_401180(_DWORD *)</span><br><span class=\"line\">.text:00401180 sub_401180      proc near               ; CODE XREF: sub_4011D0+A↓p</span><br><span class=\"line\">.text:00401180                                         ; sub_401EF0+8↓p ...</span><br><span class=\"line\">.text:00401180</span><br><span class=\"line\">.text:00401180 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401180</span><br><span class=\"line\">.text:00401180                 push    ebp             ; 析构函数</span><br><span class=\"line\">.text:00401181                 mov     ebp, esp</span><br><span class=\"line\">.text:00401183                 push    ecx             ; char</span><br><span class=\"line\">.text:00401184                 mov     [ebp-4], ecx</span><br><span class=\"line\">.text:00401187                 mov     eax, [ebp-4]</span><br><span class=\"line\">.text:0040118A                 mov     dword ptr [eax], offset Global_vtable</span><br><span class=\"line\">.text:00401190                 push    offset aGlobal_0 ; &quot;~Global()\\n&quot;</span><br><span class=\"line\">.text:00401195                 call    printf</span><br><span class=\"line\">.text:0040119A                 add     esp, 4</span><br><span class=\"line\">.text:0040119D                 mov     esp, ebp</span><br><span class=\"line\">.text:0040119F                 pop     ebp</span><br><span class=\"line\">.text:004011A0                 retn</span><br><span class=\"line\">.text:004011A0 sub_401180      endp</span><br></pre></td></tr></table></figure>\n\n<p>结合虚表可以方便快捷地根据析构函数定位全局对象所属类的构造函数的调用情况。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>“Chart of xrefs from”指的是某数据或函数的来源，IDA的中文版翻译为“交叉参考来自……”是贴切的，因此本书使用“交叉参考来自……”的译法。</p>\n<p>“Chart of xrefs to”指的是数据或函数的引用者（读取者），译为“交叉参考到……”也是很贴切的，故本书使用此种译法</p></blockquote>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>关 于 atexit 的 实 现 原 理 ， 请 查 阅 VS2019 安 装 目 录 下 的\\Community\\VC\\Tools\\MSVC\\14.22.27905\\crt\\src\\vcruntime\\utility.cpp文件。如果程序存在全局对象、静态对象或者调用了atexit函数，那么在执行<code>_initterm</code>函数<code>(**it)()</code>的时候会执行<code>_register_onexit_function</code>函数，这个函数用于注册终止函数，这个终止函数由<code>_onexit</code>函数负责维护。在main()函数退出后，调用exit函数，exit函数又会调用<code>_execute_onexit_table</code>。在<code>_execute_onexit_table</code>函数内，遍历终止所有终止函数。</p>\n","text":"虚函数是面向对象程序设计的关键组成部分。对于具有虚函数的类而言，构造函数和析构函数的识别过程更加简单。而且，在类中定义虚函数之后，如果没有提供构造函数，编译器会...","permalink":"/post/C++逆向——虚函数","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">虚函数的机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%85%E5%90%AB%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">包含虚函数的类的定义及虚表指针的初始化过程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E8%87%AA%E8%BA%AB%E7%B1%BB%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">调用自身类中的虚函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90\"><span class=\"toc-text\">析构函数分析</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%86%E5%88%AB\"><span class=\"toc-text\">虚函数的识别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%AB%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">含有虚函数的全局对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%BD%8D%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">定位全局对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#atexit%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">atexit函数</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li></ol>","author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"C++逆向——识别类和类之间的关系","uid":"d75c57bec22710c7148f63c849522585","slug":"C++逆向——识别类和类之间的关系","date":"2023-02-15T12:11:27.000Z","updated":"2025-06-07T18:22:43.367Z","comments":true,"path":"api/articles/C++逆向——识别类和类之间的关系.json","keywords":null,"cover":[],"text":"在C++的继承关系中，子类具备父类所有成员数据和成员函数。子 类 对 象 可 以 直 接 使 用 父 类 中 声 明 为 公 有 （ public ） 和 保 ...","permalink":"/post/C++逆向——识别类和类之间的关系","photos":[],"count_time":{"symbolsCount":"70k","symbolsTime":"1:04"},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"C++逆向——析构函数","uid":"b0a53c23c95ed95e45a9b9b266d30456","slug":"C++逆向——析构函数","date":"2023-02-09T01:22:15.000Z","updated":"2025-06-07T18:07:06.600Z","comments":true,"path":"api/articles/C++逆向——析构函数.json","keywords":null,"cover":[],"text":"析构函数的出现时机对象何时被销毁呢？根据对象所在的作用域，当程序流程执行到作用域结束处时，会释放该作用域内的所有对象，在释放的过程中会调用对象的析构函数。析构函...","permalink":"/post/C++逆向——析构函数","photos":[],"count_time":{"symbolsCount":"36k","symbolsTime":"33 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}