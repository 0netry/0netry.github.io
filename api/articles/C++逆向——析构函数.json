{"title":"C++逆向——析构函数","uid":"b0a53c23c95ed95e45a9b9b266d30456","slug":"C++逆向——析构函数","date":"2023-02-09T01:22:15.000Z","updated":"2025-06-07T18:07:06.600Z","comments":true,"path":"api/articles/C++逆向——析构函数.json","keywords":null,"cover":[],"content":"<h1 id=\"析构函数的出现时机\"><a href=\"#析构函数的出现时机\" class=\"headerlink\" title=\"析构函数的出现时机\"></a>析构函数的出现时机</h1><h2 id=\"对象何时被销毁呢？\"><a href=\"#对象何时被销毁呢？\" class=\"headerlink\" title=\"对象何时被销毁呢？\"></a>对象何时被销毁呢？</h2><p>根据对象所在的作用域，当程序流程执行到作用域结束处时，会释放该作用域内的所有对象，在释放的过程中会调用对象的析构函数。析构函数与构造函数的出现时机相同，但并非有构造函数就一定会有对应的析构函数。析构函数的触发时机也需要视情况而定，主要分如下几种情况。</p>\n<ul>\n<li><p>局部对象：作用域结束前调用析构函数。</p>\n</li>\n<li><p>堆对象：释放堆空间前调用析构函数。</p>\n</li>\n<li><p>参数对象：退出函数前，调用参数对象的析构函数。</p>\n</li>\n<li><p>返回对象：如无对象引用定义，退出函数后，调用返回对象的析构函数，否则与对象引用的作用域一致。</p>\n</li>\n<li><p>全局对象：main()函数返回后调用析构函数。</p>\n</li>\n<li><p>静态对象：main()函数返回后调用析构函数。</p>\n</li>\n</ul>\n<h2 id=\"局部对象\"><a href=\"#局部对象\" class=\"headerlink\" title=\"局部对象\"></a>局部对象</h2><p>要考察局部对象析构函数出现的时机，应重点考察其作用域的结束处。与构造函数相比较而言，析构函数的出现时机相对固定。对于局部对象，当对象所在作用域结束后，将销毁该作用域所有变量的栈空间，此时便是析构函数出现的时机</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>() &#123;</span><br><span class=\"line\">\t\tage = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~<span class=\"built_in\">Person</span>() &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;~Person()\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\tPerson person;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">//退出函数后调用析构函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E5%AF%B9%E8%B1%A1/%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8.png\" alt=\"局部对象的析构函数调用\"></p>\n<p>上面代码中类Person提供了析构函数，在对象Person所在的作用域结束处，调用了析构函数~Person()。析构函数同样属于成员函数，因此在调用的过程中也需要传递this指针。</p>\n<p>析构函数与构造函数略有不同，析构函数不支持函数重载，只有一个参数，即this指针，而且编译器隐藏了这个参数的传递过程。对于开发者而言，它是一个隐藏了this指针的无参函数。</p>\n<h2 id=\"堆对象\"><a href=\"#堆对象\" class=\"headerlink\" title=\"堆对象\"></a>堆对象</h2><p>堆对象比较特殊，编译器将它的生杀大权交给了使用者。使用new申请堆对象空间后，何时释放对象要看开发者在哪里调用delete释放对象所在的堆空间。delete的使用便是找到堆对象调用析构函数的关键点。</p>\n<h3 id=\"堆对象析构函数的调用\"><a href=\"#堆对象析构函数的调用\" class=\"headerlink\" title=\"堆对象析构函数的调用\"></a>堆对象析构函数的调用</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>() &#123;</span><br><span class=\"line\">\t\tage = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~<span class=\"built_in\">Person</span>() &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;~Person()\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\tPerson* person = <span class=\"keyword\">new</span> <span class=\"built_in\">Person</span>();</span><br><span class=\"line\">\tperson-&gt;age = <span class=\"number\">21</span>; <span class=\"comment\">//为了便于讲解，这里没检查指针</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, person-&gt;age);</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> person;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>ida汇编及伪代码视图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//main函数</span><br><span class=\"line\">.text:004010C0 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:004010C0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:004010C0</span><br><span class=\"line\">.text:004010C0 var_24          = dword ptr -24h</span><br><span class=\"line\">.text:004010C0 var_20          = dword ptr -20h</span><br><span class=\"line\">.text:004010C0 var_1C          = dword ptr -1Ch</span><br><span class=\"line\">.text:004010C0 var_18          = dword ptr -18h</span><br><span class=\"line\">.text:004010C0 Block           = dword ptr -14h</span><br><span class=\"line\">.text:004010C0 var_10          = dword ptr -10h</span><br><span class=\"line\">.text:004010C0 var_C           = dword ptr -0Ch</span><br><span class=\"line\">.text:004010C0 var_4           = dword ptr -4</span><br><span class=\"line\">.text:004010C0 argc            = dword ptr  8</span><br><span class=\"line\">.text:004010C0 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:004010C0 envp            = dword ptr  10h</span><br><span class=\"line\">.text:004010C0</span><br><span class=\"line\">.text:004010C0 ; FUNCTION CHUNK AT .text:00401FE0 SIZE 0000000F BYTES</span><br><span class=\"line\">.text:004010C0 ; FUNCTION CHUNK AT .text:00401FF4 SIZE 0000001D BYTES</span><br><span class=\"line\">.text:004010C0</span><br><span class=\"line\">.text:004010C0 ; __unwind &#123; // _main_SEH</span><br><span class=\"line\">.text:004010C0                 push    ebp</span><br><span class=\"line\">.text:004010C1                 mov     ebp, esp</span><br><span class=\"line\">.text:004010C3                 push    0FFFFFFFFh</span><br><span class=\"line\">.text:004010C5                 push    offset _main_SEH</span><br><span class=\"line\">.text:004010CA                 mov     eax, large fs:0</span><br><span class=\"line\">.text:004010D0                 push    eax</span><br><span class=\"line\">.text:004010D1                 sub     esp, 18h</span><br><span class=\"line\">.text:004010D4                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:004010D9                 xor     eax, ebp</span><br><span class=\"line\">.text:004010DB                 push    eax</span><br><span class=\"line\">.text:004010DC                 lea     eax, [ebp-0Ch]</span><br><span class=\"line\">.text:004010DF                 mov     large fs:0, eax</span><br><span class=\"line\">.text:004010E5                 push    4               ; Size</span><br><span class=\"line\">.text:004010E7                 call    ??2@YAPAXI@Z    ; operator new(uint)，调用new函数申请内存空间</span><br><span class=\"line\">.text:004010EC                 add     esp, 4</span><br><span class=\"line\">.text:004010EF                 mov     [ebp-14h], eax  ; 保存申请的内存地址到临时变量</span><br><span class=\"line\">.text:004010F2 ;   try &#123;</span><br><span class=\"line\">.text:004010F2                 mov     dword ptr [ebp-4], 0</span><br><span class=\"line\">.text:004010F9                 cmp     dword ptr [ebp-14h], 0</span><br><span class=\"line\">.text:004010FD                 jz      short loc_40110C ; 检查内存空间是否申请成功</span><br><span class=\"line\">.text:004010FF                 mov     ecx, [ebp-14h]  ; 传递this指针</span><br><span class=\"line\">.text:00401102                 call    sub_401080      ; 申请内存成功，调用构造函数</span><br><span class=\"line\">.text:00401107                 mov     [ebp-18h], eax  ; 保存构造函数返回值到临时变量</span><br><span class=\"line\">.text:0040110A                 jmp     short loc_401113</span><br><span class=\"line\">.text:0040110C ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:0040110C</span><br><span class=\"line\">.text:0040110C loc_40110C:                             ; CODE XREF: _main+3D↑j</span><br><span class=\"line\">.text:0040110C                 mov     dword ptr [ebp-18h], 0 ; 申请内存失败，赋值临时变量NULL</span><br><span class=\"line\">.text:00401113</span><br><span class=\"line\">.text:00401113 loc_401113:                             ; CODE XREF: _main+4A↑j</span><br><span class=\"line\">.text:00401113                 mov     eax, [ebp-18h]</span><br><span class=\"line\">.text:00401116                 mov     [ebp-20h], eax  ; 保存申请的地址到指针变量person</span><br><span class=\"line\">.text:00401116 ;   &#125; // starts at 4010F2</span><br><span class=\"line\">.text:00401119                 mov     dword ptr [ebp-4], 0FFFFFFFFh</span><br><span class=\"line\">.text:00401120                 mov     ecx, [ebp-20h]  ; ecx=person</span><br><span class=\"line\">.text:00401123                 mov     [ebp-10h], ecx</span><br><span class=\"line\">.text:00401126                 mov     edx, [ebp-10h]</span><br><span class=\"line\">.text:00401129                 mov     dword ptr [edx], 15h ; person-&gt;age=21</span><br><span class=\"line\">.text:0040112F                 mov     eax, [ebp-10h]</span><br><span class=\"line\">.text:00401132                 mov     ecx, [eax]</span><br><span class=\"line\">.text:00401134                 push    ecx             ; 参数2，person-&gt;age</span><br><span class=\"line\">.text:00401135                 push    offset aD       ; &quot;%d\\n&quot;</span><br><span class=\"line\">.text:0040113A                 call    printf</span><br><span class=\"line\">.text:0040113F                 add     esp, 8</span><br><span class=\"line\">.text:00401142                 mov     edx, [ebp-10h]</span><br><span class=\"line\">.text:00401145                 mov     [ebp-1Ch], edx</span><br><span class=\"line\">.text:00401148                 cmp     dword ptr [ebp-1Ch], 0 ; 检查内存空间是否申请成功</span><br><span class=\"line\">.text:0040114C                 jz      short loc_40115D</span><br><span class=\"line\">.text:0040114E                 push    1               ; 标记，以后讲多重继承时会详谈</span><br><span class=\"line\">.text:00401150                 mov     ecx, [ebp-1Ch]  ; 传递this指针</span><br><span class=\"line\">.text:00401153                 call    sub_401180      ; 内存申请成功，调用析构代理函数</span><br><span class=\"line\">.text:00401158                 mov     [ebp-24h], eax</span><br><span class=\"line\">.text:0040115B                 jmp     short loc_401164</span><br><span class=\"line\">.text:0040115D ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:0040115D</span><br><span class=\"line\">.text:0040115D loc_40115D:                             ; CODE XREF: _main+8C↑j</span><br><span class=\"line\">.text:0040115D                 mov     dword ptr [ebp-24h], 0</span><br><span class=\"line\">.text:00401164</span><br><span class=\"line\">.text:00401164 loc_401164:                             ; CODE XREF: _main+9B↑j</span><br><span class=\"line\">.text:00401164                 xor     eax, eax</span><br><span class=\"line\">.text:00401166                 mov     ecx, [ebp-0Ch]</span><br><span class=\"line\">.text:00401169                 mov     large fs:0, ecx</span><br><span class=\"line\">.text:00401170                 pop     ecx</span><br><span class=\"line\">.text:00401171                 mov     esp, ebp</span><br><span class=\"line\">.text:00401173                 pop     ebp</span><br><span class=\"line\">.text:00401174                 retn</span><br><span class=\"line\">.text:00401174 ; &#125; // starts at 4010C0</span><br><span class=\"line\">.text:00401174 _main           endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  _DWORD *v4; // [esp+10h] [ebp-18h]</span><br><span class=\"line\">  void *Block; // [esp+14h] [ebp-14h]</span><br><span class=\"line\"></span><br><span class=\"line\">  Block = operator new(4u);</span><br><span class=\"line\">  if ( Block )</span><br><span class=\"line\">    v4 = (_DWORD *)sub_401080(Block);</span><br><span class=\"line\">  else</span><br><span class=\"line\">    v4 = 0;</span><br><span class=\"line\">  *v4 = 21;</span><br><span class=\"line\">  sub_401040(&quot;%d\\n&quot;, *v4);</span><br><span class=\"line\">  if ( v4 )</span><br><span class=\"line\">    sub_401180(1);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//析构代理函数</span><br><span class=\"line\">.text:00401180 ; void *__thiscall sub_401180(void *this, char)</span><br><span class=\"line\">.text:00401180 sub_401180      proc near               ; CODE XREF: _main+93↑p</span><br><span class=\"line\">.text:00401180</span><br><span class=\"line\">.text:00401180 Block           = dword ptr -4</span><br><span class=\"line\">.text:00401180 arg_0           = dword ptr  8</span><br><span class=\"line\">.text:00401180</span><br><span class=\"line\">.text:00401180                 push    ebp</span><br><span class=\"line\">.text:00401181                 mov     ebp, esp</span><br><span class=\"line\">.text:00401183                 push    ecx</span><br><span class=\"line\">.text:00401184                 mov     [ebp-4], ecx</span><br><span class=\"line\">.text:00401187                 mov     ecx, [ebp-4]    ; 传递this指针</span><br><span class=\"line\">.text:0040118A                 call    sub_4010A0      ; 调用析构函数</span><br><span class=\"line\">.text:0040118F                 mov     eax, [ebp+8]</span><br><span class=\"line\">.text:00401192                 and     eax, 1          ; 检查析构函数标记，以后讲多重继承时会详谈</span><br><span class=\"line\">.text:00401195                 jz      short loc_4011A5</span><br><span class=\"line\">.text:00401197                 push    4</span><br><span class=\"line\">.text:00401199                 mov     ecx, [ebp-4]</span><br><span class=\"line\">.text:0040119C                 push    ecx             ; 参数1，堆空间的首地址</span><br><span class=\"line\">.text:0040119D                 call    sub_4011EC      ; 调用delete函数，释放堆空间</span><br><span class=\"line\">.text:004011A2                 add     esp, 8</span><br><span class=\"line\">.text:004011A5</span><br><span class=\"line\">.text:004011A5 loc_4011A5:                             ; CODE XREF: sub_401180+15↑j</span><br><span class=\"line\">.text:004011A5                 mov     eax, [ebp+Block]</span><br><span class=\"line\">.text:004011A8                 mov     esp, ebp</span><br><span class=\"line\">.text:004011AA                 pop     ebp</span><br><span class=\"line\">.text:004011AB                 retn    4</span><br><span class=\"line\">.text:004011AB sub_401180      endp</span><br><span class=\"line\"></span><br><span class=\"line\">void *__thiscall sub_401180(void *this, char a2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  sub_4010A0((char)this);</span><br><span class=\"line\">  if ( (a2 &amp; 1) != 0 )</span><br><span class=\"line\">    sub_4011EC(this);</span><br><span class=\"line\">  return this;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//delete函数</span><br><span class=\"line\">.text:004011EC ; void __cdecl sub_4011EC(void *Block)</span><br><span class=\"line\">.text:004011EC sub_4011EC      proc near               ; CODE XREF: sub_401180+1D↑p</span><br><span class=\"line\">.text:004011EC                                         ; unknown_libname_2+1F↓p ...</span><br><span class=\"line\">.text:004011EC</span><br><span class=\"line\">.text:004011EC Block           = dword ptr  8</span><br><span class=\"line\">.text:004011EC</span><br><span class=\"line\">.text:004011EC                 push    ebp</span><br><span class=\"line\">.text:004011ED                 mov     ebp, esp</span><br><span class=\"line\">.text:004011EF                 push    [ebp+Block]     ; Block</span><br><span class=\"line\">.text:004011F2                 call    j_free</span><br><span class=\"line\">.text:004011F7                 pop     ecx</span><br><span class=\"line\">.text:004011F8                 pop     ebp</span><br><span class=\"line\">.text:004011F9                 retn</span><br><span class=\"line\">.text:004011F9 sub_4011EC      endp</span><br><span class=\"line\"></span><br><span class=\"line\">void __cdecl sub_4011EC(void *Block)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  j_free(Block);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>VS中的析构函数比较特殊，在释放过程中，需要使用析构代理函数间接调用析构函数。GCC和Clang编译器虽然没有使用代理析构函数，但是其生成的代码功能与代理析构函数一致。为什么不直接调用析构函数呢？原因有很多，其中一个就是在某些情况下，需要释放的对象不止一个，如果直接调用析构函数，无法完成多对象的析构。</p>\n<h3 id=\"多个堆对象的申请与释放\"><a href=\"#多个堆对象的申请与释放\" class=\"headerlink\" title=\"多个堆对象的申请与释放\"></a>多个堆对象的申请与释放</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>() &#123;</span><br><span class=\"line\">\t\tage = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~<span class=\"built_in\">Person</span>() &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;~Person()\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\tPerson* objs = <span class=\"keyword\">new</span> Person[<span class=\"number\">3</span>]; <span class=\"comment\">//申请对象数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">delete</span>[] objs; <span class=\"comment\">//释放对象数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>ida汇编及伪代码视图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:004010C0 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:004010C0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:004010C0</span><br><span class=\"line\">.text:004010C0 var_24          = dword ptr -24h</span><br><span class=\"line\">.text:004010C0 var_20          = dword ptr -20h</span><br><span class=\"line\">.text:004010C0 var_1C          = dword ptr -1Ch</span><br><span class=\"line\">.text:004010C0 var_18          = dword ptr -18h</span><br><span class=\"line\">.text:004010C0 var_14          = dword ptr -14h</span><br><span class=\"line\">.text:004010C0 Block           = dword ptr -10h</span><br><span class=\"line\">.text:004010C0 var_C           = dword ptr -0Ch</span><br><span class=\"line\">.text:004010C0 var_4           = dword ptr -4</span><br><span class=\"line\">.text:004010C0 argc            = dword ptr  8</span><br><span class=\"line\">.text:004010C0 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:004010C0 envp            = dword ptr  10h</span><br><span class=\"line\">.text:004010C0</span><br><span class=\"line\">.text:004010C0 ; FUNCTION CHUNK AT .text:00402200 SIZE 0000000F BYTES</span><br><span class=\"line\">.text:004010C0 ; FUNCTION CHUNK AT .text:00402214 SIZE 0000001D BYTES</span><br><span class=\"line\">.text:004010C0</span><br><span class=\"line\">.text:004010C0 ; __unwind &#123; // _main_SEH</span><br><span class=\"line\">.text:004010C0                 push    ebp</span><br><span class=\"line\">.text:004010C1                 mov     ebp, esp</span><br><span class=\"line\">.text:004010C3                 push    0FFFFFFFFh</span><br><span class=\"line\">.text:004010C5                 push    offset _main_SEH</span><br><span class=\"line\">.text:004010CA                 mov     eax, large fs:0</span><br><span class=\"line\">.text:004010D0                 push    eax</span><br><span class=\"line\">.text:004010D1                 sub     esp, 18h</span><br><span class=\"line\">.text:004010D4                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:004010D9                 xor     eax, ebp</span><br><span class=\"line\">.text:004010DB                 push    eax</span><br><span class=\"line\">.text:004010DC                 lea     eax, [ebp-0Ch]</span><br><span class=\"line\">.text:004010DF                 mov     large fs:0, eax</span><br><span class=\"line\">.text:004010E5                 push    10h             ; 每个对象占4字节，却申请了16字节大小的空间，多出的4字节数据是什么呢？</span><br><span class=\"line\">.text:004010E5                                         ; 在申请对象数组时，会使用堆空间的首地址处的4字节内容保存对象总个数</span><br><span class=\"line\">.text:004010E7                 call    sub_401368      ; 调用new函数</span><br><span class=\"line\">.text:004010EC                 add     esp, 4</span><br><span class=\"line\">.text:004010EF                 mov     [ebp-10h], eax  ; [ebp-10h]保存申请的堆空间的首地址</span><br><span class=\"line\">.text:004010F2 ;   try &#123;</span><br><span class=\"line\">.text:004010F2                 mov     dword ptr [ebp-4], 0</span><br><span class=\"line\">.text:004010F9                 cmp     dword ptr [ebp-10h], 0 ; 检查堆空间的申请是否成功</span><br><span class=\"line\">.text:004010FD                 jz      short loc_40112D ; 申请堆空间失败，赋值空指针</span><br><span class=\"line\">.text:004010FF                 mov     eax, [ebp-10h]</span><br><span class=\"line\">.text:00401102                 mov     dword ptr [eax], 3 ; 设置首地址的4字节数据为对象个数</span><br><span class=\"line\">.text:00401108                 push    offset sub_4010A0 ; 参数5，析构函数的地址，作为构造代理函数参数</span><br><span class=\"line\">.text:0040110D                 push    offset sub_401080 ; 参数4，构造函数的地址，作为构造代理函数参数</span><br><span class=\"line\">.text:00401112                 push    3               ; 参数3，对象个数，作为函数参数</span><br><span class=\"line\">.text:00401114                 push    4               ; 参数2，对象大小，作为函数参数</span><br><span class=\"line\">.text:00401116                 mov     ecx, [ebp-10h]</span><br><span class=\"line\">.text:00401119                 add     ecx, 4          ; 跳过首地址的4字节数据</span><br><span class=\"line\">.text:0040111C                 push    ecx             ; 参数1，第一个对象地址，作为函数参数</span><br><span class=\"line\">.text:0040111D                 call    ??_L@YGXPAXIIP6EX0@Z1@Z ; `eh vector constructor iterator&#x27;(void *,uint,uint,void (*)(void *),void (*)(void *)) ; 构造函数迭代器</span><br><span class=\"line\">.text:00401122                 mov     edx, [ebp-10h]</span><br><span class=\"line\">.text:00401125                 add     edx, 4          ; 跳过堆空间首4字节的数据</span><br><span class=\"line\">.text:00401128                 mov     [ebp-14h], edx  ; 保存堆空间中的第一个对象的首地址</span><br><span class=\"line\">.text:0040112B                 jmp     short loc_401134 ; 跳过申请堆空间失败的处理</span><br><span class=\"line\">.text:0040112D ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:0040112D</span><br><span class=\"line\">.text:0040112D loc_40112D:                             ; CODE XREF: _main+3D↑j</span><br><span class=\"line\">.text:0040112D                 mov     dword ptr [ebp-14h], 0 ; 申请堆空间失败，赋值空指针</span><br><span class=\"line\">.text:00401134</span><br><span class=\"line\">.text:00401134 loc_401134:                             ; CODE XREF: _main+6B↑j</span><br><span class=\"line\">.text:00401134                 mov     eax, [ebp-14h]</span><br><span class=\"line\">.text:00401137                 mov     [ebp-1Ch], eax</span><br><span class=\"line\">.text:00401137 ;   &#125; // starts at 4010F2</span><br><span class=\"line\">.text:0040113A                 mov     dword ptr [ebp-4], 0FFFFFFFFh</span><br><span class=\"line\">.text:00401141                 mov     ecx, [ebp-1Ch]</span><br><span class=\"line\">.text:00401144                 mov     [ebp-20h], ecx</span><br><span class=\"line\">.text:00401147                 mov     edx, [ebp-20h]</span><br><span class=\"line\">.text:0040114A                 mov     [ebp-18h], edx  ; 数据最后到objs，打开02就简洁了</span><br><span class=\"line\">.text:0040114D                 cmp     dword ptr [ebp-18h], 0</span><br><span class=\"line\">.text:00401151                 jz      short loc_401162 ; 检查对象指针是否为NULL</span><br><span class=\"line\">.text:00401153                 push    3               ; 参数2，释放对象类型标志</span><br><span class=\"line\">.text:00401153                                         ; 1为单个对象，3为释放对象数组</span><br><span class=\"line\">.text:00401153                                         ; 0表示仅执行析构函数，不释放堆空间（其作用会在讲解多重继承时详细介绍）</span><br><span class=\"line\">.text:00401153                                         ; 这个标志占2位，使用delete[]时标志为二进制11，直接用delete为二进制01</span><br><span class=\"line\">.text:00401155                 mov     ecx, [ebp-18h]  ; 参数1，释放堆对象首地址</span><br><span class=\"line\">.text:00401158                 call    ??_E?$ComPtr@UIUnknown@@@WRL@Microsoft@@QAEPAXI@Z ; Microsoft::WRL::ComPtr&lt;IUnknown&gt;::`vector deleting destructor&#x27;(uint)</span><br><span class=\"line\">.text:00401158                                         ; 释放堆对象函数，该函数有两个参数</span><br><span class=\"line\">.text:0040115D                 mov     [ebp-24h], eax</span><br><span class=\"line\">.text:00401160                 jmp     short loc_401169</span><br><span class=\"line\">.text:00401162 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:00401162</span><br><span class=\"line\">.text:00401162 loc_401162:                             ; CODE XREF: _main+91↑j</span><br><span class=\"line\">.text:00401162                 mov     dword ptr [ebp-24h], 0</span><br><span class=\"line\">.text:00401169</span><br><span class=\"line\">.text:00401169 loc_401169:                             ; CODE XREF: _main+A0↑j</span><br><span class=\"line\">.text:00401169                 xor     eax, eax</span><br><span class=\"line\">.text:0040116B                 mov     ecx, [ebp-0Ch]</span><br><span class=\"line\">.text:0040116E                 mov     large fs:0, ecx</span><br><span class=\"line\">.text:00401175                 pop     ecx</span><br><span class=\"line\">.text:00401176                 mov     esp, ebp</span><br><span class=\"line\">.text:00401178                 pop     ebp</span><br><span class=\"line\">.text:00401179                 retn</span><br><span class=\"line\">.text:00401179 ; &#125; // starts at 4010C0</span><br><span class=\"line\">.text:00401179 _main           endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  _DWORD *v4; // [esp+14h] [ebp-14h]</span><br><span class=\"line\">  _DWORD *Block; // [esp+18h] [ebp-10h]</span><br><span class=\"line\"></span><br><span class=\"line\">  Block = (_DWORD *)sub_401368(16);</span><br><span class=\"line\">  if ( Block )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    *Block = 3;</span><br><span class=\"line\">    `eh vector constructor iterator&#x27;(Block + 1, 4u, 3u, sub_401080, (void (__thiscall *)(void *))sub_4010A0);</span><br><span class=\"line\">    v4 = Block + 1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  else</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v4 = 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if ( v4 )</span><br><span class=\"line\">    Microsoft::WRL::ComPtr&lt;IUnknown&gt;::`vector deleting destructor&#x27;(3);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>根据上面的代码可以知道，在申请对象数组时，由于对象都在同一个堆空间中，32位程序编译器使用了堆空间的前4字节数据保存对象的总个数，64位程序编译器使用了堆空间的前8字节数据保存对象的总个数。正是因为多出来的这些空间，许多初学者在申请对象数组时使用了new []，而在释放对象的过程中没有使用delete []（使用的是delete），于是产生了堆空间释放的错误。在使用delete（不使用delete []）的情况下，当数组元素为基本数据类型时不会出错，但是当数组元素为存在析构函数的对象时就会出错</p>\n<p>在VS中，由于类对象与其他基本数据类型不同，在对象产生时，需要调用构造函数来初始化对象中的数据，所以用到了代理函数。代理函数的功能是根据对象数组的元素逐个调用它们的构造函数，完成初始化过程。GCC和Clang虽然没有使用代理函数，但是功能和代理函数一致。</p>\n<h3 id=\"堆对象数组的构造函数初始化代码\"><a href=\"#堆对象数组的构造函数初始化代码\" class=\"headerlink\" title=\"堆对象数组的构造函数初始化代码\"></a>堆对象数组的构造函数初始化代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>() &#123;</span><br><span class=\"line\">\t\tage = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~<span class=\"built_in\">Person</span>() &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;~Person()\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\tPerson* objs = <span class=\"keyword\">new</span> Person[<span class=\"number\">3</span>]; <span class=\"comment\">//申请对象数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">delete</span>[] objs; <span class=\"comment\">//释放对象数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ida汇编及伪代码视图（main函数见上一节，堆对象数组的构造函数初始化代码）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//构造代理函数有5个参数</span><br><span class=\"line\">//第一个对象地址、对象大小、对象个数、构造函数的地址、析构函数的地址</span><br><span class=\"line\">.text:00401371 ; void __stdcall `eh vector constructor iterator&#x27;(char *, unsigned int, unsigned int, void (__thiscall *)(void *), void (__thiscall *)(void *))</span><br><span class=\"line\">.text:00401371 ??_L@YGXPAXIIP6EX0@Z1@Z proc near       ; CODE XREF: _main+5D↑p</span><br><span class=\"line\">.text:00401371</span><br><span class=\"line\">.text:00401371 var_20          = dword ptr -20h</span><br><span class=\"line\">.text:00401371 var_19          = byte ptr -19h</span><br><span class=\"line\">.text:00401371 ms_exc          = CPPEH_RECORD ptr -18h</span><br><span class=\"line\">.text:00401371 arg_0           = dword ptr  8</span><br><span class=\"line\">.text:00401371 arg_4           = dword ptr  0Ch</span><br><span class=\"line\">.text:00401371 arg_8           = dword ptr  10h</span><br><span class=\"line\">.text:00401371 arg_C           = dword ptr  14h</span><br><span class=\"line\">.text:00401371 arg_10          = dword ptr  18h</span><br><span class=\"line\">.text:00401371</span><br><span class=\"line\">.text:00401371 ; __unwind &#123; // __SEH_prolog4</span><br><span class=\"line\">.text:00401371                 push    10h</span><br><span class=\"line\">.text:00401373                 push    offset stru_4037D8</span><br><span class=\"line\">.text:00401378                 call    __SEH_prolog4</span><br><span class=\"line\">.text:0040137D                 xor     ebx, ebx</span><br><span class=\"line\">.text:0040137F                 mov     [ebp+var_20], ebx</span><br><span class=\"line\">.text:00401382                 mov     [ebp+var_19], bl</span><br><span class=\"line\">.text:00401385 ;   __try &#123; // __finally(loc_4013CB)</span><br><span class=\"line\">.text:00401385                 mov     [ebp+ms_exc.registration.TryLevel], ebx</span><br><span class=\"line\">.text:00401388</span><br><span class=\"line\">.text:00401388 loc_401388:                             ; CODE XREF: `eh vector constructor iterator&#x27;(void *,uint,uint,void (*)(void *),void (*)(void *))+35↓j</span><br><span class=\"line\">.text:00401388                 cmp     ebx, [ebp+arg_8] ; 判断对象个数是否为0</span><br><span class=\"line\">.text:0040138B                 jz      short loc_4013A8</span><br><span class=\"line\">.text:0040138D                 mov     ecx, [ebp+arg_C] ; 获取构造函数地址并保存到ecx中</span><br><span class=\"line\">.text:00401390                 call    ds:___guard_check_icall_fptr ; guard_check_icall_fptr 是CFG保护开启才有的保护函数；这个函数里面，将会去判断 ecx 这个地址里的调用函数是不是一个合法的函数。</span><br><span class=\"line\">.text:00401396                 mov     ecx, [ebp+arg_0] ; 获取对象所在堆空间的首地址，使用ecx传递this指针</span><br><span class=\"line\">.text:00401399                 call    [ebp+arg_C]     ; 调用构造函数</span><br><span class=\"line\">.text:0040139C                 mov     eax, [ebp+arg_4]</span><br><span class=\"line\">.text:0040139F                 add     [ebp+arg_0], eax ; 修改指针，使其指向下一对象的首地址</span><br><span class=\"line\">.text:004013A2                 inc     ebx</span><br><span class=\"line\">.text:004013A3                 mov     [ebp+var_20], ebx</span><br><span class=\"line\">.text:004013A6                 jmp     short loc_401388 ; 判断对象个数是否为0</span><br><span class=\"line\">.text:004013A8 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:004013A8</span><br><span class=\"line\">.text:004013A8 loc_4013A8:                             ; CODE XREF: `eh vector constructor iterator&#x27;(void *,uint,uint,void (*)(void *),void (*)(void *))+1A↑j</span><br><span class=\"line\">.text:004013A8                 mov     al, 1</span><br><span class=\"line\">.text:004013AA                 mov     [ebp+var_19], al</span><br><span class=\"line\">.text:004013AA ;   &#125; // starts at 401385</span><br><span class=\"line\">.text:004013AD                 mov     [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh</span><br><span class=\"line\">.text:004013B4                 call    loc_4013D1</span><br><span class=\"line\">.text:004013B9 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:004013B9</span><br><span class=\"line\">.text:004013B9 loc_4013B9:                             ; CODE XREF: `eh vector constructor iterator&#x27;(void *,uint,uint,void (*)(void *),void (*)(void *)):loc_4013E4↓j</span><br><span class=\"line\">.text:004013B9                 mov     ecx, [ebp+ms_exc.registration.Next]</span><br><span class=\"line\">.text:004013BC                 mov     large fs:0, ecx</span><br><span class=\"line\">.text:004013C3                 pop     ecx</span><br><span class=\"line\">.text:004013C4                 pop     edi</span><br><span class=\"line\">.text:004013C5                 pop     esi</span><br><span class=\"line\">.text:004013C6                 pop     ebx</span><br><span class=\"line\">.text:004013C7                 leave</span><br><span class=\"line\">.text:004013C8                 retn    14h</span><br><span class=\"line\">.text:004013CB ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:004013CB</span><br><span class=\"line\">.text:004013CB loc_4013CB:                             ; DATA XREF: .rdata:stru_4037D8↓o</span><br><span class=\"line\">.text:004013CB ;   __finally // owned by 401385</span><br><span class=\"line\">.text:004013CB                 mov     ebx, [ebp+var_20]</span><br><span class=\"line\">.text:004013CE                 mov     al, [ebp+var_19]</span><br><span class=\"line\">.text:004013D1</span><br><span class=\"line\">.text:004013D1 loc_4013D1:                             ; CODE XREF: `eh vector constructor iterator&#x27;(void *,uint,uint,void (*)(void *),void (*)(void *))+43↑j</span><br><span class=\"line\">.text:004013D1                 test    al, al</span><br><span class=\"line\">.text:004013D3                 jnz     short loc_4013E4</span><br><span class=\"line\">.text:004013D5                 push    [ebp+arg_10]    ; 析构函数地址</span><br><span class=\"line\">.text:004013D8                 push    ebx             ; unsigned int</span><br><span class=\"line\">.text:004013D9                 push    [ebp+arg_4]     ; unsigned int</span><br><span class=\"line\">.text:004013DC                 push    [ebp+arg_0]     ; void *</span><br><span class=\"line\">.text:004013DF                 call    ?__ArrayUnwind@@YGXPAXIIP6EX0@Z@Z ; __ArrayUnwind(void *,uint,uint,void (*)(void *)) ; 如果某个构造函数产生异常，则进行栈解退，用到析构函数</span><br><span class=\"line\">.text:004013E4</span><br><span class=\"line\">.text:004013E4 loc_4013E4:                             ; CODE XREF: `eh vector constructor iterator&#x27;(void *,uint,uint,void (*)(void *),void (*)(void *))+62↑j</span><br><span class=\"line\">.text:004013E4                 retn</span><br><span class=\"line\">.text:004013E4 ; &#125; // starts at 401371</span><br><span class=\"line\">.text:004013E4 ??_L@YGXPAXIIP6EX0@Z1@Z endp</span><br><span class=\"line\"></span><br><span class=\"line\">void __stdcall `eh vector constructor iterator&#x27;(</span><br><span class=\"line\">        char *a1,</span><br><span class=\"line\">        unsigned int a2,</span><br><span class=\"line\">        unsigned int a3,</span><br><span class=\"line\">        void (__thiscall *a4)(void *),</span><br><span class=\"line\">        void (__thiscall *a5)(void *))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  int i; // ebx</span><br><span class=\"line\"></span><br><span class=\"line\">  for ( i = 0; i != a3; ++i )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    a4(a1);</span><br><span class=\"line\">    a1 += a2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面展示了申请多个堆对象构造函数的调用过程。在Release版下，编译器产生了循环结构的代码，根据数组中对象的总个数，从堆数组中的第一个对象首地址开始，依次向后遍历数组中的每个对象，将数组中每个对象的首地址作为this指针逐个调用构造函数。</p>\n<h3 id=\"堆对象释放代码分析\"><a href=\"#堆对象释放代码分析\" class=\"headerlink\" title=\"堆对象释放代码分析\"></a>堆对象释放代码分析</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>() &#123;</span><br><span class=\"line\">\t\tage = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~<span class=\"built_in\">Person</span>() &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;~Person()\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\tPerson* objs = <span class=\"keyword\">new</span> Person[<span class=\"number\">3</span>]; <span class=\"comment\">//申请对象数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">delete</span>[] objs; <span class=\"comment\">//释放对象数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ida汇编及伪代码视图（main函数见上一节，这里只分析堆对象释放代码）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//释放堆对象函数，该函数有两个参数：</span><br><span class=\"line\">//释放堆对象首地址（通过ecx传递）</span><br><span class=\"line\">//释放对象类型标志（1为单个对象，3为释放对象数组，0表示仅执行析构函数，不释放堆空间，此处为3）</span><br><span class=\"line\">.text:00401180 ; char *__thiscall Microsoft::WRL::ComPtr&lt;IUnknown&gt;::`vector deleting destructor&#x27;(char *this, char)</span><br><span class=\"line\">.text:00401180 ??_E?$ComPtr@UIUnknown@@@WRL@Microsoft@@QAEPAXI@Z proc near</span><br><span class=\"line\">.text:00401180                                         ; CODE XREF: _main+98↑p</span><br><span class=\"line\">.text:00401180</span><br><span class=\"line\">.text:00401180 Block           = dword ptr -10h</span><br><span class=\"line\">.text:00401180 var_C           = dword ptr -0Ch</span><br><span class=\"line\">.text:00401180 arg_0           = dword ptr  8</span><br><span class=\"line\">.text:00401180 arg_4           = dword ptr  0Ch</span><br><span class=\"line\">.text:00401180</span><br><span class=\"line\">.text:00401180 ; FUNCTION CHUNK AT .text:00402240 SIZE 0000001D BYTES</span><br><span class=\"line\">.text:00401180</span><br><span class=\"line\">.text:00401180 ; __unwind &#123; // SEH_401180</span><br><span class=\"line\">.text:00401180                 push    ebp</span><br><span class=\"line\">.text:00401181                 mov     ebp, esp</span><br><span class=\"line\">.text:00401183                 push    0FFFFFFFFh</span><br><span class=\"line\">.text:00401185                 push    offset SEH_401180</span><br><span class=\"line\">.text:0040118A                 mov     eax, large fs:0</span><br><span class=\"line\">.text:00401190                 push    eax</span><br><span class=\"line\">.text:00401191                 push    ecx</span><br><span class=\"line\">.text:00401192                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:00401197                 xor     eax, ebp</span><br><span class=\"line\">.text:00401199                 push    eax</span><br><span class=\"line\">.text:0040119A                 lea     eax, [ebp+var_C]</span><br><span class=\"line\">.text:0040119D                 mov     large fs:0, eax</span><br><span class=\"line\">.text:004011A3                 mov     [ebp+Block], ecx</span><br><span class=\"line\">.text:004011A6                 mov     eax, [ebp+arg_0]</span><br><span class=\"line\">.text:004011A9                 and     eax, 2          ; 判断释放标志，是否为对象数组</span><br><span class=\"line\">.text:004011AC                 jz      short loc_4011F2</span><br><span class=\"line\">.text:004011AE                 push    offset sub_4010A0 ; 参数4，析构函数地址，作为析构代理函数参数使用</span><br><span class=\"line\">.text:004011B3                 mov     ecx, [ebp+Block] ; 获取第一个对象的首地址</span><br><span class=\"line\">.text:004011B6                 mov     edx, [ecx-4]    ; 获取对象个数</span><br><span class=\"line\">.text:004011B9                 push    edx             ; 参数3，堆空间中的对象总数</span><br><span class=\"line\">.text:004011BA                 push    4               ; 参数2，每个对象大小</span><br><span class=\"line\">.text:004011BC                 mov     eax, [ebp+Block]</span><br><span class=\"line\">.text:004011BF                 push    eax             ; 参数1，对象的首地址</span><br><span class=\"line\">.text:004011C0                 call    ??_M@YGXPAXIIP6EX0@Z@Z ; `eh vector destructor iterator&#x27;(void *,uint,uint,void (*)(void *))，析构函数迭代器</span><br><span class=\"line\">.text:004011C5                 mov     ecx, [ebp+arg_0] ; 获取释放标志</span><br><span class=\"line\">.text:004011C8                 and     ecx, 1</span><br><span class=\"line\">.text:004011CB                 jz      short loc_4011EA ; 检查是否释放堆空间</span><br><span class=\"line\">.text:004011CD                 mov     edx, [ebp+Block]</span><br><span class=\"line\">.text:004011D0                 mov     eax, [edx-4]</span><br><span class=\"line\">.text:004011D3                 lea     ecx, ds:4[eax*4]</span><br><span class=\"line\">.text:004011DA                 push    ecx</span><br><span class=\"line\">.text:004011DB                 mov     edx, [ebp+Block]</span><br><span class=\"line\">.text:004011DE                 sub     edx, 4</span><br><span class=\"line\">.text:004011E1                 push    edx             ; Block，修正为堆空间的首地址</span><br><span class=\"line\">.text:004011E2                 call    sub_401237      ; 调用delete函数释放堆空间</span><br><span class=\"line\">.text:004011E7                 add     esp, 8</span><br><span class=\"line\">.text:004011EA</span><br><span class=\"line\">.text:004011EA loc_4011EA:                             ; CODE XREF: Microsoft::WRL::ComPtr&lt;IUnknown&gt;::`vector deleting destructor&#x27;(uint)+4B↑j</span><br><span class=\"line\">.text:004011EA                 mov     eax, [ebp+Block]</span><br><span class=\"line\">.text:004011ED                 sub     eax, 4</span><br><span class=\"line\">.text:004011F0                 jmp     short loc_401213</span><br><span class=\"line\">.text:004011F2 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:004011F2</span><br><span class=\"line\">.text:004011F2 loc_4011F2:                             ; CODE XREF: Microsoft::WRL::ComPtr&lt;IUnknown&gt;::`vector deleting destructor&#x27;(uint)+2C↑j</span><br><span class=\"line\">.text:004011F2                 mov     ecx, [ebp+Block] ; 参数1，对象的首地址</span><br><span class=\"line\">.text:004011F5                 call    sub_4010A0      ; 调用析构函数</span><br><span class=\"line\">.text:004011FA                 mov     eax, [ebp+arg_0] ; 获取释放标志</span><br><span class=\"line\">.text:004011FD                 and     eax, 1</span><br><span class=\"line\">.text:00401200                 jz      short loc_401210 ; 检查是否释放堆空间</span><br><span class=\"line\">.text:00401202                 push    4</span><br><span class=\"line\">.text:00401204                 mov     ecx, [ebp+Block]</span><br><span class=\"line\">.text:00401207                 push    ecx             ; Block</span><br><span class=\"line\">.text:00401208                 call    sub_40135A      ; 调用delete释放堆空间</span><br><span class=\"line\">.text:0040120D                 add     esp, 8</span><br><span class=\"line\">.text:00401210</span><br><span class=\"line\">.text:00401210 loc_401210:                             ; CODE XREF: Microsoft::WRL::ComPtr&lt;IUnknown&gt;::`vector deleting destructor&#x27;(uint)+80↑j</span><br><span class=\"line\">.text:00401210                 mov     eax, [ebp+Block]</span><br><span class=\"line\">.text:00401213</span><br><span class=\"line\">.text:00401213 loc_401213:                             ; CODE XREF: Microsoft::WRL::ComPtr&lt;IUnknown&gt;::`vector deleting destructor&#x27;(uint)+70↑j</span><br><span class=\"line\">.text:00401213                 mov     ecx, [ebp+var_C]</span><br><span class=\"line\">.text:00401216                 mov     large fs:0, ecx</span><br><span class=\"line\">.text:0040121D                 pop     ecx</span><br><span class=\"line\">.text:0040121E                 mov     esp, ebp</span><br><span class=\"line\">.text:00401220                 pop     ebp</span><br><span class=\"line\">.text:00401221                 retn    4</span><br><span class=\"line\">.text:00401221 ; &#125; // starts at 401180</span><br><span class=\"line\">.text:00401221 ??_E?$ComPtr@UIUnknown@@@WRL@Microsoft@@QAEPAXI@Z endp</span><br><span class=\"line\"></span><br><span class=\"line\">char *__thiscall Microsoft::WRL::ComPtr&lt;IUnknown&gt;::`vector deleting destructor&#x27;(char *this, char a2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if ( (a2 &amp; 2) != 0 )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    `eh vector destructor iterator&#x27;(this, 4u, *((_DWORD *)this - 1), (void (__thiscall *)(void *))sub_4010A0);</span><br><span class=\"line\">    if ( (a2 &amp; 1) != 0 )</span><br><span class=\"line\">      sub_401237(this - 4);</span><br><span class=\"line\">    return this - 4;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  else</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    sub_4010A0((char)this);</span><br><span class=\"line\">    if ( (a2 &amp; 1) != 0 )</span><br><span class=\"line\">      sub_40135A(this);</span><br><span class=\"line\">    return this;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//析构函数迭代器，有四个参数：</span><br><span class=\"line\">//对象的首地址、每个对象大小、堆空间中的对象总数、析构函数地址</span><br><span class=\"line\">.text:00401245 ; void __stdcall `eh vector destructor iterator&#x27;(char *, unsigned int, unsigned int, void (__thiscall *)(void *))</span><br><span class=\"line\">.text:00401245 ??_M@YGXPAXIIP6EX0@Z@Z proc near        ; CODE XREF: Microsoft::WRL::ComPtr&lt;IUnknown&gt;::`vector deleting destructor&#x27;(uint)+40↑p</span><br><span class=\"line\">.text:00401245</span><br><span class=\"line\">.text:00401245 var_19          = byte ptr -19h</span><br><span class=\"line\">.text:00401245 ms_exc          = CPPEH_RECORD ptr -18h</span><br><span class=\"line\">.text:00401245 arg_0           = dword ptr  8</span><br><span class=\"line\">.text:00401245 arg_4           = dword ptr  0Ch</span><br><span class=\"line\">.text:00401245 arg_8           = dword ptr  10h</span><br><span class=\"line\">.text:00401245 arg_C           = dword ptr  14h</span><br><span class=\"line\">.text:00401245</span><br><span class=\"line\">.text:00401245 ; __unwind &#123; // __SEH_prolog4</span><br><span class=\"line\">.text:00401245                 push    0Ch</span><br><span class=\"line\">.text:00401247                 push    offset stru_403798</span><br><span class=\"line\">.text:0040124C                 call    __SEH_prolog4</span><br><span class=\"line\">.text:00401251                 mov     [ebp+var_19], 0</span><br><span class=\"line\">.text:00401255                 mov     ebx, [ebp+arg_4] ; 获取对象大小</span><br><span class=\"line\">.text:00401258                 mov     eax, ebx</span><br><span class=\"line\">.text:0040125A                 mov     edi, [ebp+arg_8] ; 获取堆空间中的对象总数</span><br><span class=\"line\">.text:0040125D                 imul    eax, edi        ; 计算对象数组大小</span><br><span class=\"line\">.text:00401260                 mov     esi, [ebp+arg_0] ; 获取对象的首地址</span><br><span class=\"line\">.text:00401263                 add     esi, eax</span><br><span class=\"line\">.text:00401265                 mov     [ebp+arg_0], esi ; 定位到对象数组的末尾</span><br><span class=\"line\">.text:00401268 ;   __try &#123; // __finally(loc_4012AE)</span><br><span class=\"line\">.text:00401268                 and     [ebp+ms_exc.registration.TryLevel], 0</span><br><span class=\"line\">.text:0040126C</span><br><span class=\"line\">.text:0040126C loc_40126C:                             ; CODE XREF: `eh vector destructor iterator&#x27;(void *,uint,uint,void (*)(void *))+44↓j</span><br><span class=\"line\">.text:0040126C                 mov     eax, edi</span><br><span class=\"line\">.text:0040126E                 dec     edi</span><br><span class=\"line\">.text:0040126F                 mov     [ebp+arg_8], edi</span><br><span class=\"line\">.text:00401272                 test    eax, eax</span><br><span class=\"line\">.text:00401274                 jz      short loc_40128B</span><br><span class=\"line\">.text:00401276                 sub     esi, ebx        ; 修正为第n个对象的首地址（从后往前）</span><br><span class=\"line\">.text:00401278                 mov     [ebp+arg_0], esi</span><br><span class=\"line\">.text:0040127B                 mov     ecx, [ebp+arg_C] ; 获取析构函数地址并保存到ecx中</span><br><span class=\"line\">.text:0040127E                 call    ds:___guard_check_icall_fptr ; guard_check_icall_fptr 是CFG保护开启才有的保护函数；这个函数里面，将会去判断 ecx 这个地址里的调用函数是不是一个合法的函数。</span><br><span class=\"line\">.text:00401284                 mov     ecx, esi        ; 获取对象所在堆空间的首地址，使用ecx传递this指针</span><br><span class=\"line\">.text:00401286                 call    [ebp+arg_C]     ; 调用析构函数</span><br><span class=\"line\">.text:00401289                 jmp     short loc_40126C</span><br><span class=\"line\">.text:0040128B ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:0040128B</span><br><span class=\"line\">.text:0040128B loc_40128B:                             ; CODE XREF: `eh vector destructor iterator&#x27;(void *,uint,uint,void (*)(void *))+2F↑j</span><br><span class=\"line\">.text:0040128B                 mov     al, 1</span><br><span class=\"line\">.text:0040128D                 mov     [ebp+var_19], al</span><br><span class=\"line\">.text:0040128D ;   &#125; // starts at 401268</span><br><span class=\"line\">.text:00401290                 mov     [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh</span><br><span class=\"line\">.text:00401297                 call    loc_4012BA</span><br><span class=\"line\">.text:0040129C ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:0040129C</span><br><span class=\"line\">.text:0040129C loc_40129C:                             ; CODE XREF: `eh vector destructor iterator&#x27;(void *,uint,uint,void (*)(void *)):loc_4012C9↓j</span><br><span class=\"line\">.text:0040129C                 mov     ecx, [ebp+ms_exc.registration.Next]</span><br><span class=\"line\">.text:0040129F                 mov     large fs:0, ecx</span><br><span class=\"line\">.text:004012A6                 pop     ecx</span><br><span class=\"line\">.text:004012A7                 pop     edi</span><br><span class=\"line\">.text:004012A8                 pop     esi</span><br><span class=\"line\">.text:004012A9                 pop     ebx</span><br><span class=\"line\">.text:004012AA                 leave</span><br><span class=\"line\">.text:004012AB                 retn    10h</span><br><span class=\"line\">.text:004012AE ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:004012AE</span><br><span class=\"line\">.text:004012AE loc_4012AE:                             ; DATA XREF: .rdata:stru_403798↓o</span><br><span class=\"line\">.text:004012AE ;   __finally // owned by 401268</span><br><span class=\"line\">.text:004012AE                 mov     edi, [ebp+arg_8]</span><br><span class=\"line\">.text:004012B1                 mov     ebx, [ebp+arg_4]</span><br><span class=\"line\">.text:004012B4                 mov     esi, [ebp+arg_0]</span><br><span class=\"line\">.text:004012B7                 mov     al, [ebp+var_19]</span><br><span class=\"line\">.text:004012BA</span><br><span class=\"line\">.text:004012BA loc_4012BA:                             ; CODE XREF: `eh vector destructor iterator&#x27;(void *,uint,uint,void (*)(void *))+52↑j</span><br><span class=\"line\">.text:004012BA                 test    al, al</span><br><span class=\"line\">.text:004012BC                 jnz     short loc_4012C9</span><br><span class=\"line\">.text:004012BE                 push    [ebp+arg_C]     ; 析构函数地址</span><br><span class=\"line\">.text:004012C1                 push    edi             ; unsigned int</span><br><span class=\"line\">.text:004012C2                 push    ebx             ; unsigned int</span><br><span class=\"line\">.text:004012C3                 push    esi             ; void *</span><br><span class=\"line\">.text:004012C4                 call    ?__ArrayUnwind@@YGXPAXIIP6EX0@Z@Z ; __ArrayUnwind(void *,uint,uint,void (*)(void *))  ; 原型void __stdcall __ArrayUnwind(MyClass* objs,unsigned size,int count,void (__thiscall *pDtor)(void*))，第[count]对象由于没有构造成功，因此从[count-1]个对象开始析构，即如果某个析构函数产生异常，则跳过该对象，继续析构之前的对象</span><br><span class=\"line\">.text:004012C9</span><br><span class=\"line\">.text:004012C9 loc_4012C9:                             ; CODE XREF: `eh vector destructor iterator&#x27;(void *,uint,uint,void (*)(void *))+77↑j</span><br><span class=\"line\">.text:004012C9                 retn</span><br><span class=\"line\">.text:004012C9 ; &#125; // starts at 401245</span><br><span class=\"line\">.text:004012C9 ??_M@YGXPAXIIP6EX0@Z@Z endp</span><br><span class=\"line\"></span><br><span class=\"line\">void __stdcall `eh vector destructor iterator&#x27;(</span><br><span class=\"line\">        char *a1,</span><br><span class=\"line\">        unsigned int a2,</span><br><span class=\"line\">        unsigned int a3,</span><br><span class=\"line\">        void (__thiscall *a4)(void *))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  unsigned int v4; // edi</span><br><span class=\"line\">  char *i; // esi</span><br><span class=\"line\"></span><br><span class=\"line\">  v4 = a3;</span><br><span class=\"line\">  for ( i = &amp;a1[a3 * a2]; v4--; a4(i) )</span><br><span class=\"line\">    i -= a2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>上面的代码展示了申请多个堆对象析构函数的调用过程。在Release版下，编译器产生了循环结构的代码，根据数组中对象的总个数，从堆数组中的最后一个对象的首地址开始，依次向前遍历数组中的每个对象，将数组中每个对象的首地址作为this指针逐个调用析构函数。</p>\n<p>释放对象数组时，在delete函数后面添加符号“[]”是一个关键之处。单个对象的释放不可以添加符号“[]”，因为这样会把delete函数的目标指针减4或者8，释放单个对象的空间时就会发生错误，当执行到delete函数时会产生堆空间释放错误。</p>\n<p>对于以上堆内存格式，当使用new运算申请对象数组时，前4或者8字节空间用于记录数组内元素的个数，以便于执行每个数组元素的构造函数和析构函数。但是，对于基本数据类型来说，构造函数和析构函数的问题就不存在了，于是delete和delete[]的效果是一致的。出于代码可读性的考虑，建议读者在采用new申请对象时，如果是数组，则释放空间时就用delete[]，否则就用delete。</p>\n<p>C语言中的free函数与C++中的delete运算的区别很大，很重要的一点就是free不负责触发析构函数。同时，free不是运算符，无法进行运算符重载。</p>\n<h2 id=\"参数对象和返回对象\"><a href=\"#参数对象和返回对象\" class=\"headerlink\" title=\"参数对象和返回对象\"></a>参数对象和返回对象</h2><p>参数对象与返回对象会在不同的时机触发复制构造函数，它们的析构时机与所在作用域相关。只要函数的参数为对象类型，就会在函数调用结束后调用它的析构函数，然后释放参数对象所占的内存空间。返回值为对象的情况就不同了，返回对象时有赋值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person person = getObject();</span><br></pre></td></tr></table></figure>\n\n<p>上述代码是把person的地址作为隐含参数传递给getObject()，在getObject()内部完成复制构造的过程。函数执行完毕后，person就已经构造完成了，所以析构函数由person的作用域决定</p>\n<p>当返回值为对象的函数遇到如下代码时：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person = getObject();</span><br></pre></td></tr></table></figure>\n\n<p>因为这样的代码不是person在定义时赋初值，所以不会触发person的复制构造函数，这时候会产生临时对象作为getObject()的隐含参数，这个临时对象会在getObject()内部完成复制构造函数的过程。函数执行完毕后，如果Person的类中定义了“&#x3D;”运算符重载，则进行调用；否则根据对象成员逐个赋值。如果对象内数据量过大，就会调用rep movs这样的串操作指令批量赋值，这样的赋值方式属于浅拷贝。临时对象以一条高级语句为生命周期，它在函数调用时产生，在语句执行完毕时销毁。C和C++以分号作为语句的结束符，也就是说，一旦分号出现，就会触发临时对象的析构函数。特殊情况是，当引用这个临时对象时，它的生命期会和引用一致。又如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number = getNumber(), printf(&quot;Hello\\n&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>这是一条语句，逗号运算符后是printf调用，于是临时对象的析构在printf函数执行完毕后才会触发</p>\n<h2 id=\"全局对象与静态对象\"><a href=\"#全局对象与静态对象\" class=\"headerlink\" title=\"全局对象与静态对象\"></a>全局对象与静态对象</h2><p>全 局 对 象 与 静 态 对 象 相 同 ， 在 VS 中 其 构 造 函 数 在 函 数mainCRTStartup的_initterm调用中被构造。它们的析构函数的调用时机是在main()函数执行完毕之后。既然构造函数出现在初始化过程中，对应的析构函数就会出现在程序结束处。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1/%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9D%9F.png\" alt=\"程序结束\"></p>\n<p>在main()函数调用结束后，由exit结束进程，从而终止程序的运行 。 全 局 对 象 的 析 构 函 数 调 用 也 在 其 中 ， 由 exit 函 数 内 的_execute_onexit_table实现，关键代码如下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_PVFV* saved_first = first;</span><br><span class=\"line\">_PVFV* saved_last = last;</span><br><span class=\"line\">for (;;)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">//从后向前依次释放全局对象</span><br><span class=\"line\">_PVFV const function = __crt_fast_decode_pointer(*last);</span><br><span class=\"line\">*last = encoded_nullptr;</span><br><span class=\"line\">//调用保存的函数指着</span><br><span class=\"line\">function();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用__crt_fast_decode_pointer函数可以获取保存各类资源释放函数的首地址。</p>\n<p>编译器是在何时保存函数指针的呢？</p>\n<p>全局构造函数的调用是在初始化函数内完成的。在执行每个全局对象构造代理函数时都会先执行对象的构造函数，然后使用atexit注册析构代理函数</p>\n<p>因为保存析构代理函数被定义为无参函数，所以在调用析构函数时无法传递this指针。于是编译器需要为每个全局对象和静态对象建立一个中间代理的析构函数，用于传入全局对象的this指针。</p>\n<p>在分析析构函数时，可以构造函数作为参照，但并非出现构造函数就一定会产生析构函数。在没有编写析构函数的类中，编译器会根据情况决定是否提供默认的析构函数。默认的构造函数和析构函数与虚函数的知识点紧密相关。</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><h2 id=\"析构函数的必要条件\"><a href=\"#析构函数的必要条件\" class=\"headerlink\" title=\"析构函数的必要条件\"></a>析构函数的必要条件</h2><ul>\n<li><p>函数的调用是这个对象在作用域内的最后一次成员函数调用，分析this指针即可区分对象，是哪个对象的this指针就是哪个对象的成员函数。</p>\n</li>\n<li><p>使用thiscall调用方式，使用ecx或者rcx传递this指针，没有返回值。</p>\n</li>\n</ul>\n","text":"析构函数的出现时机对象何时被销毁呢？根据对象所在的作用域，当程序流程执行到作用域结束处时，会释放该作用域内的所有对象，在释放的过程中会调用对象的析构函数。析构函...","permalink":"/post/C++逆向——析构函数","photos":[],"count_time":{"symbolsCount":"36k","symbolsTime":"33 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">析构函数的出现时机</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E4%BD%95%E6%97%B6%E8%A2%AB%E9%94%80%E6%AF%81%E5%91%A2%EF%BC%9F\"><span class=\"toc-text\">对象何时被销毁呢？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">局部对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">堆对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A0%86%E5%AF%B9%E8%B1%A1%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">堆对象析构函数的调用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E4%B8%AA%E5%A0%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%B3%E8%AF%B7%E4%B8%8E%E9%87%8A%E6%94%BE\"><span class=\"toc-text\">多个堆对象的申请与释放</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A0%86%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">堆对象数组的构造函数初始化代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A0%86%E5%AF%B9%E8%B1%A1%E9%87%8A%E6%94%BE%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90\"><span class=\"toc-text\">堆对象释放代码分析</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">参数对象和返回对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">全局对象与静态对象</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">析构函数的必要条件</span></a></li></ol></li></ol>","author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"https://github.com/0netry","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"虚函数","uid":"cff45971697c57c78d8a68c46a85aef2","slug":"C++逆向——虚函数","date":"2023-02-13T06:11:19.000Z","updated":"2025-06-07T18:09:49.856Z","comments":true,"path":"api/articles/C++逆向——虚函数.json","keywords":null,"cover":[],"text":"虚函数是面向对象程序设计的关键组成部分。对于具有虚函数的类而言，构造函数和析构函数的识别过程更加简单。而且，在类中定义虚函数之后，如果没有提供构造函数，编译器会...","permalink":"/post/C++逆向——虚函数","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"https://github.com/0netry","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"构造函数和析构函数","uid":"da3425ec82161418a9e220cbb5402aa8","slug":"C++逆向——构造函数","date":"2023-02-08T11:47:12.000Z","updated":"2025-06-07T16:11:40.927Z","comments":true,"path":"api/articles/C++逆向——构造函数.json","keywords":null,"cover":[],"text":"构造函数与析构函数是类重要的组成部分，在类中起到至关重要的作用。构造函数常用来完成对象生成时的数据初始化工作，而析构函数则常用于在对象销毁时释放对象申请的资源。...","permalink":"/post/C++逆向——构造函数","photos":[],"count_time":{"symbolsCount":"30k","symbolsTime":"27 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"https://github.com/0netry","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}