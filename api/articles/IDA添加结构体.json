{"title":"IDA添加结构体","uid":"d90627d53e222069704f901ed1b80995","slug":"IDA添加结构体","date":"2022-06-09T08:49:43.000Z","updated":"2025-06-09T10:16:41.620Z","comments":true,"path":"api/articles/IDA添加结构体.json","keywords":null,"cover":[],"content":"<h1 id=\"导入头文件方法\"><a href=\"#导入头文件方法\" class=\"headerlink\" title=\"导入头文件方法\"></a>导入头文件方法</h1><p>①首先菜单栏选择File -&gt; Load File -&gt; Parse C Header file（Ctrl+F9）然后导入结构体文件（xxx.h），导入成功会显示compile successful</p>\n<p>②在结构体界面右键选择Add Struct type，此时会弹出创建结构体的对话框</p>\n<p>​    <img src=\"/%E5%AF%BC%E5%85%A5%E5%A4%B4%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/%E5%88%9B%E5%BB%BA%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E8%AF%9D%E6%A1%86.jpg\"></p>\n<p>③在弹出的对话框中选择Add standard structure，此时会弹出标准结构体对话框</p>\n<p>​    <img src=\"/%E5%AF%BC%E5%85%A5%E5%A4%B4%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/%E6%A0%87%E5%87%86%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E8%AF%9D%E6%A1%86.jpg\"></p>\n<p>④在弹出的对话框中按Ctrl+F搜索导入的结构体名称并选中添加即可</p>\n<p>​    <img src=\"/%E5%AF%BC%E5%85%A5%E5%A4%B4%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/%E6%B7%BB%E5%8A%A0%E5%AF%BC%E5%85%A5%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93.jpg\"></p>\n<h1 id=\"手动添加结构体方法\"><a href=\"#手动添加结构体方法\" class=\"headerlink\" title=\"手动添加结构体方法\"></a>手动添加结构体方法</h1><p>①首先在结构体界面右键选择Add Struct type，此时会弹出创建结构体的对话框</p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E5%88%9B%E5%BB%BA%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E8%AF%9D%E6%A1%86.jpg\"></p>\n<p>②输入结构体名称然后回车就会创建结构体</p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E5%88%9B%E5%BB%BA%E7%BB%93%E6%9E%84%E4%BD%93.jpg\"></p>\n<p>③然后右键Edit struct，在弹出的对话框中设置结构体对齐值</p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E8%AE%BE%E7%BD%AE%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90%E5%80%BC.jpg\"></p>\n<p>④然后选择结构体</p>\n<ul>\n<li><p>在结构体结尾（struct_name ends）处按D即可添加结构体成员，但是要注意结构体对齐</p>\n</li>\n<li><p>如果无法设置dq类型，则菜单栏选择setup data types，勾选5 Quadro word</p>\n</li>\n</ul>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E8%AE%BE%E7%BD%AEdq%E7%B1%BB%E5%9E%8B.jpg\"></p>\n<ul>\n<li>需要补齐对齐值的话，则可以设置为数组，即选中要补齐的所有字节右键选择Array，然后看Array Size是否是要补齐的字节数量，是则回车即可</li>\n</ul>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E8%AE%BE%E7%BD%AE%E4%B8%BA%E6%95%B0%E7%BB%84.jpg\"></p>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><p>下面将针对下列结构体使用方法二进行添加、</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragram pack(push)</span></span><br><span class=\"line\"><span class=\"meta\">#pragram pack(8)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Vector2D</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> x;</span><br><span class=\"line\">    <span class=\"type\">float</span> y;</span><br><span class=\"line\">    <span class=\"type\">char</span> z;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> k;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#pragram pack(pop) </span></span><br></pre></td></tr></table></figure>\n\n<p>1.首先要计算下结构体成员偏移及成员直接需要补齐的字节数</p>\n<p>上述结构体中设置了对齐值8，char占1字节，float占4字节，long long占8字节，根据以下公式</p>\n<p><strong>结构体成员偏移计算公式: MeMber offset % min(alg,sizeof(Member type)) &#x3D;&#x3D; 0（</strong>其中成员的Member offset 从零开始,当计算完毕之后,需要加上自己所占的字节大小,然后继续参与运算,如果运算不成立,则偏移继续增加,一直到偏移成立<strong>）</strong></p>\n<p><strong>结构体总大小计算公式:  sizeof(struct) % min(Max type size,alg) &#x3D;&#x3D; 0;</strong></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th>偏移</th>\n<th>字节大小</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>x</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>y</td>\n<td>y</td>\n<td>y</td>\n<td>y</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>z</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>8</td>\n<td>1</td>\n</tr>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>k</td>\n<td>k</td>\n<td>k</td>\n<td>k</td>\n<td>16</td>\n<td>8</td>\n</tr>\n<tr>\n<td>k</td>\n<td>k</td>\n<td>k</td>\n<td>k</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p><strong>第一个成员x：</strong></p>\n<p>当Member Offset&#x3D;0时， MeMber offset % min(alg,sizeof(Member type)) &#x3D;0%min(8,1)&#x3D;&#x3D; 0满足偏移计算公式，所以<strong>第一个成员的偏移为0</strong>，而其类型为char，<strong>占1个字节</strong>，所以计算下一个成员的偏移时应从（本成员的偏移值+所占字节）&#x3D;0+1&#x3D;1开始</p>\n<p><strong>第二个成员y：</strong></p>\n<p>①当Member Offset&#x3D;1时， MeMber offset % min(alg,sizeof(Member type)) &#x3D;1%min(8,4)!&#x3D; 0，不满足偏移计算公式，加1继续运算</p>\n<p>②当Member Offset&#x3D;2时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;2%min(8,4)!&#x3D; 0，不满足偏移计算公式，加1继续运算</p>\n<p>③当Member Offset&#x3D;3时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;3%min(8,4)!&#x3D; 0，不满足偏移计算公式，加1继续运算</p>\n<p>④当Member Offset&#x3D;1时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;4%min(8,4)&#x3D;&#x3D; 0，满足偏移计算公式，所以<strong>第二个成员的偏移为4</strong>，而其类型为float，占4个字节，所以计算下一个成员的偏移时应从（本成员的偏移值+所占字节）&#x3D;4+4&#x3D;8开始</p>\n<p>注：所以<strong>第一个成员和第二个成员之间应补齐3个字节</strong>（即不满足公式的偏移数量），即上面的0</p>\n<p><strong>第三个成员z：</strong></p>\n<p>当Member Offset&#x3D;1时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;8%min(8,1)&#x3D;&#x3D; 0，满足偏移计算公式，所以<strong>第三个成员的偏移为8</strong>，而其类型为char，<strong>占1个字节</strong>，所以计算下一个成员的偏移时应从（本成员的偏移值+所占字节）&#x3D;8+1&#x3D;9开始</p>\n<p><strong>第四个成员k：</strong></p>\n<p>①当Member Offset&#x3D;9时， MeMber offset % min(alg,sizeof(Member type)) &#x3D;9%min(8,8)!&#x3D; 0，不满足偏移计算公式，加1继续运算</p>\n<p>②当Member Offset&#x3D;10时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;10%min(8,8)!&#x3D; 0，不满足偏移计算公式，加1继续运算</p>\n<p>③当Member Offset&#x3D;11时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;11%min(8,8)!&#x3D; 0，不满足偏移计算公式，加1继续运算</p>\n<p>④当Member Offset&#x3D;12时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;12%min(8,8)!&#x3D; 0，不满足偏移计算公式，加1继续运算</p>\n<p>⑤当Member Offset&#x3D;13时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;13%min(8,8)!&#x3D;  0，不满足偏移计算公式，加1继续运算</p>\n<p>⑥当Member Offset&#x3D;14时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;14%min(8,8)!&#x3D;  0，不满足偏移计算公式，加1继续运算</p>\n<p>⑦当Member Offset&#x3D;15时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;15%min(8,8)!&#x3D;  0，不满足偏移计算公式，加1继续运算</p>\n<p>⑧当Member Offset&#x3D;16时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;12%min(8,8)&#x3D;&#x3D; 0，满足偏移计算公式，所以<strong>第四个成员的偏移为16</strong>，其类型为long long，<strong>占8个字节</strong></p>\n<p>注：所以<strong>第三个成员和第四个成员之间应补齐7个字节</strong>（即不满足公式的偏移数量），即上面的0</p>\n<p><strong>结构体总大小：</strong></p>\n<p> sizeof(struct)&#x3D;最后一个成员的偏移+所占大小&#x3D;16+8&#x3D;24</p>\n<p>结构体成员类型所占字节最大为8（long long）</p>\n<p>根据结构体大小计算公式： sizeof(struct) % min(Max type size,alg) &#x3D;24%min(8，8)&#x3D;&#x3D; 0;</p>\n<p>所以结构体总大小为24</p>\n<p>2.首先在结构体界面右键选择Add Struct type，此时会弹出创建结构体的对话框</p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94%E5%88%9B%E5%BB%BA%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AF%B9%E8%AF%9D%E6%A1%86.jpg\"></p>\n<p>②输入结构体名称然后回车就会创建结构体</p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94%E5%88%9B%E5%BB%BA%E7%BB%93%E6%9E%84%E4%BD%93.jpg\"></p>\n<p>③然后右键Edit struct，在弹出的对话框中设置结构体对齐值</p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94%E8%AE%BE%E7%BD%AE%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90%E5%80%BC.jpg\"></p>\n<p>④添加结构体成员</p>\n<p>在结构体结尾（struct_name ends）处按D添加结构体成员</p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98.jpg\"></p>\n<p>根据前面的计算，第一个成员偏移为0，占1个字节，所以只需要将上面第一个成员field_0成员重命名为x即可（右键Rename或按N）</p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%88%90%E5%91%98field_0%E6%88%90%E5%91%98%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%BAx.jpg\"></p>\n<p>根据前面的计算，第二个成员偏移为4，占4个字节，所以需要移动移动光标到偏移4处的类型，然后按D调整类型为dd，并将其重命名为y（右键Rename或按N）</p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%BA%8C%E4%B8%AA%E6%88%90%E5%91%98.jpg\"></p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E4%B8%AA%E6%88%90%E5%91%98%E9%87%8D%E5%91%BD%E5%90%8D.jpg\"></p>\n<p>接着在结构体结尾（struct_name ends）处按D继续添加结构体成员</p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%B8%89%E4%B8%AA%E6%88%90%E5%91%98.jpg\"></p>\n<p>根据前面的计算，第三个成员偏移为8，占1个字节，所以只需要在偏移为8（即上图中y成员下面的field_8成员）处重命名为z即可（右键Rename或按N）</p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E4%B8%AA%E6%88%90%E5%91%98%E9%87%8D%E5%91%BD%E5%90%8D.jpg\"></p>\n<p>根据前面的计算，第四个成员偏移为16，占8个字节，所以需要移动移动光标到偏移16处（需要先在构体结尾（struct_name ends）处按D继续添加结构体成员才能看到16）的类型，然后按D调整类型为dq，并将其重命名为k（右键Rename或按N）</p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94%E6%B7%BB%E5%8A%A0%E7%AC%AC%E5%9B%9B%E4%B8%AA%E6%88%90%E5%91%98.jpg\"></p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E4%B8%AA%E6%88%90%E5%91%98%E9%87%8D%E5%91%BD%E5%90%8D.jpg\"></p>\n<p>⑤接着将各成员之间需要补齐的字节定义为数组即可</p>\n<p>首先选中x和y之间的所有备注为undefined的块（即为需要补齐的字节），然后右键选择Array，然后看Array Size是否是要补齐的字节数量（根据前面计算为3），是则回车即可，然后将其重命名为align1</p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94%E5%90%84%E6%88%90%E5%91%98%E4%B9%8B%E9%97%B4%E8%A1%A5%E9%BD%901.jpg\"></p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94%E5%90%84%E6%88%90%E5%91%98%E4%B9%8B%E9%97%B4%E8%A1%A5%E9%BD%902.jpg\"></p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94%E5%90%84%E6%88%90%E5%91%98%E4%B9%8B%E9%97%B4%E8%A1%A5%E9%BD%903.jpg\"></p>\n<p>接着选中z和k之间的所有备注为undefined的块（即为需要补齐的字节），然后右键选择Array，然后看Array Size是否是要补齐的字节数量（根据前面计算为7），是则回车即可，然后将其重命名为align2</p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94%E5%90%84%E6%88%90%E5%91%98%E4%B9%8B%E9%97%B4%E8%A1%A5%E9%BD%904.jpg\"></p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94%E5%90%84%E6%88%90%E5%91%98%E4%B9%8B%E9%97%B4%E8%A1%A5%E9%BD%905.jpg\"></p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94%E5%90%84%E6%88%90%E5%91%98%E4%B9%8B%E9%97%B4%E8%A1%A5%E9%BD%906.jpg\"></p>\n<p>至此，结构体添加完成，只需要在要要引用的位置设置该结构体即可（即跳转到引用变量处，alt+q选中添加的结构体即可）</p>\n<p>如果只是在使用变量的地方只有偏移，则先k一下，转换成变量表示后，在跳转到变量所在处设置为结构体</p>\n<p>​    <img src=\"/%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95/%E7%A4%BA%E4%BE%8B%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E6%B7%BB%E5%8A%A0%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93.jpg\"></p>\n","text":"导入头文件方法①首先菜单栏选择File -> Load File -> Parse C Header file（Ctrl+F9）然后导入结构体文件（xxx.h）...","permalink":"/post/IDA添加结构体","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":14,"path":"api/tags/逆向.json"},{"name":"IDA使用","slug":"IDA使用","count":1,"path":"api/tags/IDA使用.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AF%BC%E5%85%A5%E5%A4%B4%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">导入头文件方法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">手动添加结构体方法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">示例</span></a></li></ol>","author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Windows静态反调试技术（一）","uid":"cfe529b139f3ec3d5a0094d71b2823b9","slug":"Windows静态反调试技术（一）","date":"2022-06-20T13:12:54.000Z","updated":"2025-06-09T21:41:11.315Z","comments":true,"path":"api/articles/Windows静态反调试技术（一）.json","keywords":null,"cover":[],"text":"PEB利用PEB结构体信息可以判断当前进程是否处于被调试状态。回顾下PEB结构体的成员： Win7 x86中： 123456789101112131415161...","permalink":"/post/Windows静态反调试技术（一）","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":14,"path":"api/tags/逆向.json"},{"name":"Windows静态反调试技术","slug":"Windows静态反调试技术","count":3,"path":"api/tags/Windows静态反调试技术.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"UPX脱壳实战——结合逆向工程核心原理","uid":"d804751ae060ee6bddee780d4be7bc78","slug":"UPX脱壳实战——结合逆向工程核心原理","date":"2022-05-11T03:23:55.000Z","updated":"2025-06-05T15:24:37.476Z","comments":true,"path":"api/articles/UPX脱壳实战——结合逆向工程核心原理.json","keywords":null,"cover":[],"text":"用《逆向工程核心原理》这本书中的notepad_upx.exe来实验 未加壳的oep 单步跟踪法脱壳的方法有很多，先来讲脱壳方法中最基础的单步跟踪法。单步跟踪法...","permalink":"/post/UPX脱壳实战——结合逆向工程核心原理","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"逆向工程核心原理","slug":"逆向工程核心原理","count":7,"path":"api/tags/逆向工程核心原理.json"},{"name":"加壳与脱壳","slug":"加壳与脱壳","count":1,"path":"api/tags/加壳与脱壳.json"},{"name":"iat修复","slug":"iat修复","count":1,"path":"api/tags/iat修复.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}