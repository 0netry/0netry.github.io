{"title":"Windows静态反调试技术（三）","uid":"0f5e7a00cb9e0d76fb61aefba4cb6bf5","slug":"Windows静态反调试技术（三）","date":"2022-06-25T13:18:17.000Z","updated":"2025-06-09T21:41:41.029Z","comments":true,"path":"api/articles/Windows静态反调试技术（三）.json","keywords":null,"cover":null,"content":"<h1 id=\"TLS回调函数\"><a href=\"#TLS回调函数\" class=\"headerlink\" title=\"TLS回调函数\"></a>TLS回调函数</h1><p>由于TLS回调函数会先于EP代码执行，可以在回调函数内部使用IsDebuggerPresent()等函数判断调试与否，再决定是否继续运行程序。</p>\n<h1 id=\"ETC\"><a href=\"#ETC\" class=\"headerlink\" title=\"ETC\"></a>ETC</h1><p>借助Win32 API获取系统信息来实现反调试。如：</p>\n<p>（1）检测Ollydbg窗口 &lt;- FindWindow()；</p>\n<p>（2）检测Ollydbg进程 &lt;- CreateToolhelp32Snapshot()；</p>\n<p>（3）检查计算机名称是否为”TEST”、”ANALYSIS”等 &lt;- GetComputerName()；</p>\n<p>（4）检查程序运行路径中是否存在”TEST”、”SAMPLE”等名称 &lt;- GetCommandLine()；</p>\n<p>（5）检测虚拟机是否处于运行状态（查看虚拟机特有的进程名称 &lt;- VMWareService.exe、VMWareTray.exe、VMWareUser.exe）</p>\n<h2 id=\"FindWindow\"><a href=\"#FindWindow\" class=\"headerlink\" title=\"FindWindow\"></a>FindWindow</h2><p>使用此函数查找目标窗口，如果找到，可以禁用窗口，也可以直接退出程序</p>\n<p>函数声明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HWND FindWindow</span><br><span class=\"line\">(</span><br><span class=\"line\">LPCSTR lpClassName,</span><br><span class=\"line\">LPCSTR lpWindowName</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>参数表：</p>\n<p>lpClassName：指向一个以NULL字符结尾的、用来指定类名的字符串或一个可以确定类名字符串的原子。如果这个参数是一个原子，那么它必须是一个在调用此函数前已经通过GlobalAddAtom函数创建好的<a href=\"http://baike.baidu.com/view/1210911.htm\">全局原子</a>。这个原子（一个16bit的值），必须被放置在lpClassName的低位<a href=\"http://baike.baidu.com/view/60408.htm\">字节</a>中，lpClassName的高位字节置零。</p>\n<p>如果该参数为null时，将会寻找任何与lpWindowName参数匹配的窗口</p>\n<p>lpWindowName：指向一个以NULL字符结尾的、用来指定窗口名（即窗口标题）的字符串。如果此参数为NULL，则匹配所有窗口名。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void CAntiDebugDlg::OnBnClickedBtnFindwindow()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    HWND Hwnd = NULL;</span><br><span class=\"line\">    Hwnd = ::FindWindow(L&quot;OllyDbg&quot;, NULL);</span><br><span class=\"line\">    if (Hwnd == NULL) &#123;</span><br><span class=\"line\">        MessageBoxW(L&quot;Not Being Debugged!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        MessageBoxW(L&quot;Being Debugged!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"枚举窗口\"><a href=\"#枚举窗口\" class=\"headerlink\" title=\"枚举窗口\"></a>枚举窗口</h2><p>使用EnumWindow函数枚举窗口，并且为每一窗口调用一次回调函数，在回调函数中可以调用GetWindowText获取窗口的标题。与目标窗口名进行比对，如果比对成功，则说明发现调试器。</p>\n<p>函数声明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WINUSERAPI</span><br><span class=\"line\">BOOL</span><br><span class=\"line\">WINAPI</span><br><span class=\"line\">EnumWindows(</span><br><span class=\"line\">    _In_ WNDENUMPROC lpEnumFunc,</span><br><span class=\"line\">_In_ LPARAM lParam</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>参数表：</p>\n<p>lpEnumFunc：回调函数指针。</p>\n<p>lParam：指定一个传递给回调函数的应用程序定义值。</p>\n<p>回调函数原型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BOOL CALLBACK EnumWindowsProc(HWND hwnd,LPARAM lParam);</span><br></pre></td></tr></table></figure>\n\n<p>参数表：</p>\n<p>Hwnd：顶层窗口的句柄。</p>\n<p>Lparam：应用程序定义的一个值（即EnumWindows中的lParam）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Int GetWindowText(HWND hWnd,LPTSTR lpString,Int nMaxCount);</span><br></pre></td></tr></table></figure>\n\n<p>参数表:</p>\n<p>hWnd：带文本的窗口或控件的句柄。</p>\n<p>IpString：指向接收文本的<a href=\"http://baike.baidu.com/view/266782.htm\">缓冲区</a>的<a href=\"http://baike.baidu.com/view/159417.htm\">指针</a>。</p>\n<p>nMaxCount：指定要保存在缓冲区内的字符的最大个数，其中包含NULL字符。如果文本超过界限，它就被截断。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    WCHAR wzChar[100] = &#123; 0 &#125;;</span><br><span class=\"line\">    CStringW strData = L&quot;OllyDbg&quot;;</span><br><span class=\"line\">    if (IsWindowVisible(hwnd)) &#123;</span><br><span class=\"line\">        GetWindowText(hwnd, wzChar, 100);</span><br><span class=\"line\">        if (wcsstr(wzChar, strData)) &#123;</span><br><span class=\"line\">            MessageBoxW(NULL,L&quot;Being Debugged!&quot;,NULL,0);</span><br><span class=\"line\">            g_bDebugged = TRUE;</span><br><span class=\"line\">            return FALSE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return TRUE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void CAntiDebugDlg::OnBnClickedBtnEnumwindow()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    EnumWindows(EnumWindowsProc, NULL);</span><br><span class=\"line\">    if (g_bDebugged == FALSE) &#123;</span><br><span class=\"line\">        MessageBoxW(L&quot;Not Being Debugged!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"枚举进程\"><a href=\"#枚举进程\" class=\"headerlink\" title=\"枚举进程\"></a>枚举进程</h2><p>枚举进程列表，查看是否有调试器进程</p>\n<p>函数声明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HANDLE WINAPI CreateToolhelp32Snapshot(</span><br><span class=\"line\">DWORD dwFlags, </span><br><span class=\"line\"> DWORD th32ProcessID </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>通过获取进程信息为指定的进程、进程使用的堆[HEAP]、模块[MODULE]、<a href=\"http://baike.baidu.com/view/1053.htm\">线程</a>建立一个快照。</p>\n<p>参数表：</p>\n<p>dwFlags：用来指定“快照”中需要返回的对象，可以是TH32CS_SNAPPROCESS等</p>\n<p>th32ProcessID: 一个进程ID号，用来指定要获取哪一个进程的快照，当获取系统进程列表或获取 当前进程快照时可以设为0</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BOOL</span><br><span class=\"line\">WINAPI</span><br><span class=\"line\">Process32FirstW(</span><br><span class=\"line\">    HANDLE hSnapshot,</span><br><span class=\"line\">    LPPROCESSENTRY32W lppe</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure>\n\n<p>process32First是一个进程获取函数，当我们利用函数CreateToolhelp32Snapshot()获得当前运行进程的快照后，我们可以利用process32First函数来获得第一个进程的句柄。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BOOL</span><br><span class=\"line\">WINAPI</span><br><span class=\"line\">Process32NextW(</span><br><span class=\"line\">    HANDLE hSnapshot,</span><br><span class=\"line\">    LPPROCESSENTRY32W lppe</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure>\n\n<p>Process32Next是一个进程获取函数，当我们利用函数CreateToolhelp32Snapshot()获得当前运行进程的快照后,我们可以利用Process32Next函数来获得下一个进程的句柄。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void CAntiDebugDlg::OnBnClickedBtnEnumprocess()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // TODO: 在此添加控件通知处理程序代码</span><br><span class=\"line\">    HANDLE hwnd = NULL;</span><br><span class=\"line\">    PROCESSENTRY32W pe32 = &#123; 0 &#125;;</span><br><span class=\"line\">    pe32.dwSize = sizeof(pe32);//如果没有这句，得出的路径不对</span><br><span class=\"line\">    WCHAR str[] = L&quot;OLLYDBG&quot;;</span><br><span class=\"line\">    CStringW strTemp;</span><br><span class=\"line\">    BOOL bOK = FALSE;</span><br><span class=\"line\">    hwnd = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);</span><br><span class=\"line\">    if (hwnd != INVALID_HANDLE_VALUE) &#123;</span><br><span class=\"line\">        bool bMore = Process32FirstW(hwnd, &amp;pe32);</span><br><span class=\"line\">        do &#123;</span><br><span class=\"line\">            strTemp = pe32.szExeFile;</span><br><span class=\"line\">            //统一转换为大写进行比较</span><br><span class=\"line\">            strTemp.MakeUpper();</span><br><span class=\"line\">            if (wcsstr(strTemp, str)) &#123;</span><br><span class=\"line\">                MessageBoxW(L&quot;Being Debugged!&quot;);</span><br><span class=\"line\">                bOK = TRUE;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else if (wcsstr(pe32.szExeFile, L&quot;WINDBG&quot;)) &#123;</span><br><span class=\"line\">                MessageBoxW(L&quot;Being Debugged!&quot;);</span><br><span class=\"line\">                bOK = TRUE;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; while (Process32NextW(hwnd, &amp;pe32));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (bOK == FALSE) &#123;</span><br><span class=\"line\">        MessageBoxW(L&quot;Not Being Debugged!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    CloseHandle(hwnd);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查看父进程是不是Explorer\"><a href=\"#查看父进程是不是Explorer\" class=\"headerlink\" title=\"查看父进程是不是Explorer\"></a>查看父进程是不是Explorer</h2><p>当我们双击运行应用程序的时候，父进程都是Explorer，如果是通过调试器启动的，父进程就不是Explorer。</p>\n<p>通过GetCurrentProcessId()获得当前进程的ID</p>\n<p>通过桌面窗口类和名称获得Explorer进程的ID</p>\n<p>使用Process32First&#x2F;Next()函数枚举进程列表，通过PROCESSENTRY32.th32ParentProcessID 获得的当前进程的父进程ID与Explorer的ID进程比对。如果不一样的很可能被调试器附加</p>\n<p>函数声明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DWORD GetWindowThreadProcessId(</span><br><span class=\"line\">HWND hWnd,</span><br><span class=\"line\">LPDWORD lpdwProcessId</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>找出某个窗口的创建者（<a href=\"http://baike.baidu.com/subview/1053/1053.htm\">线程</a>或进程），返回创建者的标志符。</p>\n<p>参数说明：</p>\n<p>hWnd：（向函数提供的）被查找窗口的句柄.</p>\n<p>lpdwProcessId：进程号的存放地址（变量地址）</p>\n<p>使用方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void CAntiDebugDlg::OnBnClickedBtnExplorer()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // TODO: 在此添加控件通知处理程序代码</span><br><span class=\"line\">    HANDLE hwnd = NULL;</span><br><span class=\"line\">    HANDLE hexplorer = NULL;</span><br><span class=\"line\">    PROCESSENTRY32 pe32 = &#123; 0 &#125;;</span><br><span class=\"line\">    pe32.dwSize = sizeof(pe32);</span><br><span class=\"line\">    CStringW str = L&quot;explorer&quot;;</span><br><span class=\"line\">    DWORD ExplorerId = 0;</span><br><span class=\"line\">    DWORD SelfId = 0;</span><br><span class=\"line\">    DWORD SelfParentId = 0;</span><br><span class=\"line\">    SelfId = GetCurrentProcessId();</span><br><span class=\"line\">    hexplorer = ::FindWindowW(L&quot;Progman&quot;,NULL);</span><br><span class=\"line\">    GetWindowThreadProcessId((HWND)hexplorer, &amp;ExplorerId);</span><br><span class=\"line\">    hwnd = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);</span><br><span class=\"line\">    if (hwnd != INVALID_HANDLE_VALUE)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Process32FirstW(hwnd, &amp;pe32);</span><br><span class=\"line\">        do </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (SelfId == pe32.th32ProcessID)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                SelfParentId = pe32.th32ParentProcessID;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; while (Process32NextW(hwnd,&amp;pe32));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (ExplorerId == SelfParentId) &#123;</span><br><span class=\"line\">        MessageBoxW(L&quot;Not Being Debugged!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MessageBoxW(L&quot;Being Debugged!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    CloseHandle(hwnd);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"查看StartupInfo结构\"><a href=\"#查看StartupInfo结构\" class=\"headerlink\" title=\"查看StartupInfo结构\"></a>查看StartupInfo结构</h1><p>在windows操作系统中，Explorer创建进程的时候会把STARTUPINFO结构中的某些值设为0，非Explorer创建进程的时候会忽略这个结构中的值，所以可以通过查看这个结构中的值是不是为0来判断是否在调试状态。</p>\n<p>函数说明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WINBASEAPI</span><br><span class=\"line\">VOID</span><br><span class=\"line\">WINAPI</span><br><span class=\"line\">GetStartupInfoW(</span><br><span class=\"line\">    _Out_ LPSTARTUPINFOW lpStartupInfo</span><br><span class=\"line\">    );</span><br><span class=\"line\">    取得进程在启动时被指定的 STARTUPINFO 结构</span><br><span class=\"line\">typedef struct _STARTUPINFOW &#123;</span><br><span class=\"line\">    DWORD   cb;</span><br><span class=\"line\">    LPWSTR  lpReserved;</span><br><span class=\"line\">    LPWSTR  lpDesktop;</span><br><span class=\"line\">    LPWSTR  lpTitle;</span><br><span class=\"line\">    DWORD   dwX;</span><br><span class=\"line\">    DWORD   dwY;</span><br><span class=\"line\">    DWORD   dwXSize;</span><br><span class=\"line\">    DWORD   dwYSize;</span><br><span class=\"line\">    DWORD   dwXCountChars;</span><br><span class=\"line\">    DWORD   dwYCountChars;</span><br><span class=\"line\">    DWORD   dwFillAttribute;</span><br><span class=\"line\">    DWORD   dwFlags;</span><br><span class=\"line\">    WORD    wShowWindow;</span><br><span class=\"line\">    WORD    cbReserved2;</span><br><span class=\"line\">    LPBYTE  lpReserved2;</span><br><span class=\"line\">    HANDLE  hStdInput;</span><br><span class=\"line\">    HANDLE  hStdOutput;</span><br><span class=\"line\">    HANDLE  hStdError;</span><br><span class=\"line\">&#125; STARTUPINFOW, *LPSTARTUPINFOW;</span><br><span class=\"line\">使用方法：</span><br><span class=\"line\">void CAntiDebugDlg::OnBnClickedBtnStartupinfor()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // TODO: 在此添加控件通知处理程序代码</span><br><span class=\"line\">    STARTUPINFO info = &#123; 0 &#125;;</span><br><span class=\"line\">    GetStartupInfo(&amp;info);</span><br><span class=\"line\">    if (info.dwX != 0 || info.dwY != 0 || info.dwXCountChars != 0 || info.dwYCountChars != 0</span><br><span class=\"line\">        || info.dwFillAttribute != 0 || info.dwXSize != 0 || info.dwYSize != 0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MessageBoxW(L&quot;Being Debugged!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        MessageBoxW(L&quot;Not Being Debugged!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"CheckRemoteDebuggerPresent\"><a href=\"#CheckRemoteDebuggerPresent\" class=\"headerlink\" title=\"CheckRemoteDebuggerPresent\"></a>CheckRemoteDebuggerPresent</h1><p>这个函数同IsDebuggerPresent函数几乎一致，它用来检测本机器中的一个进程是否运行在调试器中。同时，它也检查PEB结构中的IsDebugged属性。他不仅可以探测进程自身是否被调试，同时可以探测系统其他进程是否被调试。这个函数将一个进程句柄作为参数，检查这个句柄对应的进程是否被调试器附加，同时，CheckRemoteDebuggerPresent也可以通过传递自身进程句柄探测自己是否被调试。</p>\n<p>函数声明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BOOL CheckRemoteDebuggerPresent(</span><br><span class=\"line\">HANDLE hProcess,</span><br><span class=\"line\">PBOOL pbDebuggerPresent</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>此函数用来确定是否有调试器附加到进程。</p>\n<p>参数表：</p>\n<p>hProcess：进程句柄</p>\n<p>pbDebuggerPresent：指向一个BOOL的变量，如果进程被调试，此变量被赋值为TRUE。</p>\n<p>使用方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef BOOL(WINAPI *CHECK_REMOTE_DEBUGGER_PRESENT)(HANDLE, PBOOL);</span><br><span class=\"line\">void CAntiDebugDlg::OnBnClickedBtnCheckremote()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // TODO: 在此添加控件通知处理程序代码</span><br><span class=\"line\">    HANDLE      hProcess;</span><br><span class=\"line\">    HINSTANCE   hModule;</span><br><span class=\"line\">    BOOL        bDebuggerPresent = FALSE;</span><br><span class=\"line\">    CHECK_REMOTE_DEBUGGER_PRESENT CheckRemoteDebuggerPresent;</span><br><span class=\"line\">    hModule = GetModuleHandleA(&quot;Kernel32&quot;);</span><br><span class=\"line\">    CheckRemoteDebuggerPresent =</span><br><span class=\"line\">        (CHECK_REMOTE_DEBUGGER_PRESENT)GetProcAddress(hModule, &quot;CheckRemoteDebuggerPresent&quot;);</span><br><span class=\"line\">    hProcess = GetCurrentProcess();</span><br><span class=\"line\">    CheckRemoteDebuggerPresent(hProcess, &amp;bDebuggerPresent);</span><br><span class=\"line\">    if (bDebuggerPresent == TRUE)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MessageBoxW(L&quot;Being Debugged!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MessageBoxW(L&quot;Not Being Debugged!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"SeDebugPrivilege进程权限\"><a href=\"#SeDebugPrivilege进程权限\" class=\"headerlink\" title=\"SeDebugPrivilege进程权限\"></a>SeDebugPrivilege进程权限</h1><p>默认情况下进程没有 SeDebugPrivilege 权限，调试时，会从调试器继承这个权限，可以通过打开 CSRSS.EXE 进程间接地使用SeDebugPrivilege来判断进程是否被调试。</p>\n<p>使用方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void CAntiDebugDlg::OnBnClickedBtnSedebugpre()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // TODO: 在此添加控件通知处理程序代码</span><br><span class=\"line\">    HANDLE hProcessSnap;</span><br><span class=\"line\">    HANDLE hProcess;</span><br><span class=\"line\">    PROCESSENTRY32 tp32 = &#123; 0 &#125;;  //结构体</span><br><span class=\"line\">    tp32.dwSize = sizeof(tp32);</span><br><span class=\"line\">    CString str = L&quot;csrss.exe&quot;;</span><br><span class=\"line\">    hProcessSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);</span><br><span class=\"line\">    if (INVALID_HANDLE_VALUE != hProcessSnap)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Process32First(hProcessSnap, &amp;tp32);</span><br><span class=\"line\">        do &#123;</span><br><span class=\"line\">            if (0 == lstrcmpi(str, tp32.szExeFile))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, NULL, tp32.th32ProcessID);</span><br><span class=\"line\">                if (NULL != hProcess)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    MessageBoxW(L&quot;Being Debugged!&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                else</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    MessageBoxW(L&quot;Not Being Debugged!&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                CloseHandle(hProcess);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; while (Process32Next(hProcessSnap, &amp;tp32));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    CloseHandle(hProcessSnap);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"GuardPages\"><a href=\"#GuardPages\" class=\"headerlink\" title=\"GuardPages\"></a>GuardPages</h1><p>这个检查是针对 OllyDbg 的，因为它和 OllyDbg 的内存访问&#x2F;写入断点特性相关。除了硬件断点和软件断点外， OllyDbg 允许设置一个内存访问&#x2F;写入断点，这种类型的断点是通过页面保护来实现的。简单地说，页面保护提供了当应用程序的某块内存被访问时获得通知这样一个途径。</p>\n<p>页面保护是通过 PAGE_GUARD 页面保护修改符来设置的，如果访问的内存地址是受保护页面的一部分，将会产生一个 STATUS_GUARD_PAGE_VIOLATION(0x80000001)异常。如果进程被 OllyDbg 调试并且受保护的页面被访问，将不会抛出异常，访问将会被当作内存断点</p>\n<p>使用方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static bool isDebugged = 1;</span><br><span class=\"line\">LONG WINAPI TopUnhandledExceptionFilter2(</span><br><span class=\"line\">    struct _EXCEPTION_POINTERS *ExceptionInfo</span><br><span class=\"line\">)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _asm pushad</span><br><span class=\"line\">    </span><br><span class=\"line\">    lpSetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)lpOldHandler);</span><br><span class=\"line\">    ExceptionInfo-&gt;ContextRecord-&gt;Eip = NewEip;</span><br><span class=\"line\">    isDebugged = 0;</span><br><span class=\"line\">    _asm popad</span><br><span class=\"line\">    return EXCEPTION_CONTINUE_EXECUTION;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void CAntiDebugDlg::OnBnClickedBtnGuidpages()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // TODO: 在此添加控件通知处理程序代码</span><br><span class=\"line\">    ULONG dwOldType;</span><br><span class=\"line\">    DWORD dwPageSize;</span><br><span class=\"line\">    LPVOID lpvBase;               // 获取内存的基地址</span><br><span class=\"line\">    SYSTEM_INFO sSysInfo;         // 系统信息</span><br><span class=\"line\">    GetSystemInfo(&amp;sSysInfo);     // 获取系统信息</span><br><span class=\"line\">    dwPageSize = sSysInfo.dwPageSize;       //系统内存页大小</span><br><span class=\"line\"></span><br><span class=\"line\">    lpSetUnhandledExceptionFilter = (pSetUnhandledExceptionFilter)GetProcAddress(LoadLibrary(L&quot;kernel32.dll&quot;),</span><br><span class=\"line\">        &quot;SetUnhandledExceptionFilter&quot;);</span><br><span class=\"line\">    lpOldHandler = (DWORD)lpSetUnhandledExceptionFilter(TopUnhandledExceptionFilter2);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 分配内存</span><br><span class=\"line\">    lpvBase = VirtualAlloc(NULL, dwPageSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class=\"line\">    if (lpvBase == NULL)    </span><br><span class=\"line\">        MessageBoxW(L&quot;VirtualAlloc Error&quot;);</span><br><span class=\"line\">    _asm &#123;</span><br><span class=\"line\">        mov   NewEip, offset safe //方式二，更简单</span><br><span class=\"line\">        mov   eax, lpvBase</span><br><span class=\"line\">        push  eax</span><br><span class=\"line\">        mov   byte ptr[eax], 0C3H //写一个 RETN 到保留内存，以便下面的调用</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (0 == ::VirtualProtect(lpvBase, dwPageSize, PAGE_EXECUTE_READ | PAGE_GUARD, &amp;dwOldType)) &#123;</span><br><span class=\"line\">        MessageBoxW(L&quot;VirtualProtect Error&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _asm &#123;</span><br><span class=\"line\">        pop   ecx</span><br><span class=\"line\">        call  ecx   //调用时压栈</span><br><span class=\"line\">        safe :</span><br><span class=\"line\">        pop   ecx    //堆栈平衡，弹出调用时的压栈</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (1 == isDebugged) &#123;</span><br><span class=\"line\">        MessageBoxW(L&quot;Being Debugged!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        MessageBoxW(L&quot;Not Being Debugged!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    VirtualFree(lpvBase, dwPageSize, MEM_DECOMMIT);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"硬件断点\"><a href=\"#硬件断点\" class=\"headerlink\" title=\"硬件断点\"></a>硬件断点</h1><p>硬件断点是通过设置名为 Dr0 到 Dr7 的调试寄存器来实现的。 Dr0-Dr3 包含至多 4 个断点的地址， Dr6 是个标志，它指示哪个断点被触发了， Dr7 包含了控制 4 个硬件断点诸如启用&#x2F;禁用或者中断于读&#x2F;写的标志。</p>\n<p>由于调试寄存器无法在 Ring3 下访问，硬件断点的检测需要执行一小段代码。可以利用含有调试寄存器值的 CONTEXT 结构，该结构可以通过传递给异常处理例程的 ContextRecord 参数来访问。</p>\n<p>使用方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static bool isDebuggedHBP = 0;</span><br><span class=\"line\">LONG WINAPI TopUnhandledExceptionFilterHBP(</span><br><span class=\"line\">    struct _EXCEPTION_POINTERS *ExceptionInfo</span><br><span class=\"line\">)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _asm pushad</span><br><span class=\"line\">    //AfxMessageBox(&quot;回调函数被调用&quot;);</span><br><span class=\"line\">    ExceptionInfo-&gt;ContextRecord-&gt;Eip = NewEip;</span><br><span class=\"line\">    if (0 != ExceptionInfo-&gt;ContextRecord-&gt;Dr0 || 0 != ExceptionInfo-&gt;ContextRecord-&gt;Dr1 ||</span><br><span class=\"line\">        0 != ExceptionInfo-&gt;ContextRecord-&gt;Dr2 || 0 != ExceptionInfo-&gt;ContextRecord-&gt;Dr3)</span><br><span class=\"line\">        isDebuggedHBP = 1;  //检测有无硬件断点</span><br><span class=\"line\">    ExceptionInfo-&gt;ContextRecord-&gt;Dr0 = 0; //禁用硬件断点，置0</span><br><span class=\"line\">    ExceptionInfo-&gt;ContextRecord-&gt;Dr1 = 0;</span><br><span class=\"line\">    ExceptionInfo-&gt;ContextRecord-&gt;Dr2 = 0;</span><br><span class=\"line\">    ExceptionInfo-&gt;ContextRecord-&gt;Dr3 = 0;</span><br><span class=\"line\">    ExceptionInfo-&gt;ContextRecord-&gt;Dr6 = 0;</span><br><span class=\"line\">    ExceptionInfo-&gt;ContextRecord-&gt;Dr7 = 0;</span><br><span class=\"line\">    ExceptionInfo-&gt;ContextRecord-&gt;Eip = NewEip; //转移到安全位置</span><br><span class=\"line\">    _asm popad</span><br><span class=\"line\">    return EXCEPTION_CONTINUE_EXECUTION;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void CAntiDebugDlg::OnBnClickedBtnHdbreakpoint()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // TODO: 在此添加控件通知处理程序代码</span><br><span class=\"line\">    lpSetUnhandledExceptionFilter = (pSetUnhandledExceptionFilter)GetProcAddress(LoadLibrary(L&quot;kernel32.dll&quot;),</span><br><span class=\"line\">        &quot;SetUnhandledExceptionFilter&quot;);</span><br><span class=\"line\">    lpOldHandler = (DWORD)lpSetUnhandledExceptionFilter(TopUnhandledExceptionFilterHBP);</span><br><span class=\"line\">    _asm &#123;</span><br><span class=\"line\">        mov   NewEip, offset safe //方式二，更简单</span><br><span class=\"line\">        int   3</span><br><span class=\"line\">        mov   isDebuggedHBP, 1 //调试时可能也不会触发异常去检测硬件断点</span><br><span class=\"line\">        safe:</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (1 == isDebuggedHBP) &#123;</span><br><span class=\"line\">        MessageBoxW(L&quot;Being Debugged!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        MessageBoxW(L&quot;Not Being Debugged!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"封锁键盘，鼠标输入\"><a href=\"#封锁键盘，鼠标输入\" class=\"headerlink\" title=\"封锁键盘，鼠标输入\"></a>封锁键盘，鼠标输入</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WINUSERAPI</span><br><span class=\"line\">BOOL</span><br><span class=\"line\">WINAPI</span><br><span class=\"line\">BlockInput(</span><br><span class=\"line\">    BOOL fBlockIt);</span><br></pre></td></tr></table></figure>\n\n<p>BlockInput函数阻塞键盘及鼠标事件到达应用程序。该参数指明函数的目的。如果参数为TRUE，则鼠标和键盘事件将被阻塞。如果参数为FALSE， 则鼠标和键盘事件不被阻塞。</p>\n<p>可以在代码中的关键位置调用此函数。</p>\n<p>使用方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void CAntiDebugDlg::OnBnClickedBtnBlockinput()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // TODO: 在此添加控件通知处理程序代码</span><br><span class=\"line\">    DWORD dwNoUse;</span><br><span class=\"line\">    DWORD dwNoUse2;</span><br><span class=\"line\">    ::BlockInput(TRUE);</span><br><span class=\"line\">    dwNoUse = 2;</span><br><span class=\"line\">    dwNoUse2 = 3;</span><br><span class=\"line\">    dwNoUse = dwNoUse2;</span><br><span class=\"line\">    ::BlockInput(FALSE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"禁用窗口\"><a href=\"#禁用窗口\" class=\"headerlink\" title=\"禁用窗口\"></a>禁用窗口</h1><p>与BlockInput函数的功能类似，用来禁用窗口</p>\n<p>函数说明：</p>\n<p>BOOL EnableWindow（HWND hWnd，BOOL bEnable）</p>\n<p>hWnd：被允许&#x2F;禁止的<a href=\"http://baike.baidu.com/subview/1452762/1452762.htm\">窗口句柄</a></p>\n<p>bEnable: 定义窗口是被允许，还是被禁止。若该参数为TRUE，则窗口被允许。若该参数为FALSE，则窗口被禁止。</p>\n<p>Windows <a href=\"http://baike.baidu.com/subview/533172/533172.htm\">API函数</a>。该函数允许&#x2F;禁止指定的窗口或控件接受鼠标和键盘的输入，当输入被禁止时，窗口不响应鼠标和按键的输入，输入允许时，窗口接受所有的输入。</p>\n<p>使用方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void CAntiDebugDlg::OnBnClickedBtnEnbalewindow()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // TODO: 在此添加控件通知处理程序代码</span><br><span class=\"line\">    CWnd *wnd;</span><br><span class=\"line\">    wnd = GetForegroundWindow();</span><br><span class=\"line\">    wnd-&gt;EnableWindow(FALSE);</span><br><span class=\"line\">    DWORD dwNoUse;</span><br><span class=\"line\">    DWORD dwNoUse2;</span><br><span class=\"line\">    dwNoUse = 2;</span><br><span class=\"line\">    dwNoUse2 = 3;</span><br><span class=\"line\">    dwNoUse = dwNoUse2;</span><br><span class=\"line\">    wnd-&gt;EnableWindow(TRUE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"OutputDebugString\"><a href=\"#OutputDebugString\" class=\"headerlink\" title=\"OutputDebugString\"></a>OutputDebugString</h1><p>OutputDebugString 函数用于向调试器发送一个格式化的字符串， Ollydbg 会在底端显示相应的信息。 OllyDbg 存在格式化字符串溢出漏洞，非常严重，轻则崩溃，重则执行任意代码。这个漏洞是由于 Ollydbg 对传递给 kernel32!OutputDebugString()的字符串参数过滤不严导致的，它只对参数进行那个长度检查，只接受 255 个字节，但没对参数进行检查，所以导致缓冲区溢出。</p>\n<p>使用方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//能够让OD崩溃</span><br><span class=\"line\">void CAntiDebugDlg::OnBnClickedBtnOutputdebugstring()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // TODO: 在此添加控件通知处理程序代码</span><br><span class=\"line\">    ::OutputDebugString(L&quot;%s%s%s&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","text":"TLS回调函数由于TLS回调函数会先于EP代码执行，可以在回调函数内部使用IsDebuggerPresent()等函数判断调试与否，再决定是否继续运行程序。 E...","permalink":"/post/Windows静态反调试技术（三）","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":14,"path":"api/tags/逆向.json"},{"name":"Windows静态反调试技术","slug":"Windows静态反调试技术","count":3,"path":"api/tags/Windows静态反调试技术.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">TLS回调函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ETC\"><span class=\"toc-text\">ETC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#FindWindow\"><span class=\"toc-text\">FindWindow</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%9A%E4%B8%BE%E7%AA%97%E5%8F%A3\"><span class=\"toc-text\">枚举窗口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%9A%E4%B8%BE%E8%BF%9B%E7%A8%8B\"><span class=\"toc-text\">枚举进程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E7%88%B6%E8%BF%9B%E7%A8%8B%E6%98%AF%E4%B8%8D%E6%98%AFExplorer\"><span class=\"toc-text\">查看父进程是不是Explorer</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8BStartupInfo%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">查看StartupInfo结构</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#CheckRemoteDebuggerPresent\"><span class=\"toc-text\">CheckRemoteDebuggerPresent</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#SeDebugPrivilege%E8%BF%9B%E7%A8%8B%E6%9D%83%E9%99%90\"><span class=\"toc-text\">SeDebugPrivilege进程权限</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#GuardPages\"><span class=\"toc-text\">GuardPages</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%A1%AC%E4%BB%B6%E6%96%AD%E7%82%B9\"><span class=\"toc-text\">硬件断点</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B0%81%E9%94%81%E9%94%AE%E7%9B%98%EF%BC%8C%E9%BC%A0%E6%A0%87%E8%BE%93%E5%85%A5\"><span class=\"toc-text\">封锁键盘，鼠标输入</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%A6%81%E7%94%A8%E7%AA%97%E5%8F%A3\"><span class=\"toc-text\">禁用窗口</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#OutputDebugString\"><span class=\"toc-text\">OutputDebugString</span></a></li></ol>","author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Windows动态反调试技术（一）","uid":"744ee437e256eacc7e89be203fb836fd","slug":"Windows动态反调试技术（一）","date":"2022-07-09T13:39:34.000Z","updated":"2025-06-09T21:55:47.591Z","comments":true,"path":"api/articles/Windows动态反调试技术（一）.json","keywords":null,"cover":[],"text":"异常SetUnhandledExceptionFilter()进程中发生异常时，若SEH未处理或注册的SEH根本不存在，此时会调用执行系统的kernel32!U...","permalink":"/post/Windows动态反调试技术（一）","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":14,"path":"api/tags/逆向.json"},{"name":"Windows动态反调试技术","slug":"Windows动态反调试技术","count":2,"path":"api/tags/Windows动态反调试技术.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Windows静态反调试技术（二）","uid":"4d2341767a6c86040d957eae87d1ec51","slug":"Windows静态反调试技术（二）","date":"2022-06-22T13:16:13.000Z","updated":"2025-06-09T21:41:20.984Z","comments":true,"path":"api/articles/Windows静态反调试技术（二）.json","keywords":null,"cover":[],"text":"NtQueryInformationProcess()NtQueryInformationProcess定义通过NtQueryInformationProces...","permalink":"/post/Windows静态反调试技术（二）","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":14,"path":"api/tags/逆向.json"},{"name":"Windows静态反调试技术","slug":"Windows静态反调试技术","count":3,"path":"api/tags/Windows静态反调试技术.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}