{"title":"UPX脱壳实战——结合逆向工程核心原理","uid":"d804751ae060ee6bddee780d4be7bc78","slug":"UPX脱壳实战——结合逆向工程核心原理","date":"2022-05-11T03:23:55.000Z","updated":"2025-06-05T15:24:37.476Z","comments":true,"path":"api/articles/UPX脱壳实战——结合逆向工程核心原理.json","keywords":null,"cover":[],"content":"<p>用《逆向工程核心原理》这本书中的notepad_upx.exe来实验</p>\n<h1 id=\"未加壳的oep\"><a href=\"#未加壳的oep\" class=\"headerlink\" title=\"未加壳的oep\"></a><strong>未加壳的oep</strong></h1><p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605230537483.png\" alt=\"image-20250605230537483\"></p>\n<h1 id=\"单步跟踪法\"><a href=\"#单步跟踪法\" class=\"headerlink\" title=\"单步跟踪法\"></a><strong>单步跟踪法</strong></h1><p>脱壳的方法有很多，先来讲脱壳方法中最基础的单步跟踪法。单步跟踪法就是利用OD的单条指令执行功能，从壳的入口一直执行到OEP，最终通过这个OEP将原程序dump出来。在单步跟踪的时候需要跳过一些不能执行到的指令。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　使用单步跟踪法追踪OEP的常见步骤：</span><br><span class=\"line\">　　1、用OD载入待脱壳文件，如果出现压缩提示，选择“不分析代码”；</span><br><span class=\"line\">　　2、向下单步跟踪，实现向下的跳转；</span><br><span class=\"line\">　　3、遇到程序往上跳转的时候（包括循环），在回跳的下一句代码上单击并按键盘上的“F4”键跳过回跳指令；</span><br><span class=\"line\">　　4、OD中的绿色线条表示跳转没有实理，不必理会，红色线条表示跳转已经实现；</span><br><span class=\"line\">　　5、如果刚载入程序的时候，在附近有一个CALL指令，那么就要按键盘上的“F7”键跟进这个CALL内，不然程序很容易运行起来；</span><br><span class=\"line\">　　6、在跟踪的时候，如果执行某个CALL指令后就运行，一定要按键盘上的“F7”键进入这个CALL之内再单步跟踪；</span><br><span class=\"line\">　　7、遇到在popad指令下的远转移指令时，要格处注意，因为这个远转移指令的目的地很可能就是OEP。</span><br></pre></td></tr></table></figure>\n\n<p>用x32dbg打开加壳程序，会断在pushad指令处</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605230635663.png\" alt=\"image-20250605230635663\"></p>\n<p>单步运行（step over），当遇到jcc&#x2F;loop指令时，要判断他是往下跳还是往上跳，如果为往下跳，直接跳过去就可以（直接单步运行），但是如果是往上跳，可能会有循环等结构，比较的麻烦，需要利用断点的方式来避免往上跳的情况，这里需要注意，如果遇到jump指令向上时，不能简单的用这一招，需要结合整个jump指令的范围内的jcc来决定，如下所示：</p>\n<p>1.当运行到01015359处的jcc指令时，该指令是往上跳的(从01015359跳到01015348)，这时就在01015359处的下一条指令也就是0101535B处断点然后继续运行来跳过，然后继续单步运行</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605230650877.png\" alt=\"image-20250605230650877\"></p>\n<p>2.当遇到向上跳的jmp指令时，不能只简单用上面的方法，首先在jmp的后一条指令打断点，然后需要回溯跳转范围内的jcc指令，看有没有跳转到jmp指令后面的，若有则在跳转地址打断点，然后再点运行，如下图中只有1015402和10153EC两处在jmp指令后，在这两处打断点，然后点击运行</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605230723394.png\" alt=\"image-20250605230723394\"></p>\n<p>3.经过上一步运行后，断点会停在10153EC处</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605230740059.png\" alt=\"image-20250605230740059\"></p>\n<p>4.继续向下单步，发现其被包含在一个jmp(10153FD)的跳转范围内，则去掉此处的断点，利用2中的处理方法继续设断点，发现只有1015402在10153FD之后，在1015402设置断点，然后点运行</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605230752760.png\" alt=\"image-20250605230752760\"></p>\n<p>5.此时断点会停在1015402处，继续单步运行，后面会再次遇到jmp（1015476）指令，此时只有1015478符合设断点的条件，但是1015478是个call指令，不宜只设此处一个断点，（有可能此处的call是退出程序的函数。我调试是用od会显示此处是exitprocess函数），所以此时需要看看跳转范围里的jcc，看是否有跳转到范围以上的（即地址小于1015459的），发现有个跳到101543C的</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605230809529.png\" alt=\"image-20250605230809529\"></p>\n<p>6.回溯101543C，发现其有跳转到jmp（1015476）指令之后的101547E，在101547E处设置断点，然后点运行</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605230823239.png\" alt=\"image-20250605230823239\"></p>\n<p>7.此时断点停在101547E处，继续单步运行，就看到了popad指令，这也是马上到oep的标志，继续单步运行，发现有个jmp指令（10154BB），但是此时没有向上或向下的箭头，这是因为这是一个大跳转，而这个大跳转的地址就极大可能是oep地址（如下图中的100739D）</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605230836939.png\" alt=\"image-20250605230836939\"></p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605230843793.png\" alt=\"image-20250605230843793\"></p>\n<p>8.继续单步运行，程序就会跳转到100739D地址处，此处便是oep，可以看和前面未加壳的oep一致</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605230856847.png\" alt=\"image-20250605230856847\"></p>\n<h1 id=\"ESP定律\"><a href=\"#ESP定律\" class=\"headerlink\" title=\"ESP定律\"></a><strong>ESP定律</strong></h1><p>ESP定律的原理在于程序中堆栈平衡的合理利用。由于在程序自解密或者自解压过程中，不少壳会先将当前寄存器内容压栈，如使用pushad，在解压结束后，会将之前的寄存器值出栈，如使用popad。因此在寄存器出栈时，往往程序代码被自动恢复，此时硬件断点触发。然后在程序当前位置，只需要少许单步跟踪，就很容易到达正确的OEP位置。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　ESP定律法是脱壳的利器，是国外友人发现的。有了ESP定律，可以方便我们脱掉大多数的压缩壳。可谓是本世纪破解界中最伟大的发现之一。这里只简单的看一下狭义ESP定律的原理。</span><br><span class=\"line\">　　使用ESP定律追踪OEP的常见步骤：</span><br><span class=\"line\">　　1、将待脱壳程序载入到OD中，开始就按键盘上的“F8”键单步跟踪一步，这时如果看到OD右边的寄存器窗口中的ESP寄存器的值有没有变为红色，如果发现ESP寄存器的值变为红色，执行第2步；</span><br><span class=\"line\">　　2、在OD的命令行窗口中执行命令hrXXXXXXXX,xxxxxxxx就是变为红色的ESP寄存器的值，在输入命令之后，一定不要忘记按键盘上的回车键；</span><br><span class=\"line\">　　3、按键盘上的“F9”键让程序运行起来；</span><br><span class=\"line\">　　4、使用单步跟踪的方法跟踪到OEP即可。</span><br></pre></td></tr></table></figure>\n\n<p>1.用x32dbg打开加壳程序，将会暂停在pushad指令处</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605230948879.png\" alt=\"image-20250605230948879\"></p>\n<p>2.单步运行一次，此时8大寄存器只有esp发生了改变（只有esp为红色），此时右键esp，并选择在内存窗口中跟随</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231000624.png\" alt=\"image-20250605231000624\"></p>\n<p>3.此时内存窗口就会转到esp所指的地址，选中前四字节，然后右键-&gt;断点-&gt;硬件访问-&gt;4字节(D)来设置硬件断点</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231012460.png\" alt=\"image-20250605231012460\"></p>\n<p>4.设置完硬件断点后，直接运行，断点将会停在跳转oep的指令附近，就看到了popad指令，这也是马上到oep的标志，继续单步运行，发现有个jmp指令（10154BB），但是此时没有向上或向下的箭头，这是因为这是一个大跳转，而这个大跳转的地址就极大可能是oep地址（如下图中的100739D）</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231025706.png\" alt=\"image-20250605231025706\"></p>\n<p>5.继续单步运行，程序就会跳转到100739D地址处，此处便是oep，可以看和前面未加壳的oep一致</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231038009.png\" alt=\"image-20250605231038009\"></p>\n<h1 id=\"二次断点法（内存镜像法）\"><a href=\"#二次断点法（内存镜像法）\" class=\"headerlink\" title=\"二次断点法（内存镜像法）\"></a>二次断点法（内存镜像法）</h1><p>二次断点是有技巧的下两个断点，在两个断点之后就可以很轻松的找到OEP。</p>\n<p>（ 不是每个都可以的，一些像UPX和ASPACK就不行。）</p>\n<p>壳如果要把原来加密或压缩的代码运行起来就必须要解压和解密原来的代码。这一个过程可以将他看做是对代码段（code段）的写入，一个EXE文件的有code段，data段，rsrc段…..依次排列在你的内存空间中，只要你在data断或者rsrc段下内存访问断点，那么中断的时候code段就已经解压完毕了。这时我们再对code段下内存访问断点，不就可以到达OEP了吗？ 1.对data段下内存访问断点而中断是因为内存写入中断，目的是断在对对data段的解压时，这时壳要对data段写数据，但是code段已经解压 完毕。</p>\n<p>2.对code段下内存访问断点而中断是因为内存执行中断，目的当然就是寻找OEP了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　使用二次断点法追踪OEP的常见步骤：</span><br><span class=\"line\">　　1、将待脱壳程序载入到OD中，单击OD的“选项”菜单下的“调试设置”命令，在弹出的“调试选项”对话框中切换到“异常”选项卡，勾选该选项卡下的所有复选框，也就是忽略所有异常；</span><br><span class=\"line\">　　2、按键盘上的“ALT+M”组合键打开OD的内存窗口；</span><br><span class=\"line\">　　3、在OD的内存窗口中找到“.rsrc”区段，单击该区段后按键盘上的“F2”键在该区段上下一断点；</span><br><span class=\"line\">　　4、按“Shift+F9”让程序运行到断点心处，而后再次打开OD的内存窗口，这次在“.rsrc”区段上面的“.code”区段（有的时候就是“.text”）上下一个断点；</span><br><span class=\"line\">　　5、按“shift+F9”让程序运行到第二次下的断点处，然后单步跟踪既可以来到OEP。</span><br></pre></td></tr></table></figure>\n\n<p>首先设置忽略所有异常</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231155339.png\" alt=\"image-20250605231155339\"></p>\n<p>然后在内存窗口找到资源段（data段&#x2F;rsrc段）下断点，按“Shift+F9”让程序运行到断点处</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231211661.png\" alt=\"image-20250605231211661\"></p>\n<p>接着在内存窗口“.code”区段（有的时候就是“.text”）上下一个断点，按“Shift+F9”让程序运行到断点处，然后单步跟踪既可以来到OEP。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231222514.png\" alt=\"image-20250605231222514\"></p>\n<h1 id=\"x32dbg结合自带的scylla进行脱壳与修复\"><a href=\"#x32dbg结合自带的scylla进行脱壳与修复\" class=\"headerlink\" title=\"x32dbg结合自带的scylla进行脱壳与修复\"></a><strong>x32dbg结合自带的scylla进行脱壳与修复</strong></h1><p>找到oep后，就可以用x32dbg结合自带的scylla插件进行脱壳和修复iat了，具体步骤如下：</p>\n<p>①首先打开scylla插件，并点击dump按钮保存脱壳后的程序</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231345933.png\" alt=\"image-20250605231345933\"></p>\n<p>②然后点击IAT Autosearch,遇到result of advanced…..直接点击是</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231358596.png\" alt=\"image-20250605231358596\"></p>\n<p>③若弹框iat found说明找到了程序的IAT表，点击确定</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231412002.png\" alt=\"image-20250605231412002\"></p>\n<p>④点击Get imports就会在上面显示找到的导入表</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231426029.png\" alt=\"image-20250605231426029\"></p>\n<p>如果有一个表没有导出成功，，如下图所示：</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231438716.png\" alt=\"image-20250605231438716\"></p>\n<p>直接右键删除这个导出失败的表，然后点击Fix Dump进行修复</p>\n<p>修复完后可以看到文件夹下多了两个程序，第二个是导出但没有修复IAT的程序，第三个是基于导出的源程序修复好了IAT。双击是可以直接运行的。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231454243.png\" alt=\"image-20250605231454243\"></p>\n<h1 id=\"使用lordpe-importREC脱壳及修复\"><a href=\"#使用lordpe-importREC脱壳及修复\" class=\"headerlink\" title=\"使用lordpe+importREC脱壳及修复\"></a><strong>使用lordpe+importREC脱壳及修复</strong></h1><p>在od找到oep后，使用ollydump脱壳并用importREC修复后程序不能运行，用lordpe修复pe还是不能运行，此时可以选择不使用ollydump脱壳，而是用lordpe脱壳并用importREC，具体操作示例如下：</p>\n<p>1.使用od找到oep后，记录下oep地址，如下找到的oep地址是0100739D</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231508285.png\" alt=\"image-20250605231508285\"></p>\n<p>2.双击运行待脱壳程序，以管理员身份打开lordpe，并选择待脱壳程序右键选择完整转存，如下示例待脱壳程序是notepad_u…</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231520514.png\" alt=\"image-20250605231520514\"></p>\n<p>3.用lordpe dump文件后，以管理员身份打开importREC，选择待脱壳程序，本例中为notepad_upx.exe</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231537972.png\" alt=\"image-20250605231537972\"></p>\n<p>4.点击IAT AutoSearch，如果出现如下提示表示找到了IAT，点击确定即可</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231549270.png\" alt=\"image-20250605231549270\"></p>\n<p>5.若找到IAT，接着点击Get Imports获取输入表，如下图获取到了输入表，但是有个显示了?，且后面有valid：No，表示有无效输入表</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231601324.png\" alt=\"image-20250605231601324\"></p>\n<p>6.点击Show Invalid选择失效的输入表，右键选择Invalidate functions，然后再右键选择Trace Level1(Disasm)，接着再选择Show Invalid；若还有，则继续右键选择Trace Level2(Hook)，接着再选择Show Invalid；若还有，继续右键选择Trace Level3(Trap Flag)，接着再选择Show Invalid；若还有，则右键选择Delete thunk(s)删除无效的输入表，接着再选择Show Invalid，可以发现没有无效输入表了</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231620144.png\" alt=\"image-20250605231620144\"></p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231626404.png\" alt=\"image-20250605231626404\"></p>\n<p>7.紧接着将oep修改为od中查找的oep，填偏移量即0000739D，然后选择Fix Dump按钮，再弹出文件框选择之前lordpe dump的文件</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231637136.png\" alt=\"image-20250605231637136\"></p>\n<p>8.修复成功后提示生成新的文件，文件名以_结尾，如本例中为notepad_upx_dumped_.exe，双击运行修复后的文件可以正常运行，用od打开修复后的文件发现直接是oep，已没有壳</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/image-20250605231648071.png\" alt=\"image-20250605231648071\"></p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a><strong>参考链接</strong></h1><p><a href=\"https://reveone.notion.site/CTF-UPX-c9c2155d8c9c44899f99cfd6a63a98fc\">CTF中手工脱壳实例(UPX壳)</a></p>\n<p><a href=\"https://bbs.kanxue.com/thread-43008.htm\">脱壳后软件无法运行的原因分析及对策——写给初学者</a></p>\n<p><a href=\"https://blog.csdn.net/islq/article/details/457591\">用importREC修复Import表</a></p>\n<p><a href=\"https://www.cnblogs.com/guomeiran/p/3924090.html\">逆向常用小工具（一）——importREC</a></p>\n<p><a href=\"https://www.cnblogs.com/zpchcbd/p/15983349.html\">对于UPX壳的脱壳问题</a></p>\n<p><a href=\"https://www.cnblogs.com/polang19/p/15921158.html\">ximo脱壳1—手脱UPX壳 </a></p>\n<p><a href=\"https://bbs.kanxue.com/thread-20366.htm\">脱壳入门初级教学</a> </p>\n<p><a href=\"https://www.52pojie.cn/thread-259984-1-1.html\">脱壳方法总汇</a></p>\n<p><a href=\"https://wooyun.js.org/drops/%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%BD%AF%E4%BB%B6%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8.html\">逆向基础——软件手动脱壳技术入门</a></p>\n<p><a href=\"https://www.cnblogs.com/LyShark/p/11190029.html\">https://www.cnblogs.com/LyShark/p/11190029.html</a></p>\n<p><a href=\"https://yangtf.gitee.io/ctf-wiki/reverse/unpack/packer-introduction/\">https://yangtf.gitee.io/ctf-wiki/reverse/unpack/packer-introduction/</a></p>\n<p><a href=\"https://www.chinapyg.com/thread-13270-1-1.html\">普通壳的脱壳方法和脱壳技巧，叫新手少走弯路！</a></p>\n","text":"用《逆向工程核心原理》这本书中的notepad_upx.exe来实验 未加壳的oep 单步跟踪法脱壳的方法有很多，先来讲脱壳方法中最基础的单步跟踪法。单步跟踪法...","permalink":"/post/UPX脱壳实战——结合逆向工程核心原理","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"逆向工程核心原理","slug":"逆向工程核心原理","count":7,"path":"api/tags/逆向工程核心原理.json"},{"name":"加壳与脱壳","slug":"加壳与脱壳","count":1,"path":"api/tags/加壳与脱壳.json"},{"name":"iat修复","slug":"iat修复","count":1,"path":"api/tags/iat修复.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%AA%E5%8A%A0%E5%A3%B3%E7%9A%84oep\"><span class=\"toc-text\">未加壳的oep</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%95%E6%AD%A5%E8%B7%9F%E8%B8%AA%E6%B3%95\"><span class=\"toc-text\">单步跟踪法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ESP%E5%AE%9A%E5%BE%8B\"><span class=\"toc-text\">ESP定律</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E6%AC%A1%E6%96%AD%E7%82%B9%E6%B3%95%EF%BC%88%E5%86%85%E5%AD%98%E9%95%9C%E5%83%8F%E6%B3%95%EF%BC%89\"><span class=\"toc-text\">二次断点法（内存镜像法）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#x32dbg%E7%BB%93%E5%90%88%E8%87%AA%E5%B8%A6%E7%9A%84scylla%E8%BF%9B%E8%A1%8C%E8%84%B1%E5%A3%B3%E4%B8%8E%E4%BF%AE%E5%A4%8D\"><span class=\"toc-text\">x32dbg结合自带的scylla进行脱壳与修复</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8lordpe-importREC%E8%84%B1%E5%A3%B3%E5%8F%8A%E4%BF%AE%E5%A4%8D\"><span class=\"toc-text\">使用lordpe+importREC脱壳及修复</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"IDA添加结构体","uid":"d90627d53e222069704f901ed1b80995","slug":"IDA添加结构体","date":"2022-06-09T08:49:43.000Z","updated":"2025-06-09T10:16:41.620Z","comments":true,"path":"api/articles/IDA添加结构体.json","keywords":null,"cover":[],"text":"导入头文件方法①首先菜单栏选择File -> Load File -> Parse C Header file（Ctrl+F9）然后导入结构体文件（xxx.h）...","permalink":"/post/IDA添加结构体","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":9,"path":"api/tags/逆向.json"},{"name":"IDA使用","slug":"IDA使用","count":1,"path":"api/tags/IDA使用.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"PE文件——基址重定位","uid":"79cf73108f662b9d6b8f237086d2463b","slug":"PE文件——基址重定位","date":"2022-05-03T14:33:53.000Z","updated":"2025-06-09T08:38:09.203Z","comments":true,"path":"api/articles/PE文件——基址重定位.json","keywords":null,"cover":[],"text":"当链接器生成一个PE文件时，会假设这个文件在执行时被装载到默认的基地址处，并把code和data的相关地址都写入PE文件。如果载入时将默认的值作为基地址载入，则...","permalink":"/post/PE文件——基址重定位","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":9,"path":"api/tags/逆向.json"},{"name":"PE文件","slug":"PE文件","count":3,"path":"api/tags/PE文件.json"},{"name":"基址重定位","slug":"基址重定位","count":1,"path":"api/tags/基址重定位.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}