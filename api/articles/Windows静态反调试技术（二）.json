{"title":"Windows静态反调试技术（二）","uid":"4d2341767a6c86040d957eae87d1ec51","slug":"Windows静态反调试技术（二）","date":"2022-06-22T13:16:13.000Z","updated":"2025-06-09T21:41:20.984Z","comments":true,"path":"api/articles/Windows静态反调试技术（二）.json","keywords":null,"cover":[],"content":"<h1 id=\"NtQueryInformationProcess\"><a href=\"#NtQueryInformationProcess\" class=\"headerlink\" title=\"NtQueryInformationProcess()\"></a>NtQueryInformationProcess()</h1><h2 id=\"NtQueryInformationProcess定义\"><a href=\"#NtQueryInformationProcess定义\" class=\"headerlink\" title=\"NtQueryInformationProcess定义\"></a>NtQueryInformationProcess定义</h2><p>通过NtQueryInformationProcess() API可以获取各种与进程调试相关的信息，该函数定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NTSTATUS WINAPI <span class=\"title function_\">NtQueryInformationProcess</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">\t__in HANDLE ProcessHandle,</span></span><br><span class=\"line\"><span class=\"params\">\t__in PROCESSINFOCLASS ProcessInformationClass,</span></span><br><span class=\"line\"><span class=\"params\">\t__out PVOID ProcessInformation,</span></span><br><span class=\"line\"><span class=\"params\">\t__in ULONG ProcessInformationLength,</span></span><br><span class=\"line\"><span class=\"params\">\t__out_opt PULONG ReturnLength</span></span><br><span class=\"line\"><span class=\"params\">)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>为NtQueryInformationProcess()函数的第二个参数PROCESSINFOCLASS ProcessInformationClass指定特定的值并调用该函数，相关信息就会被设置到其第三个参数PVOID ProcessInformation。PROCESSINFOCLASS是枚举类型，拥有的值如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">PROCESSINFOCLASS</span>&#123;</span></span><br><span class=\"line\">\tProcessBasicInformation=<span class=\"number\">0</span>,</span><br><span class=\"line\">\tProcessQuotaLimits,</span><br><span class=\"line\">\tProcessIoCounters,</span><br><span class=\"line\">\tProcessVmCounters,</span><br><span class=\"line\">\tProcessTimes,</span><br><span class=\"line\">\tProcessBasePriority,</span><br><span class=\"line\">\tProcessRaisePriority,</span><br><span class=\"line\">\tProcessDebugPort=<span class=\"number\">7</span>,        <span class=\"comment\">//0x7</span></span><br><span class=\"line\">\tProcessExceptionPort,</span><br><span class=\"line\">\tProcessAccessToken,</span><br><span class=\"line\">\tProcessLdtInformation,</span><br><span class=\"line\">\tProcessLdtSize,</span><br><span class=\"line\">\tProcessDefaultHardErrorMode,</span><br><span class=\"line\">\tProcessIoPortHandlers,</span><br><span class=\"line\">\tProcessPooledUsageAndLimits,</span><br><span class=\"line\">\tProcessWorkingSetWatch,</span><br><span class=\"line\">\tProcessUserModeIOPL,</span><br><span class=\"line\">\tProcessEnableAlignmentFaultFixup,</span><br><span class=\"line\">\tProcessPriorityClass,</span><br><span class=\"line\">\tProcessWx86Information,</span><br><span class=\"line\">\tProcessHandleCount,</span><br><span class=\"line\">\tProcessAffinityMask,</span><br><span class=\"line\">\tProcessPriorityBoost,</span><br><span class=\"line\">\tMaxProcessInfoClass,</span><br><span class=\"line\">\tProcessWow64Information=<span class=\"number\">26</span>,</span><br><span class=\"line\">\tProcessImageFileName=<span class=\"number\">27</span>,</span><br><span class=\"line\">\tProcessDebugObjectHandle=<span class=\"number\">30</span>,     <span class=\"comment\">//0x1E</span></span><br><span class=\"line\">\tProcessDebugFlags=<span class=\"number\">32</span>,            <span class=\"comment\">//0x1F</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上代码中与调试器探测有关的成员为ProcessDebugPort（0x7）、ProcessDebugObjectHandle（0x1E）、</p>\n<p>ProcessDebugFlags（0x1F）。</p>\n<h2 id=\"与反调试相关的成员\"><a href=\"#与反调试相关的成员\" class=\"headerlink\" title=\"与反调试相关的成员\"></a>与反调试相关的成员</h2><h3 id=\"ProcessDebugPort（0x7）\"><a href=\"#ProcessDebugPort（0x7）\" class=\"headerlink\" title=\"ProcessDebugPort（0x7）\"></a>ProcessDebugPort（0x7）</h3><p>进程处于调试状态时，系统就会为它分配1个调试端口（Debug Port）。ProcessInformationClass参数的值设置为ProcessDebugPort（0x7）时，调用NtQueryInformationProcess()函数就能获取调试端口。若进程处于非调试状态，则变量dwDebugPort的值被设置为0；若进程处于调试状态，则变量dwDebugPort的值被设置为0xFFFFFFFF，参考如下代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ProcessDebugPort（0x7）</span></span><br><span class=\"line\">DWORD dwDebugPort=<span class=\"number\">0</span>;</span><br><span class=\"line\">pNtQueryInformationProcess(GetCurrentProcess(),</span><br><span class=\"line\">\t\t\t\t        \tProcessDebugPort,</span><br><span class=\"line\">\t\t\t\t        \t&amp;dwDebugPort,</span><br><span class=\"line\">\t\t\t\t        \t<span class=\"keyword\">sizeof</span>(dwDebugPort),</span><br><span class=\"line\">\t\t\t\t        \t<span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;NtQueryInformationProcess(ProcessDebugPort)=0x%X\\n&quot;</span>,dwDebugPort);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(dwDebugPort !=<span class=\"number\">0x0</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;=&gt; Debugging!\\n\\n&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;=&gt; Not Debugging!\\n\\n&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CheckRemoteDebuggerPresent\"><a href=\"#CheckRemoteDebuggerPresent\" class=\"headerlink\" title=\"CheckRemoteDebuggerPresent()\"></a>CheckRemoteDebuggerPresent()</h3><p>CheckRemoteDebuggerPresent() API与IsDebuggerPresent() API类似，用来检测进程是否处于调试状态。CheckRemoteDebuggerPresent()函数不仅可以用来检测当前进程，还可以用来检测其他进程是否处于调试状态。进入CheckRemoteDebuggerPresent() API查看代码，可以看到其调用了NtQueryInformationProcess(ProcessDebugPort) API。如下图所示：</p>\n<p><img src=\"/./NtQueryInformationProcess/%E4%B8%8E%E5%8F%8D%E8%B0%83%E8%AF%95%E7%9B%B8%E5%85%B3%E7%9A%84%E6%88%90%E5%91%98/ProcessDebugPort/CheckRemoteDebuggerPresent(\" alt=\"CheckRemoteDebuggerPresent\"> API内部代码.png)</p>\n<h3 id=\"ProcessDebugObjectHandle（0x1E）\"><a href=\"#ProcessDebugObjectHandle（0x1E）\" class=\"headerlink\" title=\"ProcessDebugObjectHandle（0x1E）\"></a>ProcessDebugObjectHandle（0x1E）</h3><p>调试进程时会生成调试对象（Debug Object）。函数的第二个参数值为ProcessDebugObjectHandle（0x1E）时，调用函数后通过第三个参数就能获取调试对象句柄。进程处于调试状态时，调试对象句柄的值就存在；若进程处于非调试状态，则调试对象句柄值为NULL。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ProcessDebugObjectHandle（0x1E）</span></span><br><span class=\"line\">HANDLE hDebugObject=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">pNtQueryInformationProcess(GetCurrentProcess(),</span><br><span class=\"line\">\t\t\t\t        \tProcessDebugObjectHandle,</span><br><span class=\"line\">\t\t\t\t        \t&amp;hDebugObject,</span><br><span class=\"line\">\t\t\t\t        \t<span class=\"keyword\">sizeof</span>(hDebugObject),</span><br><span class=\"line\">\t\t\t\t        \t<span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;NtQueryInformationProcess(ProcessDebugObjectHandle)=0x%X\\n&quot;</span>,hDebugObject);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(hDebugObject !=<span class=\"number\">0x0</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;=&gt; Debugging!\\n\\n&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;=&gt; Not Debugging!\\n\\n&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"ProcessDebugFlags（0x1F）\"><a href=\"#ProcessDebugFlags（0x1F）\" class=\"headerlink\" title=\"ProcessDebugFlags（0x1F）\"></a>ProcessDebugFlags（0x1F）</h3><p>检测Debug Flags（调试标志）的值也可以判断进程是否处于被调试状态。函数的第二个参数设置为ProcessDebugFlags（0x1F）时，调用函数后通过第三个参数即可获取调试标志的值：若为0，则进程处于被调试状态；若为1，则进程处于非调试状态。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ProcessDebugFlags（0x1F）</span></span><br><span class=\"line\">BOOL bDebugFlag=TRUE;</span><br><span class=\"line\">pNtQueryInformationProcess(GetCurrentProcess(),</span><br><span class=\"line\">\t\t\t\t        \tProcessDebugFlags,</span><br><span class=\"line\">\t\t\t\t        \t&amp;bDebugFlag,</span><br><span class=\"line\">\t\t\t\t        \t<span class=\"keyword\">sizeof</span>(bDebugFlag),</span><br><span class=\"line\">\t\t\t\t        \t<span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;NtQueryInformationProcess(ProcessDebugFlags)=0x%X\\n&quot;</span>,bDebugFlag);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(bDebugFlag ==<span class=\"number\">0x0</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;=&gt; Debugging!\\n\\n&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;=&gt; Not Debugging!\\n\\n&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"NtQuerySystemInformation\"><a href=\"#NtQuerySystemInformation\" class=\"headerlink\" title=\"NtQuerySystemInformation()\"></a>NtQuerySystemInformation()</h1><p>之前介绍的是通过探测调试器来判断自己的进程是否处于被调试状态，下面是基于调试环境检测的反调试技术。运用这种反调试技术可以检测当前OS是否在调试模式下运行。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>设置调试模式的方法：</p>\n<p>（1）Windows XP：编辑”boot.ini”后重启</p>\n<p>[boot loader]</p>\n<p>timeout&#x3D;30</p>\n<p>default&#x3D;multi(0)disk(0)rdisk(0)partition(1)\\WINDOWS</p>\n<p>[operating systems]</p>\n<p>multi(0)disk(0)rdisk(0)partition(1)\\WINDOWS&#x3D;”Microsoft Windows XP Professional” &#x2F;noexecute&#x3D;optin &#x2F;fastdetect &#x2F;debugport&#x3D;com1 &#x2F;baudrate&#x3D;115200 &#x2F;Debug</p>\n<p>（2）Windows7：使用bcdedit.exe实用程序</p>\n<p>命令：bcdedit &#x2F;debug on</p></blockquote>\n<h2 id=\"NtQuerySystemInformation定义\"><a href=\"#NtQuerySystemInformation定义\" class=\"headerlink\" title=\"NtQuerySystemInformation定义\"></a>NtQuerySystemInformation定义</h2><p>ntdll!NtQuerySystemInformation() API是一个系统函数，用来获取当前运行的多种OS信息。其定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NTSTATUS WINAPI <span class=\"title function_\">NtQuerySystemInformation</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">\t__in SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class=\"line\"><span class=\"params\">\t__inout PVOID SystemInformation,</span></span><br><span class=\"line\"><span class=\"params\">\t__in ULONG SystemInformationLength,</span></span><br><span class=\"line\"><span class=\"params\">\t__out_opt PULONG ReturnLength</span></span><br><span class=\"line\"><span class=\"params\">)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>SYSTEM_INFORMATION_CLASS SystemInformationClass参数中指定需要的系统信息类型，将某结构体的地址传递给PVOID SystemInformation参数，API返回时，该结构体中就填充着相关信息。</p>\n<p>SYSTEM_INFORMATION_CLASS是枚举类型，拥有的值如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> _<span class=\"title\">SYSTEM_INFORMATION_CLASS</span>&#123;</span></span><br><span class=\"line\">\tSystemBasicInformation=<span class=\"number\">0</span>,</span><br><span class=\"line\">\tSystemPerformanceInformation=<span class=\"number\">2</span>,</span><br><span class=\"line\">\tSystemTimeOfDayInformation=<span class=\"number\">3</span>,</span><br><span class=\"line\">\tSystemProcessInformation=<span class=\"number\">5</span>,</span><br><span class=\"line\">\tSystemProcessPerformanceInformation=<span class=\"number\">8</span>,</span><br><span class=\"line\">\tSystemInterruptInformation=<span class=\"number\">23</span>,        </span><br><span class=\"line\">\tSystemExceptionInformation=<span class=\"number\">33</span>,</span><br><span class=\"line\">\tSystemKernelDebuggerInformation=<span class=\"number\">35</span>,  <span class=\"comment\">//0x23</span></span><br><span class=\"line\">\tSystemRegistryQuotaInformation=<span class=\"number\">37</span>, </span><br><span class=\"line\">    SystemLookasideInformation=<span class=\"number\">45</span></span><br><span class=\"line\">&#125;SYSTEM_INFORMATION_CLASS;</span><br></pre></td></tr></table></figure>\n\n<p>向SystemInformationClass参数传入SystemKernelDebuggerInformation（0x23）值，即可判断出当前OS是否在调试模式下运行。</p>\n<h2 id=\"SystemKernelDebuggerInformation（0x23）\"><a href=\"#SystemKernelDebuggerInformation（0x23）\" class=\"headerlink\" title=\"SystemKernelDebuggerInformation（0x23）\"></a>SystemKernelDebuggerInformation（0x23）</h2><p>查看实际的反调试源代码即可轻松掌握其原理：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;windows.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;tchar.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">MyNtQuerySystemInformation</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"title function_\">NTSTATUS</span> <span class=\"params\">(WINAPI *NTQUERYSYSTEMINFORMATION)</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        ULONG SystemInformationClass,</span></span><br><span class=\"line\"><span class=\"params\">        PVOID SystemInformation,</span></span><br><span class=\"line\"><span class=\"params\">        ULONG SystemInformationLength,</span></span><br><span class=\"line\"><span class=\"params\">        PULONG ReturnLength</span></span><br><span class=\"line\"><span class=\"params\">    )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">SYSTEM_KERNEL_DEBUGGER_INFORMATION</span> </span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">        BOOLEAN DebuggerEnabled;</span><br><span class=\"line\">        BOOLEAN DebuggerNotPresent;</span><br><span class=\"line\">    &#125; SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;</span><br><span class=\"line\"></span><br><span class=\"line\">    NTQUERYSYSTEMINFORMATION NtQuerySystemInformation;</span><br><span class=\"line\">  </span><br><span class=\"line\">    NtQuerySystemInformation = (NTQUERYSYSTEMINFORMATION)  </span><br><span class=\"line\">                                GetProcAddress(GetModuleHandle(<span class=\"string\">L&quot;ntdll&quot;</span>), </span><br><span class=\"line\">                                               <span class=\"string\">&quot;NtQuerySystemInformation&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ULONG SystemKernelDebuggerInformation = <span class=\"number\">0x23</span>;</span><br><span class=\"line\">    ULONG ulReturnedLength = <span class=\"number\">0</span>;</span><br><span class=\"line\">    SYSTEM_KERNEL_DEBUGGER_INFORMATION DebuggerInfo = &#123;<span class=\"number\">0</span>,&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    NtQuerySystemInformation(SystemKernelDebuggerInformation, </span><br><span class=\"line\">                             (PVOID) &amp;DebuggerInfo, </span><br><span class=\"line\">                             <span class=\"keyword\">sizeof</span>(DebuggerInfo),      <span class=\"comment\">// 2 bytes</span></span><br><span class=\"line\">                             &amp;ulReturnedLength);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;NtQuerySystemInformation(SystemKernelDebuggerInformation) = 0x%X 0x%X\\n&quot;</span>, </span><br><span class=\"line\">           DebuggerInfo.DebuggerEnabled, DebuggerInfo.DebuggerNotPresent);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( DebuggerInfo.DebuggerEnabled )  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;  =&gt; Debugging!!!\\n\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span>                                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;  =&gt; Not debugging...\\n\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> _tmain(<span class=\"type\">int</span> argc, TCHAR* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    MyNtQuerySystemInformation();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\npress any key to quit...\\n&quot;</span>);</span><br><span class=\"line\">    _gettch();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中，调用NtQuerySystemInformation() API时，第一个参数（SystemInformationClass）的值被设置为SystemKernelDebuggerInformation（0x23），第二个参数（SystemInformation）为SYSTEM_KERNEL_DEBUGGER_INFORMATION结构体的地址。当API返回时，若系统处在调试模式下，则SYSTEM_KERNEL_DEBUGGER_INFORMATION.DebuggerEnabled的值被设置为1（SYSTEM_KERNEL_DEBUGGER_INFORMATION.DebuggerNotPresent的值恒为1）。</p>\n<h2 id=\"破解之法\"><a href=\"#破解之法\" class=\"headerlink\" title=\"破解之法\"></a>破解之法</h2><p>在Windows XP系统中编辑boot.ini文件，删除”&#x2F;debugport&#x3D;com1 &#x2F;baudrate&#x3D;115200 &#x2F;Debug”值。在Windows 7系统的命令行窗口执行”bcdedit &#x2F;debug off”命令即可。并且重启系统则要以正常模式启动。</p>\n<h1 id=\"NtQueryObject\"><a href=\"#NtQueryObject\" class=\"headerlink\" title=\"NtQueryObject()\"></a>NtQueryObject()</h1><p>系统中的某个调试器调试进程时，会创建1个调试对象类型的内核对象，检测该对象是否存在即可判断是否有进程正在被调试。</p>\n<h2 id=\"NtQueryObject定义\"><a href=\"#NtQueryObject定义\" class=\"headerlink\" title=\"NtQueryObject定义\"></a>NtQueryObject定义</h2><p>ntdll!NtQueryObject() API用来获取系统各种内核对象的信息，NtQueryObject()函数的定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NTSTATUS <span class=\"title function_\">NtQueryObject</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">\t__in_opt HANDLE Handle,</span></span><br><span class=\"line\"><span class=\"params\">\t__in OBJECT_INFORMATION_CLASS ObjectInformationClass,</span></span><br><span class=\"line\"><span class=\"params\">\t__out_opt PVOID ObjectInformation,</span></span><br><span class=\"line\"><span class=\"params\">\t__in ULONG ObjectInformationLength,</span></span><br><span class=\"line\"><span class=\"params\">\t__out_opt PULONG ReturnLength</span></span><br><span class=\"line\"><span class=\"params\">)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>调用NtQueryObject()函数时，先向第二个参数OBJECT_INFORMATION_CLASS ObjectInformationClass赋予某个特定值，调用API后，包含相关信息的结构体指针就被返回第三个参数PVOID ObjectInformation。</p>\n<p>OBJECT_INFORMATION_CLASS是枚举类型，其拥有的值如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> _<span class=\"title\">OBJECT_INFORMATION_CLASS</span>&#123;</span></span><br><span class=\"line\">\tObjectBasicInformation,</span><br><span class=\"line\">\tObjectNameInformation,</span><br><span class=\"line\">\tObjectTypeInformation,</span><br><span class=\"line\">\tObjectAllTypesInformation,            <span class=\"comment\">//3</span></span><br><span class=\"line\">\tObjectHandleInformation</span><br><span class=\"line\">&#125;OBJECT_INFORMATION_CLASS,*POBJECT_INFORMATION_CLASS;</span><br></pre></td></tr></table></figure>\n\n<p>首先使用ObjectAllTypesInformation值获取系统所有对象信息，然后从中检测是否存在调试对象。</p>\n<h2 id=\"NtQueryObject-API使用方法\"><a href=\"#NtQueryObject-API使用方法\" class=\"headerlink\" title=\"NtQueryObject() API使用方法\"></a>NtQueryObject() API使用方法</h2><p>（1）获取内核对象信息链表的大小</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ULONG lSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">pNtQueryObject(<span class=\"literal\">NULL</span>, ObjectAllTypesInformation, &amp;lSize, <span class=\"keyword\">sizeof</span>(lSize), &amp;lSize);</span><br></pre></td></tr></table></figure>\n\n<p>（2）分配内存</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> *pBuf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">pBuf = VirtualAlloc(<span class=\"literal\">NULL</span>, lSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</span><br></pre></td></tr></table></figure>\n\n<p>（3）获取内核对象信息链表</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">OBJECT_TYPE_INFORMATION</span> &#123;</span></span><br><span class=\"line\">        UNICODE_STRING TypeName;</span><br><span class=\"line\">        ULONG TotalNumberOfHandles;</span><br><span class=\"line\">        ULONG TotalNumberOfObjects;</span><br><span class=\"line\">&#125;OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">OBJECT_ALL_INFORMATION</span> &#123;</span></span><br><span class=\"line\">        ULONG                   NumberOfObjectsTypes;</span><br><span class=\"line\">        OBJECT_TYPE_INFORMATION ObjectTypeInformation[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125; OBJECT_ALL_INFORMATION, *POBJECT_ALL_INFORMATION;</span><br><span class=\"line\"></span><br><span class=\"line\">pNtQueryObject((HANDLE)<span class=\"number\">0xFFFFFFFF</span>, ObjectAllTypesInformation, pBuf, lSize, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">POBJECT_ALL_INFORMATION pObjectAllInfo = (POBJECT_ALL_INFORMATION)pBuf;</span><br></pre></td></tr></table></figure>\n\n<p>调用NtQueryObjec函数后，系统所有对象的信息代码就被存入pBuf，然后将pBuf转换为OBJECT_ALL_INFORMATION类型。OBJECT_ALL_INFORMATION结构体由OBJECT_TYPE_INFORMATION结构体数组构成。实际内核对象类型的信息就被存储在OBJECT_TYPE_INFORMATION结构体数组中，通过循环检索即可查看是否存在”调试对象”对象类型。</p>\n<p>（4）确定”调试对象”对象类型</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;windows.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;tchar.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> _<span class=\"title\">OBJECT_INFORMATION_CLASS</span> &#123;</span></span><br><span class=\"line\">    ObjectBasicInformation,</span><br><span class=\"line\">    ObjectNameInformation,</span><br><span class=\"line\">    ObjectTypeInformation,</span><br><span class=\"line\">    ObjectAllTypesInformation,</span><br><span class=\"line\">    ObjectHandleInformation</span><br><span class=\"line\">&#125; OBJECT_INFORMATION_CLASS, *POBJECT_INFORMATION_CLASS;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">MyNtQueryObject</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">LSA_UNICODE_STRING</span> &#123;</span></span><br><span class=\"line\">        USHORT Length;</span><br><span class=\"line\">        USHORT MaximumLength;</span><br><span class=\"line\">        PWSTR Buffer;</span><br><span class=\"line\">    &#125; LSA_UNICODE_STRING, *PLSA_UNICODE_STRING, UNICODE_STRING, *PUNICODE_STRING;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"title function_\">NTSTATUS</span> <span class=\"params\">(WINAPI *NTQUERYOBJECT)</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        HANDLE Handle,</span></span><br><span class=\"line\"><span class=\"params\">        OBJECT_INFORMATION_CLASS ObjectInformationClass,</span></span><br><span class=\"line\"><span class=\"params\">        PVOID ObjectInformation,</span></span><br><span class=\"line\"><span class=\"params\">        ULONG ObjectInformationLength,</span></span><br><span class=\"line\"><span class=\"params\">        PULONG ReturnLength</span></span><br><span class=\"line\"><span class=\"params\">    )</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">pragma</span> pack(1)</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">OBJECT_TYPE_INFORMATION</span> &#123;</span></span><br><span class=\"line\">        UNICODE_STRING TypeName;</span><br><span class=\"line\">        ULONG TotalNumberOfHandles;</span><br><span class=\"line\">        ULONG TotalNumberOfObjects;</span><br><span class=\"line\">    &#125;OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">OBJECT_ALL_INFORMATION</span> &#123;</span></span><br><span class=\"line\">        ULONG                   NumberOfObjectsTypes;</span><br><span class=\"line\">        OBJECT_TYPE_INFORMATION ObjectTypeInformation[<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125; OBJECT_ALL_INFORMATION, *POBJECT_ALL_INFORMATION;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">pragma</span> pack()</span></span><br><span class=\"line\">       </span><br><span class=\"line\">    POBJECT_ALL_INFORMATION pObjectAllInfo = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"type\">void</span> *pBuf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    ULONG lSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    BOOL bDebugging = FALSE;</span><br><span class=\"line\"></span><br><span class=\"line\">    NTQUERYOBJECT pNtQueryObject = (NTQUERYOBJECT)</span><br><span class=\"line\">                                    GetProcAddress(GetModuleHandle(<span class=\"string\">L&quot;ntdll.dll&quot;</span>), </span><br><span class=\"line\">                                                   <span class=\"string\">&quot;NtQueryObject&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Get the size of the list</span></span><br><span class=\"line\">    pNtQueryObject(<span class=\"literal\">NULL</span>, ObjectAllTypesInformation, &amp;lSize, <span class=\"keyword\">sizeof</span>(lSize), &amp;lSize);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Allocate list buffer</span></span><br><span class=\"line\">    pBuf = VirtualAlloc(<span class=\"literal\">NULL</span>, lSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Get the actual list</span></span><br><span class=\"line\">    pNtQueryObject((HANDLE)<span class=\"number\">0xFFFFFFFF</span>, ObjectAllTypesInformation, pBuf, lSize, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    pObjectAllInfo = (POBJECT_ALL_INFORMATION)pBuf;</span><br><span class=\"line\"></span><br><span class=\"line\">    UCHAR *pObjInfoLocation = (UCHAR *)pObjectAllInfo-&gt;ObjectTypeInformation;</span><br><span class=\"line\">    POBJECT_TYPE_INFORMATION pObjectTypeInfo = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( UINT i = <span class=\"number\">0</span>; i &lt; pObjectAllInfo-&gt;NumberOfObjectsTypes; i++ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pObjectTypeInfo = (POBJECT_TYPE_INFORMATION)pObjInfoLocation;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( wcscmp(<span class=\"string\">L&quot;DebugObject&quot;</span>, pObjectTypeInfo-&gt;TypeName.Buffer) == <span class=\"number\">0</span> )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            bDebugging = (pObjectTypeInfo-&gt;TotalNumberOfObjects &gt; <span class=\"number\">0</span>) ? TRUE : FALSE;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// calculate next struct</span></span><br><span class=\"line\">        pObjInfoLocation = (UCHAR*)pObjectTypeInfo-&gt;TypeName.Buffer;</span><br><span class=\"line\">        pObjInfoLocation += pObjectTypeInfo-&gt;TypeName.Length;</span><br><span class=\"line\">        pObjInfoLocation = (UCHAR*)(((ULONG)pObjInfoLocation &amp; <span class=\"number\">0xFFFFFFFC</span>) + <span class=\"keyword\">sizeof</span>(ULONG));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>( pBuf )</span><br><span class=\"line\">    VirtualFree(pBuf, <span class=\"number\">0</span>, MEM_RELEASE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;NtQueryObject(ObjectAllTypesInformation)\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( bDebugging )  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;  =&gt; Debugging!!!\\n\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span>              <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;  =&gt; Not debugging...\\n\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> _tmain(<span class=\"type\">int</span> argc, TCHAR* argv[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    MyNtQueryObject();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\npress any key to quit...\\n&quot;</span>);</span><br><span class=\"line\">    _gettch();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>1.用x32dbg打开StaAD_NtQO.exe，显示”Debugging!!!”，这是因为NtQueryObject() API中探测到了调试对象。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%BA%8C%EF%BC%89/NtQueryObject/Win10_StaAD_NtQO_%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8C.png\" alt=\"Win10_StaAD_NtQO调试运行\"></p>\n<p>2.破解之法</p>\n<p>重新运行程序，在401059地址处设置断点（可以先在ntdll!NtQueryObject API处下断点，然后运行直到返回，查看调用处的第二个参数是否为3，是则在调用处下断点，该程序中位于401059地址处），然后运行程序。</p>\n<p>①401059地址处的CALL ESI指令用来调用ntdll!NtQueryObject() API，此时查看栈可发现，第二个参数的值为ObjectAllTypesInformation（3）</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%BA%8C%EF%BC%89/NtQueryObject/Win10_StaAD_NtQO_%E8%B0%83%E7%94%A8NtQueryObject.png\" alt=\"Win10_StaAD_NtQO调用NtQueryObject\"></p>\n<p>②将栈中第二个参数的值修改为0后再执行401059处的指令，这样就无法探测到调试器的存在了</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%BA%8C%EF%BC%89/NtQueryObject/Win10_StaAD_NtQO_%E4%BF%AE%E6%94%B9NtQueryObject%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E4%B8%BA0.png\" alt=\"Win10_StaAD_NtQO修改NtQueryObject第二个参数为0\"></p>\n<p>当然，直接钩取ntdll!NtQueryObject() API，输入ObjectAllTypesInformation（3）值或操作结果值，也能不被探测到。</p>\n<h1 id=\"ZwSetInformationThread\"><a href=\"#ZwSetInformationThread\" class=\"headerlink\" title=\"ZwSetInformationThread()\"></a>ZwSetInformationThread()</h1><p>下面介绍强制分离（Detach）被调试者和调试者的技术。</p>\n<h2 id=\"ZwSetInformationThread定义\"><a href=\"#ZwSetInformationThread定义\" class=\"headerlink\" title=\"ZwSetInformationThread定义\"></a>ZwSetInformationThread定义</h2><p>利用ZwSetInformationThread() API，被调试者可将自身从调试器中分离出来。其定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> _<span class=\"title\">THREAD_INFORMATION_CLASS</span> &#123;</span></span><br><span class=\"line\">        ThreadBasicInformation,</span><br><span class=\"line\">        ThreadTimes,</span><br><span class=\"line\">        ThreadPriority,</span><br><span class=\"line\">        ThreadBasePriority,</span><br><span class=\"line\">        ThreadAffinityMask,</span><br><span class=\"line\">        ThreadImpersonationToken,</span><br><span class=\"line\">        ThreadDescriptorTableEntry,</span><br><span class=\"line\">        ThreadEnableAlignmentFaultFixup,</span><br><span class=\"line\">        ThreadEventPair,</span><br><span class=\"line\">        ThreadQuerySetWin32StartAddress,</span><br><span class=\"line\">        ThreadZeroTlsCell,</span><br><span class=\"line\">        ThreadPerformanceCount,</span><br><span class=\"line\">        ThreadAmILastThread,</span><br><span class=\"line\">        ThreadIdealProcessor,</span><br><span class=\"line\">        ThreadPriorityBoost,</span><br><span class=\"line\">        ThreadSetTlsArrayAddress,</span><br><span class=\"line\">        ThreadIsIoPending,</span><br><span class=\"line\">        ThreadHideFromDebugger           <span class=\"comment\">// 17 (0x11)</span></span><br><span class=\"line\">&#125; THREAD_INFORMATION_CLASS, *PTHREAD_INFORMATION_CLASS;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"title function_\">NTSTATUS</span> <span class=\"params\">(WINAPI* ZWSETINFORMATIONTHREAD)</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        __in HANDLE ThreadHandle,</span></span><br><span class=\"line\"><span class=\"params\">        __in THREAD_INFORMATION_CLASS ThreadInformationClass,</span></span><br><span class=\"line\"><span class=\"params\">        __in PVOID ThreadInformation,</span></span><br><span class=\"line\"><span class=\"params\">        __in ULONG ThreadInformationLength</span></span><br><span class=\"line\"><span class=\"params\">)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>ZwSetInformationThread()函数是一个系统原生API，它是用来为线程设置信息的。该函数拥有2个参数，第一个参数ThreadHandle用来接收当前线程的句柄，第二个参数ThreadInformationClass表示线程信息类型，若其值设置为ThreadHideFromDebugger(0x11)，调用该函数后，调试进程就会被分离出来。ZwSetInformationThread() API不会对正常运行的程序（非调试运行）产生任何影响，但若运行的是调试器程序，调用该API将使调试器终止运行，同时终止自身进程。</p>\n<h2 id=\"练习-1\"><a href=\"#练习-1\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p>1.用x32dbg打开StaAD_ZwSIT.exe，分别在401027、401029处设置断点，然后运行到401027处</p>\n<p>调试器在401027处暂停，位于该地址处的CALL ESI指令用来调用ntdll!ZwSetInformationThread() API。运行401027处的指令，这样就会分离出被调试进程并终止运行。而且调试器无法正常调试401029地址处的指令，出现运行错误</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%BA%8C%EF%BC%89/ZwSetInformationThread/Win10_StaAD_ZwSIT_%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8C.png\" alt=\"Win10_StaAD_ZwSIT_调试运行\"></p>\n<p>2.破解之法</p>\n<p>①调用401027地址处的ZwSetInformationThread() API前，查找存储在栈中的第二个参数ThreadInformationClass值，若其值为ThreadHideFromDebugger(0x11)，则修改为0后继续运行即可。</p>\n<p>②也可以钩取ZwSetInformationThread() API，并以同样方式操作函数的参数。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>利用ZwSetInformationThread()进行反调试的工作原理是：将线程隐藏起来，调试器就接收不到信息，从而无法调试。另外，Windows XP以后新增了DebugActiveProcessStop() API.</p></blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BOOL WINAPI <span class=\"title function_\">DebugActiveProcessStop</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">\t__in DWORD dwProcessId</span></span><br><span class=\"line\"><span class=\"params\">)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>DebugActiveProcessStop() API用来分离调试器与被调试进程，从而停止调试。前面介绍的ZwSetInformationThread() API则用来隐藏当前线程，使调试器无法再收到该线程的调试事件，最终停止调试。</p>\n","text":"NtQueryInformationProcess()NtQueryInformationProcess定义通过NtQueryInformationProces...","permalink":"/post/Windows静态反调试技术（二）","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":14,"path":"api/tags/逆向.json"},{"name":"Windows静态反调试技术","slug":"Windows静态反调试技术","count":3,"path":"api/tags/Windows静态反调试技术.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#NtQueryInformationProcess\"><span class=\"toc-text\">NtQueryInformationProcess()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NtQueryInformationProcess%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">NtQueryInformationProcess定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8E%E5%8F%8D%E8%B0%83%E8%AF%95%E7%9B%B8%E5%85%B3%E7%9A%84%E6%88%90%E5%91%98\"><span class=\"toc-text\">与反调试相关的成员</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ProcessDebugPort%EF%BC%880x7%EF%BC%89\"><span class=\"toc-text\">ProcessDebugPort（0x7）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CheckRemoteDebuggerPresent\"><span class=\"toc-text\">CheckRemoteDebuggerPresent()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ProcessDebugObjectHandle%EF%BC%880x1E%EF%BC%89\"><span class=\"toc-text\">ProcessDebugObjectHandle（0x1E）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ProcessDebugFlags%EF%BC%880x1F%EF%BC%89\"><span class=\"toc-text\">ProcessDebugFlags（0x1F）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#NtQuerySystemInformation\"><span class=\"toc-text\">NtQuerySystemInformation()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NtQuerySystemInformation%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">NtQuerySystemInformation定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SystemKernelDebuggerInformation%EF%BC%880x23%EF%BC%89\"><span class=\"toc-text\">SystemKernelDebuggerInformation（0x23）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A0%B4%E8%A7%A3%E4%B9%8B%E6%B3%95\"><span class=\"toc-text\">破解之法</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#NtQueryObject\"><span class=\"toc-text\">NtQueryObject()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NtQueryObject%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">NtQueryObject定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NtQueryObject-API%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">NtQueryObject() API使用方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">练习</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ZwSetInformationThread\"><span class=\"toc-text\">ZwSetInformationThread()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ZwSetInformationThread%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">ZwSetInformationThread定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%83%E4%B9%A0-1\"><span class=\"toc-text\">练习</span></a></li></ol></li></ol>","author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Windows静态反调试技术（三）","uid":"0f5e7a00cb9e0d76fb61aefba4cb6bf5","slug":"Windows静态反调试技术（三）","date":"2022-06-25T13:18:17.000Z","updated":"2025-06-09T21:41:41.029Z","comments":true,"path":"api/articles/Windows静态反调试技术（三）.json","keywords":null,"cover":null,"text":"TLS回调函数由于TLS回调函数会先于EP代码执行，可以在回调函数内部使用IsDebuggerPresent()等函数判断调试与否，再决定是否继续运行程序。 E...","permalink":"/post/Windows静态反调试技术（三）","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":14,"path":"api/tags/逆向.json"},{"name":"Windows静态反调试技术","slug":"Windows静态反调试技术","count":3,"path":"api/tags/Windows静态反调试技术.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Windows静态反调试技术（一）","uid":"cfe529b139f3ec3d5a0094d71b2823b9","slug":"Windows静态反调试技术（一）","date":"2022-06-20T13:12:54.000Z","updated":"2025-06-09T21:41:11.315Z","comments":true,"path":"api/articles/Windows静态反调试技术（一）.json","keywords":null,"cover":[],"text":"PEB利用PEB结构体信息可以判断当前进程是否处于被调试状态。回顾下PEB结构体的成员： Win7 x86中： 123456789101112131415161...","permalink":"/post/Windows静态反调试技术（一）","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":14,"path":"api/tags/逆向.json"},{"name":"Windows静态反调试技术","slug":"Windows静态反调试技术","count":3,"path":"api/tags/Windows静态反调试技术.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}