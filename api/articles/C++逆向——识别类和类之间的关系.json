{"title":"C++逆向——识别类和类之间的关系","uid":"d75c57bec22710c7148f63c849522585","slug":"C++逆向——识别类和类之间的关系","date":"2023-02-15T12:11:27.000Z","updated":"2025-06-07T18:22:43.367Z","comments":true,"path":"api/articles/C++逆向——识别类和类之间的关系.json","keywords":null,"cover":[],"content":"<p>在C++的继承关系中，子类具备父类所有成员数据和成员函数。子 类 对 象 可 以 直 接 使 用 父 类 中 声 明 为 公 有 （ public ） 和 保 护（protected）的数据成员与成员函数。对于在父类中声明为私有（private）的成员，虽然子类对象无法直接访问，但是在子类对象的内存结构中，父类私有的成员数据依然存在。C++语法规定的访问控制仅限于编译层面，在编译的过程中由编译器进行语法检查，因此访问控制不会影响对象的内存结构。</p>\n<h1 id=\"定义基类和派生类\"><a href=\"#定义基类和派生类\" class=\"headerlink\" title=\"定义基类和派生类\"></a>定义基类和派生类</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#pragma warning(disable : 4996)</span><br><span class=\"line\"></span><br><span class=\"line\">class Base &#123; //基类定义</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tBase() &#123;</span><br><span class=\"line\">\t\tprintf(&quot;Base\\n&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~Base() &#123;</span><br><span class=\"line\">\t\tprintf(&quot;~Base\\n&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid setNumber(int n) &#123;</span><br><span class=\"line\">\t\tbase = n;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint getNumber() &#123;</span><br><span class=\"line\">\t\treturn base;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint base;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Derive : public Base &#123; //派生类定义</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid showNumber(int n) &#123;</span><br><span class=\"line\">\t\tsetNumber(n);</span><br><span class=\"line\">\t\tderive = n + 1;</span><br><span class=\"line\">\t\tprintf(&quot;%d\\n&quot;, getNumber());</span><br><span class=\"line\">\t\tprintf(&quot;%d\\n&quot;, derive);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint derive;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main(int argc, char* argv[]) &#123;</span><br><span class=\"line\">\tDerive derive;</span><br><span class=\"line\">\tderive.showNumber(argc);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中定义了两个具有继承关系的类。父类Base中定义了数据成员base、构造函数、析构函数和两个成员函数。子类中只有一个成员函数showNumber和一个数据成员derive。根据C++的语法规则，子类Derive将继承父类中的成员数据和成员函数。那么，当申请子类对象Derive时，它在内存中如何存储，又如何使用父类成员函数呢？</p>\n<p>分析其汇编查看其内存结构及程序执行流程，汇编如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//main函数</span><br><span class=\"line\">.text:00401140 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:00401140 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:00401140</span><br><span class=\"line\">.text:00401140 var_1C          = dword ptr -1Ch</span><br><span class=\"line\">.text:00401140 var_18          = byte ptr -18h</span><br><span class=\"line\">.text:00401140 var_10          = dword ptr -10h</span><br><span class=\"line\">.text:00401140 var_C           = dword ptr -0Ch</span><br><span class=\"line\">.text:00401140 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401140 argc            = dword ptr  8</span><br><span class=\"line\">.text:00401140 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:00401140 envp            = dword ptr  10h</span><br><span class=\"line\">.text:00401140</span><br><span class=\"line\">.text:00401140 ; FUNCTION CHUNK AT .text:00401E80 SIZE 00000008 BYTES</span><br><span class=\"line\">.text:00401140 ; FUNCTION CHUNK AT .text:00401E8D SIZE 00000027 BYTES</span><br><span class=\"line\">.text:00401140</span><br><span class=\"line\">.text:00401140 ; __unwind &#123; // _main_SEH</span><br><span class=\"line\">.text:00401140                 push    ebp</span><br><span class=\"line\">.text:00401141                 mov     ebp, esp</span><br><span class=\"line\">.text:00401143                 push    0FFFFFFFFh</span><br><span class=\"line\">.text:00401145                 push    offset _main_SEH</span><br><span class=\"line\">.text:0040114A                 mov     eax, large fs:0</span><br><span class=\"line\">.text:00401150                 push    eax</span><br><span class=\"line\">.text:00401151                 sub     esp, 10h</span><br><span class=\"line\">.text:00401154                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:00401159                 xor     eax, ebp</span><br><span class=\"line\">.text:0040115B                 mov     [ebp-10h], eax</span><br><span class=\"line\">.text:0040115E                 push    eax</span><br><span class=\"line\">.text:0040115F                 lea     eax, [ebp-0Ch]</span><br><span class=\"line\">.text:00401162                 mov     large fs:0, eax</span><br><span class=\"line\">.text:00401168                 lea     ecx, [ebp-18h]  ; 获取对象首地址作为this指针</span><br><span class=\"line\">.text:0040116B                 call    sub_4011C0      ; 调用类Derive的构造函数，编译器为Derive提供了默认的构造函数</span><br><span class=\"line\">.text:00401170 ;   try &#123;</span><br><span class=\"line\">.text:00401170                 mov     dword ptr [ebp-4], 0</span><br><span class=\"line\">.text:00401177                 mov     eax, [ebp+8]</span><br><span class=\"line\">.text:0040117A                 push    eax             ; 参数2：argc</span><br><span class=\"line\">.text:0040117B                 lea     ecx, [ebp-18h]  ; 参数1：传入this指针</span><br><span class=\"line\">.text:0040117E                 call    sub_4010F0      ; 调用成员函数showNumber</span><br><span class=\"line\">.text:00401183                 mov     dword ptr [ebp-1Ch], 0</span><br><span class=\"line\">.text:00401183 ;   &#125; // starts at 401170</span><br><span class=\"line\">.text:0040118A                 mov     dword ptr [ebp-4], 0FFFFFFFFh</span><br><span class=\"line\">.text:00401191                 lea     ecx, [ebp-18h]  ; 传入this指针</span><br><span class=\"line\">.text:00401194                 call    sub_4011E0      ; 调用类Derive的析构函数，编译器为Derive提供了默认的析构函数</span><br><span class=\"line\">.text:00401199                 mov     eax, [ebp-1Ch]</span><br><span class=\"line\">.text:0040119C                 mov     ecx, [ebp-0Ch]</span><br><span class=\"line\">.text:0040119F                 mov     large fs:0, ecx</span><br><span class=\"line\">.text:004011A6                 pop     ecx</span><br><span class=\"line\">.text:004011A7                 mov     ecx, [ebp-10h]</span><br><span class=\"line\">.text:004011AA                 xor     ecx, ebp        ; StackCookie</span><br><span class=\"line\">.text:004011AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class=\"line\">.text:004011B1                 mov     esp, ebp</span><br><span class=\"line\">.text:004011B3                 pop     ebp</span><br><span class=\"line\">.text:004011B4                 retn</span><br><span class=\"line\">.text:004011B4 ; &#125; // starts at 401140</span><br><span class=\"line\">.text:004011B4 _main           endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char v4[8]; // [esp+8h] [ebp-18h] BYREF</span><br><span class=\"line\">  int v5; // [esp+1Ch] [ebp-4h]</span><br><span class=\"line\"></span><br><span class=\"line\">  sub_4011C0(v4);</span><br><span class=\"line\">  v5 = 0;</span><br><span class=\"line\">  sub_4010F0(argc);</span><br><span class=\"line\">  v5 = -1;</span><br><span class=\"line\">  sub_4011E0(v4);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//子类Derive的默认构造函数分析</span><br><span class=\"line\">.text:004011C0 ; void *__thiscall sub_4011C0(void *this)</span><br><span class=\"line\">.text:004011C0 sub_4011C0      proc near               ; CODE XREF: _main+2B↑p</span><br><span class=\"line\">.text:004011C0</span><br><span class=\"line\">.text:004011C0 var_4           = byte ptr -4</span><br><span class=\"line\">.text:004011C0</span><br><span class=\"line\">.text:004011C0                 push    ebp             ; 子类Derive的默认构造函数分析</span><br><span class=\"line\">.text:004011C1                 mov     ebp, esp</span><br><span class=\"line\">.text:004011C3                 push    ecx</span><br><span class=\"line\">.text:004011C4                 mov     [ebp-4], ecx</span><br><span class=\"line\">.text:004011C7                 mov     ecx, [ebp-4]    ; 以子类对象首地址作为父类的this指针</span><br><span class=\"line\">.text:004011CA                 call    sub_401080      ; 调用父类构造函数</span><br><span class=\"line\">.text:004011CF                 mov     eax, [ebp-4]</span><br><span class=\"line\">.text:004011D2                 mov     esp, ebp</span><br><span class=\"line\">.text:004011D4                 pop     ebp</span><br><span class=\"line\">.text:004011D5                 retn</span><br><span class=\"line\">.text:004011D5 sub_4011C0      endp</span><br><span class=\"line\"></span><br><span class=\"line\">void *__thiscall sub_4011C0(void *this)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  sub_401080((char)this);</span><br><span class=\"line\">  return this;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//父类构造函数</span><br><span class=\"line\">.text:00401080 ; int __fastcall sub_401080(char)</span><br><span class=\"line\">.text:00401080 sub_401080      proc near               ; CODE XREF: sub_4011C0+A↓p</span><br><span class=\"line\">.text:00401080</span><br><span class=\"line\">.text:00401080 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401080</span><br><span class=\"line\">.text:00401080                 push    ebp             ; 父类构造函数</span><br><span class=\"line\">.text:00401081                 mov     ebp, esp</span><br><span class=\"line\">.text:00401083                 push    ecx             ; char</span><br><span class=\"line\">.text:00401084                 mov     [ebp+var_4], ecx</span><br><span class=\"line\">.text:00401087                 push    offset Format   ; &quot;Base\\n&quot;</span><br><span class=\"line\">.text:0040108C                 call    printf</span><br><span class=\"line\">.text:00401091                 add     esp, 4</span><br><span class=\"line\">.text:00401094                 mov     eax, [ebp+var_4]</span><br><span class=\"line\">.text:00401097                 mov     esp, ebp</span><br><span class=\"line\">.text:00401099                 pop     ebp</span><br><span class=\"line\">.text:0040109A                 retn</span><br><span class=\"line\">.text:0040109A sub_401080      endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __fastcall sub_401080(char a1)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  int v2; // [esp+0h] [ebp-4h]</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;Base\\n&quot;, a1);</span><br><span class=\"line\">  return v2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//子类Derive的默认析构函数分析</span><br><span class=\"line\">.text:004011E0 ; int __fastcall sub_4011E0(char)</span><br><span class=\"line\">.text:004011E0 sub_4011E0      proc near               ; CODE XREF: _main+54↑p</span><br><span class=\"line\">.text:004011E0                                         ; _main+D43↓j</span><br><span class=\"line\">.text:004011E0</span><br><span class=\"line\">.text:004011E0 var_4           = byte ptr -4</span><br><span class=\"line\">.text:004011E0</span><br><span class=\"line\">.text:004011E0                 push    ebp             ; 子类Derive的默认析构函数分析</span><br><span class=\"line\">.text:004011E1                 mov     ebp, esp</span><br><span class=\"line\">.text:004011E3                 push    ecx</span><br><span class=\"line\">.text:004011E4                 mov     [ebp-4], ecx</span><br><span class=\"line\">.text:004011E7                 mov     ecx, [ebp-4]    ; 以子类对象首地址作为父类的this指针</span><br><span class=\"line\">.text:004011EA                 call    sub_4010A0      ; 调用父类析构函数</span><br><span class=\"line\">.text:004011EF                 mov     esp, ebp</span><br><span class=\"line\">.text:004011F1                 pop     ebp</span><br><span class=\"line\">.text:004011F2                 retn</span><br><span class=\"line\">.text:004011F2 sub_4011E0      endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __fastcall sub_4011E0(char a1)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return sub_4010A0(a1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//父类析构函数</span><br><span class=\"line\">.text:004010A0 ; int sub_4010A0()</span><br><span class=\"line\">.text:004010A0 sub_4010A0      proc near               ; CODE XREF: sub_4011E0+A↓p</span><br><span class=\"line\">.text:004010A0</span><br><span class=\"line\">.text:004010A0 var_4           = dword ptr -4</span><br><span class=\"line\">.text:004010A0</span><br><span class=\"line\">.text:004010A0                 push    ebp             ; 父类析构函数</span><br><span class=\"line\">.text:004010A1                 mov     ebp, esp</span><br><span class=\"line\">.text:004010A3                 push    ecx             ; char</span><br><span class=\"line\">.text:004010A4                 mov     [ebp+var_4], ecx</span><br><span class=\"line\">.text:004010A7                 push    offset aBase_0  ; &quot;~Base\\n&quot;</span><br><span class=\"line\">.text:004010AC                 call    printf</span><br><span class=\"line\">.text:004010B1                 add     esp, 4</span><br><span class=\"line\">.text:004010B4                 mov     esp, ebp</span><br><span class=\"line\">.text:004010B6                 pop     ebp</span><br><span class=\"line\">.text:004010B7                 retn</span><br><span class=\"line\">.text:004010B7 sub_4010A0      endp</span><br><span class=\"line\"></span><br><span class=\"line\">int sub_4010A0()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return printf(&quot;~Base\\n&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对上面代码进行分析后发现，编译器提供了默认构造函数与析构函数。当子类中没有构造函数或析构函数，父类却需要构造函数和析构函数时，编译器会为子类提供默认的构造函数与析构函数。</p>\n<p>由于子类继承了父类，因此子类中需要拥有父类的各成员，类似在子类中定义了父类的对象作为数据成员使用。</p>\n<p>上面代码中的类关系如果转换成以下代码，它们的内存结构是等价的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base&#123;...&#125;; //类定义见代码清单12-1</span><br><span class=\"line\"></span><br><span class=\"line\">class Derive &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\"></span><br><span class=\"line\">Base base; //原来的父类Base 成为成员对象int derive; // 原来的子类派生数据</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>原来的父类Base成为Derive的一个成员对象，当产生Derive类的对象时，会先产生成员对象base，这需要调用其构造函数。当Derive类没有构造函数时，为了能够在Derive类对象产生时调用成员对象的构造函数，编译器同样会提供默认的构造函数，以实现成员构造函数的调用。</p>\n<p>但是，如果子类含有构造函数，而父类不存在构造函数，则编译器不会为父类提供默认的构造函数。在构造子类时，因为父类中没有虚表指针，也不存在构造祖先类的问题，所以添加默认构造函数对父类没有任何意义。父类中含有虚函数的情况则不同，此时父类需要初始化虚表工作，因此编译器会为其提供默认的构造函数，以初始化虚表指针。</p>\n<p>当子类对象被销毁时，其父类也同时被销毁，为了可以调用父类的析构函数，编译器为子类提供了默认的析构函数。在子类的析构函数中，析构函数的调用顺序与构造函数相反，先执行自身的析构代码，再执行父类的析构代码。</p>\n<p>依照构造函数与析构函数的调用顺序，不仅可以顺藤摸瓜找出各类之间的关系，还可以区别出构造函数与析构函数。</p>\n<h1 id=\"类的构造顺序\"><a href=\"#类的构造顺序\" class=\"headerlink\" title=\"类的构造顺序\"></a>类的构造顺序</h1><p>子类对象在内存中的数据排列：先安排父类的数据，后安排子类新定义的数据。当类中定义了其他对象作为成员，并在初始化列表中指定了某个成员的初始化值时，构造的顺序会是怎样的呢？我们先来看下面的代码。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123; <span class=\"comment\">//基类定义</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Base</span>() &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Base\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~<span class=\"built_in\">Base</span>() &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;~Base\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setNumber</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t\tbase = n;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getNumber</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> base;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> base;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Member</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Member</span>() &#123;</span><br><span class=\"line\">\t\tmember = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> member;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derive</span> : <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Derive</span>() :<span class=\"built_in\">derive</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;使用初始化列表\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tMember member; <span class=\"comment\">//类中定义其他对象作为成员</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> derive;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\tDerive derive;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ida汇编及伪代码视图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//main函数</span><br><span class=\"line\">.text:00401150 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:00401150 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:00401150</span><br><span class=\"line\">.text:00401150 var_14          = dword ptr -14h</span><br><span class=\"line\">.text:00401150 var_10          = byte ptr -10h</span><br><span class=\"line\">.text:00401150 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401150 argc            = dword ptr  8</span><br><span class=\"line\">.text:00401150 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:00401150 envp            = dword ptr  10h</span><br><span class=\"line\">.text:00401150</span><br><span class=\"line\">.text:00401150                 push    ebp</span><br><span class=\"line\">.text:00401151                 mov     ebp, esp</span><br><span class=\"line\">.text:00401153                 sub     esp, 14h</span><br><span class=\"line\">.text:00401156                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:0040115B                 xor     eax, ebp</span><br><span class=\"line\">.text:0040115D                 mov     [ebp-4], eax</span><br><span class=\"line\">.text:00401160                 lea     ecx, [ebp-10h]  ; 传递this指针</span><br><span class=\"line\">.text:00401163                 call    sub_4010E0      ; 调用Derive的构造函数</span><br><span class=\"line\">.text:00401168                 mov     dword ptr [ebp-14h], 0</span><br><span class=\"line\">.text:0040116F                 lea     ecx, [ebp-10h]  ; 传递this指针</span><br><span class=\"line\">.text:00401172                 call    sub_401190      ; 调用Derive的析构函数</span><br><span class=\"line\">.text:00401177                 mov     eax, [ebp-14h]</span><br><span class=\"line\">.text:0040117A                 mov     ecx, [ebp-4]</span><br><span class=\"line\">.text:0040117D                 xor     ecx, ebp        ; StackCookie</span><br><span class=\"line\">.text:0040117F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class=\"line\">.text:00401184                 mov     esp, ebp</span><br><span class=\"line\">.text:00401186                 pop     ebp</span><br><span class=\"line\">.text:00401187                 retn</span><br><span class=\"line\">.text:00401187 _main           endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char v4[12]; // [esp+4h] [ebp-10h] BYREF</span><br><span class=\"line\"></span><br><span class=\"line\">  sub_4010E0();</span><br><span class=\"line\">  sub_401190(v4);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//Derive的构造函数</span><br><span class=\"line\">.text:004010E0 ; _DWORD *__thiscall sub_4010E0(_DWORD *this)</span><br><span class=\"line\">.text:004010E0 sub_4010E0      proc near               ; CODE XREF: _main+13↓p</span><br><span class=\"line\">.text:004010E0</span><br><span class=\"line\">.text:004010E0 var_10          = byte ptr -10h</span><br><span class=\"line\">.text:004010E0 var_C           = dword ptr -0Ch</span><br><span class=\"line\">.text:004010E0 var_4           = dword ptr -4</span><br><span class=\"line\">.text:004010E0 arg_4           = dword ptr  0Ch</span><br><span class=\"line\">.text:004010E0</span><br><span class=\"line\">.text:004010E0 ; FUNCTION CHUNK AT .text:00401E30 SIZE 00000008 BYTES</span><br><span class=\"line\">.text:004010E0 ; FUNCTION CHUNK AT .text:00401E3D SIZE 0000001D BYTES</span><br><span class=\"line\">.text:004010E0</span><br><span class=\"line\">.text:004010E0 ; __unwind &#123; // SEH_4010E0</span><br><span class=\"line\">.text:004010E0                 push    ebp             ; Derive构造函数</span><br><span class=\"line\">.text:004010E1                 mov     ebp, esp</span><br><span class=\"line\">.text:004010E3                 push    0FFFFFFFFh</span><br><span class=\"line\">.text:004010E5                 push    offset SEH_4010E0</span><br><span class=\"line\">.text:004010EA                 mov     eax, large fs:0</span><br><span class=\"line\">.text:004010F0                 push    eax</span><br><span class=\"line\">.text:004010F1                 push    ecx</span><br><span class=\"line\">.text:004010F2                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:004010F7                 xor     eax, ebp</span><br><span class=\"line\">.text:004010F9                 push    eax             ; char</span><br><span class=\"line\">.text:004010FA                 lea     eax, [ebp-0Ch]</span><br><span class=\"line\">.text:004010FD                 mov     large fs:0, eax</span><br><span class=\"line\">.text:00401103                 mov     [ebp-10h], ecx  ; [ebp-10h]保存了this指针</span><br><span class=\"line\">.text:00401106                 mov     ecx, [ebp-10h]  ; 传递this指针</span><br><span class=\"line\">.text:00401109                 call    sub_401080      ; 调用父类构造函数</span><br><span class=\"line\">.text:0040110E ;   try &#123;</span><br><span class=\"line\">.text:0040110E                 mov     dword ptr [ebp-4], 0</span><br><span class=\"line\">.text:00401115                 mov     ecx, [ebp-10h]</span><br><span class=\"line\">.text:00401118                 add     ecx, 4          ; 根据this指针调整到类中定义的对象member的首地址处</span><br><span class=\"line\">.text:0040111B                 call    unknown_libname_1 ; 调用Member构造函数</span><br><span class=\"line\">.text:00401120                 mov     eax, [ebp-10h]</span><br><span class=\"line\">.text:00401123                 mov     dword ptr [eax+8], 1 ; 执行初始化列表，this指针传递给eax后，[eax+8]是对成员数据derive进行寻址</span><br><span class=\"line\">.text:0040112A                 push    offset asc_402110 ; &quot;使用初始化列表\\n&quot;</span><br><span class=\"line\">.text:0040112A                                         ; 最后才是执行Derive的构造代码</span><br><span class=\"line\">.text:0040112F                 call    printf</span><br><span class=\"line\">.text:00401134                 add     esp, 4</span><br><span class=\"line\">.text:00401134 ;   &#125; // starts at 40110E</span><br><span class=\"line\">.text:00401137                 mov     dword ptr [ebp-4], 0FFFFFFFFh</span><br><span class=\"line\">.text:0040113E                 mov     eax, [ebp-10h]</span><br><span class=\"line\">.text:00401141                 mov     ecx, [ebp-0Ch]</span><br><span class=\"line\">.text:00401144                 mov     large fs:0, ecx</span><br><span class=\"line\">.text:0040114B                 pop     ecx</span><br><span class=\"line\">.text:0040114C                 mov     esp, ebp</span><br><span class=\"line\">.text:0040114E                 pop     ebp</span><br><span class=\"line\">.text:0040114F                 retn</span><br><span class=\"line\">.text:0040114F ; &#125; // starts at 4010E0</span><br><span class=\"line\">.text:0040114F sub_4010E0      endp</span><br><span class=\"line\"></span><br><span class=\"line\">_DWORD *__thiscall sub_4010E0(_DWORD *this)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char v2; // [esp+0h] [ebp-14h]</span><br><span class=\"line\"></span><br><span class=\"line\">  sub_401080((char)this);</span><br><span class=\"line\">  unknown_libname_1(this + 1);</span><br><span class=\"line\">  this[2] = 1;</span><br><span class=\"line\">  printf(&quot;使用初始化列表\\n&quot;, v2);</span><br><span class=\"line\">  return this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>根据以上分析，在有初始化列表的情况下，会优先执行初始化列表中的操作，其次才是自身的构造函数。构造的顺序：先构造父类，然后按声明顺序构造成员对象和初始化列表中指定的成员，最后才是自身的构造代码。读者可自行修改类中各个成员的定义顺序，初始化列表的内容，然后按以上方法分析并验证构造的顺序。</p>\n<h1 id=\"子类的内存布局\"><a href=\"#子类的内存布局\" class=\"headerlink\" title=\"子类的内存布局\"></a>子类的内存布局</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#pragma warning(disable : 4996)</span><br><span class=\"line\"></span><br><span class=\"line\">class Base &#123; //基类定义</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tBase() &#123;</span><br><span class=\"line\">\t\tprintf(&quot;Base\\n&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~Base() &#123;</span><br><span class=\"line\">\t\tprintf(&quot;~Base\\n&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid setNumber(int n) &#123;</span><br><span class=\"line\">\t\tbase = n;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint getNumber() &#123;</span><br><span class=\"line\">\t\treturn base;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint base;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Derive : public Base &#123; //派生类定义</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid showNumber(int n) &#123;</span><br><span class=\"line\">\t\tsetNumber(n);</span><br><span class=\"line\">\t\tderive = n + 1;</span><br><span class=\"line\">\t\tprintf(&quot;%d\\n&quot;, getNumber());</span><br><span class=\"line\">\t\tprintf(&quot;%d\\n&quot;, derive);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint derive;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main(int argc, char* argv[]) &#123;</span><br><span class=\"line\">\tDerive derive;</span><br><span class=\"line\">\tderive.showNumber(argc);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//main函数</span><br><span class=\"line\">.text:00401140 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:00401140 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:00401140</span><br><span class=\"line\">.text:00401140 var_1C          = dword ptr -1Ch</span><br><span class=\"line\">.text:00401140 var_18          = byte ptr -18h</span><br><span class=\"line\">.text:00401140 var_10          = dword ptr -10h</span><br><span class=\"line\">.text:00401140 var_C           = dword ptr -0Ch</span><br><span class=\"line\">.text:00401140 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401140 argc            = dword ptr  8</span><br><span class=\"line\">.text:00401140 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:00401140 envp            = dword ptr  10h</span><br><span class=\"line\">.text:00401140</span><br><span class=\"line\">.text:00401140 ; FUNCTION CHUNK AT .text:00401E80 SIZE 00000008 BYTES</span><br><span class=\"line\">.text:00401140 ; FUNCTION CHUNK AT .text:00401E8D SIZE 00000027 BYTES</span><br><span class=\"line\">.text:00401140</span><br><span class=\"line\">.text:00401140 ; __unwind &#123; // _main_SEH</span><br><span class=\"line\">.text:00401140                 push    ebp</span><br><span class=\"line\">.text:00401141                 mov     ebp, esp</span><br><span class=\"line\">.text:00401143                 push    0FFFFFFFFh</span><br><span class=\"line\">.text:00401145                 push    offset _main_SEH</span><br><span class=\"line\">.text:0040114A                 mov     eax, large fs:0</span><br><span class=\"line\">.text:00401150                 push    eax</span><br><span class=\"line\">.text:00401151                 sub     esp, 10h</span><br><span class=\"line\">.text:00401154                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:00401159                 xor     eax, ebp</span><br><span class=\"line\">.text:0040115B                 mov     [ebp-10h], eax</span><br><span class=\"line\">.text:0040115E                 push    eax</span><br><span class=\"line\">.text:0040115F                 lea     eax, [ebp-0Ch]</span><br><span class=\"line\">.text:00401162                 mov     large fs:0, eax</span><br><span class=\"line\">.text:00401168                 lea     ecx, [ebp-18h]  ; 获取对象首地址作为this指针</span><br><span class=\"line\">.text:0040116B                 call    sub_4011C0      ; 调用类Derive的构造函数，编译器为Derive提供了默认的构造函数</span><br><span class=\"line\">.text:00401170 ;   try &#123;</span><br><span class=\"line\">.text:00401170                 mov     dword ptr [ebp-4], 0</span><br><span class=\"line\">.text:00401177                 mov     eax, [ebp+8]</span><br><span class=\"line\">.text:0040117A                 push    eax             ; 参数2：argc</span><br><span class=\"line\">.text:0040117B                 lea     ecx, [ebp-18h]  ; 参数1：传入this指针</span><br><span class=\"line\">.text:0040117E                 call    sub_4010F0      ; 调用成员函数showNumber</span><br><span class=\"line\">.text:00401183                 mov     dword ptr [ebp-1Ch], 0</span><br><span class=\"line\">.text:00401183 ;   &#125; // starts at 401170</span><br><span class=\"line\">.text:0040118A                 mov     dword ptr [ebp-4], 0FFFFFFFFh</span><br><span class=\"line\">.text:00401191                 lea     ecx, [ebp-18h]  ; 传入this指针</span><br><span class=\"line\">.text:00401194                 call    sub_4011E0      ; 调用类Derive的析构函数，编译器为Derive提供了默认的析构函数</span><br><span class=\"line\">.text:00401199                 mov     eax, [ebp-1Ch]</span><br><span class=\"line\">.text:0040119C                 mov     ecx, [ebp-0Ch]</span><br><span class=\"line\">.text:0040119F                 mov     large fs:0, ecx</span><br><span class=\"line\">.text:004011A6                 pop     ecx</span><br><span class=\"line\">.text:004011A7                 mov     ecx, [ebp-10h]</span><br><span class=\"line\">.text:004011AA                 xor     ecx, ebp        ; StackCookie</span><br><span class=\"line\">.text:004011AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class=\"line\">.text:004011B1                 mov     esp, ebp</span><br><span class=\"line\">.text:004011B3                 pop     ebp</span><br><span class=\"line\">.text:004011B4                 retn</span><br><span class=\"line\">.text:004011B4 ; &#125; // starts at 401140</span><br><span class=\"line\">.text:004011B4 _main           endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char v4[8]; // [esp+8h] [ebp-18h] BYREF</span><br><span class=\"line\">  int v5; // [esp+1Ch] [ebp-4h]</span><br><span class=\"line\"></span><br><span class=\"line\">  sub_4011C0(v4);</span><br><span class=\"line\">  v5 = 0;</span><br><span class=\"line\">  sub_4010F0(argc);</span><br><span class=\"line\">  v5 = -1;</span><br><span class=\"line\">  sub_4011E0(v4);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//子类Derive的默认构造函数分析</span><br><span class=\"line\">.text:004011C0 ; void *__thiscall sub_4011C0(void *this)</span><br><span class=\"line\">.text:004011C0 sub_4011C0      proc near               ; CODE XREF: _main+2B↑p</span><br><span class=\"line\">.text:004011C0</span><br><span class=\"line\">.text:004011C0 var_4           = byte ptr -4</span><br><span class=\"line\">.text:004011C0</span><br><span class=\"line\">.text:004011C0                 push    ebp             ; 子类Derive的默认构造函数分析</span><br><span class=\"line\">.text:004011C1                 mov     ebp, esp</span><br><span class=\"line\">.text:004011C3                 push    ecx</span><br><span class=\"line\">.text:004011C4                 mov     [ebp-4], ecx</span><br><span class=\"line\">.text:004011C7                 mov     ecx, [ebp-4]    ; 以子类对象首地址作为父类的this指针</span><br><span class=\"line\">.text:004011CA                 call    sub_401080      ; 调用父类构造函数</span><br><span class=\"line\">.text:004011CF                 mov     eax, [ebp-4]</span><br><span class=\"line\">.text:004011D2                 mov     esp, ebp</span><br><span class=\"line\">.text:004011D4                 pop     ebp</span><br><span class=\"line\">.text:004011D5                 retn</span><br><span class=\"line\">.text:004011D5 sub_4011C0      endp</span><br><span class=\"line\"></span><br><span class=\"line\">void *__thiscall sub_4011C0(void *this)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  sub_401080((char)this);</span><br><span class=\"line\">  return this;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//父类构造函数</span><br><span class=\"line\">.text:00401080 ; int __fastcall sub_401080(char)</span><br><span class=\"line\">.text:00401080 sub_401080      proc near               ; CODE XREF: sub_4011C0+A↓p</span><br><span class=\"line\">.text:00401080</span><br><span class=\"line\">.text:00401080 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401080</span><br><span class=\"line\">.text:00401080                 push    ebp             ; 父类构造函数</span><br><span class=\"line\">.text:00401081                 mov     ebp, esp</span><br><span class=\"line\">.text:00401083                 push    ecx             ; char</span><br><span class=\"line\">.text:00401084                 mov     [ebp+var_4], ecx</span><br><span class=\"line\">.text:00401087                 push    offset Format   ; &quot;Base\\n&quot;</span><br><span class=\"line\">.text:0040108C                 call    printf</span><br><span class=\"line\">.text:00401091                 add     esp, 4</span><br><span class=\"line\">.text:00401094                 mov     eax, [ebp+var_4]</span><br><span class=\"line\">.text:00401097                 mov     esp, ebp</span><br><span class=\"line\">.text:00401099                 pop     ebp</span><br><span class=\"line\">.text:0040109A                 retn</span><br><span class=\"line\">.text:0040109A sub_401080      endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __fastcall sub_401080(char a1)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  int v2; // [esp+0h] [ebp-4h]</span><br><span class=\"line\"></span><br><span class=\"line\">  printf(&quot;Base\\n&quot;, a1);</span><br><span class=\"line\">  return v2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//子类Derive的默认析构函数分析</span><br><span class=\"line\">.text:004011E0 ; int __fastcall sub_4011E0(char)</span><br><span class=\"line\">.text:004011E0 sub_4011E0      proc near               ; CODE XREF: _main+54↑p</span><br><span class=\"line\">.text:004011E0                                         ; _main+D43↓j</span><br><span class=\"line\">.text:004011E0</span><br><span class=\"line\">.text:004011E0 var_4           = byte ptr -4</span><br><span class=\"line\">.text:004011E0</span><br><span class=\"line\">.text:004011E0                 push    ebp             ; 子类Derive的默认析构函数分析</span><br><span class=\"line\">.text:004011E1                 mov     ebp, esp</span><br><span class=\"line\">.text:004011E3                 push    ecx</span><br><span class=\"line\">.text:004011E4                 mov     [ebp-4], ecx</span><br><span class=\"line\">.text:004011E7                 mov     ecx, [ebp-4]    ; 以子类对象首地址作为父类的this指针</span><br><span class=\"line\">.text:004011EA                 call    sub_4010A0      ; 调用父类析构函数</span><br><span class=\"line\">.text:004011EF                 mov     esp, ebp</span><br><span class=\"line\">.text:004011F1                 pop     ebp</span><br><span class=\"line\">.text:004011F2                 retn</span><br><span class=\"line\">.text:004011F2 sub_4011E0      endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __fastcall sub_4011E0(char a1)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return sub_4010A0(a1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//父类析构函数</span><br><span class=\"line\">.text:004010A0 ; int sub_4010A0()</span><br><span class=\"line\">.text:004010A0 sub_4010A0      proc near               ; CODE XREF: sub_4011E0+A↓p</span><br><span class=\"line\">.text:004010A0</span><br><span class=\"line\">.text:004010A0 var_4           = dword ptr -4</span><br><span class=\"line\">.text:004010A0</span><br><span class=\"line\">.text:004010A0                 push    ebp             ; 父类析构函数</span><br><span class=\"line\">.text:004010A1                 mov     ebp, esp</span><br><span class=\"line\">.text:004010A3                 push    ecx             ; char</span><br><span class=\"line\">.text:004010A4                 mov     [ebp+var_4], ecx</span><br><span class=\"line\">.text:004010A7                 push    offset aBase_0  ; &quot;~Base\\n&quot;</span><br><span class=\"line\">.text:004010AC                 call    printf</span><br><span class=\"line\">.text:004010B1                 add     esp, 4</span><br><span class=\"line\">.text:004010B4                 mov     esp, ebp</span><br><span class=\"line\">.text:004010B6                 pop     ebp</span><br><span class=\"line\">.text:004010B7                 retn</span><br><span class=\"line\">.text:004010B7 sub_4010A0      endp</span><br><span class=\"line\"></span><br><span class=\"line\">int sub_4010A0()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return printf(&quot;~Base\\n&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，在子类对象Derive的内存布局中，首地址处的第一个数据是父类数据成员base，向后的4字节数据为自身数据成员derive，如下表所示。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%9A%84%E5%85%B3%E7%B3%BB/%E5%AD%90%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/Derive%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png\" alt=\"Derive对象内存结构\"></p>\n<p>有了这样的内存结构，不但可以使用指向子类对象的子类指针间接寻址到父类定义的成员，还可以使用指向子类对象的父类指针间接寻址到父类定义的成员。在使用父类成员函数时，传递的this指针也可以是子类对象的首地址。因此，在父类中，可以根据以上内存结构将子类对象的首地址视为父类对象的首地址实现对数据的操作，而且不会出错。因为父类对象的长度不超过子类对象，而子类对象只要派生新的数据，其长度即可超过父类，所以子类指针的寻址范围不小于父类指针。在使用子类指针访问父类对象时，如果访问的成员数据是父类对象定义的，则不会出错；如果访问的是子类派生的成员数据，则会造成访问越界。</p>\n<h1 id=\"子类调用父类函数\"><a href=\"#子类调用父类函数\" class=\"headerlink\" title=\"子类调用父类函数\"></a>子类调用父类函数</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#pragma warning(disable : 4996)</span><br><span class=\"line\"></span><br><span class=\"line\">class Base &#123; //基类定义</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tBase() &#123;</span><br><span class=\"line\">\t\tprintf(&quot;Base\\n&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~Base() &#123;</span><br><span class=\"line\">\t\tprintf(&quot;~Base\\n&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid setNumber(int n) &#123;</span><br><span class=\"line\">\t\tbase = n;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint getNumber() &#123;</span><br><span class=\"line\">\t\treturn base;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint base;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Derive : public Base &#123; //派生类定义</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid showNumber(int n) &#123;</span><br><span class=\"line\">\t\tsetNumber(n);</span><br><span class=\"line\">\t\tderive = n + 1;</span><br><span class=\"line\">\t\tprintf(&quot;%d\\n&quot;, getNumber());</span><br><span class=\"line\">\t\tprintf(&quot;%d\\n&quot;, derive);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint derive;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main(int argc, char* argv[]) &#123;</span><br><span class=\"line\">\tDerive derive;</span><br><span class=\"line\">\tderive.showNumber(argc);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ida汇编及伪代码视图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//main函数</span><br><span class=\"line\">.text:00401140 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:00401140 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:00401140</span><br><span class=\"line\">.text:00401140 var_1C          = dword ptr -1Ch</span><br><span class=\"line\">.text:00401140 var_18          = byte ptr -18h</span><br><span class=\"line\">.text:00401140 var_10          = dword ptr -10h</span><br><span class=\"line\">.text:00401140 var_C           = dword ptr -0Ch</span><br><span class=\"line\">.text:00401140 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401140 argc            = dword ptr  8</span><br><span class=\"line\">.text:00401140 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:00401140 envp            = dword ptr  10h</span><br><span class=\"line\">.text:00401140</span><br><span class=\"line\">.text:00401140 ; FUNCTION CHUNK AT .text:00401E80 SIZE 00000008 BYTES</span><br><span class=\"line\">.text:00401140 ; FUNCTION CHUNK AT .text:00401E8D SIZE 00000027 BYTES</span><br><span class=\"line\">.text:00401140</span><br><span class=\"line\">.text:00401140 ; __unwind &#123; // _main_SEH</span><br><span class=\"line\">.text:00401140                 push    ebp</span><br><span class=\"line\">.text:00401141                 mov     ebp, esp</span><br><span class=\"line\">.text:00401143                 push    0FFFFFFFFh</span><br><span class=\"line\">.text:00401145                 push    offset _main_SEH</span><br><span class=\"line\">.text:0040114A                 mov     eax, large fs:0</span><br><span class=\"line\">.text:00401150                 push    eax</span><br><span class=\"line\">.text:00401151                 sub     esp, 10h</span><br><span class=\"line\">.text:00401154                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:00401159                 xor     eax, ebp</span><br><span class=\"line\">.text:0040115B                 mov     [ebp-10h], eax</span><br><span class=\"line\">.text:0040115E                 push    eax</span><br><span class=\"line\">.text:0040115F                 lea     eax, [ebp-0Ch]</span><br><span class=\"line\">.text:00401162                 mov     large fs:0, eax</span><br><span class=\"line\">.text:00401168                 lea     ecx, [ebp-18h]  ; 获取对象首地址作为this指针</span><br><span class=\"line\">.text:0040116B                 call    sub_4011C0      ; 调用类Derive的构造函数，编译器为Derive提供了默认的构造函数</span><br><span class=\"line\">.text:00401170 ;   try &#123;</span><br><span class=\"line\">.text:00401170                 mov     dword ptr [ebp-4], 0</span><br><span class=\"line\">.text:00401177                 mov     eax, [ebp+8]</span><br><span class=\"line\">.text:0040117A                 push    eax             ; 参数2：argc</span><br><span class=\"line\">.text:0040117B                 lea     ecx, [ebp-18h]  ; 参数1：传入this指针</span><br><span class=\"line\">.text:0040117E                 call    sub_4010F0      ; 调用成员函数showNumber</span><br><span class=\"line\">.text:00401183                 mov     dword ptr [ebp-1Ch], 0</span><br><span class=\"line\">.text:00401183 ;   &#125; // starts at 401170</span><br><span class=\"line\">.text:0040118A                 mov     dword ptr [ebp-4], 0FFFFFFFFh</span><br><span class=\"line\">.text:00401191                 lea     ecx, [ebp-18h]  ; 传入this指针</span><br><span class=\"line\">.text:00401194                 call    sub_4011E0      ; 调用类Derive的析构函数，编译器为Derive提供了默认的析构函数</span><br><span class=\"line\">.text:00401199                 mov     eax, [ebp-1Ch]</span><br><span class=\"line\">.text:0040119C                 mov     ecx, [ebp-0Ch]</span><br><span class=\"line\">.text:0040119F                 mov     large fs:0, ecx</span><br><span class=\"line\">.text:004011A6                 pop     ecx</span><br><span class=\"line\">.text:004011A7                 mov     ecx, [ebp-10h]</span><br><span class=\"line\">.text:004011AA                 xor     ecx, ebp        ; StackCookie</span><br><span class=\"line\">.text:004011AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class=\"line\">.text:004011B1                 mov     esp, ebp</span><br><span class=\"line\">.text:004011B3                 pop     ebp</span><br><span class=\"line\">.text:004011B4                 retn</span><br><span class=\"line\">.text:004011B4 ; &#125; // starts at 401140</span><br><span class=\"line\">.text:004011B4 _main           endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char v4[8]; // [esp+8h] [ebp-18h] BYREF</span><br><span class=\"line\">  int v5; // [esp+1Ch] [ebp-4h]</span><br><span class=\"line\"></span><br><span class=\"line\">  sub_4011C0(v4);</span><br><span class=\"line\">  v5 = 0;</span><br><span class=\"line\">  sub_4010F0(argc);</span><br><span class=\"line\">  v5 = -1;</span><br><span class=\"line\">  sub_4011E0(v4);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//showNumber函数</span><br><span class=\"line\">.text:004010F0 ; int __thiscall sub_4010F0(_DWORD *this, int)</span><br><span class=\"line\">.text:004010F0 sub_4010F0      proc near               ; CODE XREF: _main+3E↓p</span><br><span class=\"line\">.text:004010F0</span><br><span class=\"line\">.text:004010F0 var_4           = dword ptr -4</span><br><span class=\"line\">.text:004010F0 arg_0           = dword ptr  8</span><br><span class=\"line\">.text:004010F0</span><br><span class=\"line\">.text:004010F0                 push    ebp             ; showNumber函数</span><br><span class=\"line\">.text:004010F1                 mov     ebp, esp</span><br><span class=\"line\">.text:004010F3                 push    ecx</span><br><span class=\"line\">.text:004010F4                 mov     [ebp-4], ecx    ; [ebp-4]中保留了this指针</span><br><span class=\"line\">.text:004010F7                 mov     eax, [ebp+8]    ; 参数2：n</span><br><span class=\"line\">.text:004010FA                 push    eax</span><br><span class=\"line\">.text:004010FB                 mov     ecx, [ebp-4]    ; 参数1：因为this指针同时也是对象中父类部分的首地址，所以在调用父类成员函数时，this指针的值和子类对象等同</span><br><span class=\"line\">.text:004010FE                 call    sub_4010C0      ; 调用基类成员函数setNumber</span><br><span class=\"line\">.text:00401103                 mov     ecx, [ebp+8]</span><br><span class=\"line\">.text:00401106                 add     ecx, 1          ; 将参数n值加1</span><br><span class=\"line\">.text:00401109                 mov     edx, [ebp-4]    ; edx拿到this指针</span><br><span class=\"line\">.text:0040110C                 mov     [edx+4], ecx    ; 参考内存结构，edx+4是子类成员derive的地址，derive=n+1</span><br><span class=\"line\">.text:0040110F                 mov     ecx, [ebp-4]    ; 传递this指针</span><br><span class=\"line\">.text:00401112                 call    unknown_libname_1 ; 调用基类成员函数getNumber</span><br><span class=\"line\">.text:00401117                 push    eax             ; 参数2：Base.base</span><br><span class=\"line\">.text:00401118                 push    offset aD       ; &quot;%d\\n&quot;</span><br><span class=\"line\">.text:0040111D                 call    printf</span><br><span class=\"line\">.text:00401122                 add     esp, 8</span><br><span class=\"line\">.text:00401125                 mov     eax, [ebp-4]</span><br><span class=\"line\">.text:00401128                 mov     ecx, [eax+4]</span><br><span class=\"line\">.text:0040112B                 push    ecx             ; 参数2：derive</span><br><span class=\"line\">.text:0040112C                 push    offset aD       ; &quot;%d\\n&quot;</span><br><span class=\"line\">.text:00401131                 call    printf</span><br><span class=\"line\">.text:00401136                 add     esp, 8</span><br><span class=\"line\">.text:00401139                 mov     esp, ebp</span><br><span class=\"line\">.text:0040113B                 pop     ebp</span><br><span class=\"line\">.text:0040113C                 retn    4</span><br><span class=\"line\">.text:0040113C sub_4010F0      endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __thiscall sub_4010F0(_DWORD *this, int a2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char v2; // al</span><br><span class=\"line\"></span><br><span class=\"line\">  sub_4010C0(a2);</span><br><span class=\"line\">  this[1] = a2 + 1;</span><br><span class=\"line\">  v2 = unknown_libname_1(this);</span><br><span class=\"line\">  printf(&quot;%d\\n&quot;, v2);</span><br><span class=\"line\">  return printf(&quot;%d\\n&quot;, this[1]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>父类中成员函数setNumber在子类中并没有被定义，但根据派生关系，在子类中可以使用父类的公有函数。</p>\n<p>如果使用对象或对象的指针调用成员函数，编译器可根据对象所属作用域通过“名称粉碎法” [1]实现正确匹配。在成员函数中调用其他成员函数时，可匹配当前作用域。</p>\n<p>在调用父类成员函数时，虽然其this指针传递的是子类对象的首地址，但是在父类成员函数中可以成功寻址到父类中的数据。回想之前提到的对象内存布局，父类数据成员被排列在地址最前端，之后是子类数据成员。showNumber运行后的内存信息如下图所示：</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%9A%84%E5%85%B3%E7%B3%BB/%E5%AD%90%E7%B1%BB%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E5%87%BD%E6%95%B0/%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1Derive%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png\" alt=\"子类对象Derive的内存布局\"></p>\n<p>这 时 ， 首 地 址 处 为 父 类 数 据 成 员 ， 而 父 类 中 的 成 员 函 数setNumber在寻址此数据成员时，会将首地址的4字节数据作为数据成员base。由此可见，父类数据成员被排列在最前端是为了在添加派生类后方便子类使用父类中的成员数据，并且可以将子类指针当作父类指针使用。按照继承顺序依次排列各个数据成员，这样一来，不管是操作子类对象还是父类对象，只要确认了对象的首地址，对父类成员数据的偏移量而言都是一样的。对子类对象而言，使用父类指针或者子类指针都可以正确访问其父类数据。反之，如果使用一个父类对象的指针去访问子类对象，则存在越界访问的危险。</p>\n<h1 id=\"多态（虚函数）\"><a href=\"#多态（虚函数）\" class=\"headerlink\" title=\"多态（虚函数）\"></a>多态（虚函数）</h1><p>学习虚函数时，我们分析了类中的隐藏数据成员——虚表指针。正因为有这个虚表指针，调用虚函数的方式改为查表并间接调用，在虚表中得到函数首地址并跳转到此地址处执行代码。利用此特性即可通过父类指针访问不同的派生类。在调用父类中定义的虚函数时，根据指针指向的对象中的虚表指针，可得到虚表信息，间接调用虚函数，即构成了多态。</p>\n<p>以“人”为基类，可以派生出不同国家的人：中国人、美国人、德国人等。这些人有一个共同的功能——说话，但是他们实现这个功能的过程不同，例如中国人说汉语、美国人说英语、德国人说德语。每个国家的人都有不同的说话方法，为了让“说话”这个方法有一个通用接口，可以设立一个“人”类将其抽象化。使用“人”类的指针或引用调用具体对象的“说话”方法，就形成了多态。</p>\n<h2 id=\"人类说话方法的多态模拟类结构\"><a href=\"#人类说话方法的多态模拟类结构\" class=\"headerlink\" title=\"人类说话方法的多态模拟类结构\"></a>人类说话方法的多态模拟类结构</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123; <span class=\"comment\">// 基类——“人”类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Person</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">showSpeak</span><span class=\"params\">()</span> </span>&#123;&#125; <span class=\"comment\">// 这里用纯虚函数更好，相关的知识点后面会讲到</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Chinese</span> : <span class=\"keyword\">public</span> Person &#123; <span class=\"comment\">// 中国人：继承自人类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Chinese</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Chinese</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">showSpeak</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">// 覆盖基类虚函数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Speak Chinese\\r\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">American</span> : <span class=\"keyword\">public</span> Person &#123; <span class=\"comment\">//美国人：继承自人类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">American</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">American</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">showSpeak</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">//覆盖基类虚函数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Speak American\\r\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">German</span> : <span class=\"keyword\">public</span> Person &#123; <span class=\"comment\">//德国人：继承自人类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">German</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">German</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">showSpeak</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">//覆盖基类虚函数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Speak German\\r\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">(Person* person)</span> </span>&#123; <span class=\"comment\">//根据虚表信息获取虚函数首地址并调用</span></span><br><span class=\"line\">\tperson-&gt;<span class=\"built_in\">showSpeak</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\tChinese chinese;</span><br><span class=\"line\">\tAmerican american;</span><br><span class=\"line\">\tGerman german;</span><br><span class=\"line\">\t<span class=\"built_in\">speak</span>(&amp;chinese);</span><br><span class=\"line\">\t<span class=\"built_in\">speak</span>(&amp;american);</span><br><span class=\"line\">\t<span class=\"built_in\">speak</span>(&amp;german);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，利用父类指针可以指向子类的特性，可以间接调用各子类中的虚函数。虽然指针类型为父类，但是因为虚表的排列顺序是按虚函数在类继承层次中首次声明的顺序排列的，所以只要继承了父类，其派生类的虚表中父类部分的排列就与父类一致，子类新定义的虚函数会按照声明顺序紧跟其后。因此，在调用过程中，我们给speak函数传递任何一个基于Person的派生对象地址都可以正确调用虚函数showSpeak。</p>\n<p>在调用虚函数的过程中，程序是如何通过虚表指针访问虚函数的呢？具体分析如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// main函数分析略</span><br><span class=\"line\">// speak函数讲解</span><br><span class=\"line\">text:004012B0 sub_4012B0      proc near               ; CODE XREF: _main+53↓p</span><br><span class=\"line\">.text:004012B0                                         ; _main+5F↓p ...</span><br><span class=\"line\">.text:004012B0</span><br><span class=\"line\">.text:004012B0 arg_0           = dword ptr  8</span><br><span class=\"line\">.text:004012B0</span><br><span class=\"line\">.text:004012B0                 push    ebp             ; speak函数</span><br><span class=\"line\">.text:004012B1                 mov     ebp, esp</span><br><span class=\"line\">.text:004012B3                 mov     eax, [ebp+8]    ; eax获取参数person的值</span><br><span class=\"line\">.text:004012B6                 mov     edx, [eax]      ; 取虚表首地址并传递给edx</span><br><span class=\"line\">.text:004012B8                 mov     ecx, [ebp+8]    ; 传递this指针</span><br><span class=\"line\">.text:004012BB                 mov     eax, [edx+4]    ; 利用虚表指针edx，间接调用函数</span><br><span class=\"line\">.text:004012BB                                         ; 回顾父类Person的类型声明，第一个声明的虚函数是析构函数，第二个声明的是showSpeak</span><br><span class=\"line\">.text:004012BB                                         ; 所以showSpeak在虚函数表中的位置排第二，[edx+4]即showSpeak的函数地址</span><br><span class=\"line\">.text:004012BE                 call    eax</span><br><span class=\"line\">.text:004012C0                 pop     ebp</span><br><span class=\"line\">.text:004012C1                 retn</span><br><span class=\"line\">.text:004012C1 sub_4012B0      endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl sub_4012B0(int a1)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return (*(int (__thiscall **)(int))(*(_DWORD *)a1 + 4))(a1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，虚函数的调用过程使用了间接寻址方式，而非直接调用函数地址。由于虚表采用间接调用机制，因此在使用父类指针person调用虚函数时，没有依照其作用域调用Person类中定义的成员函数showSpeak。需要注意的是，GCC编译器虚析构函数会生成两个虚表项，因此showSpeak函数在第三项（后续例子将详细分析）。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对比如下代码中虚函数调用：<br>24: setNumber(n);<br>010F2C3D mov eax,dword ptr [ebp+8]<br>010F2C40 push eax<br>010F2C41 mov ecx,dword ptr [ebp-8]<br>010F2C44 call 010F13BB ;这里直接调用，无法构成多态</p>\n<p>可以发现，当没有使用对象指针或者对象引用时，调用虚函数指令的寻址方式为直接调用，从而无法构成多态。而上面代码中使用了对象指针调用虚函数，所以会产生间接调用方式，进而构成多态。</p></blockquote>\n<p>当父类中定义有虚函数时，将会产生虚表。当父类的子类产生对象时，会在调用子类构造函数前优先调用</p>\n<p>父类构造函数，并以子类对象的首地址作为this指针传递给父类构造函数。在父类构造函数中，会先初始化子类虚表指针为父类的虚表首地址。此时，如果在父类构造函数中调用虚函数，虽然虚表指针属于子类对象，但指向的地址却是父类的虚表首地址，这时可判断出虚表所属作用域与当前作用域相同，于是会转换成直接调用方式，最终造成构造函数内的虚函数失效。修改代码清单12-5，在Person类的构造函数中添加虚函数调用，如下所示。</p>\n<h2 id=\"在父类构造函数中调用虚函数\"><a href=\"#在父类构造函数中调用虚函数\" class=\"headerlink\" title=\"在父类构造函数中调用虚函数\"></a>在父类构造函数中调用虚函数</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123; <span class=\"comment\">// 基类——“人”类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>() &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">showSpeak</span>(); <span class=\"comment\">//调用虚函数，不多态</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Person</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">showSpeak</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Speak No\\n&quot;</span>);</span><br><span class=\"line\">\t&#125; <span class=\"comment\">// 这里用纯虚函数更好，相关的知识点后面会讲到</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Chinese</span> : <span class=\"keyword\">public</span> Person &#123; <span class=\"comment\">// 中国人：继承自人类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Chinese</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Chinese</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">showSpeak</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">// 覆盖基类虚函数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Speak Chinese\\r\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">American</span> : <span class=\"keyword\">public</span> Person &#123; <span class=\"comment\">//美国人：继承自人类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">American</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">American</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">showSpeak</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">//覆盖基类虚函数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Speak American\\r\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">German</span> : <span class=\"keyword\">public</span> Person &#123; <span class=\"comment\">//德国人：继承自人类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">German</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">German</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">showSpeak</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">//覆盖基类虚函数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Speak German\\r\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">(Person* person)</span> </span>&#123; <span class=\"comment\">//根据虚表信息获取虚函数首地址并调用</span></span><br><span class=\"line\">\tperson-&gt;<span class=\"built_in\">showSpeak</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\tChinese chinese;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ida汇编及伪代码视图：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main函数</span></span><br><span class=\"line\">.text:<span class=\"number\">004011</span>A0 ; <span class=\"function\"><span class=\"type\">int</span> __cdecl <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span></span><br><span class=\"line\"><span class=\"function\">.text:<span class=\"number\">004011</span>A0 _main           proc near               ;</span> CODE XREF: __scrt_common_main_seh(<span class=\"type\">void</span>)+F5↓p</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>A0</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>A0 var_C           = dword ptr <span class=\"number\">-0</span>Ch</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>A0 var_8           = byte ptr <span class=\"number\">-8</span></span><br><span class=\"line\">.text:<span class=\"number\">004011</span>A0 var_4           = dword ptr <span class=\"number\">-4</span></span><br><span class=\"line\">.text:<span class=\"number\">004011</span>A0 argc            = dword ptr  <span class=\"number\">8</span></span><br><span class=\"line\">.text:<span class=\"number\">004011</span>A0 argv            = dword ptr  <span class=\"number\">0</span>Ch</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>A0 envp            = dword ptr  <span class=\"number\">10</span>h</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>A0</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>A0                 push    ebp</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>A1                 mov     ebp, esp</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>A3                 sub     esp, <span class=\"number\">0</span>Ch</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>A6                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>AB                 <span class=\"keyword\">xor</span>     eax, ebp</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>AD                 mov     [ebp<span class=\"number\">-4</span>], eax</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>B0                 lea     ecx, [ebp<span class=\"number\">-8</span>]    ; 获取对象首地址作为<span class=\"keyword\">this</span>指针</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>B3                 call    sub_401110      ; 调用类Chinese的构造函数</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>B8                 mov     dword ptr [ebp<span class=\"number\">-0</span>Ch], <span class=\"number\">0</span></span><br><span class=\"line\">.text:<span class=\"number\">004011</span>BF                 lea     ecx, [ebp<span class=\"number\">-8</span>]    ; 传入<span class=\"keyword\">this</span>指针</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>C2                 call    sub_401130      ; 调用类Chinese的析构函数</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>C7                 mov     eax, [ebp<span class=\"number\">-0</span>Ch]</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>CA                 mov     ecx, [ebp<span class=\"number\">-4</span>]</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>CD                 <span class=\"keyword\">xor</span>     ecx, ebp        ; StackCookie</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>CF                 call    @__security_check_cookie@<span class=\"number\">4</span> ; __security_check_cookie(x)</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>D4                 mov     esp, ebp</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>D6                 pop     ebp</span><br><span class=\"line\">.text:<span class=\"number\">004011</span>D7                 retn</span><br><span class=\"line\">.text:<span class=\"number\">004011</span><span class=\"function\">D7 _main           endp</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> __cdecl <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> v4[<span class=\"number\">4</span>]; <span class=\"comment\">// [esp+4h] [ebp-8h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">sub_401110</span>(v4);</span><br><span class=\"line\">  <span class=\"built_in\">sub_401130</span>(v4);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Chinese的构造函数</span></span><br><span class=\"line\">.text:<span class=\"number\">00401110</span> ; <span class=\"function\">_DWORD *__thiscall <span class=\"title\">sub_401110</span><span class=\"params\">(_DWORD *<span class=\"keyword\">this</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">.text:<span class=\"number\">00401110</span> sub_401110      proc near               ;</span> CODE XREF: _main<span class=\"number\">+13</span>↓p</span><br><span class=\"line\">.text:<span class=\"number\">00401110</span></span><br><span class=\"line\">.text:<span class=\"number\">00401110</span> var_4           = dword ptr <span class=\"number\">-4</span></span><br><span class=\"line\">.text:<span class=\"number\">00401110</span></span><br><span class=\"line\">.text:<span class=\"number\">00401110</span>                 push    ebp             ; 类Chinese的构造函数</span><br><span class=\"line\">.text:<span class=\"number\">00401111</span>                 mov     ebp, esp</span><br><span class=\"line\">.text:<span class=\"number\">00401113</span>                 push    ecx</span><br><span class=\"line\">.text:<span class=\"number\">00401114</span>                 mov     [ebp<span class=\"number\">-4</span>], ecx</span><br><span class=\"line\">.text:<span class=\"number\">00401117</span>                 mov     ecx, [ebp<span class=\"number\">-4</span>]    ; 以子类对象首地址作为父类的<span class=\"keyword\">this</span>指针</span><br><span class=\"line\">.text:<span class=\"number\">0040111</span>A                 call    sub_401080      ; 调用父类Person的构造函数</span><br><span class=\"line\">.text:<span class=\"number\">0040111</span>F                 mov     eax, [ebp<span class=\"number\">-4</span>]</span><br><span class=\"line\">.text:<span class=\"number\">00401122</span>                 mov     dword ptr [eax], offset off_402128 ; 设置虚表指针为自身（Chinese）虚表</span><br><span class=\"line\">.text:<span class=\"number\">0040112</span>8                 mov     eax, [ebp<span class=\"number\">-4</span>]</span><br><span class=\"line\">.text:<span class=\"number\">0040112</span>B                 mov     esp, ebp</span><br><span class=\"line\">.text:<span class=\"number\">0040112</span>D                 pop     ebp</span><br><span class=\"line\">.text:<span class=\"number\">0040112</span>E                 retn</span><br><span class=\"line\">.text:<span class=\"number\">0040112</span><span class=\"function\">E sub_401110      endp</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">_DWORD *__thiscall <span class=\"title\">sub_401110</span><span class=\"params\">(_DWORD *<span class=\"keyword\">this</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">sub_401080</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  *<span class=\"keyword\">this</span> = &amp;off_402128;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Person的构造函数</span></span><br><span class=\"line\">.text:<span class=\"number\">004010</span>80 ; <span class=\"function\">_DWORD *__thiscall <span class=\"title\">sub_401080</span><span class=\"params\">(_DWORD *<span class=\"keyword\">this</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">.text:<span class=\"number\">004010</span>80 sub_401080      proc near               ;</span> CODE XREF: sub_401110+A↓p</span><br><span class=\"line\">.text:<span class=\"number\">004010</span>80</span><br><span class=\"line\">.text:<span class=\"number\">004010</span>80 var_4           = byte ptr <span class=\"number\">-4</span></span><br><span class=\"line\">.text:<span class=\"number\">004010</span>80</span><br><span class=\"line\">.text:<span class=\"number\">004010</span>80                 push    ebp             ; Person的构造函数</span><br><span class=\"line\">.text:<span class=\"number\">004010</span>81                 mov     ebp, esp</span><br><span class=\"line\">.text:<span class=\"number\">004010</span>83                 push    ecx</span><br><span class=\"line\">.text:<span class=\"number\">004010</span>84                 mov     [ebp<span class=\"number\">-4</span>], ecx</span><br><span class=\"line\">.text:<span class=\"number\">004010</span>87                 mov     eax, [ebp<span class=\"number\">-4</span>]</span><br><span class=\"line\">.text:<span class=\"number\">004010</span>8A                 mov     dword ptr [eax], offset off_402134 ; 设置虚表指针为Person虚表</span><br><span class=\"line\">.text:<span class=\"number\">004010</span>90                 mov     ecx, [ebp<span class=\"number\">-4</span>]    ; <span class=\"type\">char</span></span><br><span class=\"line\">.text:<span class=\"number\">004010</span>93                 call    sub_4010C0      ; 直接调用父类方法<span class=\"built_in\">showSpeak</span>()</span><br><span class=\"line\">.text:<span class=\"number\">004010</span>98                 mov     eax, [ebp<span class=\"number\">-4</span>]</span><br><span class=\"line\">.text:<span class=\"number\">004010</span>9B                 mov     esp, ebp</span><br><span class=\"line\">.text:<span class=\"number\">004010</span>9D                 pop     ebp</span><br><span class=\"line\">.text:<span class=\"number\">004010</span>9E                 retn</span><br><span class=\"line\">.text:<span class=\"number\">004010</span>9<span class=\"function\">E sub_401080      endp</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">_DWORD *__thiscall <span class=\"title\">sub_401080</span><span class=\"params\">(_DWORD *<span class=\"keyword\">this</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  *<span class=\"keyword\">this</span> = &amp;off_402134;</span><br><span class=\"line\">  <span class=\"built_in\">sub_4010C0</span>((<span class=\"type\">char</span>)<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上代码执行过程如下图所示：</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%9A%84%E5%85%B3%E7%B3%BB/%E5%A4%9A%E6%80%81/%E5%9C%A8%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0.png\" alt=\"构造函数调用虚函数\"></p>\n<p>上图演示了构造函数中使用虚函数的流程。按C++规定的构造顺序，父类构造函数会在子类构造函数之前运行，在执行父类构造函数时将虚表指针修改为当前类的虚表指针，也就是父类的虚表指针，因此导致虚函数的特性失效。如果父类构造函数内部存在虚函数调用，这样的顺序能防止在子类中构造父类时，父类根据虚表错误地调用子类的成员函数。</p>\n<p>虽然在构造函数和析构函数中调用虚函数会使其多态性失效，但是为什么还要修改虚表指针呢？编译器直接把构造函数或析构函数中的虚函数调用修改为直接调用方式，不就可以避免这类问题了吗？大家不要忘了，程序员仍然可以自己编写其他成员函数，间接调用本类中声明的其他虚函数。假设类A中定义了成员函数f1()和虚函数f2()，而且类B继承自类A并重写了f2()。根据前面的讲解我们可以知道，在子类B的构造函数执行前会调用父类A的构造函数，此时如果在类A的构造函数中调用f1()，显然不会构成多态，编译器会产生直接调用f1()的代码。但是，如果在f1()中又调用了f2()，就会产生间接调用的指令，形成多态。如果类B对象的虚表指针没有更换为类A的虚表指针，会导致在访问类B的虚表后调用到类B中的f2()函数，而此时类B的对象尚未构造完成，其数据成员是不确定的，这时在f2()中引用类B的对象中的数据成员是很危险的。</p>\n<p>同理，在析构类B的对象时，会先执行类B的析构函数，然后执行类A的析构函数。如果在类A的析构函数中调用f1()，显然也不能构成多态，编译器同样会产生直接调用f1()的代码。但是，如果f1()中又调用了f2()，此时会构成多态，如果这个对象的虚表指针没有更换为类A的虚表指针，同样也会导致访问虚表并调用类B中的f2()。但是，此时B类对象已经执行过析构函数，所以B类中定义的数据已经不可靠了，对其进行操作同样是很危险的。</p>\n<p>在析构函数中，同样需要处理虚函数的调用，因此也需要处理虚函数。按C++中定义的析构顺序，<strong>首先调用自身的析构函数，然后调用成员对象的析构函数，最后调用父类的析构函数。</strong>在对象析构时，首先设置虚表指针为自身虚表，再调用自身的析构函数。如果有成员对象，则按声明的顺序以倒序方式依次调用成员对象的析构函数。最后，调用父类析构函数。在调用父类的析构函数时，会设置虚表指针为父类自身的虚表。</p>\n<h2 id=\"构造函数和析构函数中调用虚函数的流程\"><a href=\"#构造函数和析构函数中调用虚函数的流程\" class=\"headerlink\" title=\"构造函数和析构函数中调用虚函数的流程\"></a>构造函数和析构函数中调用虚函数的流程</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123; <span class=\"comment\">// 基类——“人”类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>() &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">showSpeak</span>(); <span class=\"comment\">//添加虚函数调用</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Person</span>() &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">showSpeak</span>(); <span class=\"comment\">//添加虚函数调用</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">showSpeak</span><span class=\"params\">()</span> </span>&#123;&#125; <span class=\"comment\">//纯虚函数，后面会讲解</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Chinese</span> : <span class=\"keyword\">public</span> Person &#123; <span class=\"comment\">// 中国人：继承自人类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Chinese</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Chinese</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">showSpeak</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">// 覆盖基类虚函数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Speak Chinese\\r\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">American</span> : <span class=\"keyword\">public</span> Person &#123; <span class=\"comment\">//美国人：继承自人类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">American</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">American</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">showSpeak</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">//覆盖基类虚函数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Speak American\\r\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">German</span> : <span class=\"keyword\">public</span> Person &#123; <span class=\"comment\">//德国人：继承自人类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">German</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">virtual</span> ~<span class=\"built_in\">German</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">showSpeak</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">//覆盖基类虚函数</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Speak German\\r\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">(Person* person)</span> </span>&#123; <span class=\"comment\">//根据虚表信息获取虚函数首地址并调用</span></span><br><span class=\"line\">\tperson-&gt;<span class=\"built_in\">showSpeak</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\tChinese chinese;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ida汇编及伪代码视图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//main函数</span><br><span class=\"line\">.text:004011C0 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:004011C0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:004011C0</span><br><span class=\"line\">.text:004011C0 var_C           = dword ptr -0Ch</span><br><span class=\"line\">.text:004011C0 var_8           = byte ptr -8</span><br><span class=\"line\">.text:004011C0 var_4           = dword ptr -4</span><br><span class=\"line\">.text:004011C0 argc            = dword ptr  8</span><br><span class=\"line\">.text:004011C0 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:004011C0 envp            = dword ptr  10h</span><br><span class=\"line\">.text:004011C0</span><br><span class=\"line\">.text:004011C0                 push    ebp</span><br><span class=\"line\">.text:004011C1                 mov     ebp, esp</span><br><span class=\"line\">.text:004011C3                 sub     esp, 0Ch</span><br><span class=\"line\">.text:004011C6                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:004011CB                 xor     eax, ebp</span><br><span class=\"line\">.text:004011CD                 mov     [ebp-4], eax</span><br><span class=\"line\">.text:004011D0                 lea     ecx, [ebp-8]    ; 传递this指针</span><br><span class=\"line\">.text:004011D3                 call    sub_401130      ; 调用Chinese的构造函数</span><br><span class=\"line\">.text:004011D8                 mov     dword ptr [ebp-0Ch], 0</span><br><span class=\"line\">.text:004011DF                 lea     ecx, [ebp-8]    ; 传递this指针</span><br><span class=\"line\">.text:004011E2                 call    sub_401150      ; 调用Chinese的析构函数</span><br><span class=\"line\">.text:004011E7                 mov     eax, [ebp-0Ch]</span><br><span class=\"line\">.text:004011EA                 mov     ecx, [ebp-4]</span><br><span class=\"line\">.text:004011ED                 xor     ecx, ebp        ; StackCookie</span><br><span class=\"line\">.text:004011EF                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class=\"line\">.text:004011F4                 mov     esp, ebp</span><br><span class=\"line\">.text:004011F6                 pop     ebp</span><br><span class=\"line\">.text:004011F7                 retn</span><br><span class=\"line\">.text:004011F7 _main           endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char v4[4]; // [esp+4h] [ebp-8h] BYREF</span><br><span class=\"line\"></span><br><span class=\"line\">  sub_401130(v4);</span><br><span class=\"line\">  sub_401150(v4);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//Chinese的构造函数</span><br><span class=\"line\">.text:00401130 ; _DWORD *__thiscall sub_401130(_DWORD *this)</span><br><span class=\"line\">.text:00401130 sub_401130      proc near               ; CODE XREF: _main+13↓p</span><br><span class=\"line\">.text:00401130</span><br><span class=\"line\">.text:00401130 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401130</span><br><span class=\"line\">.text:00401130                 push    ebp             ; Chinese的构造函数</span><br><span class=\"line\">.text:00401131                 mov     ebp, esp</span><br><span class=\"line\">.text:00401133                 push    ecx</span><br><span class=\"line\">.text:00401134                 mov     [ebp-4], ecx</span><br><span class=\"line\">.text:00401137                 mov     ecx, [ebp-4]    ; 传入当前this指针，将其作为父类的this指针</span><br><span class=\"line\">.text:0040113A                 call    sub_401080      ; 调用父类Person的构造函数</span><br><span class=\"line\">.text:0040113F                 mov     eax, [ebp-4]</span><br><span class=\"line\">.text:00401142                 mov     dword ptr [eax], offset off_402124 ; 将虚表设置为Chinese类的虚表</span><br><span class=\"line\">.text:00401148                 mov     eax, [ebp-4]    ; 返回值设置为this指针</span><br><span class=\"line\">.text:0040114B                 mov     esp, ebp</span><br><span class=\"line\">.text:0040114D                 pop     ebp</span><br><span class=\"line\">.text:0040114E                 retn</span><br><span class=\"line\">.text:0040114E sub_401130      endp</span><br><span class=\"line\"></span><br><span class=\"line\">_DWORD *__thiscall sub_401130(_DWORD *this)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  sub_401080(this);</span><br><span class=\"line\">  *this = &amp;off_402124;</span><br><span class=\"line\">  return this;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//Person的构造函数</span><br><span class=\"line\">.text:00401080 ; std::shared_mutex *__thiscall sub_401080(std::shared_mutex *this)</span><br><span class=\"line\">.text:00401080 sub_401080      proc near               ; CODE XREF: sub_401130+A↓p</span><br><span class=\"line\">.text:00401080</span><br><span class=\"line\">.text:00401080 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401080</span><br><span class=\"line\">.text:00401080                 push    ebp             ; Person的构造函数</span><br><span class=\"line\">.text:00401081                 mov     ebp, esp</span><br><span class=\"line\">.text:00401083                 push    ecx</span><br><span class=\"line\">.text:00401084                 mov     [ebp-4], ecx</span><br><span class=\"line\">.text:00401087                 mov     eax, [ebp-4]</span><br><span class=\"line\">.text:0040108A                 mov     dword ptr [eax], offset off_402130 ; 将虚表设置为Person类的虚表</span><br><span class=\"line\">.text:00401090                 mov     ecx, [ebp-4]    ; this，虚表是父类的，可以直接调用父类虚函数</span><br><span class=\"line\">.text:00401093                 call    ??1shared_mutex@std@@QAE@XZ ; 调用showSpeak函数</span><br><span class=\"line\">.text:00401098                 mov     eax, [ebp-4]    ; 返回值设置为this指针</span><br><span class=\"line\">.text:0040109B                 mov     esp, ebp</span><br><span class=\"line\">.text:0040109D                 pop     ebp</span><br><span class=\"line\">.text:0040109E                 retn</span><br><span class=\"line\">.text:0040109E sub_401080      endp</span><br><span class=\"line\"></span><br><span class=\"line\">std::shared_mutex *__thiscall sub_401080(std::shared_mutex *this)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  *(_DWORD *)this = &amp;off_402130;</span><br><span class=\"line\">  std::shared_mutex::~shared_mutex(this);</span><br><span class=\"line\">  return this;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//Chinese的析构函数</span><br><span class=\"line\">.text:00401150 ; int __thiscall sub_401150(_DWORD *this)</span><br><span class=\"line\">.text:00401150 sub_401150      proc near               ; CODE XREF: sub_401190+A↓p</span><br><span class=\"line\">.text:00401150                                         ; _main+22↓p</span><br><span class=\"line\">.text:00401150</span><br><span class=\"line\">.text:00401150 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401150</span><br><span class=\"line\">.text:00401150                 push    ebp             ; Chinese的析构函数</span><br><span class=\"line\">.text:00401151                 mov     ebp, esp</span><br><span class=\"line\">.text:00401153                 push    ecx</span><br><span class=\"line\">.text:00401154                 mov     [ebp-4], ecx</span><br><span class=\"line\">.text:00401157                 mov     eax, [ebp-4]    ; 返回值设置为this指针</span><br><span class=\"line\">.text:0040115A                 mov     dword ptr [eax], offset off_402124 ; 将虚表设置为Chinese类的虚表</span><br><span class=\"line\">.text:00401160                 mov     ecx, [ebp-4]    ; 传递this指针</span><br><span class=\"line\">.text:00401163                 call    sub_4010A0      ; 调用父类Person的析构函数</span><br><span class=\"line\">.text:00401168                 mov     esp, ebp</span><br><span class=\"line\">.text:0040116A                 pop     ebp</span><br><span class=\"line\">.text:0040116B                 retn</span><br><span class=\"line\">.text:0040116B sub_401150      endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __thiscall sub_401150(_DWORD *this)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  *this = &amp;off_402124;</span><br><span class=\"line\">  return sub_4010A0(this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//Person析构函数</span><br><span class=\"line\">.text:004010A0 ; void __thiscall sub_4010A0(std::shared_mutex *this)</span><br><span class=\"line\">.text:004010A0 sub_4010A0      proc near               ; CODE XREF: sub_401100+A↓p</span><br><span class=\"line\">.text:004010A0                                         ; sub_401150+13↓p</span><br><span class=\"line\">.text:004010A0</span><br><span class=\"line\">.text:004010A0 var_10          = dword ptr -10h</span><br><span class=\"line\">.text:004010A0 var_C           = dword ptr -0Ch</span><br><span class=\"line\">.text:004010A0 arg_4           = dword ptr  0Ch</span><br><span class=\"line\">.text:004010A0</span><br><span class=\"line\">.text:004010A0 ; FUNCTION CHUNK AT .text:00401EC0 SIZE 0000001D BYTES</span><br><span class=\"line\">.text:004010A0</span><br><span class=\"line\">.text:004010A0 ; __unwind &#123; // SEH_4010A0</span><br><span class=\"line\">.text:004010A0                 push    ebp             ; Person析构函数</span><br><span class=\"line\">.text:004010A1                 mov     ebp, esp</span><br><span class=\"line\">.text:004010A3                 push    0FFFFFFFFh</span><br><span class=\"line\">.text:004010A5                 push    offset SEH_4010A0</span><br><span class=\"line\">.text:004010AA                 mov     eax, large fs:0</span><br><span class=\"line\">.text:004010B0                 push    eax</span><br><span class=\"line\">.text:004010B1                 push    ecx</span><br><span class=\"line\">.text:004010B2                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:004010B7                 xor     eax, ebp</span><br><span class=\"line\">.text:004010B9                 push    eax</span><br><span class=\"line\">.text:004010BA                 lea     eax, [ebp-0Ch]</span><br><span class=\"line\">.text:004010BD                 mov     large fs:0, eax</span><br><span class=\"line\">.text:004010C3                 mov     [ebp-10h], ecx</span><br><span class=\"line\">.text:004010C6                 mov     eax, [ebp-10h]  ; 返回值设置为this指针</span><br><span class=\"line\">.text:004010C9                 mov     dword ptr [eax], offset off_402130 ; 将虚表设置为Person类的虚表</span><br><span class=\"line\">.text:004010C9                                         ; 因为当前虚表指针指向了子类虚表，所以需要重新修改为父类虚表，防止调用到子类的虚函数</span><br><span class=\"line\">.text:004010CF                 mov     ecx, [ebp-10h]  ; this，虚表是父类的，可以直接调用父类虚函数</span><br><span class=\"line\">.text:004010D2                 call    ??1shared_mutex@std@@QAE@XZ ; 调用showSpeak函数</span><br><span class=\"line\">.text:004010D7                 mov     ecx, [ebp-0Ch]</span><br><span class=\"line\">.text:004010DA                 mov     large fs:0, ecx</span><br><span class=\"line\">.text:004010E1                 pop     ecx</span><br><span class=\"line\">.text:004010E2                 mov     esp, ebp</span><br><span class=\"line\">.text:004010E4                 pop     ebp</span><br><span class=\"line\">.text:004010E5                 retn</span><br><span class=\"line\">.text:004010E5 ; &#125; // starts at 4010A0</span><br><span class=\"line\">.text:004010E5 sub_4010A0      endp</span><br><span class=\"line\"></span><br><span class=\"line\">void __thiscall sub_4010A0(std::shared_mutex *this)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  *(_DWORD *)this = &amp;off_402130;</span><br><span class=\"line\">  std::shared_mutex::~shared_mutex(this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面代码的子类构造函数代码中，先调用了父类的构造函数，然后设置虚表指针为当前类的虚表首地址。而析构函数中的顺序却与构造函数相反，先设置虚表指针为当前类的虚表首地址，然后调用父类的析构函数，其构造和析构的过程描述如下：</p>\n<p>构造：基类→基类的派生类→……→当前类。</p>\n<p>析构：当前类→基类的派生类→……→基类。</p>\n<p>在上面代码中，析构函数被定义为虚函数。<strong>为什么要将析构函数定义为虚函数呢？</strong></p>\n<p>因为可以使用父类指针保存子类对象的首地址，所以当使用父类指针指向子类堆对象时，就会出问题。当使用delete函数释放对象的空间时，如果析构函数没有被定义为虚函数，那么编译器会按指针的类型调用父类的析构函数，从而引发错误。而使用了虚析构函数后，会访问虚表并调用对象的析构函数。两种析构函数的调用过程如以下代码所示。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//没有声明为虚析构函数</span><br><span class=\"line\">Person * p = new Chinese;</span><br><span class=\"line\">delete p; //部分代码分析略</span><br><span class=\"line\"></span><br><span class=\"line\">00D85714 mov ecx,dword ptr [ebp+FFFFFF08h] ;直接调用父类的析构函数</span><br><span class=\"line\">00D8571A call 00D81456</span><br><span class=\"line\"></span><br><span class=\"line\">// 声明为虚析构函数</span><br><span class=\"line\">Person * p = new Chinese;</span><br><span class=\"line\">delete p; //部分代码分析略</span><br><span class=\"line\"></span><br><span class=\"line\">000B5716 mov ecx,dword ptr [ebp+FFFFFF08h] ;获取p并保存至ecx</span><br><span class=\"line\">000B571C mov edx,dword ptr [ecx] ;取得虚表指针</span><br><span class=\"line\">000B571E mov ecx,dword ptr [ebp+FFFFFF08h] ;传递this指针</span><br><span class=\"line\">000B5724 mov eax,dword ptr [edx] ;间接调用虚析构函数</span><br><span class=\"line\">000B5726 call eax</span><br></pre></td></tr></table></figure>\n\n<p>以上代码对普通析构函数与虚析构函数进行了对比，说明了类在有了派生与继承关系后，需要声明虚析构函数的原因。对于没有派生和继承关系的类结构，是否将析构函数声明为虚析构函数并不会影响调用的过程，但是在编写析构函数时应养成习惯，无论当前是否有派生或继承关系，都应将析构函数声明为虚析构函数，以防止将来更新和维护代码时发生析构函数的错误调用。</p>\n<h2 id=\"如何识别代码中类与类之间的关系\"><a href=\"#如何识别代码中类与类之间的关系\" class=\"headerlink\" title=\"如何识别代码中类与类之间的关系\"></a>如何识别代码中类与类之间的关系</h2><p>最好的办法还是先定位构造函数，有了构造函数就可根据构造的先后顺序得到与之有关的其他类。</p>\n<p>在构造函数中只构造自己的类很明显是基类，对于构造函数中存在调用父类构造函数的情况，可利用虚表，在IDA中使用引用参考的功能，便可得到所有的构造函数和析构函数，进而得到它们之间的派生和继承关系。下面利用IDA进行分析实战：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#pragma warning(disable : 4996)</span><br><span class=\"line\"></span><br><span class=\"line\">class Person &#123; //基类：人类</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tPerson() &#123;</span><br><span class=\"line\">\t\tshowSpeak(); //注意，构造函数调用了虚函数</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvirtual ~Person() &#123;</span><br><span class=\"line\">\t\tshowSpeak(); //注意，析构函数调用了虚函数</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvirtual void showSpeak() &#123;</span><br><span class=\"line\">\t\t//在这个函数里调用了其他的虚函数getClassName();</span><br><span class=\"line\">\t\tprintf(&quot;%s::showSpeak()\\n&quot;, getClassName());</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvirtual const char* getClassName()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn &quot;Person&quot;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Chinese : public Person &#123; //中国人，继承自&quot;人&quot;类</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tChinese() &#123;</span><br><span class=\"line\">\t\tshowSpeak();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvirtual ~Chinese() &#123;</span><br><span class=\"line\">\t\tshowSpeak();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvirtual const char* getClassName() &#123;</span><br><span class=\"line\">\t\treturn &quot;Chinese&quot;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main(int argc, char* argv[]) &#123;</span><br><span class=\"line\">\tPerson* p = new Chinese;</span><br><span class=\"line\">\tp-&gt;showSpeak();</span><br><span class=\"line\">\tdelete p;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"main函数\"><a href=\"#main函数\" class=\"headerlink\" title=\"main函数\"></a>main函数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401260 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:00401260 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:00401260</span><br><span class=\"line\">.text:00401260 var_24          = dword ptr -24h</span><br><span class=\"line\">.text:00401260 var_20          = dword ptr -20h</span><br><span class=\"line\">.text:00401260 var_1C          = dword ptr -1Ch</span><br><span class=\"line\">.text:00401260 Block           = dword ptr -18h</span><br><span class=\"line\">.text:00401260 var_14          = dword ptr -14h</span><br><span class=\"line\">.text:00401260 var_10          = dword ptr -10h</span><br><span class=\"line\">.text:00401260 var_C           = dword ptr -0Ch</span><br><span class=\"line\">.text:00401260 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401260 argc            = dword ptr  8</span><br><span class=\"line\">.text:00401260 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:00401260 envp            = dword ptr  10h</span><br><span class=\"line\">.text:00401260</span><br><span class=\"line\">.text:00401260 ; FUNCTION CHUNK AT .text:00402190 SIZE 0000000F BYTES</span><br><span class=\"line\">.text:00401260 ; FUNCTION CHUNK AT .text:004021A4 SIZE 0000001D BYTES</span><br><span class=\"line\">.text:00401260</span><br><span class=\"line\">.text:00401260 ; __unwind &#123; // _main_SEH</span><br><span class=\"line\">.text:00401260                 push    ebp</span><br><span class=\"line\">.text:00401261                 mov     ebp, esp</span><br><span class=\"line\">.text:00401263                 push    0FFFFFFFFh</span><br><span class=\"line\">.text:00401265                 push    offset _main_SEH</span><br><span class=\"line\">.text:0040126A                 mov     eax, large fs:0</span><br><span class=\"line\">.text:00401270                 push    eax</span><br><span class=\"line\">.text:00401271                 sub     esp, 18h</span><br><span class=\"line\">.text:00401274                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:00401279                 xor     eax, ebp</span><br><span class=\"line\">.text:0040127B                 push    eax</span><br><span class=\"line\">.text:0040127C                 lea     eax, [ebp-0Ch]</span><br><span class=\"line\">.text:0040127F                 mov     large fs:0, eax</span><br><span class=\"line\">.text:00401285                 push    4               ; Size</span><br><span class=\"line\">.text:00401287                 call    ??2@YAPAXI@Z    ; operator new(uint)，申请4字节堆空间</span><br><span class=\"line\">.text:0040128C                 add     esp, 4          ; 平衡new调用的参数</span><br><span class=\"line\">.text:0040128F                 mov     [ebp-18h], eax  ; [ebp-18h]保存new调用的返回值</span><br><span class=\"line\">.text:00401292 ;   try &#123;</span><br><span class=\"line\">.text:00401292                 mov     dword ptr [ebp-4], 0</span><br><span class=\"line\">.text:00401299                 cmp     dword ptr [ebp-18h], 0 ; 检查new返回值的代码，若返回值为0，则跳过构造函数的调用</span><br><span class=\"line\">.text:0040129D                 jz      short loc_4012AC</span><br><span class=\"line\">.text:0040129F                 mov     ecx, [ebp-18h]  ; 如果new返回值不为0，则ecx保存堆地址</span><br><span class=\"line\">.text:004012A2                 call    sub_401160      ; 调用Chinese构造函数</span><br><span class=\"line\">.text:004012A7                 mov     [ebp-1Ch], eax  ; 此时返回值为Chinese的虚表</span><br><span class=\"line\">.text:004012AA                 jmp     short loc_4012B3</span><br><span class=\"line\">.text:004012AC ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:004012AC</span><br><span class=\"line\">.text:004012AC loc_4012AC:                             ; CODE XREF: _main+3D↑j</span><br><span class=\"line\">.text:004012AC                 mov     dword ptr [ebp-1Ch], 0</span><br><span class=\"line\">.text:004012B3</span><br><span class=\"line\">.text:004012B3 loc_4012B3:                             ; CODE XREF: _main+4A↑j</span><br><span class=\"line\">.text:004012B3                 mov     eax, [ebp-1Ch]</span><br><span class=\"line\">.text:004012B6                 mov     [ebp-20h], eax</span><br><span class=\"line\">.text:004012B6 ;   &#125; // starts at 401292</span><br><span class=\"line\">.text:004012B9                 mov     dword ptr [ebp-4], 0FFFFFFFFh</span><br><span class=\"line\">.text:004012C0                 mov     ecx, [ebp-20h]</span><br><span class=\"line\">.text:004012C3                 mov     [ebp-10h], ecx</span><br><span class=\"line\">.text:004012C6                 mov     edx, [ebp-10h]</span><br><span class=\"line\">.text:004012C9                 mov     eax, [edx]</span><br><span class=\"line\">.text:004012CB                 mov     ecx, [ebp-10h]  ; 虚表是Chinese的</span><br><span class=\"line\">.text:004012CE                 mov     edx, [eax+4]    ; 定位到Chinese的showSpeak函数</span><br><span class=\"line\">.text:004012D1                 call    edx             ; 调用Chinese的showSpeak函数</span><br><span class=\"line\">.text:004012D3                 mov     eax, [ebp-10h]</span><br><span class=\"line\">.text:004012D6                 mov     [ebp-14h], eax</span><br><span class=\"line\">.text:004012D9                 cmp     dword ptr [ebp-14h], 0</span><br><span class=\"line\">.text:004012DD                 jz      short loc_4012F2</span><br><span class=\"line\">.text:004012DF                 push    1</span><br><span class=\"line\">.text:004012E1                 mov     ecx, [ebp-14h]</span><br><span class=\"line\">.text:004012E4                 mov     edx, [ecx]</span><br><span class=\"line\">.text:004012E6                 mov     ecx, [ebp-14h]</span><br><span class=\"line\">.text:004012E9                 mov     eax, [edx]</span><br><span class=\"line\">.text:004012EB                 call    eax             ; 调用Chinese析构函数</span><br><span class=\"line\">.text:004012ED                 mov     [ebp-24h], eax</span><br><span class=\"line\">.text:004012F0                 jmp     short loc_4012F9</span><br><span class=\"line\">.text:004012F2 ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:004012F2</span><br><span class=\"line\">.text:004012F2 loc_4012F2:                             ; CODE XREF: _main+7D↑j</span><br><span class=\"line\">.text:004012F2                 mov     dword ptr [ebp-24h], 0</span><br><span class=\"line\">.text:004012F9</span><br><span class=\"line\">.text:004012F9 loc_4012F9:                             ; CODE XREF: _main+90↑j</span><br><span class=\"line\">.text:004012F9                 xor     eax, eax</span><br><span class=\"line\">.text:004012FB                 mov     ecx, [ebp-0Ch]</span><br><span class=\"line\">.text:004012FE                 mov     large fs:0, ecx</span><br><span class=\"line\">.text:00401305                 pop     ecx</span><br><span class=\"line\">.text:00401306                 mov     esp, ebp</span><br><span class=\"line\">.text:00401308                 pop     ebp</span><br><span class=\"line\">.text:00401309                 retn</span><br><span class=\"line\">.text:00401309 ; &#125; // starts at 401260</span><br><span class=\"line\">.text:00401309 _main           endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  int v4; // [esp+Ch] [ebp-1Ch]</span><br><span class=\"line\"></span><br><span class=\"line\">  if ( operator new(4u) )</span><br><span class=\"line\">    v4 = sub_401160();</span><br><span class=\"line\">  else</span><br><span class=\"line\">    v4 = 0;</span><br><span class=\"line\">  (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 4))(v4);</span><br><span class=\"line\">  if ( v4 )</span><br><span class=\"line\">    (**(void (__thiscall ***)(int, int))v4)(v4, 1);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从main函数的流程可以看到，会先调用new函数创建堆，然后调用Chinese的构造函数进行初始化操作，再调用Chinese的showSpeak函数，最后调用Chinese的析构函数释放相关资源，下面依次查看这些函数</p>\n<h3 id=\"Chinese的构造函数\"><a href=\"#Chinese的构造函数\" class=\"headerlink\" title=\"Chinese的构造函数\"></a>Chinese的构造函数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401160 ; _DWORD *__thiscall sub_401160(_DWORD *this)</span><br><span class=\"line\">.text:00401160 sub_401160      proc near               ; CODE XREF: _main+42↓p</span><br><span class=\"line\">.text:00401160</span><br><span class=\"line\">.text:00401160 var_10          = dword ptr -10h</span><br><span class=\"line\">.text:00401160 var_C           = dword ptr -0Ch</span><br><span class=\"line\">.text:00401160 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401160 arg_4           = dword ptr  0Ch</span><br><span class=\"line\">.text:00401160</span><br><span class=\"line\">.text:00401160 ; FUNCTION CHUNK AT .text:00402160 SIZE 00000008 BYTES</span><br><span class=\"line\">.text:00401160 ; FUNCTION CHUNK AT .text:0040216D SIZE 0000001D BYTES</span><br><span class=\"line\">.text:00401160</span><br><span class=\"line\">.text:00401160 ; __unwind &#123; // SEH_401160</span><br><span class=\"line\">.text:00401160                 push    ebp             ; Chinese构造函数</span><br><span class=\"line\">.text:00401161                 mov     ebp, esp</span><br><span class=\"line\">.text:00401163                 push    0FFFFFFFFh</span><br><span class=\"line\">.text:00401165                 push    offset SEH_401160</span><br><span class=\"line\">.text:0040116A                 mov     eax, large fs:0</span><br><span class=\"line\">.text:00401170                 push    eax</span><br><span class=\"line\">.text:00401171                 push    ecx</span><br><span class=\"line\">.text:00401172                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:00401177                 xor     eax, ebp</span><br><span class=\"line\">.text:00401179                 push    eax</span><br><span class=\"line\">.text:0040117A                 lea     eax, [ebp-0Ch]</span><br><span class=\"line\">.text:0040117D                 mov     large fs:0, eax</span><br><span class=\"line\">.text:00401183                 mov     [ebp-10h], ecx</span><br><span class=\"line\">.text:00401186                 mov     ecx, [ebp-10h]</span><br><span class=\"line\">.text:00401189                 call    sub_401080      ; 调用父类Person构造函数</span><br><span class=\"line\">.text:0040118E ;   try &#123;</span><br><span class=\"line\">.text:0040118E                 mov     dword ptr [ebp-4], 0</span><br><span class=\"line\">.text:00401195                 mov     eax, [ebp-10h]</span><br><span class=\"line\">.text:00401198                 mov     dword ptr [eax], offset ??_7Chinese@@6B@ ; const Chinese::`vftable&#x27;</span><br><span class=\"line\">.text:00401198                                         ; 将虚表设置为Chinese类的虚表</span><br><span class=\"line\">.text:0040119E                 mov     ecx, [ebp-10h]  ; this，虚表是Chinese的，可以直接调用Chinese的虚函数</span><br><span class=\"line\">.text:004011A1                 call    showSpeak       ; 调用Chinese的showSpeak</span><br><span class=\"line\">.text:004011A1 ;   &#125; // starts at 40118E</span><br><span class=\"line\">.text:004011A6                 mov     dword ptr [ebp-4], 0FFFFFFFFh</span><br><span class=\"line\">.text:004011AD                 mov     eax, [ebp-10h]</span><br><span class=\"line\">.text:004011B0                 mov     ecx, [ebp-0Ch]</span><br><span class=\"line\">.text:004011B3                 mov     large fs:0, ecx</span><br><span class=\"line\">.text:004011BA                 pop     ecx</span><br><span class=\"line\">.text:004011BB                 mov     esp, ebp</span><br><span class=\"line\">.text:004011BD                 pop     ebp</span><br><span class=\"line\">.text:004011BE                 retn</span><br><span class=\"line\">.text:004011BE ; &#125; // starts at 401160</span><br><span class=\"line\">.text:004011BE sub_401160      endp</span><br></pre></td></tr></table></figure>\n\n<p>在Chinese构造函数中，会先调用父类Person构造函数，然后再将虚表设置为自身（Chinese类）的虚表，并调用showSpeak函数</p>\n<h4 id=\"父类Person构造函数\"><a href=\"#父类Person构造函数\" class=\"headerlink\" title=\"父类Person构造函数\"></a>父类Person构造函数</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401080 ; _DWORD *__thiscall sub_401080(_DWORD *this)</span><br><span class=\"line\">.text:00401080 sub_401080      proc near               ; CODE XREF: sub_401160+29↓p</span><br><span class=\"line\">.text:00401080</span><br><span class=\"line\">.text:00401080 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401080</span><br><span class=\"line\">.text:00401080                 push    ebp             ; Person构造函数</span><br><span class=\"line\">.text:00401081                 mov     ebp, esp</span><br><span class=\"line\">.text:00401083                 push    ecx</span><br><span class=\"line\">.text:00401084                 mov     [ebp-4], ecx</span><br><span class=\"line\">.text:00401087                 mov     eax, [ebp-4]</span><br><span class=\"line\">.text:0040108A                 mov     dword ptr [eax], offset ??_7Person@@6B@ ; const Person::`vftable&#x27;</span><br><span class=\"line\">.text:0040108A                                         ; 将虚表设置为Person类的虚表</span><br><span class=\"line\">.text:00401090                 mov     ecx, [ebp-4]    ; this，虚表是父类的，可以直接调用父类虚函数</span><br><span class=\"line\">.text:00401093                 call    showSpeak       ; 调用父类的showSpeak函数</span><br><span class=\"line\">.text:00401098                 mov     eax, [ebp-4]</span><br><span class=\"line\">.text:0040109B                 mov     esp, ebp</span><br><span class=\"line\">.text:0040109D                 pop     ebp</span><br><span class=\"line\">.text:0040109E                 retn</span><br><span class=\"line\">.text:0040109E sub_401080      endp</span><br></pre></td></tr></table></figure>\n\n<p>在父类Person构造函数中，首先将虚表设置为Person类的虚表，然后直接调用此类的showSpeak函数</p>\n<p>我们来看看Person类的虚表??_7Person@@6B@里面的内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; const Person::`vftable&#x27;</span><br><span class=\"line\">.rdata:004031B8 ??_7Person@@6B@ dd offset sub_401130    ; DATA XREF: sub_401080+A↑o</span><br><span class=\"line\">.rdata:004031B8                                         ; sub_4010A0+29↑o</span><br><span class=\"line\">.rdata:004031BC                 dd offset sub_4010F0</span><br><span class=\"line\">.rdata:004031C0                 dd offset sub_401120</span><br></pre></td></tr></table></figure>\n\n<p>IDA 以 注 释 的 形 式 给 出 了 反 汇 编 代 码 中 所 有 引 用 了 标 号 <code>??_7Person@@6B@ </code>的 指 令 地 址 ， 供 我 们 分 析 时 参 考 。 如 “DATAXREF: sub_401080+A↑”，表示sub_401080函数的首地址偏移0Ah字节处的指令引用了标号<code>??_7Person@@6B@</code>，最后的上箭头“↑”表示引用处的地址在当前标号的上面，也就是说引用处的地址值比这个标号的地址值小。</p>\n<p>接着观察sub_401080和sub_4010A0中的内容，双击后可以看到，这两个名称都是函数名称，可证实??_7Person@@6B@是函数指针数组的首地址，而且其中每个函数都有对ecx的引用。在引用前没有给ecx赋值，说明这两个函数都是将ecx作为参数传递的。结合0040108A 处 的 指 令 <code>“mov     dword ptr [eax], offset ??_7Person@@6B@”</code>，其中eax保存的是new调用申请的堆空间首地址，这条指令在首地址处放置了函数指针数组的地址。</p>\n<p>结合以上种种信息，我们可以认定，eax中的地址是对象的地址，而函数指针数组就是虚表。退一步讲，即使源码不是这样，我们按此还原后的C++代码在功能和内存布局上也是等价的。</p>\n<h4 id=\"父类Person构造函数中调用的showSpeak函数\"><a href=\"#父类Person构造函数中调用的showSpeak函数\" class=\"headerlink\" title=\"父类Person构造函数中调用的showSpeak函数\"></a>父类Person构造函数中调用的showSpeak函数</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:004010F0 ; int __thiscall showSpeak(void *this)</span><br><span class=\"line\">.text:004010F0 showSpeak       proc near               ; CODE XREF: sub_401080+13↑p</span><br><span class=\"line\">.text:004010F0                                         ; sub_4010A0+32↑p ...</span><br><span class=\"line\">.text:004010F0</span><br><span class=\"line\">.text:004010F0 var_4           = dword ptr -4</span><br><span class=\"line\">.text:004010F0</span><br><span class=\"line\">.text:004010F0                 push    ebp             ; showSpeak函数</span><br><span class=\"line\">.text:004010F1                 mov     ebp, esp</span><br><span class=\"line\">.text:004010F3                 push    ecx</span><br><span class=\"line\">.text:004010F4                 mov     [ebp-4], ecx</span><br><span class=\"line\">.text:004010F7                 mov     eax, [ebp-4]</span><br><span class=\"line\">.text:004010FA                 mov     edx, [eax]</span><br><span class=\"line\">.text:004010FC                 mov     ecx, [ebp-4]</span><br><span class=\"line\">.text:004010FF                 mov     eax, [edx+8]    ; 定位到getClassName函数</span><br><span class=\"line\">.text:00401102                 call    eax             ; 调用getClassName函数</span><br><span class=\"line\">.text:00401104                 push    eax             ; char</span><br><span class=\"line\">.text:00401105                 push    offset Format   ; &quot;%s::showSpeak()\\n&quot;</span><br><span class=\"line\">.text:0040110A                 call    sub_401040</span><br><span class=\"line\">.text:0040110F                 add     esp, 8</span><br><span class=\"line\">.text:00401112                 mov     esp, ebp</span><br><span class=\"line\">.text:00401114                 pop     ebp</span><br><span class=\"line\">.text:00401115                 retn</span><br><span class=\"line\">.text:00401115 showSpeak       endp</span><br></pre></td></tr></table></figure>\n\n<p>showSpeak函数中主要是调用getClassName函数，但是调的是谁的getClassName函数还要看此时存的是谁的虚表，在父类Person构造函数中，将虚表设置为了Person类的虚表，所以此时调用的是父类Person的getClassName函数</p>\n<p>而对于Person的虚表，根据Person类中虚函数的定义，sub_401130是Person的析构函数，sub_4010F0是Person的showSpeak函数，sub_401120是Person的getClassName函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">virtual ~Person() &#123;</span><br><span class=\"line\">\t\tshowSpeak(); //注意，析构函数调用了虚函数</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">virtual void showSpeak() &#123;</span><br><span class=\"line\">\t//在这个函数里调用了其他的虚函数getClassName();</span><br><span class=\"line\">\tprintf(&quot;%s::showSpeak()\\n&quot;, getClassName());</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">virtual const char* getClassName()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn &quot;Person&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">; const Person::`vftable&#x27;</span><br><span class=\"line\">.rdata:004031B8 ??_7Person@@6B@ dd offset sub_401130    ; DATA XREF: sub_401080+A↑o</span><br><span class=\"line\">.rdata:004031B8                                         ; sub_4010A0+29↑o</span><br><span class=\"line\">.rdata:004031BC                 dd offset sub_4010F0</span><br><span class=\"line\">.rdata:004031C0                 dd offset sub_401120</span><br></pre></td></tr></table></figure>\n\n<p>查看sub_401120，可以看到确实是上面的分析</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401120 ; const char *sub_401120()</span><br><span class=\"line\">.text:00401120 sub_401120      proc near               ; DATA XREF: .rdata:004031C0↓o</span><br><span class=\"line\">.text:00401120</span><br><span class=\"line\">.text:00401120 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401120</span><br><span class=\"line\">.text:00401120                 push    ebp</span><br><span class=\"line\">.text:00401121                 mov     ebp, esp</span><br><span class=\"line\">.text:00401123                 push    ecx</span><br><span class=\"line\">.text:00401124                 mov     [ebp+var_4], ecx</span><br><span class=\"line\">.text:00401127                 mov     eax, offset aPerson ; &quot;Person&quot;</span><br><span class=\"line\">.text:0040112C                 mov     esp, ebp</span><br><span class=\"line\">.text:0040112E                 pop     ebp</span><br><span class=\"line\">.text:0040112F                 retn</span><br><span class=\"line\">.text:0040112F sub_401120      endp</span><br><span class=\"line\"></span><br><span class=\"line\">const char *sub_401120()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return &quot;Person&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Chinese类的虚表\"><a href=\"#Chinese类的虚表\" class=\"headerlink\" title=\"Chinese类的虚表\"></a>Chinese类的虚表</h4><p>查看Chinese类的虚表??_7Chinese@@6B@，再根据Chinese类中虚函数的定义，sub_401230是Chinese的析构函数，sub_4010F0是Chinese的showSpeak函数，sub_401220是Chinese的getClassName函数。可以看到，Chinese类中并没有定义showSpeak函数，所以其虚表中直接填写父类Person的showSpeak函数地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">virtual ~Chinese() &#123;</span><br><span class=\"line\">\tshowSpeak();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">virtual const char* getClassName() &#123;</span><br><span class=\"line\">\treturn &quot;Chinese&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.rdata:004031A8 ; const Chinese::`vftable&#x27;</span><br><span class=\"line\">.rdata:004031A8 ??_7Chinese@@6B@ dd offset sub_401230   ; DATA XREF: sub_401160+38↑o</span><br><span class=\"line\">.rdata:004031A8                                         ; sub_4011C0+29↑o</span><br><span class=\"line\">.rdata:004031AC                 dd offset sub_4010F0</span><br><span class=\"line\">.rdata:004031B0                 dd offset sub_401220</span><br></pre></td></tr></table></figure>\n\n<p>查看sub_401220，可以看到确实是上面的分析</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401220 ; const char *sub_401220()</span><br><span class=\"line\">.text:00401220 sub_401220      proc near               ; DATA XREF: .rdata:004031B0↓o</span><br><span class=\"line\">.text:00401220</span><br><span class=\"line\">.text:00401220 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401220</span><br><span class=\"line\">.text:00401220                 push    ebp</span><br><span class=\"line\">.text:00401221                 mov     ebp, esp</span><br><span class=\"line\">.text:00401223                 push    ecx</span><br><span class=\"line\">.text:00401224                 mov     [ebp+var_4], ecx</span><br><span class=\"line\">.text:00401227                 mov     eax, offset aChinese ; &quot;Chinese&quot;</span><br><span class=\"line\">.text:0040122C                 mov     esp, ebp</span><br><span class=\"line\">.text:0040122E                 pop     ebp</span><br><span class=\"line\">.text:0040122F                 retn</span><br><span class=\"line\">.text:0040122F sub_401220      endp</span><br><span class=\"line\"></span><br><span class=\"line\">const char *sub_401220()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return &quot;Chinese&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Chinese的析构函数\"><a href=\"#Chinese的析构函数\" class=\"headerlink\" title=\"Chinese的析构函数\"></a>Chinese的析构函数</h3><p>根据前面分析的Chinese的虚表得出sub_401230是Chinese的析构函数，sub_4010F0是Chinese的showSpeak函数，sub_401220是Chinese的getClassName函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">virtual ~Chinese() &#123;</span><br><span class=\"line\">\tshowSpeak();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">virtual const char* getClassName() &#123;</span><br><span class=\"line\">\treturn &quot;Chinese&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.rdata:004031A8 ; const Chinese::`vftable&#x27;</span><br><span class=\"line\">.rdata:004031A8 ??_7Chinese@@6B@ dd offset sub_401230   ; DATA XREF: sub_401160+38↑o</span><br><span class=\"line\">.rdata:004031A8                                         ; sub_4011C0+29↑o</span><br><span class=\"line\">.rdata:004031AC                 dd offset sub_4010F0</span><br><span class=\"line\">.rdata:004031B0                 dd offset sub_401220</span><br></pre></td></tr></table></figure>\n\n<p>查看sub_401230，析构部分主要在sub_4011C0函数中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401230 ; _DWORD *__thiscall sub_401230(_DWORD *this, char)</span><br><span class=\"line\">.text:00401230 sub_401230      proc near               ; DATA XREF: .rdata:const Chinese::`vftable&#x27;↓o</span><br><span class=\"line\">.text:00401230</span><br><span class=\"line\">.text:00401230 Block           = dword ptr -4</span><br><span class=\"line\">.text:00401230 arg_0           = dword ptr  8</span><br><span class=\"line\">.text:00401230</span><br><span class=\"line\">.text:00401230                 push    ebp             ; Chinese析构函数</span><br><span class=\"line\">.text:00401231                 mov     ebp, esp</span><br><span class=\"line\">.text:00401233                 push    ecx</span><br><span class=\"line\">.text:00401234                 mov     [ebp-4], ecx</span><br><span class=\"line\">.text:00401237                 mov     ecx, [ebp-4]</span><br><span class=\"line\">.text:0040123A                 call    sub_4011C0      ; Chinese析构函数</span><br><span class=\"line\">.text:0040123F                 mov     eax, [ebp+arg_0]</span><br><span class=\"line\">.text:00401242                 and     eax, 1</span><br><span class=\"line\">.text:00401245                 jz      short loc_401255</span><br><span class=\"line\">.text:00401247                 push    4</span><br><span class=\"line\">.text:00401249                 mov     ecx, [ebp+Block]</span><br><span class=\"line\">.text:0040124C                 push    ecx             ; Block</span><br><span class=\"line\">.text:0040124D                 call    sub_401348</span><br><span class=\"line\">.text:00401252                 add     esp, 8</span><br><span class=\"line\">.text:00401255</span><br><span class=\"line\">.text:00401255 loc_401255:                             ; CODE XREF: sub_401230+15↑j</span><br><span class=\"line\">.text:00401255                 mov     eax, [ebp+Block]</span><br><span class=\"line\">.text:00401258                 mov     esp, ebp</span><br><span class=\"line\">.text:0040125A                 pop     ebp</span><br><span class=\"line\">.text:0040125B                 retn    4</span><br><span class=\"line\">.text:0040125B sub_401230      endp</span><br></pre></td></tr></table></figure>\n\n<p>查看sub_4011C0函数：</p>\n<p>首先会将虚表设置为Chinese类的虚表，然后调用Chinese的showSpeak函数，最后再调用父类Person析构函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:004011C0 ; int __thiscall sub_4011C0(_DWORD *this)</span><br><span class=\"line\">.text:004011C0 sub_4011C0      proc near               ; CODE XREF: sub_401230+A↓p</span><br><span class=\"line\">.text:004011C0</span><br><span class=\"line\">.text:004011C0 var_10          = dword ptr -10h</span><br><span class=\"line\">.text:004011C0 var_C           = dword ptr -0Ch</span><br><span class=\"line\">.text:004011C0</span><br><span class=\"line\">.text:004011C0 ; FUNCTION CHUNK AT .text:00402140 SIZE 0000001D BYTES</span><br><span class=\"line\">.text:004011C0</span><br><span class=\"line\">.text:004011C0 ; __unwind &#123; // SEH_4011C0</span><br><span class=\"line\">.text:004011C0                 push    ebp</span><br><span class=\"line\">.text:004011C1                 mov     ebp, esp</span><br><span class=\"line\">.text:004011C3                 push    0FFFFFFFFh</span><br><span class=\"line\">.text:004011C5                 push    offset SEH_4011C0</span><br><span class=\"line\">.text:004011CA                 mov     eax, large fs:0</span><br><span class=\"line\">.text:004011D0                 push    eax</span><br><span class=\"line\">.text:004011D1                 push    ecx</span><br><span class=\"line\">.text:004011D2                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:004011D7                 xor     eax, ebp</span><br><span class=\"line\">.text:004011D9                 push    eax</span><br><span class=\"line\">.text:004011DA                 lea     eax, [ebp-0Ch]</span><br><span class=\"line\">.text:004011DD                 mov     large fs:0, eax</span><br><span class=\"line\">.text:004011E3                 mov     [ebp-10h], ecx</span><br><span class=\"line\">.text:004011E6                 mov     eax, [ebp-10h]</span><br><span class=\"line\">.text:004011E9                 mov     dword ptr [eax], offset ??_7Chinese@@6B@ ; const Chinese::`vftable&#x27;</span><br><span class=\"line\">.text:004011E9                                         ; 将虚表设置为Chinese类的虚表</span><br><span class=\"line\">.text:004011EF                 mov     ecx, [ebp-10h]  ; 此时虚表存的是Chinese的虚表</span><br><span class=\"line\">.text:004011F2                 call    sub_4010F0      ; 调用Chinese的showSpeak</span><br><span class=\"line\">.text:004011F7                 mov     ecx, [ebp-10h]</span><br><span class=\"line\">.text:004011FA                 call    sub_4010A0      ; 调用父类Person析构函数</span><br><span class=\"line\">.text:004011FF                 mov     ecx, [ebp-0Ch]</span><br><span class=\"line\">.text:00401202                 mov     large fs:0, ecx</span><br><span class=\"line\">.text:00401209                 pop     ecx</span><br><span class=\"line\">.text:0040120A                 mov     esp, ebp</span><br><span class=\"line\">.text:0040120C                 pop     ebp</span><br><span class=\"line\">.text:0040120D                 retn</span><br><span class=\"line\">.text:0040120D ; &#125; // starts at 4011C0</span><br><span class=\"line\">.text:0040120D sub_4011C0      endp</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"父类Person析构函数\"><a href=\"#父类Person析构函数\" class=\"headerlink\" title=\"父类Person析构函数\"></a>父类Person析构函数</h2><p>首先会将虚表设置为Person类的虚表，然后调用Person的showSpeak函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:004010A0 ; int __thiscall sub_4010A0(_DWORD *this)</span><br><span class=\"line\">.text:004010A0 sub_4010A0      proc near               ; CODE XREF: sub_401130+A↓p</span><br><span class=\"line\">.text:004010A0                                         ; sub_4011C0+3A↓p ...</span><br><span class=\"line\">.text:004010A0</span><br><span class=\"line\">.text:004010A0 var_10          = dword ptr -10h</span><br><span class=\"line\">.text:004010A0 var_C           = dword ptr -0Ch</span><br><span class=\"line\">.text:004010A0 arg_4           = dword ptr  0Ch</span><br><span class=\"line\">.text:004010A0</span><br><span class=\"line\">.text:004010A0 ; FUNCTION CHUNK AT .text:00402140 SIZE 0000001D BYTES</span><br><span class=\"line\">.text:004010A0</span><br><span class=\"line\">.text:004010A0 ; __unwind &#123; // SEH_4011C0</span><br><span class=\"line\">.text:004010A0                 push    ebp</span><br><span class=\"line\">.text:004010A1                 mov     ebp, esp</span><br><span class=\"line\">.text:004010A3                 push    0FFFFFFFFh</span><br><span class=\"line\">.text:004010A5                 push    offset SEH_4011C0</span><br><span class=\"line\">.text:004010AA                 mov     eax, large fs:0</span><br><span class=\"line\">.text:004010B0                 push    eax</span><br><span class=\"line\">.text:004010B1                 push    ecx</span><br><span class=\"line\">.text:004010B2                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:004010B7                 xor     eax, ebp</span><br><span class=\"line\">.text:004010B9                 push    eax</span><br><span class=\"line\">.text:004010BA                 lea     eax, [ebp-0Ch]</span><br><span class=\"line\">.text:004010BD                 mov     large fs:0, eax</span><br><span class=\"line\">.text:004010C3                 mov     [ebp-10h], ecx</span><br><span class=\"line\">.text:004010C6                 mov     eax, [ebp-10h]</span><br><span class=\"line\">.text:004010C9                 mov     dword ptr [eax], offset ??_7Person@@6B@ ; const Person::`vftable&#x27;</span><br><span class=\"line\">.text:004010C9                                         ; 将虚表设置为Person类的虚表</span><br><span class=\"line\">.text:004010CF                 mov     ecx, [ebp-10h]  ; 此时虚表存的是Person的虚表</span><br><span class=\"line\">.text:004010D2                 call    sub_4010F0      ; 调用Person的showSpeak函数</span><br><span class=\"line\">.text:004010D7                 mov     ecx, [ebp-0Ch]</span><br><span class=\"line\">.text:004010DA                 mov     large fs:0, ecx</span><br><span class=\"line\">.text:004010E1                 pop     ecx</span><br><span class=\"line\">.text:004010E2                 mov     esp, ebp</span><br><span class=\"line\">.text:004010E4                 pop     ebp</span><br><span class=\"line\">.text:004010E5                 retn</span><br><span class=\"line\">.text:004010E5 ; &#125; // starts at 4010A0</span><br><span class=\"line\">.text:004010E5 sub_4010A0      endp</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>根据前面的分析可以得到派生关系，在构造函数中先填写父类的虚表，然 后 按 继 承 的 层 次 关 系 逐 层 填 写 子 类 的 虚 表</p>\n","text":"在C++的继承关系中，子类具备父类所有成员数据和成员函数。子 类 对 象 可 以 直 接 使 用 父 类 中 声 明 为 公 有 （ public ） 和 保 ...","permalink":"/post/C++逆向——识别类和类之间的关系","photos":[],"count_time":{"symbolsCount":"70k","symbolsTime":"1:04"},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB\"><span class=\"toc-text\">定义基类和派生类</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">类的构造顺序</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AD%90%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80\"><span class=\"toc-text\">子类的内存布局</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AD%90%E7%B1%BB%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">子类调用父类函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81%EF%BC%88%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%89\"><span class=\"toc-text\">多态（虚函数）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%BA%E7%B1%BB%E8%AF%B4%E8%AF%9D%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%9A%E6%80%81%E6%A8%A1%E6%8B%9F%E7%B1%BB%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">人类说话方法的多态模拟类结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">在父类构造函数中调用虚函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">构造函数和析构函数中调用虚函数的流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%B1%BB%E4%B8%8E%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">如何识别代码中类与类之间的关系</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#main%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">main函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Chinese%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">Chinese的构造函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%88%B6%E7%B1%BBPerson%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">父类Person构造函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%88%B6%E7%B1%BBPerson%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E7%9A%84showSpeak%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">父类Person构造函数中调用的showSpeak函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Chinese%E7%B1%BB%E7%9A%84%E8%99%9A%E8%A1%A8\"><span class=\"toc-text\">Chinese类的虚表</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Chinese%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">Chinese的析构函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%88%B6%E7%B1%BBPerson%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">父类Person析构函数</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"C++逆向——多重继承","uid":"9301d0d9fdad61b6c1164e4bbd50c3da","slug":"C++逆向——多重继承","date":"2023-02-17T07:22:42.000Z","updated":"2025-06-07T18:30:39.668Z","comments":true,"path":"api/articles/C++逆向——多重继承.json","keywords":null,"cover":[],"text":"当子类拥有多个父类（如类C继承自类A同时也继承自类B）时，便构成了多重继承关系。在多重继承的情况下，子类继承的父类变为多个，但其结构与单一继承相似。 多重继承类...","permalink":"/post/C++逆向——多重继承","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"17 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"虚函数","uid":"cff45971697c57c78d8a68c46a85aef2","slug":"C++逆向——虚函数","date":"2023-02-13T06:11:19.000Z","updated":"2025-06-07T18:09:49.856Z","comments":true,"path":"api/articles/C++逆向——虚函数.json","keywords":null,"cover":[],"text":"虚函数是面向对象程序设计的关键组成部分。对于具有虚函数的类而言，构造函数和析构函数的识别过程更加简单。而且，在类中定义虚函数之后，如果没有提供构造函数，编译器会...","permalink":"/post/C++逆向——虚函数","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}