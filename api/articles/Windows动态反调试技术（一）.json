{"title":"Windows动态反调试技术（一）","uid":"744ee437e256eacc7e89be203fb836fd","slug":"Windows动态反调试技术（一）","date":"2025-07-09T13:39:34.000Z","updated":"2025-06-09T21:26:29.686Z","comments":true,"path":"api/articles/Windows动态反调试技术（一）.json","keywords":null,"cover":[],"content":"<h1 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h1><h2 id=\"SetUnhandledExceptionFilter\"><a href=\"#SetUnhandledExceptionFilter\" class=\"headerlink\" title=\"SetUnhandledExceptionFilter()\"></a>SetUnhandledExceptionFilter()</h2><p>进程中发生异常时，若SEH未处理或注册的SEH根本不存在，此时会调用执行系统的<strong>kernel32!UnhandledExceptionFilter()</strong> API。该函数内部会运行系统的最后一个异常处理器（名为Top Level Exception Filter或Last Exception Filter）。系统最后的异常处理器通常会弹出错误消息框，然后终止进程。</p>\n<p>值得注意的是，<strong>kernel32!UnhandledExceptionFilter()</strong> 内部调用了ntdll!NtQueryInformationProcess(ProcessDebugPort) API（静态反调试技术），以判断是否正在调试进程。若进程正常运行（非调试运行），则运行系统最后的异常处理器；若进程处于调试中，则将异常派送给调试器。通过<strong>kernel32!SetUnhandledExceptionFilter()</strong> API可以修改系统最后的异常处理器（Top Level Exception Filter）。</p>\n<h3 id=\"SetUnhandledExceptionFilter-API\"><a href=\"#SetUnhandledExceptionFilter-API\" class=\"headerlink\" title=\"SetUnhandledExceptionFilter() API\"></a>SetUnhandledExceptionFilter() API</h3><p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> LPTOP_LEVEL_EXCEPTION_FILTER WINAPI <span class=\"title function_\">SetUnHandledExceptionFilter</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">__in LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter</span></span><br><span class=\"line\"><span class=\"params\">)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>调用该函数修改系统最后异常处理器时，只要将新的Top Level Exception Filter函数地址传递给函数的IpTopLeveIExceptionFilter参数即可（<strong>返回值为上一个Last Exception Filter函数地址</strong>）。Top Level Exception Filter函数定义如下：</p>\n<h3 id=\"TopLevelExceptionFilter-API\"><a href=\"#TopLevelExceptionFilter-API\" class=\"headerlink\" title=\"TopLevelExceptionFilter() API\"></a>TopLevelExceptionFilter() API</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">EXCEPTION_POINTERS</span>&#123;</span></span><br><span class=\"line\">  PEXCEPTION_RECORD ExceptionRecord;</span><br><span class=\"line\">  PCONTEXT          ContextRecord;</span><br><span class=\"line\">&#125;EXCEPTION_POINTERS,*PEXCEPTION_POINTERS;</span><br><span class=\"line\"></span><br><span class=\"line\">LONG <span class=\"title function_\">TopLevelExceptionFilter</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">PEXCEPTION_POINTERS pExcept</span></span><br><span class=\"line\"><span class=\"params\">)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>基于异常的反调试技术中，通常先特意触发异常，然后在新注册的Last Exception Filter内部判断进程正常运行还是调试运行，并根据判断结果修改EIP值。系统在此过程中自行判断调试与否。这种反调试技术融合了静态与动态方法，下面通过练习示例进一步学习。</p>\n<h3 id=\"基于Windows10的练习\"><a href=\"#基于Windows10的练习\" class=\"headerlink\" title=\"基于Windows10的练习\"></a>基于Windows10的练习</h3><p>1.使用X32dbg（也可用ollydbg）打开DynAD_SUEF.exe，并在程序入口点设置断点</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%B8%80%EF%BC%89/%E5%BC%82%E5%B8%B8/Win10_DynAD_SUEF_%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E6%96%AD%E7%82%B9.png\"></p>\n<p>2.运行进入401030，可以看到程序会调用SetUnhandledExceptionFilter()来注册新的TopLevelExceptionFilter（即图中401000地址处），并把上一个LastExceptionFilter函数保存到ds:[40CB3C]处。然后将exa置0，若401052地址处的指令，程序将尝试向未定义的进程虚拟内存地址（0）写入值，这会引发无效的内存非法访问异常。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%B8%80%EF%BC%89/%E5%BC%82%E5%B8%B8/Win10_DynAD_SUEF_%E6%B3%A8%E5%86%8C%E6%96%B0%E7%9A%84TopLevelExceptionFilter.png\"></p>\n<p>3.查看新的TopLevelExceptionFilter函数代码，可以看到该函数首先再次调用SetUnhandledExceptionFilter()来恢复Exception Filter（即ds:[40CB3C]），然后获取pExcept-&gt;ContextRecord-&gt;Eip,并使其加4，而原来的pExcept-&gt;ContextRecord-&gt;Eip保存的是异常发生的地址（由2可知为401052），所以新的pExcept-&gt;ContextRecord-&gt;Eip则为401056。也就是说，返回Exception Filter后，继续从401056地址处执行代码。</p>\n<p>附：用[ebp+]为参数（+8是第一个参数，+C是第二个参数），而根据之前的语法，TopLevelExceptionFilter函数的传入的参数为pExcept（即[ebp+8]&#x3D;pExcept），而pExcept的第二个成员指向pContext(或ContextRecord，即[ecx+4]&#x3D;pContext);而pContext偏移B8处的成员为Eip（即[eax+B8]&#x3D;pContext-&gt;Eip）.</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%B8%80%EF%BC%89/%E5%BC%82%E5%B8%B8/Win10_DynAD_SUEF_%E6%96%B0%E7%9A%84TopLevelExceptionFilter%E4%BB%A3%E7%A0%81.png\"></p>\n<p>4.根据以上的分析，分别在401000、401052、401056等地址处下断点，根据前面的学习可以知道，正常情况下（非调试运行），当程序在401052处触发异常后，就会进入401000中进行处理，处理完成后，就会回到401056继续运行，但是用X32dbg调试程序后，观察程序执行过程，发现程序并未命中401000、401056这俩断点，且一直在异常处循环，这是因为若SEH未处理或注册的SEH根本不存在，此时会调用执行系统的<strong>kernel32!UnhandledExceptionFilter()</strong> API，该函数内部会运行系统的最后一个异常处理器，但<strong>kernel32!UnhandledExceptionFilter()</strong> 内部会调用ntdll!NtQueryInformationProcess(ProcessDebugPort) API（静态反调试技术），以判断是否正在调试进程。若进程正常运行（非调试运行），则运行系统最后的异常处理器；若进程处于调试中，则将异常派送给调试器。所以在调试时，还要绕过ntdll!NtQueryInformationProcess(ProcessDebugPort) API静态反调试以像正常运行那样调试程序。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%B8%80%EF%BC%89/%E5%BC%82%E5%B8%B8/Win10_DynAD_SUEF_%E6%9C%AA%E7%BB%95%E8%BF%87%E5%8F%8D%E8%B0%83%E8%AF%95%E6%83%85%E5%86%B5%E4%B8%8B%E8%B0%83%E8%AF%95%E6%96%AD%E7%82%B9%E5%91%BD%E4%B8%AD%E6%83%85%E5%86%B5.png\"></p>\n<p>5.对于Windows10，查找调用ntdll!NtQueryInformationProcess的方式如下：</p>\n<p>①首先运行程序到401030处，然后查找ntdll!NtQueryInformationProcess并设置断点</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%B8%80%EF%BC%89/%E5%BC%82%E5%B8%B8/Win10_DynAD_SUEF_%E6%9F%A5%E6%89%BEntdll!NtQueryInformationProcess%E5%B9%B6%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9.png\"></p>\n<p>②然后运行401052处的指令触发异常，然后F9两次（或一次），直到进入ntdll!NtQueryInformationProcess函数内部。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%B8%80%EF%BC%89/%E5%BC%82%E5%B8%B8/Win10_DynAD_SUEF_%E6%96%AD%E7%82%B9%E5%88%B0ntdll!NtQueryInformationProcess%E5%86%85%E9%83%A8.png\"></p>\n<p>③接着点击运行直到返回（Ctrl+F9），然后返回调用处，查看调用ntdll!NtQueryInformationProcess函数时第二个参数传入的值是否是ProcessDebug（7），此值用于探测调试器，以及所处模块是否为kernelBase。如下面图片：第一张图显示调用ntdll!NtQueryInformationProcess函数时传入的第二个参数为22，所处模块为ntdll，所以还要继续点击运行直到返回直到找到符合条件的；第二张图中调用ntdll!NtQueryInformationProcess函数时传入的第二个参数为7，所处模块为kernelBase，符合条件，然后在push第三个参数（即第二张图中768922E6 push eax处，此处后面需要修改值以绕过反调试）和调用结束返回处（即768922F4 test eax,eax）下断点，并把ntdll!NtQueryInformationProcess函数内部的断点去掉</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%B8%80%EF%BC%89/%E5%BC%82%E5%B8%B8/Win10_DynAD_SUEF_%E8%B0%83%E7%94%A8ntdll!NtQueryInformationProcess%E9%9D%9E%E8%BF%9B%E8%A1%8C%E5%8F%8D%E8%B0%83%E8%AF%95.png\"></p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%B8%80%EF%BC%89/%E5%BC%82%E5%B8%B8/Win10_DynAD_SUEF_%E8%B0%83%E7%94%A8ntdll!NtQueryInformationProcess%E8%BF%9B%E8%A1%8C%E5%8F%8D%E8%B0%83%E8%AF%95.png\"></p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%B8%80%EF%BC%89/%E5%BC%82%E5%B8%B8/Win10_DynAD_SUEF_%E5%88%A0%E9%99%A4ntdll!NtQueryInformationProcess%E5%86%85%E9%83%A8%E6%96%AD%E7%82%B9.png\"></p>\n<p>④重新运行程序，直到断点停到kernelBase模块调用ntdll!NtQueryInformationProcess进行调试检测时传入第三个参数的指令处（即图中768922E6 push eax处），然后在寄存器窗口中右键eax选择在内存窗口中转到，以便监控并修改调用结束后第三个参数，这个参数用于标识是否处于调试中（为0表示处于非调试状态，为0xFFFFFFFF表示处于调试状态）</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%B8%80%EF%BC%89/%E5%BC%82%E5%B8%B8/Win10_DynAD_SUEF_%E8%B0%83%E7%94%A8%E6%97%B6%E7%9B%91%E6%8E%A7%E4%BC%A0%E5%85%A5ntdll!NtQueryInformationProcess%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0.png\"></p>\n<p>⑤继续运行直到停到ntdll!NtQueryInformationProcess调用结束返回处（即768922F4 test eax,eax），可以观察到上一步要监测的第三个参数的值变成了0xFFFFFFFF</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%B8%80%EF%BC%89/%E5%BC%82%E5%B8%B8/Win10_DynAD_SUEF_ntdll!NtQueryInformationProcess%E8%B0%83%E7%94%A8%E7%BB%93%E6%9D%9F%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E5%8F%98%E4%B8%BA0xFFFFFFFF.png\"></p>\n<p>⑥此时需要将第三个参数修改为0以绕过反调试检测</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%B8%80%EF%BC%89/%E5%BC%82%E5%B8%B8/Win10_DynAD_SUEF_%E4%BF%AE%E6%94%B9ntdll!NtQueryInformationProcess%E8%B0%83%E7%94%A8%E7%BB%93%E6%9D%9F%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E4%B8%BA0.png\"></p>\n<p>⑦修改ntdll!NtQueryInformationProcess调用结束后第三个参数的值，然后继续运行，可以发现即使在调试时，也能正常运行401000、401056处的代码</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%B8%80%EF%BC%89/%E5%BC%82%E5%B8%B8/Win10_DynAD_SUEF_%E7%BB%95%E8%BF%87%E5%8F%8D%E8%B0%83%E8%AF%95%E5%90%8E%E7%9A%84%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5.png\"></p>\n<h1 id=\"Timing-Check\"><a href=\"#Timing-Check\" class=\"headerlink\" title=\"Timing Check\"></a>Timing Check</h1><h2 id=\"时间间隔测量法\"><a href=\"#时间间隔测量法\" class=\"headerlink\" title=\"时间间隔测量法\"></a>时间间隔测量法</h2><p>测量时间间隔的方法有很多种，常用方法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.Counter based method(利用CPU的计数器Counter)</span><br><span class=\"line\">RDTSC</span><br><span class=\"line\">kernel32!QueryPerformanceCounter()/ntdll!NtQueryPerformanceCounter()</span><br><span class=\"line\">kernel32!GetTickCount()</span><br><span class=\"line\"></span><br><span class=\"line\">2.Time based method(利用系统的实际时间)</span><br><span class=\"line\">timeGetTime()</span><br><span class=\"line\">_ftime()</span><br><span class=\"line\"></span><br><span class=\"line\">计数器的准确程度由高到低排列如下：</span><br><span class=\"line\">RDTSC&gt;NtQueryPerformanceCounter()&gt;GetTickCount()</span><br><span class=\"line\">NtQueryPerformanceCounter()与GetTickCount()使用相同的硬件(PerformanceCounter)，但二者准确度不同；</span><br><span class=\"line\">RDTSC是CPU内部的计数器，准确度最高</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RDTSC\"><a href=\"#RDTSC\" class=\"headerlink\" title=\"RDTSC\"></a>RDTSC</h2><p>RDTSC(Read Time Stamp Counter，读取时间戳计数器)</p>\n<p>x86 CPU中存在一个名为TSC（Time Stamp Counter，时间戳计数器）的64位寄存器。CPU対<br>每个Clock Cycle（时钟周期）计数，然后保存到TSC。RDTSC是一条汇编指令，用来将TSC值读入EDX:EAX寄存器（TSC大小为64位，其高32位被保存至EDX寄存器，低32位被保存至EAX寄存器）。</p>\n<h2 id=\"基于Windows10的练习-1\"><a href=\"#基于Windows10的练习-1\" class=\"headerlink\" title=\"基于Windows10的练习\"></a>基于Windows10的练习</h2><p>1.使用X32dbg（也可用ollydbg）打开DynAD_RDTSC.exe，并在程序入口点设置断点</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%B8%80%EF%BC%89/Timing_Check/Win10_DynAD_RDTSC_%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E6%96%AD%E7%82%B9.png\"></p>\n<p>2.下面是程序利用RDTSC进行反调试的代码流</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">            .....                                                   </span><br><span class=\"line\">; 第一次执行RDTSC指令——将TSC保存到EDX:EAX(64位)</span><br><span class=\"line\">0040101C     rdtsc</span><br><span class=\"line\"> </span><br><span class=\"line\">; 将结果值放入栈中                                                     </span><br><span class=\"line\">0040101E     push edx                                                   </span><br><span class=\"line\">0040101F     push eax</span><br><span class=\"line\"></span><br><span class=\"line\">; 用于消耗时间的循环(实际代码可能很复杂)                                                   </span><br><span class=\"line\">00401020     xor eax,eax                                                </span><br><span class=\"line\">00401022     mov ecx,3E8                                                </span><br><span class=\"line\">00401027     inc eax                                                    </span><br><span class=\"line\">00401028     loop dynad_rdtsc.401027</span><br><span class=\"line\">      </span><br><span class=\"line\">; 第二次执行RDTSC指令                              </span><br><span class=\"line\">0040102A     rdtsc</span><br><span class=\"line\"></span><br><span class=\"line\">; 在栈中输入第一次求得的TSC                                                      </span><br><span class=\"line\">0040102C     pop esi                                                    </span><br><span class=\"line\">0040102D     pop edi</span><br><span class=\"line\"> </span><br><span class=\"line\">; 比较TSC值的高位                                                   </span><br><span class=\"line\">0040102E     cmp edx,edi                                                </span><br><span class=\"line\">00401030     ja dynad_rdtsc.40103E</span><br><span class=\"line\"></span><br><span class=\"line\">; 比较TSC值的低位差值</span><br><span class=\"line\">; 若比特定值(0xFFFFFF)大，则断定处于调试状态                                      </span><br><span class=\"line\">00401032     sub eax,esi                                                </span><br><span class=\"line\">00401034     mov dword ptr ss:[ebp-4],eax                               </span><br><span class=\"line\">00401037     cmp eax,FFFFFF                                             </span><br><span class=\"line\">0040103C     jb dynad_rdtsc.401042</span><br><span class=\"line\"></span><br><span class=\"line\">; 在比较语句的作用下进入异常触发代码，进程非正常终止                                      </span><br><span class=\"line\">0040103E     xor eax,eax                                                </span><br><span class=\"line\">00401040     mov dword ptr ds:[eax],eax      ; 异常</span><br><span class=\"line\">   </span><br><span class=\"line\">; 忽略比较语句，继续运行                        </span><br><span class=\"line\">00401042     popad</span><br><span class=\"line\">             .....        </span><br></pre></td></tr></table></figure>\n\n<p>上述代码可以看出，2次RDTSC指令调用之间存在一定的时间间隔，通过计算时间差值(Delta)来判断进程是否处于调试状态。Delta值不固定，一般在0xFFFF~0XFFFFFFFF之间取值。<br>40102A地址间的代码区域中，只要执行1次StepInto（F7）或StepOver（F8）命令，Count的间隔就会大于0xFFFFFFFF。<br>3.破解之法<br>有几种方法可以破解以上反调试技术。</p>\n<p>（1）不使用跟踪命令，直接使用RUN命令越过相关代码。<br>在40102C地址处设置断点后运行。虽然运行速度略慢于正常运行速度，但与代码跟踪相比要快很多。</p>\n<p>（2）操作第二个RDTSC的结果值（EDX:EAX）</p>\n<p>操作第二个RDTSC的结果值，使之与第一个结果值相同，从而顺利通过CMP语句</p>\n<p>（3）操纵条件分支指令（CMP&#x2F;Jcc）</p>\n<p>在调试器中强制修改Flags的值，阻止执行跳转至40103E处。</p>\n<p>CF与ZF全为0时，JA指令执行跳转动作。只要将CF与ZF之一的值修改为1，JA指令即失效。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%EF%BC%88%E4%B8%80%EF%BC%89/Timing_Check/Win10_DynAD_RDTSC_%E4%BF%AE%E6%94%B9ZF%E9%98%BB%E6%AD%A2JA%E8%B7%B3%E8%BD%AC.png\"></p>\n<p>（4）利用内核模式驱动程序使RDTSC指令失效</p>\n<p>利用内核模式驱动程序可以从根本上使基于RDTSC的动态反调试技术失效（其实，OllydAdvanced PlugIn就采用了该方法）。</p>\n<h2 id=\"检测系统时钟\"><a href=\"#检测系统时钟\" class=\"headerlink\" title=\"检测系统时钟\"></a>检测系统时钟</h2><p>当进程被调试时，调试器事件处理代码、步过指令等将占用 CPU 循环。如果相邻指令之间所花费的时间如果大大超出常规，就意味着进程很可能是在被调试。有如下两种时钟检测来探测调试器存在的方法：</p>\n<ul>\n<li>记录执行一段操作前后的时间戳，然后比较这两个时间戳，如果存在滞后，则可以认为存在调试器</li>\n<li>记录触发一个异常前后的时间戳。如果不调试进程，可以很快处理完异常，因为调试器处理异常的速度非常慢。默认情况下，调试器处理异常时需要认为干预，这导致大量延迟。虽然很多调试器允许我们忽略异常，将异常直接返回给程序，但这样操作仍然存在不小的延迟</li>\n</ul>\n<p>首先我们可以使用rdtsc指令，它返回至系统重新启动以来的时钟数，并且将其作为一个64位的值存入edx:eax中。恶意代码运行两次rdstc指令，然后比较两次读取之间的差值来判断是否存在调试器。</p>\n<p>另外也可以使用函数QueryPerformanceCounter和GetTickCount。同rdstc指令一样，这两个API函数也可以被用来执行一个反调试的时钟检测。为了获取比较的时间差，调用两次函数查询这个计数器，如果两次调用时间话费时间过于长，则可以认为存在调试器。</p>\n<p>GetTickCount返回从操作系统启动所经过的毫秒数。调用两次此函数，如果返回值的差值相差反常，就说明在调试状态。</p>\n<p>QueryPerformanceCounter和GetTickCount的原理类似，这里以GetTickCount为例说明使用方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void CAntiDebugDlg::OnBnClickedBtnGettickcount()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // TODO: 在此添加控件通知处理程序代码</span><br><span class=\"line\">    DWORD dwTime1 = 0;</span><br><span class=\"line\">    DWORD dwTime2 = 0;</span><br><span class=\"line\">    dwTime1 = GetTickCount();</span><br><span class=\"line\">    GetCurrentProcessId();</span><br><span class=\"line\">    GetCurrentProcessId();</span><br><span class=\"line\">    GetCurrentProcessId();</span><br><span class=\"line\">    dwTime2 = GetTickCount();</span><br><span class=\"line\">    if (dwTime2 - dwTime1 &gt; 100)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MessageBoxW(L&quot;Being Debugged!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        MessageBoxW(L&quot;Not Being Debugged!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","feature":true,"text":"异常SetUnhandledExceptionFilter()进程中发生异常时，若SEH未处理或注册的SEH根本不存在，此时会调用执行系统的kernel32!U...","permalink":"/post/Windows动态反调试技术（一）","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":14,"path":"api/tags/逆向.json"},{"name":"Windows动态反调试技术","slug":"Windows动态反调试技术","count":2,"path":"api/tags/Windows动态反调试技术.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">异常</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SetUnhandledExceptionFilter\"><span class=\"toc-text\">SetUnhandledExceptionFilter()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SetUnhandledExceptionFilter-API\"><span class=\"toc-text\">SetUnhandledExceptionFilter() API</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TopLevelExceptionFilter-API\"><span class=\"toc-text\">TopLevelExceptionFilter() API</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8EWindows10%E7%9A%84%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">基于Windows10的练习</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Timing-Check\"><span class=\"toc-text\">Timing Check</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E6%B5%8B%E9%87%8F%E6%B3%95\"><span class=\"toc-text\">时间间隔测量法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RDTSC\"><span class=\"toc-text\">RDTSC</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8EWindows10%E7%9A%84%E7%BB%83%E4%B9%A0-1\"><span class=\"toc-text\">基于Windows10的练习</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F\"><span class=\"toc-text\">检测系统时钟</span></a></li></ol></li></ol>","author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"Windows动态反调试技术（二）","uid":"bd414604d17df76b597f4081d3f02f14","slug":"Windows动态反调试技术（二）","date":"2025-06-11T13:05:26.000Z","updated":"2025-06-09T21:26:58.273Z","comments":true,"path":"api/articles/Windows动态反调试技术（二）.json","keywords":null,"cover":[],"text":"单步执行TF值设置为1时，CPU将进入单步执行（Single Step）模式。单步执行模式中，CPU执行1条指令后即触发1个EXCEPTION_SINGLE_S...","permalink":"/post/Windows动态反调试技术（二）","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":14,"path":"api/tags/逆向.json"},{"name":"Windows动态反调试技术","slug":"Windows动态反调试技术","count":2,"path":"api/tags/Windows动态反调试技术.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}