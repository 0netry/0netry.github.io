{"title":"构造函数和析构函数","uid":"da3425ec82161418a9e220cbb5402aa8","slug":"C++逆向——构造函数","date":"2023-02-08T11:47:12.000Z","updated":"2025-06-07T16:11:40.927Z","comments":true,"path":"api/articles/C++逆向——构造函数.json","keywords":null,"cover":[],"content":"<p>构造函数与析构函数是类重要的组成部分，在类中起到至关重要的作用。<strong>构造函数常用来完成对象生成时的数据初始化工作，而析构函数则常用于在对象销毁时释放对象申请的资源。</strong>当对象生成时，编译器会自动产生调用其类构造函数的代码，在编码过程中可以为类中的数据成员赋予恰当的初始值。当对象被销毁时，编译器同样会产生调用其类析构函数的代码。构造函数与析构函数都是类中特殊的成员函数，构造函数支持函数重载，而析构函数只能是一个无参函数。它们不可定义返回值，调用构造函数后，返回值为对象首地址，也就是this指针。在某些情况下，编译器会提供默认的构造函数和析构函数，但并不是任何情况下编译器都会提供。</p>\n<h1 id=\"构造函数的出现时机\"><a href=\"#构造函数的出现时机\" class=\"headerlink\" title=\"构造函数的出现时机\"></a>构造函数的出现时机</h1><p>对象生成时会自动调用构造函数。只要找到定义对象的地方就找到了构造函数的调用时机。这看似简单，实际情况却是不同作用域的对象生命周期不同，如局部对象、全局对象、静态对象等的生命周期各不相同，而当对象作为函数参数与返回值时，构造函数的出现时机又有所不同。</p>\n<h2 id=\"局部对象\"><a href=\"#局部对象\" class=\"headerlink\" title=\"局部对象\"></a>局部对象</h2><p>局部对象下的构造函数出现时机比较容易识别。当对象产生时，便有可能引发构造函数的调用。</p>\n<h3 id=\"无参构造函数的调用过程\"><a href=\"#无参构造函数的调用过程\" class=\"headerlink\" title=\"无参构造函数的调用过程\"></a>无参构造函数的调用过程</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>() &#123; <span class=\"comment\">//无参构造函数</span></span><br><span class=\"line\">\t\tage = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\tPerson person; <span class=\"comment\">//类对象定义</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ida汇编及伪代码视图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//main函数</span><br><span class=\"line\">.text:00401020 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:00401020 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:00401020</span><br><span class=\"line\">.text:00401020 var_8           = byte ptr -8</span><br><span class=\"line\">.text:00401020 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401020 argc            = dword ptr  8</span><br><span class=\"line\">.text:00401020 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:00401020 envp            = dword ptr  10h</span><br><span class=\"line\">.text:00401020</span><br><span class=\"line\">.text:00401020                 push    ebp</span><br><span class=\"line\">.text:00401021                 mov     ebp, esp</span><br><span class=\"line\">.text:00401023                 sub     esp, 8</span><br><span class=\"line\">.text:00401026                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:0040102B                 xor     eax, ebp</span><br><span class=\"line\">.text:0040102D                 mov     [ebp-4], eax</span><br><span class=\"line\">.text:00401030                 lea     ecx, [ebp-8]    ; 取得对象首地址，传入ecx作为参数，ecx=&amp;person</span><br><span class=\"line\">.text:00401033                 call    sub_401000      ; 调用构造函数</span><br><span class=\"line\">.text:00401038                 xor     eax, eax</span><br><span class=\"line\">.text:0040103A                 mov     ecx, [ebp-4]</span><br><span class=\"line\">.text:0040103D                 xor     ecx, ebp        ; StackCookie</span><br><span class=\"line\">.text:0040103F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class=\"line\">.text:00401044                 mov     esp, ebp</span><br><span class=\"line\">.text:00401046                 pop     ebp</span><br><span class=\"line\">.text:00401047                 retn</span><br><span class=\"line\">.text:00401047 _main           endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char v4[4]; // [esp+0h] [ebp-8h] BYREF</span><br><span class=\"line\"></span><br><span class=\"line\">  sub_401000(v4);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//构造函数</span><br><span class=\"line\">.text:00401000 ; _DWORD *__thiscall sub_401000(_DWORD *this)</span><br><span class=\"line\">.text:00401000 sub_401000      proc near               ; CODE XREF: _main+13↓p</span><br><span class=\"line\">.text:00401000</span><br><span class=\"line\">.text:00401000 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401000</span><br><span class=\"line\">.text:00401000                 push    ebp</span><br><span class=\"line\">.text:00401001                 mov     ebp, esp</span><br><span class=\"line\">.text:00401003                 push    ecx</span><br><span class=\"line\">.text:00401004                 mov     [ebp-4], ecx    ; [ebp-4]就是this指针</span><br><span class=\"line\">.text:00401007                 mov     eax, [ebp-4]    ; eax保存了对象的首地址</span><br><span class=\"line\">.text:0040100A                 mov     dword ptr [eax], 14h ; 将数据成员age设置为20</span><br><span class=\"line\">.text:00401010                 mov     eax, [ebp-4]    ; 将this指针存入eax，作为返回值</span><br><span class=\"line\">.text:00401013                 mov     esp, ebp</span><br><span class=\"line\">.text:00401015                 pop     ebp</span><br><span class=\"line\">.text:00401016                 retn</span><br><span class=\"line\">.text:00401016 sub_401000      endp</span><br><span class=\"line\"></span><br><span class=\"line\">_DWORD *__thiscall sub_401000(_DWORD *this)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  *this = 20;</span><br><span class=\"line\">  return this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当进入对象的作用域时，编译器会产生调用构造函数的代码。因为构造函数属于成员函数，所以在调用的过程中同样需要传递this指针。构造函数调用结束后，会将this指针作为返回值。返回this指针便是构造函数的特征之一，结合C++的语法，我们可以总结识别局部对象构造函数的必要条件（请读者注意，并不是充分条件）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">该成员函数是这个对象在作用域内调用的第一个成员函数，根据this指针可以区分每个对象。</span><br><span class=\"line\"></span><br><span class=\"line\">这个成员函数是通过thiscall方式调用的。</span><br><span class=\"line\"></span><br><span class=\"line\">这个函数返回this指针。</span><br></pre></td></tr></table></figure>\n\n<p>构造函数必然满足以上3个条件，缺一不可。</p>\n<h2 id=\"堆对象\"><a href=\"#堆对象\" class=\"headerlink\" title=\"堆对象\"></a>堆对象</h2><p>堆对象的识别重点在于识别堆空间的申请与使用。在C++的语法中，堆空间的申请需要使用malloc函数、new运算符或者其他同类功能的函数。因此，识别堆对象就有了重要依据，代码如下所示。</p>\n<p>Person* p &#x3D; new Person();</p>\n<p>这行代码看上去是申请了一个类型为Person的堆对象，使用指针p保存了对象的首地址。因为产生了对象，所以此行代码将会调用Person类的无参构造函数。</p>\n<h3 id=\"构造函数返回值的使用\"><a href=\"#构造函数返回值的使用\" class=\"headerlink\" title=\"构造函数返回值的使用\"></a>构造函数返回值的使用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#pragma warning(disable : 4996)</span><br><span class=\"line\"></span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tPerson() &#123;</span><br><span class=\"line\">\t\tage = 20;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main(int argc, char* argv[]) &#123;</span><br><span class=\"line\">\tPerson* p = new Person;</span><br><span class=\"line\">\t//为了突出本节讨论的问题，这里没有检查new运算的返回值</span><br><span class=\"line\">\tp-&gt;age = 21;</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;, p-&gt;age);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ida汇编及伪代码视图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:004010A0 ; __unwind &#123; // _main_SEH</span><br><span class=\"line\">.text:004010A0                 push    ebp</span><br><span class=\"line\">.text:004010A1                 mov     ebp, esp</span><br><span class=\"line\">.text:004010A3                 push    0FFFFFFFFh</span><br><span class=\"line\">.text:004010A5                 push    offset _main_SEH</span><br><span class=\"line\">.text:004010AA                 mov     eax, large fs:0</span><br><span class=\"line\">.text:004010B0                 push    eax</span><br><span class=\"line\">.text:004010B1                 sub     esp, 10h</span><br><span class=\"line\">.text:004010B4                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:004010B9                 xor     eax, ebp</span><br><span class=\"line\">.text:004010BB                 push    eax</span><br><span class=\"line\">.text:004010BC                 lea     eax, [ebp-0Ch]</span><br><span class=\"line\">.text:004010BF                 mov     large fs:0, eax</span><br><span class=\"line\">.text:004010C5                 push    4               ; Size，压入类的大小，用于堆内存申请</span><br><span class=\"line\">.text:004010C7                 call    ??2@YAPAXI@Z    ; operator new(uint)</span><br><span class=\"line\">.text:004010CC                 add     esp, 4</span><br><span class=\"line\">.text:004010CF                 mov     [ebp-10h], eax  ; 使用临时变量保存new返回值</span><br><span class=\"line\">.text:004010D2 ;   try &#123;</span><br><span class=\"line\">.text:004010D2                 mov     dword ptr [ebp-4], 0</span><br><span class=\"line\">.text:004010D9                 cmp     dword ptr [ebp-10h], 0 ; 检测堆内存是否申请成功</span><br><span class=\"line\">.text:004010DD                 jz      short loc_4010EC ; 申请失败则跳过构造函数调用</span><br><span class=\"line\">.text:004010DF                 mov     ecx, [ebp-10h]  ; 申请成功，将对象首地址传入ecx</span><br><span class=\"line\">.text:004010E2                 call    sub_401080      ; 调用构造函数</span><br><span class=\"line\">.text:004010E7                 mov     [ebp-14h], eax  ; 构造函数返回this指针，保存到临时变量ebp-14h中</span><br><span class=\"line\">.text:004010EA                 jmp     short loc_4010F3</span><br><span class=\"line\">.text:004010EC ; ---------------------------------------------------------------------------</span><br><span class=\"line\">.text:004010EC</span><br><span class=\"line\">.text:004010EC loc_4010EC:                             ; CODE XREF: _main+3D↑j</span><br><span class=\"line\">.text:004010EC                 mov     dword ptr [ebp-14h], 0 ; 申请堆空间失败，设置指针值为NULL</span><br><span class=\"line\">.text:004010F3</span><br><span class=\"line\">.text:004010F3 loc_4010F3:                             ; CODE XREF: _main+4A↑j</span><br><span class=\"line\">.text:004010F3                 mov     eax, [ebp-14h]</span><br><span class=\"line\">.text:004010F6                 mov     [ebp-1Ch], eax  ; 当没有打开/02选项时，对象地址将在几个临时变量中倒换，最终保存到[ebp-1Ch]中，这是指针变量p</span><br><span class=\"line\">.text:004010F6 ;   &#125; // starts at 4010D2</span><br><span class=\"line\">.text:004010F9                 mov     dword ptr [ebp-4], 0FFFFFFFFh</span><br><span class=\"line\">.text:00401100                 mov     ecx, [ebp-1Ch]  ; ecx得到this指针</span><br><span class=\"line\">.text:00401103                 mov     [ebp-18h], ecx</span><br><span class=\"line\">.text:00401106                 mov     edx, [ebp-18h]</span><br><span class=\"line\">.text:00401109                 mov     dword ptr [edx], 15h ; 为成员变量age赋值21</span><br><span class=\"line\">.text:0040110F                 mov     eax, [ebp-18h]</span><br><span class=\"line\">.text:00401112                 mov     ecx, [eax]      ; 参数2，p-&gt;age</span><br><span class=\"line\">.text:00401114                 push    ecx             ; char</span><br><span class=\"line\">.text:00401115                 push    offset Format   ; &quot;%d\\n&quot;</span><br><span class=\"line\">.text:0040111A                 call    sub_401040      ; 调用printf函数</span><br><span class=\"line\">.text:0040111F                 add     esp, 8</span><br><span class=\"line\">.text:00401122                 xor     eax, eax</span><br><span class=\"line\">.text:00401124                 mov     ecx, [ebp-0Ch]</span><br><span class=\"line\">.text:00401127                 mov     large fs:0, ecx</span><br><span class=\"line\">.text:0040112E                 pop     ecx</span><br><span class=\"line\">.text:0040112F                 mov     esp, ebp</span><br><span class=\"line\">.text:00401131                 pop     ebp</span><br><span class=\"line\">.text:00401132                 retn</span><br><span class=\"line\">.text:00401132 ; &#125; // starts at 4010A0</span><br><span class=\"line\">.text:00401132 _main           endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  _DWORD *v4; // [esp+Ch] [ebp-14h]</span><br><span class=\"line\">  _DWORD *Block; // [esp+10h] [ebp-10h]</span><br><span class=\"line\"></span><br><span class=\"line\">  Block = operator new(4u);</span><br><span class=\"line\">  if ( Block )</span><br><span class=\"line\">    v4 = sub_401080(Block);</span><br><span class=\"line\">  else</span><br><span class=\"line\">    v4 = 0;</span><br><span class=\"line\">  *v4 = 21;</span><br><span class=\"line\">  sub_401040(&quot;%d\\n&quot;, *v4);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>VS编译器使用new申请堆空间之后，需要调用构造函数，以完成对象的数据成员初始化。如果堆空间申请失败，则会避开构造函数的调用。因为在C++语法中，如果new运算执行成功，返回值便是对象的首地址，否则为NULL。因此，需要编译器检查堆空间的申请结果，产生一个双分支结构，以决定是否触发构造函数。在识别堆对象的构造函数时，应重点分析此双分支结构。找到new运算的调用后，可立即在下文寻找判定new返回值的代码，在判定成功（new的返回值非0）的分支处迅速定位并得到构造函数。在GCC和Clang编译器中并不检查构造函数的返回值，应当注意区别。</p>\n<p>在使用new申请对象堆空间时，许多初学者很容易将有参构造函数与对象数组搞混，在申请对象数组时很容易写错，将申请对象数组写成调用有参构造函数。以int类型的堆空间申请为例，代码如下所示。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 圆括号是调用有参构造函数，最后只申请了一个int类型的堆变量并赋初值10</span><br><span class=\"line\">int *p= new int(10);</span><br><span class=\"line\"></span><br><span class=\"line\">// 方括号才是申请了10个int元素的堆数组</span><br><span class=\"line\">int *p = new int[10];</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参数对象\"><a href=\"#参数对象\" class=\"headerlink\" title=\"参数对象\"></a>参数对象</h2><p>参数对象属于局部对象中的一种特殊情况。当对象作为函数参数时，调用一个特殊的构造函数——复制构造函数。该构造函数只有一个参数，类型为对象的引用。当对象为参数时，会触发此类对象的复制构造函数。如果在函数调用时传递参数对象，参数会进行复制，形参是实参的副本，相当于复制构造了一个全新的对象。</p>\n<h3 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h3><p>由于定义了新对象，因此会触发复制构造函数，在这个特殊的构造函数中完成两个对象间数据的复制。如没有定义复制构造函数，编译器会对原对象与复制对象中的各数据成员直接进行数据复制，称为默认复制构造函数，这种复制方式属于浅拷贝</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>() &#123;</span><br><span class=\"line\">\t\tage = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\tPerson obj1; </span><br><span class=\"line\">\t<span class=\"function\">Person <span class=\"title\">obj2</span><span class=\"params\">(obj1)</span></span>; <span class=\"comment\">//Person中没有提供参数为对象引用的构造函数</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ida汇编及伪代码视图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00401020 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:00401020 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:00401020</span><br><span class=\"line\">.text:00401020 var_C           = dword ptr -0Ch</span><br><span class=\"line\">.text:00401020 var_8           = dword ptr -8</span><br><span class=\"line\">.text:00401020 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401020 argc            = dword ptr  8</span><br><span class=\"line\">.text:00401020 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:00401020 envp            = dword ptr  10h</span><br><span class=\"line\">.text:00401020</span><br><span class=\"line\">.text:00401020                 push    ebp</span><br><span class=\"line\">.text:00401021                 mov     ebp, esp</span><br><span class=\"line\">.text:00401023                 sub     esp, 0Ch</span><br><span class=\"line\">.text:00401026                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:0040102B                 xor     eax, ebp</span><br><span class=\"line\">.text:0040102D                 mov     [ebp-4], eax</span><br><span class=\"line\">.text:00401030                 lea     ecx, [ebp-8]    ; ecx=&amp;obj1</span><br><span class=\"line\">.text:00401033                 call    sub_401000      ; 调用构造函数</span><br><span class=\"line\">.text:00401038                 mov     eax, [ebp-8]    ; 取出对象obj1中的数据成员信息</span><br><span class=\"line\">.text:0040103B                 mov     [ebp-0Ch], eax  ; 赋值对象obj2中的数据成员信息</span><br><span class=\"line\">.text:0040103E                 xor     eax, eax</span><br><span class=\"line\">.text:00401040                 mov     ecx, [ebp-4]</span><br><span class=\"line\">.text:00401043                 xor     ecx, ebp        ; StackCookie</span><br><span class=\"line\">.text:00401045                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class=\"line\">.text:0040104A                 mov     esp, ebp</span><br><span class=\"line\">.text:0040104C                 pop     ebp</span><br><span class=\"line\">.text:0040104D                 retn</span><br><span class=\"line\">.text:0040104D _main           endp</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><p>当类中有资源申请，并以数据成员来保存这些资源时，就需要使用者自己提供一个复制构造函数。在复制构造函数中，要处理的不仅仅是源对象的各数据成员，还有它们指向的资源数据。把这种源对象中的数据成员间接访问到的其他资源并制作副本的复制构造函数称为深拷贝</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#pragma warning(disable : 4996)</span><br><span class=\"line\"></span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tPerson() &#123;</span><br><span class=\"line\">\t\tname = NULL;//无参构造函数，初始化指针</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tPerson(const Person&amp; obj) &#123;</span><br><span class=\"line\">\t\t// 注：如果在复制构造函数中直接复制指针值，那么对象内的两个成员指针会指向同一个资源，这属于浅拷贝</span><br><span class=\"line\">\t\t\t// this-&gt;name = obj.name;</span><br><span class=\"line\">\t\t\t// 为实参对象中的指针所指向的堆空间制作一份副本，这就是深拷贝了</span><br><span class=\"line\">\t\t\tint len = strlen(obj.name);</span><br><span class=\"line\">\t\tthis-&gt;name = new char[len + sizeof(char)]; // 为便于讲解，这里没有检查指针</span><br><span class=\"line\">\t\t\tstrcpy(this-&gt;name, obj.name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid setName(const char* name) &#123;</span><br><span class=\"line\">\t\tint len = strlen(name);</span><br><span class=\"line\">\t\tif (this-&gt;name != NULL) &#123;</span><br><span class=\"line\">\t\t\tdelete[] this-&gt;name;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tthis-&gt;name = new char[len + sizeof(char)]; // 为便于讲解，这里没有检查指针</span><br><span class=\"line\">\t\t\tstrcpy(this-&gt;name, name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tchar* name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">void show(Person person) &#123; // 参数是对象类型，会触发复制构造函数</span><br><span class=\"line\">\tprintf(&quot;name:%s\\n&quot;, person.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main(int argc, char* argv[]) &#123;</span><br><span class=\"line\">\tPerson person;</span><br><span class=\"line\">\tperson.setName(&quot;Hello&quot;);</span><br><span class=\"line\">\tshow(person);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ida汇编及伪代码视图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//main函数</span><br><span class=\"line\">.text:00401220 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:00401220 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:00401220</span><br><span class=\"line\">.text:00401220 var_8           = byte ptr -8</span><br><span class=\"line\">.text:00401220 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401220 argc            = dword ptr  8</span><br><span class=\"line\">.text:00401220 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:00401220 envp            = dword ptr  10h</span><br><span class=\"line\">.text:00401220</span><br><span class=\"line\">.text:00401220                 push    ebp</span><br><span class=\"line\">.text:00401221                 mov     ebp, esp</span><br><span class=\"line\">.text:00401223                 sub     esp, 8</span><br><span class=\"line\">.text:00401226                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:0040122B                 xor     eax, ebp</span><br><span class=\"line\">.text:0040122D                 mov     [ebp-4], eax</span><br><span class=\"line\">.text:00401230                 push    4               ; Size，类对象大小</span><br><span class=\"line\">.text:00401232                 lea     ecx, [ebp-8]    ; ecx=&amp;person</span><br><span class=\"line\">.text:00401235                 call    sub_401280      ; __autoclassinit2</span><br><span class=\"line\">.text:0040123A                 lea     ecx, [ebp-8]    ; ecx=&amp;person</span><br><span class=\"line\">.text:0040123D                 call    unknown_libname_1 ; 调用无参构造函数</span><br><span class=\"line\">.text:00401242                 push    offset aHello   ; &quot;Hello&quot;</span><br><span class=\"line\">.text:00401247                 lea     ecx, [ebp-8]    ; ecx=&amp;person</span><br><span class=\"line\">.text:0040124A                 call    sub_401140      ; 调用成员函setName</span><br><span class=\"line\">.text:0040124F                 push    ecx             ; 这里的push ecx等价于sub esp,4，但是push ecx的机器码更短，效率更高</span><br><span class=\"line\">.text:0040124F                                         ; Person的类型长度为4字节，所以传递参数对象的时候需要在栈顶留下4字节，以作为参数对象的空间</span><br><span class=\"line\">.text:0040124F                                         ; 此时esp保存的内容就是参数对象的地址</span><br><span class=\"line\">.text:00401250                 mov     ecx, esp        ; 获取参数对象的地址，保存到ecx中</span><br><span class=\"line\">.text:00401252                 lea     eax, [ebp-8]    ; 获取对象person的地址并保存到eax中</span><br><span class=\"line\">.text:00401255                 push    eax             ; 参数1，将person地址作为参数</span><br><span class=\"line\">.text:00401256                 call    sub_4010A0      ; 调用复制构造函数</span><br><span class=\"line\">.text:0040125B                 call    __set_purecall_handler ; 此时栈顶上的参数对象传递完毕，开始调用show函数</span><br><span class=\"line\">.text:00401260                 add     esp, 4</span><br><span class=\"line\">.text:00401263                 xor     eax, eax</span><br><span class=\"line\">.text:00401265                 mov     ecx, [ebp-4]</span><br><span class=\"line\">.text:00401268                 xor     ecx, ebp        ; StackCookie</span><br><span class=\"line\">.text:0040126A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class=\"line\">.text:0040126F                 mov     esp, ebp</span><br><span class=\"line\">.text:00401271                 pop     ebp</span><br><span class=\"line\">.text:00401272                 retn</span><br><span class=\"line\">.text:00401272 _main           endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  void (__cdecl *v3)(); // ecx</span><br><span class=\"line\">  void (__cdecl *v5)(); // [esp-4h] [ebp-Ch]</span><br><span class=\"line\">  char v6[4]; // [esp+0h] [ebp-8h] BYREF</span><br><span class=\"line\"></span><br><span class=\"line\">  sub_401280(4u);</span><br><span class=\"line\">  unknown_libname_1(v6);</span><br><span class=\"line\">  sub_401140(&quot;Hello&quot;);</span><br><span class=\"line\">  v5 = v3;</span><br><span class=\"line\">  sub_4010A0(v6);</span><br><span class=\"line\">  _set_purecall_handler(v5);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//__autoclassinit2函数</span><br><span class=\"line\">//一旦类中定义有指针变量并且有构造函数（和初始化列表无关）就会自动调用 __autoclassinit2</span><br><span class=\"line\">//__autoclassinit2的主要工作就是 memset 对象的内存为0；</span><br><span class=\"line\">//调用前传递了person对象大小进去 push 0x4</span><br><span class=\"line\">.text:00401280 ; void *__thiscall sub_401280(void *this, size_t Size)</span><br><span class=\"line\">.text:00401280 sub_401280      proc near               ; CODE XREF: _main+15↑p</span><br><span class=\"line\">.text:00401280</span><br><span class=\"line\">.text:00401280 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401280 Size            = dword ptr  8</span><br><span class=\"line\">.text:00401280</span><br><span class=\"line\">.text:00401280                 push    ebp</span><br><span class=\"line\">.text:00401281                 mov     ebp, esp</span><br><span class=\"line\">.text:00401283                 push    ecx</span><br><span class=\"line\">.text:00401284                 mov     [ebp-4], ecx</span><br><span class=\"line\">.text:00401287                 mov     eax, [ebp+Size]</span><br><span class=\"line\">.text:0040128A                 push    eax             ; Size</span><br><span class=\"line\">.text:0040128B                 push    0               ; Val</span><br><span class=\"line\">.text:0040128D                 mov     ecx, [ebp-4]</span><br><span class=\"line\">.text:00401290                 push    ecx             ; void *</span><br><span class=\"line\">.text:00401291                 call    memset</span><br><span class=\"line\">.text:00401296                 add     esp, 0Ch</span><br><span class=\"line\">.text:00401299                 mov     esp, ebp</span><br><span class=\"line\">.text:0040129B                 pop     ebp</span><br><span class=\"line\">.text:0040129C                 retn    4</span><br><span class=\"line\">.text:0040129C sub_401280      endp</span><br><span class=\"line\"></span><br><span class=\"line\">void *__thiscall sub_401280(void *this, size_t Size)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return memset(this, 0, Size);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//复制构造函数</span><br><span class=\"line\">.text:004010A0 ; _DWORD *__thiscall sub_4010A0(_DWORD *this, const char **)</span><br><span class=\"line\">.text:004010A0 sub_4010A0      proc near               ; CODE XREF: _main+36↓p</span><br><span class=\"line\">.text:004010A0</span><br><span class=\"line\">.text:004010A0 var_28          = dword ptr -28h</span><br><span class=\"line\">.text:004010A0 var_24          = dword ptr -24h</span><br><span class=\"line\">.text:004010A0 var_20          = dword ptr -20h</span><br><span class=\"line\">.text:004010A0 var_1C          = dword ptr -1Ch</span><br><span class=\"line\">.text:004010A0 var_18          = dword ptr -18h</span><br><span class=\"line\">.text:004010A0 var_14          = dword ptr -14h</span><br><span class=\"line\">.text:004010A0 var_10          = dword ptr -10h</span><br><span class=\"line\">.text:004010A0 var_C           = dword ptr -0Ch</span><br><span class=\"line\">.text:004010A0 var_8           = dword ptr -8</span><br><span class=\"line\">.text:004010A0 var_2           = byte ptr -2</span><br><span class=\"line\">.text:004010A0 var_1           = byte ptr -1</span><br><span class=\"line\">.text:004010A0 arg_0           = dword ptr  8</span><br><span class=\"line\">.text:004010A0</span><br><span class=\"line\">.text:004010A0                 push    ebp</span><br><span class=\"line\">.text:004010A1                 mov     ebp, esp</span><br><span class=\"line\">.text:004010A3                 sub     esp, 28h</span><br><span class=\"line\">.text:004010A6                 mov     [ebp-14h], ecx  ; [ebp-14]保存this指针</span><br><span class=\"line\">.text:004010A9                 mov     eax, [ebp+8]    ; eax=&amp;obj</span><br><span class=\"line\">.text:004010AC                 mov     ecx, [eax]      ; ecx=obj.name</span><br><span class=\"line\">.text:004010AE                 mov     [ebp-8], ecx    ; 计算obj.name的长度</span><br><span class=\"line\">.text:004010B1                 mov     edx, [ebp-8]</span><br><span class=\"line\">.text:004010B4                 add     edx, 1</span><br><span class=\"line\">.text:004010B7                 mov     [ebp-18h], edx</span><br><span class=\"line\">.text:004010BA</span><br><span class=\"line\">.text:004010BA loc_4010BA:                             ; CODE XREF: sub_4010A0+2A↓j</span><br><span class=\"line\">.text:004010BA                 mov     eax, [ebp-8]</span><br><span class=\"line\">.text:004010BD                 mov     cl, [eax]</span><br><span class=\"line\">.text:004010BF                 mov     [ebp-2], cl</span><br><span class=\"line\">.text:004010C2                 add     dword ptr [ebp-8], 1</span><br><span class=\"line\">.text:004010C6                 cmp     byte ptr [ebp-2], 0</span><br><span class=\"line\">.text:004010CA                 jnz     short loc_4010BA</span><br><span class=\"line\">.text:004010CC                 mov     edx, [ebp-8]</span><br><span class=\"line\">.text:004010CF                 sub     edx, [ebp-18h]</span><br><span class=\"line\">.text:004010D2                 mov     [ebp-1Ch], edx</span><br><span class=\"line\">.text:004010D5                 mov     eax, [ebp-1Ch]</span><br><span class=\"line\">.text:004010D8                 mov     [ebp-20h], eax</span><br><span class=\"line\">.text:004010DB                 mov     ecx, [ebp-20h]</span><br><span class=\"line\">.text:004010DE                 add     ecx, 1          ; 参数1，len +1</span><br><span class=\"line\">.text:004010E1                 push    ecx</span><br><span class=\"line\">.text:004010E2                 call    sub_4012B2      ; 调用new函数</span><br><span class=\"line\">.text:004010E7                 add     esp, 4</span><br><span class=\"line\">.text:004010EA                 mov     [ebp-24h], eax</span><br><span class=\"line\">.text:004010ED                 mov     edx, [ebp-14h]</span><br><span class=\"line\">.text:004010F0                 mov     eax, [ebp-24h]</span><br><span class=\"line\">.text:004010F3                 mov     [edx], eax</span><br><span class=\"line\">.text:004010F5                 mov     ecx, [ebp+8]</span><br><span class=\"line\">.text:004010F8                 mov     edx, [ecx]</span><br><span class=\"line\">.text:004010FA                 mov     [ebp-10h], edx</span><br><span class=\"line\">.text:004010FD                 mov     eax, [ebp-14h]</span><br><span class=\"line\">.text:00401100                 mov     ecx, [eax]      ; this-&gt;name = new char[len +sizeof(char)];</span><br><span class=\"line\">.text:00401102                 mov     [ebp-0Ch], ecx</span><br><span class=\"line\">.text:00401105                 mov     edx, [ebp-0Ch]</span><br><span class=\"line\">.text:00401108                 mov     [ebp-28h], edx</span><br><span class=\"line\">.text:0040110B</span><br><span class=\"line\">.text:0040110B loc_40110B:                             ; CODE XREF: sub_4010A0+91↓j</span><br><span class=\"line\">.text:0040110B                 mov     eax, [ebp-10h]</span><br><span class=\"line\">.text:0040110E                 mov     cl, [eax]</span><br><span class=\"line\">.text:00401110                 mov     [ebp-1], cl</span><br><span class=\"line\">.text:00401113                 mov     edx, [ebp-0Ch]</span><br><span class=\"line\">.text:00401116                 mov     al, [ebp-1]</span><br><span class=\"line\">.text:00401119                 mov     [edx], al</span><br><span class=\"line\">.text:0040111B                 mov     ecx, [ebp-10h]</span><br><span class=\"line\">.text:0040111E                 add     ecx, 1</span><br><span class=\"line\">.text:00401121                 mov     [ebp-10h], ecx</span><br><span class=\"line\">.text:00401124                 mov     edx, [ebp-0Ch]</span><br><span class=\"line\">.text:00401127                 add     edx, 1</span><br><span class=\"line\">.text:0040112A                 mov     [ebp-0Ch], edx</span><br><span class=\"line\">.text:0040112D                 cmp     byte ptr [ebp-1], 0</span><br><span class=\"line\">.text:00401131                 jnz     short loc_40110B</span><br><span class=\"line\">.text:00401133                 mov     eax, [ebp-14h]</span><br><span class=\"line\">.text:00401136                 mov     esp, ebp</span><br><span class=\"line\">.text:00401138                 pop     ebp</span><br><span class=\"line\">.text:00401139                 retn    4</span><br><span class=\"line\">.text:00401139 sub_4010A0      endp</span><br><span class=\"line\"></span><br><span class=\"line\">_DWORD *__thiscall sub_4010A0(_DWORD *this, const char **a2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  const char *v4; // [esp+18h] [ebp-10h]</span><br><span class=\"line\">  _BYTE *v5; // [esp+1Ch] [ebp-Ch]</span><br><span class=\"line\">  char v6; // [esp+27h] [ebp-1h]</span><br><span class=\"line\"></span><br><span class=\"line\">  *this = sub_4012B2(&amp;(*a2)[strlen(*a2) + 1] - *a2);</span><br><span class=\"line\">  v4 = *a2;</span><br><span class=\"line\">  v5 = (_BYTE *)*this;</span><br><span class=\"line\">  do</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v6 = *v4;</span><br><span class=\"line\">    *v5++ = *v4++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  while ( v6 );</span><br><span class=\"line\">  return this;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//show函数</span><br><span class=\"line\">.text:00401200 ; _purecall_handler __cdecl _set_purecall_handler(_purecall_handler Handler)</span><br><span class=\"line\">.text:00401200 __set_purecall_handler proc near        ; CODE XREF: _main+3B↓p</span><br><span class=\"line\">.text:00401200</span><br><span class=\"line\">.text:00401200 Handler         = dword ptr  8</span><br><span class=\"line\">.text:00401200</span><br><span class=\"line\">.text:00401200                 push    ebp</span><br><span class=\"line\">.text:00401201                 mov     ebp, esp</span><br><span class=\"line\">.text:00401203                 mov     eax, [ebp+Handler]</span><br><span class=\"line\">.text:00401206                 push    eax             ; char</span><br><span class=\"line\">.text:00401207                 push    offset Format   ; &quot;name:%s\\n&quot;</span><br><span class=\"line\">.text:0040120C                 call    sub_401040</span><br><span class=\"line\">.text:00401211                 add     esp, 8</span><br><span class=\"line\">.text:00401214                 pop     ebp</span><br><span class=\"line\">.text:00401215                 retn</span><br><span class=\"line\">.text:00401215 __set_purecall_handler endp</span><br><span class=\"line\"></span><br><span class=\"line\">_purecall_handler __cdecl _set_purecall_handler(_purecall_handler Handler)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return (_purecall_handler)sub_401040(&quot;name:%s\\n&quot;, (const char *)Handler);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，在执行函数show之前，先进入Person的复制构造函数中。在复制构造函数中，我们使用的是深拷贝方式。这时数据成员this-&gt;name和obj.name保存的地址不同，但其中的数据内容却是相同的。</p>\n<p>由于使用了深拷贝方式，对对象中的数据成员指向的堆空间数据也进行了数据复制，因此当参数对象被销毁时，释放的堆空间数据是复制对象制作的数据副本，对源对象没有任何影响。另外需要注意的是，对于GCC编译器，show函数的参数对象的析构函数是在main()函数中调用的。</p>\n<h3 id=\"C-autoclassinit2\"><a href=\"#C-autoclassinit2\" class=\"headerlink\" title=\"C++ __autoclassinit2\"></a>C++ __autoclassinit2</h3><p>一旦类中定义有指针变量并且有构造函数（和初始化列表无关）就会自动调用 __autoclassinit2</p>\n<p>__autoclassinit2的主要工作就是 memset 对象的内存为0；</p>\n<p>参考：<a href=\"https://www.cnblogs.com/Dir-A/p/16879399.html\">https://www.cnblogs.com/Dir-A/p/16879399.html</a></p>\n<h2 id=\"返回对象\"><a href=\"#返回对象\" class=\"headerlink\" title=\"返回对象\"></a>返回对象</h2><p>返回对象与参数对象相似，都是局部对象中的一种特殊情况。由于函数返回时需要对返回对象进行复制，因此同样会使用复制构造函数。但是，两者使用复制构造函数的时机不同。当对象为参数时，在进入函数前使用复制构造函数，而返回对象则在函数返回时使用复制构造函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;string.h&gt;</span><br><span class=\"line\">#pragma warning(disable : 4996)</span><br><span class=\"line\"></span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tPerson() &#123;</span><br><span class=\"line\">\t\tname = NULL;//无参构造函数，初始化指针</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tPerson(const Person&amp; obj) &#123;</span><br><span class=\"line\">\t\t// 注：如果在复制构造函数中直接复制指针值，那么对象内的两个成员指针会指向同一个资源，这属于浅拷贝</span><br><span class=\"line\">\t\t\t// this-&gt;name = obj.name;</span><br><span class=\"line\">\t\t\t// 为实参对象中的指针所指向的堆空间制作一份副本，这就是深拷贝了</span><br><span class=\"line\">\t\t\tint len = strlen(obj.name);</span><br><span class=\"line\">\t\tthis-&gt;name = new char[len + sizeof(char)]; // 为便于讲解，这里没有检查指针</span><br><span class=\"line\">\t\t\tstrcpy(this-&gt;name, obj.name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid setName(const char* name) &#123;</span><br><span class=\"line\">\t\tint len = strlen(name);</span><br><span class=\"line\">\t\tif (this-&gt;name != NULL) &#123;</span><br><span class=\"line\">\t\t\tdelete[] this-&gt;name;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tthis-&gt;name = new char[len + sizeof(char)]; // 为便于讲解，这里没有检查指针</span><br><span class=\"line\">\t\t\tstrcpy(this-&gt;name, name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tchar* name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Person getObject() &#123;</span><br><span class=\"line\">\tPerson person;</span><br><span class=\"line\">\tperson.setName(&quot;Hello&quot;);</span><br><span class=\"line\">\treturn person; //返回类型为对象</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main(int argc, char* argv[]) &#123;</span><br><span class=\"line\">\tPerson person = getObject();</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ida汇编及伪代码视图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//main函数</span><br><span class=\"line\">.text:004011F0 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:004011F0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:004011F0</span><br><span class=\"line\">.text:004011F0 var_8           = byte ptr -8</span><br><span class=\"line\">.text:004011F0 var_4           = dword ptr -4</span><br><span class=\"line\">.text:004011F0 argc            = dword ptr  8</span><br><span class=\"line\">.text:004011F0 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:004011F0 envp            = dword ptr  10h</span><br><span class=\"line\">.text:004011F0</span><br><span class=\"line\">.text:004011F0                 push    ebp</span><br><span class=\"line\">.text:004011F1                 mov     ebp, esp</span><br><span class=\"line\">.text:004011F3                 sub     esp, 8</span><br><span class=\"line\">.text:004011F6                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:004011FB                 xor     eax, ebp</span><br><span class=\"line\">.text:004011FD                 mov     [ebp-4], eax</span><br><span class=\"line\">.text:00401200                 push    4               ; Size</span><br><span class=\"line\">.text:00401202                 lea     ecx, [ebp-8]</span><br><span class=\"line\">.text:00401205                 call    __autoclassinit2 ; 调用__autoclassinit2</span><br><span class=\"line\">.text:0040120A                 lea     eax, [ebp-8]    ; 取对象person的首地址</span><br><span class=\"line\">.text:0040120D                 push    eax             ; 将对象的首地址作为参数传递</span><br><span class=\"line\">.text:0040120E                 call    sub_401180      ; 调用getObject函数</span><br><span class=\"line\">.text:00401213                 add     esp, 4</span><br><span class=\"line\">.text:00401216                 xor     eax, eax</span><br><span class=\"line\">.text:00401218                 mov     ecx, [ebp-4]</span><br><span class=\"line\">.text:0040121B                 xor     ecx, ebp        ; StackCookie</span><br><span class=\"line\">.text:0040121D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class=\"line\">.text:00401222                 mov     esp, ebp</span><br><span class=\"line\">.text:00401224                 pop     ebp</span><br><span class=\"line\">.text:00401225                 retn</span><br><span class=\"line\">.text:00401225 _main           endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char v4[4]; // [esp+0h] [ebp-8h] BYREF</span><br><span class=\"line\"></span><br><span class=\"line\">  _autoclassinit2(4u);</span><br><span class=\"line\">  sub_401180(v4);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//getObject函数</span><br><span class=\"line\">.text:00401180 ; int __cdecl sub_401180(int)</span><br><span class=\"line\">.text:00401180 sub_401180      proc near               ; CODE XREF: _main+1E↓p</span><br><span class=\"line\">.text:00401180</span><br><span class=\"line\">.text:00401180 var_8           = byte ptr -8</span><br><span class=\"line\">.text:00401180 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401180 arg_0           = dword ptr  8</span><br><span class=\"line\">.text:00401180</span><br><span class=\"line\">.text:00401180                 push    ebp</span><br><span class=\"line\">.text:00401181                 mov     ebp, esp</span><br><span class=\"line\">.text:00401183                 sub     esp, 8</span><br><span class=\"line\">.text:00401186                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:0040118B                 xor     eax, ebp</span><br><span class=\"line\">.text:0040118D                 mov     [ebp-4], eax</span><br><span class=\"line\">.text:00401190                 push    4               ; Size</span><br><span class=\"line\">.text:00401192                 lea     ecx, [ebp-8]</span><br><span class=\"line\">.text:00401195                 call    __autoclassinit2</span><br><span class=\"line\">.text:0040119A                 lea     ecx, [ebp-8]    ; 将局部对象的首地址作为参数传递</span><br><span class=\"line\">.text:0040119D                 call    unknown_libname_1 ; 调用构造函数</span><br><span class=\"line\">.text:004011A2                 push    offset aHello   ; &quot;Hello&quot;</span><br><span class=\"line\">.text:004011A7                 lea     ecx, [ebp-8]    ; 将局部对象的首地址作为参数传递</span><br><span class=\"line\">.text:004011AA                 call    sub_4010C0      ; 调用成员函数setName</span><br><span class=\"line\">.text:004011AF                 lea     eax, [ebp-8]    ; 获取局部对象的首地址</span><br><span class=\"line\">.text:004011B2                 push    eax             ; 将局部对象的地址作为参数</span><br><span class=\"line\">.text:004011B3                 mov     ecx, [ebp+8]    ; 获取参数中保存的this指针</span><br><span class=\"line\">.text:004011B6                 call    sub_401020      ; 调用复制构造函数</span><br><span class=\"line\">.text:004011BB                 mov     eax, [ebp+8]    ; 将参数作为返回值</span><br><span class=\"line\">.text:004011BE                 mov     ecx, [ebp-4]</span><br><span class=\"line\">.text:004011C1                 xor     ecx, ebp        ; StackCookie</span><br><span class=\"line\">.text:004011C3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class=\"line\">.text:004011C8                 mov     esp, ebp</span><br><span class=\"line\">.text:004011CA                 pop     ebp</span><br><span class=\"line\">.text:004011CB                 retn</span><br><span class=\"line\">.text:004011CB sub_401180      endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl sub_401180(int a1)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char v2[4]; // [esp+0h] [ebp-8h] BYREF</span><br><span class=\"line\"></span><br><span class=\"line\">  _autoclassinit2(4u);</span><br><span class=\"line\">  unknown_libname_1(v2);</span><br><span class=\"line\">  sub_4010C0(&quot;Hello&quot;);</span><br><span class=\"line\">  sub_401020(v2);</span><br><span class=\"line\">  return a1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>getObject将返回对象的地址作为函数参数。在函数返回之前，利用复制构造函数将函数中局部对象的数据复制到参数指向的对象中，起到了返回对象的作用。GCC和Clang编译器优化了复制构造函数的调用，与直接构造参数对象功能是等价的。等价的函数原型如下所示。</p>\n<p>Person* getObject(Person* p);</p>\n<p>虽然编译器会对返回值为对象类型的函数进行调整，修改其参数与返回值，但是它留下了一个与返回指针类型不同的象征，就是在函数中使用构造函数。返回值和参数是对象指针类型的函数，不会使用以参数为目标的构造函数，而是直接使用指针保存对象首地址，代码如下所示</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//函数的返回类型与参数类型都是对象的指针类型</span><br><span class=\"line\">Person* getObject(Person* p) &#123;</span><br><span class=\"line\">Person person; // 定义局部对象</span><br><span class=\"line\">person.setName(&quot;World&quot;);</span><br><span class=\"line\">p = &amp;person;</span><br><span class=\"line\">return p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00401000 push ebp</span><br><span class=\"line\">00401001 mov ebp, esp</span><br><span class=\"line\">00401003 sub esp, 8</span><br><span class=\"line\">00401006 lea ecx, [ebp-4]</span><br><span class=\"line\">00401009 call sub_401070</span><br><span class=\"line\">0040100E push offset aWorld ;&quot;World&quot;</span><br><span class=\"line\">00401013 lea ecx, [ebp-4]</span><br><span class=\"line\">00401016 call sub_4010D0</span><br><span class=\"line\">0040101B lea eax, [ebp-4]</span><br><span class=\"line\">0040101E mov [ebp+8], eax</span><br><span class=\"line\">00401021 mov ecx, [ebp+8]</span><br><span class=\"line\">00401024 mov [ebp-8], ecx ;直接保存局部对象首地址</span><br><span class=\"line\">00401027 lea ecx, [ebp-4]</span><br><span class=\"line\">0040102A call sub_401090</span><br><span class=\"line\">0040102F mov eax, [ebp-8] ;将局部对象作为返回值</span><br><span class=\"line\">00401032 mov esp, ebp</span><br><span class=\"line\">00401034 pop ebp</span><br><span class=\"line\">00401035 retn</span><br></pre></td></tr></table></figure>\n\n<p>在使用指针作为参数和返回值时，函数内没有对构造函数的调用。以此为依据，便可以分辨参数或返回值是对象还是对象的指针。如果在函数内为参数指针申请了堆对象，就会存在new运算和构造函数的调用，因此更容易分辨参数和返回值了。</p>\n<h2 id=\"全局对象与静态对象\"><a href=\"#全局对象与静态对象\" class=\"headerlink\" title=\"全局对象与静态对象\"></a>全局对象与静态对象</h2><p>全局对象与全局静态对象的构造时机相同，它们构造函数的调用被隐藏在深处，但识别过程很简单。这似乎是矛盾的，但事实的确如此，这是因为程序中所有全局对象会在同一地点以初始化数据调用构造函数。既然调用构造函数被固定在了某一个点上，无论这个点被隐藏得多深，只须找到一次即可。</p>\n<p>前面启动函数时分析过<code>_cinit</code>函数（位于VS2019的启动函数<code>mainCRTStartup</code>中）。全局对象的构造函数初始化就是在此函数中实现的。在函数<code>_cinit</code>的<code>_initterm</code>函数调用中，初始化了全局对象。</p>\n<p><code>_initterm</code>实现的代码片段如下。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> <span class=\"type\">void</span> __cdecl _initterm(_PVFV* <span class=\"type\">const</span> first, _PVFV* <span class=\"type\">const</span> last)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (_PVFV* it = first; it != last; ++it)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (*it == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t(**it)();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当it不为NULL时，执行(**it)()；后并不会进入全局对象的构造函数，而是进入编译器提供的构造代理函数，由一个负责全局对象的构造代理函数完成调用全局构造函数</p>\n<h3 id=\"全局对象构造代理函数和析构代理函数的分析\"><a href=\"#全局对象构造代理函数和析构代理函数的分析\" class=\"headerlink\" title=\"全局对象构造代理函数和析构代理函数的分析\"></a>全局对象构造代理函数和析构代理函数的分析</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Person</span>() &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Person()&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~<span class=\"built_in\">Person</span>() &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;~Person()&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Person g_person1; <span class=\"comment\">//定义全局对象</span></span><br><span class=\"line\">Person g_person2; <span class=\"comment\">//定义全局对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;main&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>1.首先通过Ctrl+E键定位到mainCRTStartup函数，然后再进入<code>__scrt_common_main_seh</code>函数</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/inCRTStartup%E5%87%BD%E6%95%B0.png\" alt=\"mainCRTStartup函数\"></p>\n<p>2.在<code>__scrt_common_main_seh</code>函数有两个函数用于全局数据的初始化</p>\n<p><code>_initterm_e</code>函数用于对C语言进行初始化</p>\n<p><img src=\"/./_initterm_e%E5%87%BD%E6%95%B0.png\" alt=\"_initterm_e函数\"></p>\n<p><code>_initterm</code>函数用于对C++语言进行初始化</p>\n<p><img src=\"/./_initterm%E5%87%BD%E6%95%B0.png\" alt=\"_initterm函数\"></p>\n<p>3.全局类对象的<strong>构造代理函数数组</strong>就位于<code>_initterm</code>函数的两个参数之间</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E4%BB%A3%E7%90%86%E5%87%BD%E6%95%B0%E6%95%B0%E7%BB%84.png\" alt=\"构造代理函数数组\"></p>\n<p>4.构造代理函数1及析构代理函数1</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E4%BB%A3%E7%90%86%E5%87%BD%E6%95%B01.png\" alt=\"构造代理函数1\"></p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E4%BB%A3%E7%90%86%E5%87%BD%E6%95%B01.png\" alt=\"析构代理函数1\"></p>\n<p>5.构造代理函数2及析构代理函数2</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E4%BB%A3%E7%90%86%E5%87%BD%E6%95%B02.png\" alt=\"构造代理函数2\"></p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E4%BB%A3%E7%90%86%E5%87%BD%E6%95%B02.png\" alt=\"析构代理函数2\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>跟踪全局对象的构造函数</p>\n<p>在分析的过程中该如何跟踪全局对象的构造函数呢？可使用两种方法：直接定位初始化函数和利用栈回溯。</p>\n<p><strong>1.</strong> 直接定位初始化函数</p>\n<p>先进入<code>mainCRTStartup</code>函数，顺藤摸瓜找到初始化函数<code>_cinit</code>，在<code>_cinit</code>函数的第二个<code>_initterm</code>处设置断点。运行程序后，进入<code>_initterm</code>的实现代码内，断点在<code>(**it)()</code>；执行处，单步进入代理构造，即可得到全局对象的构造函数。读者可以先在源码环境下单步跟踪，待熟悉后就可以脱离源码，直接在反汇编的条件下利用OllyDbg或者WinDbg等调试工具熟悉反汇编代码，尝试用自己的方法总结出快速识别初始化函数的规律。对于GCC编译器，则通过main()函数定位<code>___main</code>函数的位置。</p>\n<p><strong>2.</strong> 利用栈回溯</p>\n<p>如果反汇编代码中出现了全局对象，因为全局对象的地址固定（对于有重定位表的执行文件中的全局对象，也可以在执行文件被加载后至执行前计算得到全局对象的地址），所以可以在对象的数据成员中设置读写断点，调试运行程序，等待调用构造函数。利用栈回溯窗口，找到程序的执行流程，依次向上查询即可找到构造函数调用的起始处。</p>\n<p>其实，最简单的办法是对atexit设置断点，这是因为构造代理函数中会注册析构函数，其注册的方式是使用atexit</p></blockquote>\n<h1 id=\"每个对象是否都有默认的构造函数\"><a href=\"#每个对象是否都有默认的构造函数\" class=\"headerlink\" title=\"每个对象是否都有默认的构造函数\"></a>每个对象是否都有默认的构造函数</h1><p>在许多情况下，编译器并没有提供默认的构造函数，而且02选项优化编译后，某些结构简单的类会被转换为</p>\n<p>连续定义的变量</p>\n<h2 id=\"没有定义构造函数的类\"><a href=\"#没有定义构造函数的类\" class=\"headerlink\" title=\"没有定义构造函数的类\"></a>没有定义构造函数的类</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"type\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;age = age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\tPerson person;</span><br><span class=\"line\">\tperson.<span class=\"built_in\">setAge</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, person.<span class=\"built_in\">getAge</span>());</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB.png\" alt=\"没有定义构造函数的类\"></p>\n<p>上面代码中，对象person的定义处没有任何对应的汇编代码，也没有构造函数的调用过程，可见编译器并没有为其提供默认的构造函数。</p>\n<p>那么，<strong>在何种情况下编译器会提供默认的构造函数呢？</strong>有以下两种情况。</p>\n<p><strong>1. 本类和本类中定义的成员对象或者父类中存在虚函数</strong></p>\n<p>因为需要初始化虚表，且这个工作理应在构造函数中隐式完成，所以在没有定义构造函数的情况下，编译器会添加默认的构造函数，用于隐式完成虚表的初始化工作</p>\n<p><strong>2. 父类或本类中定义的成员对象带有构造函数</strong></p>\n<p>在对象被定义时，因为对象本身为派生类，所以构造顺序是先构造父类再构造自身。当父类中带有构造函数时，将会调用父类构造函数，而这个调用过程需要在构造函数内完成，因此编译器添加了默认的构造函数来完成这个调用过程。成员对象带有构造函数的情况与此相同。</p>\n<p>在没有定义构造函数的情况下，当类中没有虚函数存在，父类和成员对象也没有定义构造函数时，提供默认的构造函数已没有任何意义，只会降低程序的执行效率，因此编译器没有对这种情况的类提供默认的构造函数。</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><h2 id=\"构造函数的必要条件\"><a href=\"#构造函数的必要条件\" class=\"headerlink\" title=\"构造函数的必要条件\"></a><strong>构造函数的必要条件</strong></h2><ul>\n<li><p>函数的调用是这个对象在作用域内的第一次成员函数调用，分析this指针即可区分对象，是哪个对象的this指针就是哪个对象的成员函数。</p>\n</li>\n<li><p>使用thiscall调用方式，使用ecx或者rcx传递this指针，返回值为this指针。</p>\n</li>\n</ul>\n","text":"构造函数与析构函数是类重要的组成部分，在类中起到至关重要的作用。构造函数常用来完成对象生成时的数据初始化工作，而析构函数则常用于在对象销毁时释放对象申请的资源。...","permalink":"/post/C++逆向——构造函数","photos":[],"count_time":{"symbolsCount":"30k","symbolsTime":"27 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">构造函数的出现时机</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">局部对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">无参构造函数的调用过程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">堆对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">构造函数返回值的使用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">参数对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%85%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">浅拷贝</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">深拷贝</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#C-autoclassinit2\"><span class=\"toc-text\">C++ __autoclassinit2</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">返回对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">全局对象与静态对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E4%BB%A3%E7%90%86%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E4%BB%A3%E7%90%86%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E6%9E%90\"><span class=\"toc-text\">全局对象构造代理函数和析构代理函数的分析</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%AF%8F%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E9%83%BD%E6%9C%89%E9%BB%98%E8%AE%A4%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">每个对象是否都有默认的构造函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B2%A1%E6%9C%89%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB\"><span class=\"toc-text\">没有定义构造函数的类</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">构造函数的必要条件</span></a></li></ol></li></ol>","author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"https://github.com/0netry","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"C++逆向——析构函数","uid":"b0a53c23c95ed95e45a9b9b266d30456","slug":"C++逆向——析构函数","date":"2023-02-09T01:22:15.000Z","updated":"2025-06-07T18:07:06.600Z","comments":true,"path":"api/articles/C++逆向——析构函数.json","keywords":null,"cover":[],"text":"析构函数的出现时机对象何时被销毁呢？根据对象所在的作用域，当程序流程执行到作用域结束处时，会释放该作用域内的所有对象，在释放的过程中会调用对象的析构函数。析构函...","permalink":"/post/C++逆向——析构函数","photos":[],"count_time":{"symbolsCount":"36k","symbolsTime":"33 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"https://github.com/0netry","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"类","uid":"ad77af543ae71f35c74ef1805fcae1ac","slug":"C++逆向——类","date":"2023-02-07T05:38:12.000Z","updated":"2025-06-07T15:51:48.097Z","comments":true,"path":"api/articles/C++逆向——类.json","keywords":null,"cover":[],"text":"结构体和类在C++中，结构体和类都具有构造函数、析构函数和成员函数，两者只有一个区别：结构体的访问控制默认为public，而类的默认访问控制是private。对...","permalink":"/post/C++逆向——类","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"https://github.com/0netry","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}