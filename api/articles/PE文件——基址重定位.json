{"title":"PE文件——基址重定位","uid":"79cf73108f662b9d6b8f237086d2463b","slug":"PE文件——基址重定位","date":"2022-05-03T14:33:53.000Z","updated":"2025-06-09T08:38:09.203Z","comments":true,"path":"api/articles/PE文件——基址重定位.json","keywords":null,"cover":[],"content":"<p>当链接器生成一个PE文件时，会假设这个文件在执行时被装载到默认的基地址处，并把code和data的相关地址都写入PE文件。如果载入时将默认的值作为基地址载入，则不需要重定位。但是，如果PE文件被装载到虚拟内存的另一个地址中，链接器登记的那个地址就是错误的，这时就需要用重定位表来调整。在PE文件中，重定位表往往单独作为一块，用”.reloc” 表示。</p>\n<h1 id=\"基址重定位的概念\"><a href=\"#基址重定位的概念\" class=\"headerlink\" title=\"基址重定位的概念\"></a>基址重定位的概念</h1><p>PE格式不参考外部DLL或模块中的其他区块，而是把文件中所有可能需要修改的地址放在一个数组里。如果PE文件不在首选的地址载入，那么文件中的每一个定位都需要被修正。对加载器来说，它不需要知道关于地址使用的任何细节，只要知道有一系列的数据需要以某种一致的方式来修正就可以了。下面以实例DlIDemo.DLL为例讲述其重定位过程。如下代码中两个加粗的地址指针就是需要重定位的数据。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E4%BD%8D%E8%BF%87%E7%A8%8B%E4%BB%A3%E7%A0%81.png\"></p>\n<p>分析一下0040100Eh处，其作用是将一个指针压入栈，00402000h是某一字符串的指针。这句指令有5字节长，第1个字节(68h)是指令的操作码，后4个字节用来保存一个DWORD大小的地址( 00402000h )。在这个例子中，指令来自一个基址为00400000h的DLL文件，因此这个字符串的RVA值是2000h。如果PE文件确实在00400000h处载入，指令就能够按照现在的样子正确执行。<br>但是，当DLL执行时，Windows 加载器决定将其映射到00870000h处(映射基址由系统决定),加载器就会比较基址和实际的载入地址，计算出一个差值。在这个例子中，差值是470000h, 这个差值能被加载到DWORD大小的地址里以形成新地址。在前面的例子中，地址0040100Fh是指令中双字的定位，对它将有一个基址重定位，实际上字符串的新地址就是00872000h。为了让Windows有能力进行这样的调整，可执行文件中有多个”基址重定位数据”。本例中的Windows 加载器应把470000h加给00402000h，并将结果00872000h写回原处。这个过程如下图所示。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%BF%87%E7%A8%8B.png\"></p>\n<p>DIlDemo.DLL在内存中进行重定位处理后的代码如下。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E4%BD%8D%E5%A4%84%E7%90%86%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81.png\"></p>\n<p>对EXE文件来说，每个文件总是使用独立的虛拟地址空间，所以EXE总是能够按照这个地址载入，这意味着EXE文件不再需要重定位信息。对DLL来说，因为多个DLL文件使用宿主EXE文件的地址空间，不能保证载入地址没有被其他DLL使用，所以DLL文件中必须包含重定位信息，除非用一个&#x2F;FIXED开关来忽略它们。在Visual Studio .NET中，链接器会为Debug和Release模式的EXE文件省略基址重定位，因此，在不同系统中跟踪同一个DLL文件时，其虚拟地址是不同的，也就是说，在读者的机器里运行DlIDemo.DLL, Windows加载器映射的基址可能不是00870000h,而是其他地址。</p>\n<h1 id=\"基址重定位表的结构\"><a href=\"#基址重定位表的结构\" class=\"headerlink\" title=\"基址重定位表的结构\"></a>基址重定位表的结构</h1><p>基址重定位表( Base Relocation Table)位于一个.reloc 区块内，找到它们的正确方式是通过数据目录表的<code>IMAGE_DIRECTORY_ENTRY_BASERELOC</code>条目查找。基址重定位数据采用类似按页分割的方法组织，是由许多重定位块串接成的，每个块中存放4KB (1000h)的重定位信息，每个重定位数据块的大小必须以DWORD( 4字节)对齐。它们以一个<code>IMAGE_BASE_RELOCATION</code>结构开始，格式如下。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/AGE_BASE_RELOCATION%E7%BB%93%E6%9E%84.png\"></p>\n<ul>\n<li>VirtualAddress: 这组重定位数据的开始RVA地址。各重定位项的地址加这个值才是该重定位项的完整RVA地址。</li>\n<li>SizeOfBlock: 当前重定位结构的大小。因为VirtualAddress和SizeOfBlock的大小都是固定的4字节，所以这个值减8就是Typeoffset数组的大小。</li>\n<li>Typeffset: 一个数组。数组每项大小为2字节，共16位。这16位分为高4位和低12位。高4位代表重定位类型; 低12位是重定位地址，它与VirtualAddress相加就是指向PE映像中需要修改的地址数据的指针。</li>\n</ul>\n<p>常见的重定位类型如下所示。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%9A%84%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%B1%BB%E5%9E%8B.png\"></p>\n<p>虽然有多种重定位类型，但对x86可执行文件来说，所有的基址重定位类型都是<code>IMAGE_REL_BASED_HIGHLOW</code>。在一组重定位结束的地方会出现一个类型是<code>IMAGE_REL_BASED_ABSOLUTE</code>的重定位，这些重定位什么都不做，只用于填充，以便下一个<code>IMAGE_BASE_RELOCATION</code>按4字节分界线对齐。所有重定位块以一个VirtualAddress 字段为0的<code>IMAGE_BASE_RELOCATION</code>结构结束。</p>\n<p>重定位表的结构如下图所示，它由数个<code>IMAGE_BASE_RELOCATION</code>结构组成，每个结构由VirtualAddress、SizeOfBlock 和TypeOffset 3部分组成。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E4%BD%8D%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png\"></p>\n<p>对于IA-64可执行文件，重定位类型似乎总是<code>IMAGE_REL_BASED_DIR64</code>。 就像x86重定位，也用<code>IMAGE_REL_BASED_ABSOLUTE</code>重定位类型进行填充。有趣的是，尽管IA-64的EXE页大小是8KB,但基址重定位仍是4KB的块。</p>\n<h1 id=\"基址重定位表实例分析\"><a href=\"#基址重定位表实例分析\" class=\"headerlink\" title=\"基址重定位表实例分析\"></a>基址重定位表实例分析</h1><p>下面以DlIDemo.DLL为例来讲解。数据目录表指向重定位表的指针是00005000h,换算成文件偏移地址就是00000E00h。其中<code>IMAGE_BASE_RELOCATION</code>结构如图所示。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8.png\"></p>\n<ul>\n<li><p>VirtualAddress: 00 00 10 00。</p>\n</li>\n<li><p>SizeOfBlock: 00 00 00 10 (有4个重定位数据，(10h -8h)&#x2F;2h&#x3D;4h )。</p>\n<p>➢重定位数据1: 30 0F。</p>\n<p>➢重定位数据2: 30 23。</p>\n<p>➢重定位数据3: 00 00 (用于对齐)。</p>\n<p>➢重定位数据4: 00 00 (用于对齐)。</p>\n<p>重定位数据计算过程如表11.15所示。</p>\n</li>\n</ul>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E4%BD%8D%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2.png\"></p>\n<p>用十六进制工具查看实例文件，其中60Fh和623h分别指向00402000h和00403030h处，如图11.25所示的阴影部分即为所需要重定位的数据。</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9A%84%E6%95%B0%E6%8D%AE.png\"></p>\n<p>执行PE文件前，加载程序在进行重定位的时候，会用PE文件在内存中的实际映像地址减PE文件所要求的映像地址，根据重定位类型的不同将差值添加到相应的地址数据中。</p>\n<h1 id=\"某次样本分析中基址重定位代码示例\"><a href=\"#某次样本分析中基址重定位代码示例\" class=\"headerlink\" title=\"某次样本分析中基址重定位代码示例\"></a>某次样本分析中基址重定位代码示例</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BOOL __cdecl <span class=\"title function_\">sub_2AC1F34</span><span class=\"params\">(_IMAGE_NT_HEADERS **a1, <span class=\"type\">int</span> a2)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  IMAGE_FILE_HEADER *v2; <span class=\"comment\">// ebx</span></span><br><span class=\"line\">  _DWORD *v4; <span class=\"comment\">// ecx</span></span><br><span class=\"line\">  <span class=\"type\">int</span> i; <span class=\"comment\">// eax</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v6; <span class=\"comment\">// edx</span></span><br><span class=\"line\">  _WORD *v7; <span class=\"comment\">// esi</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> v8; <span class=\"comment\">// edi</span></span><br><span class=\"line\">  _IMAGE_NT_HEADERS *v9; <span class=\"comment\">// [esp+4h] [ebp-8h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v2 = a1[<span class=\"number\">1</span>];</span><br><span class=\"line\">  v9 = v2;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !(*a1)-&gt;OptionalHeader.DataDirectory[<span class=\"number\">5</span>].Size )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a2 == <span class=\"number\">0</span>;</span><br><span class=\"line\">  v4 = (&amp;v2-&gt;Machine + (*a1)-&gt;OptionalHeader.DataDirectory[<span class=\"number\">5</span>].VirtualAddress);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = *v4; *v4; i = *v4 )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v6 = v4[<span class=\"number\">1</span>];</span><br><span class=\"line\">    v7 = v4 + <span class=\"number\">2</span>;</span><br><span class=\"line\">    v8 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( ((v6 - <span class=\"number\">8</span>) &amp; <span class=\"number\">0xFFFFFFFE</span>) != <span class=\"number\">0</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">do</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( (*v7 &amp; <span class=\"number\">0xF000</span>) == <span class=\"number\">0x3000</span> )         <span class=\"comment\">// 判断Typeffset高四位是否为3，即类型IMAGE_REL_BASED_HIGHLOW</span></span><br><span class=\"line\">                                                <span class=\"comment\">// 若是则进行基址重定位</span></span><br><span class=\"line\">          *(&amp;v2-&gt;Machine + i + (*v7 &amp; <span class=\"number\">0xFFF</span>)) += a2;</span><br><span class=\"line\">        v6 = v4[<span class=\"number\">1</span>];</span><br><span class=\"line\">        ++v8;</span><br><span class=\"line\">        ++v7;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> ( v8 &lt; (v6 - <span class=\"number\">8</span>) &gt;&gt; <span class=\"number\">1</span> );</span><br><span class=\"line\">      v2 = v9;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    v4 = (v4 + v6);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","text":"当链接器生成一个PE文件时，会假设这个文件在执行时被装载到默认的基地址处，并把code和data的相关地址都写入PE文件。如果载入时将默认的值作为基地址载入，则...","permalink":"/post/PE文件——基址重定位","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":9,"path":"api/tags/逆向.json"},{"name":"PE文件","slug":"PE文件","count":3,"path":"api/tags/PE文件.json"},{"name":"基址重定位","slug":"基址重定位","count":1,"path":"api/tags/基址重定位.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">基址重定位的概念</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">基址重定位表的结构</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">基址重定位表实例分析</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9F%90%E6%AC%A1%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E4%B8%AD%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">某次样本分析中基址重定位代码示例</span></a></li></ol>","author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"UPX脱壳实战——结合逆向工程核心原理","uid":"d804751ae060ee6bddee780d4be7bc78","slug":"UPX脱壳实战——结合逆向工程核心原理","date":"2022-05-11T03:23:55.000Z","updated":"2025-06-05T15:24:37.476Z","comments":true,"path":"api/articles/UPX脱壳实战——结合逆向工程核心原理.json","keywords":null,"cover":[],"text":"用《逆向工程核心原理》这本书中的notepad_upx.exe来实验 未加壳的oep 单步跟踪法脱壳的方法有很多，先来讲脱壳方法中最基础的单步跟踪法。单步跟踪法...","permalink":"/post/UPX脱壳实战——结合逆向工程核心原理","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"逆向工程核心原理","slug":"逆向工程核心原理","count":7,"path":"api/tags/逆向工程核心原理.json"},{"name":"加壳与脱壳","slug":"加壳与脱壳","count":1,"path":"api/tags/加壳与脱壳.json"},{"name":"iat修复","slug":"iat修复","count":1,"path":"api/tags/iat修复.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"编译器扩展的SEH","uid":"aa231c03641d31bfb6874bcdc873cd1e","slug":"编译器扩展的SEH","date":"2022-04-25T13:28:03.000Z","updated":"2025-06-08T15:42:15.590Z","comments":true,"path":"api/articles/编译器扩展的SEH.json","keywords":null,"cover":[],"text":"注：vc6++的异常处理函数为except_handler3，visual stdio的异常处理函数为except_handler4（具体见基于Visual S...","permalink":"/post/编译器扩展的SEH","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"24 mins."},"categories":[],"tags":[{"name":"Windows异常处理机制","slug":"Windows异常处理机制","count":2,"path":"api/tags/Windows异常处理机制.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}