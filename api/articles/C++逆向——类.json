{"title":"类","uid":"ad77af543ae71f35c74ef1805fcae1ac","slug":"C++逆向——类","date":"2023-02-07T05:38:12.000Z","updated":"2025-06-07T15:51:48.097Z","comments":true,"path":"api/articles/C++逆向——类.json","keywords":null,"cover":[],"content":"<h1 id=\"结构体和类\"><a href=\"#结构体和类\" class=\"headerlink\" title=\"结构体和类\"></a>结构体和类</h1><p>在C++中，结构体和类都具有构造函数、析构函数和成员函数，两者只有一个区别：结构体的访问控制默认为public，而类的默认访问控制是private。对于C++中的结构体而言，public、private、protected的访问控制都是在编译期进行检查，当越权访问时，编译过程中会检查此类错误并给予提示。编译成功后，程序在执行过程中不会在访问控制方面做任何检查和限制。因此，在反汇编中，C++的结构体与类没有分别，两者的原理相同，只是类型名称不同。</p>\n<h1 id=\"类与对象\"><a href=\"#类与对象\" class=\"headerlink\" title=\"类与对象\"></a>类与对象</h1><p>结构体和类都是抽象的，在真实世界中它们只可以表示某个群体，无法确定这个群体中的某个独立个体，而对象则是群体中独立存在的个体。如：</p>\n<p>人 → 类、结构，抽象的概念</p>\n<p>关羽 → 实例对象，实际存在的事物</p>\n<p>由于类是抽象概念，当两个类的特征相同时，它们之间就是相等的关系。而对象是实际存在的，即使它们之间包含的数据相同，也不能视为同一个对象。</p>\n<h2 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h2><p>下面的代码定义了自定义类型Person类以及该类的实例对象person。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">class Person &#123; //Person为抽象类名称，如同“人”这个名称</span><br><span class=\"line\">public:</span><br><span class=\"line\">Person() &#123;</span><br><span class=\"line\">age = 18;</span><br><span class=\"line\">height = 180;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int getAge() &#123; //类成员函数，如人类的行为，吃、喝、睡等</span><br><span class=\"line\">return age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int getHeight() &#123;</span><br><span class=\"line\">return height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">int age; //类数据成员，如人类的身高、体重等</span><br><span class=\"line\">int height;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main(int argc, char* argv[]) &#123;</span><br><span class=\"line\">Person person; //类的实例对象</span><br><span class=\"line\">return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面我们来看看对象person在内存中的布局</p>\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E5%B8%83%E5%B1%80/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png\" alt=\"对象的内存布局\"></p>\n<p>从上图可以看出对象person在内存中的地址为0x009EF790，该地址 处 定 义 了 对 象 person 的 各 个 数 据 成 员 ， 分 别 存 放 在 地 址0x009EF790与0x009EF794处。对象person中先定义的数据成员在低地址处，后定义的数据成员在高地址处，依次排列。对象的大小只包含数据成员，类成员函数属于执行代码，不属于类对象的数据。</p>\n<p>由图可知，凡是属于Person类型的变量，在内存中都会占据8字节的空间。这8字节由类中的两个数据成员组成，它们都是int类型，数据长度为4字节。</p>\n<p><strong>为什么在类中不能定义自身的对象呢？</strong></p>\n<p>这是因为类需要在申请内存的过程中计算出自身的大小，以用于实例化。如果在类中定义了自身的对象，在计算各数据成员的长度时，又会回到自身，这样就形成了递归定义，而这个递归并没有出口，是一个无限循环的递归定义，所以不能定义自身对象作为类成员。但是，自身类型的指针除外，因为任何类型的指针在32位下占用的内存大小始终为4字节，64位下占8个字节，等同于一个常量值，因此将其作为类的数据成员不会影响长度的计算。</p>\n<h2 id=\"空类\"><a href=\"#空类\" class=\"headerlink\" title=\"空类\"></a>空类</h2><p>空类中没有任何数据成员，按照该公式计算得出的对象长度为0字节。类型长度为0，则此类的对象不占内存空间。而实际情况是，空类的长度为1字节。如果对象完全不占用内存空间，空类就无法取得实例对象的地址，this指针失效，因此不能被实例化。而类的定义是由成员数据和成员函数组成的，在没有成员数据的情况下，还可以有成员函数，因此仍然需要做实例化。分配1字节的空间用于类的实例化，这1字节的数据并没有被使用。</p>\n<h2 id=\"this指针\"><a href=\"#this指针\" class=\"headerlink\" title=\"this指针\"></a>this指针</h2><p>this指针应属于指针类型。this指针在32位环境下占4字节空间，在64位环境下占8字节空间，保存的数据为地址信息。“this”可翻译为“这个”，因此经过字面分析可认为<strong>this指针中保存了所属对象的首地址</strong>。</p>\n<h3 id=\"访问类对象的数据成员\"><a href=\"#访问类对象的数据成员\" class=\"headerlink\" title=\"访问类对象的数据成员\"></a>访问类对象的数据成员</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"type\">int</span> age)</span> </span>&#123; <span class=\"comment\">//公有成员函数</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>-&gt;age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"type\">int</span> age; <span class=\"comment\">//公有数据成员</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">Person person;</span><br><span class=\"line\">person.<span class=\"built_in\">setAge</span>(<span class=\"number\">5</span>); <span class=\"comment\">//调用成员函数</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Person : %d\\n&quot;</span>, person.age); <span class=\"comment\">//获取数据成员</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ida汇编及伪代码视图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//main函数</span><br><span class=\"line\">.text:004010A0 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:004010A0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:004010A0</span><br><span class=\"line\">.text:004010A0 var_8           = dword ptr -8</span><br><span class=\"line\">.text:004010A0 var_4           = dword ptr -4</span><br><span class=\"line\">.text:004010A0 argc            = dword ptr  8</span><br><span class=\"line\">.text:004010A0 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:004010A0 envp            = dword ptr  10h</span><br><span class=\"line\">.text:004010A0</span><br><span class=\"line\">.text:004010A0                 push    ebp</span><br><span class=\"line\">.text:004010A1                 mov     ebp, esp</span><br><span class=\"line\">.text:004010A3                 sub     esp, 8</span><br><span class=\"line\">.text:004010A6                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:004010AB                 xor     eax, ebp</span><br><span class=\"line\">.text:004010AD                 mov     [ebp-4], eax</span><br><span class=\"line\">.text:004010B0                 push    5               ; 压入参数5</span><br><span class=\"line\">.text:004010B2                 lea     ecx, [ebp-8]    ; 传参，取出对象person的首地址存入ecx</span><br><span class=\"line\">.text:004010B5                 call    sub_401080      ; 调用setAge成员函数</span><br><span class=\"line\">.text:004010BA                 mov     eax, [ebp-8]    ; 取出对象首地址处4字节的数据age存入eax</span><br><span class=\"line\">.text:004010BD                 push    eax             ; 将eax中保存的数据成员存入传参</span><br><span class=\"line\">.text:004010BE                 push    offset aPersonD ; &quot;Person : %d\\n&quot;</span><br><span class=\"line\">.text:004010C3                 call    sub_401040      ; 调用printf函数</span><br><span class=\"line\">.text:004010C8                 add     esp, 8</span><br><span class=\"line\">.text:004010CB                 xor     eax, eax</span><br><span class=\"line\">.text:004010CD                 mov     ecx, [ebp+var_4]</span><br><span class=\"line\">.text:004010D0                 xor     ecx, ebp        ; StackCookie</span><br><span class=\"line\">.text:004010D2                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class=\"line\">.text:004010D7                 mov     esp, ebp</span><br><span class=\"line\">.text:004010D9                 pop     ebp</span><br><span class=\"line\">.text:004010DA                 retn</span><br><span class=\"line\">.text:004010DA _main           endp</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//setAge成员函数</span><br><span class=\"line\">.text:00401080 sub_401080      proc near               ; CODE XREF: _main+15↓p</span><br><span class=\"line\">.text:00401080</span><br><span class=\"line\">.text:00401080 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401080 arg_0           = dword ptr  8</span><br><span class=\"line\">.text:00401080</span><br><span class=\"line\">.text:00401080                 push    ebp</span><br><span class=\"line\">.text:00401081                 mov     ebp, esp</span><br><span class=\"line\">.text:00401083                 push    ecx             ; 申请局部变量空间</span><br><span class=\"line\">.text:00401084                 mov     [ebp-4], ecx    ; ecx中保存了对象person的首地址</span><br><span class=\"line\">.text:00401087                 mov     eax, [ebp-4]    ; eax=this</span><br><span class=\"line\">.text:0040108A                 mov     ecx, [ebp+8]    ; ecx=参数age</span><br><span class=\"line\">.text:0040108D                 mov     [eax], ecx      ; this-&gt;age = 参数age</span><br><span class=\"line\">.text:0040108F                 mov     esp, ebp</span><br><span class=\"line\">.text:00401091                 pop     ebp</span><br><span class=\"line\">.text:00401092                 retn    4</span><br><span class=\"line\">.text:00401092 sub_401080      endp</span><br><span class=\"line\"></span><br><span class=\"line\">_DWORD *__thiscall sub_401080(_DWORD *this, int a2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  _DWORD *result; // eax</span><br><span class=\"line\"></span><br><span class=\"line\">  result = this;</span><br><span class=\"line\">  *this = a2;</span><br><span class=\"line\">  return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码演示了对象调用成员的方法以及取出数据成员的过程。使用默认的调用约定时，在调用成员函数的过程中，编译器做了一个“小动作”：利用寄存器ecx保存了对象的首地址，并以寄存器传参的方式将其传递到成员函数中，这便是this指针的由来。由此可见，所有成员函数（非静态成员函数）都有一个隐藏参数，即自身类型的指针，这样的默认调用约定称为thiscall。在成员函数中访问数据成员也是通过this指针间接访问的，这便是在成员函数内可以直接使用数据成员的原因。在类中使用数据成员和成员函数时，编译器隐藏了如下操作。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//隐藏传递了this指针，这里实际为this-&gt;getAge()</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, <span class=\"built_in\">getAge</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//隐藏传递了this指针，这里实际为retrun this-&gt;age</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在C++的环境下，识别this指针的关键点是在函数的调用过程中使用ecx作为第一个参数，在ecx中保存的数据为对象的首地址，但并非所有this指针的传递都是如此。</p>\n<p>成员函数SetAge的调用方式为thiscall。thiscall的栈平衡方式与__stdcall相同，都是被调用方负责平衡。但是，两者传递参数的过程却不一样，声明为thiscall的函数，第一个参数使用寄存器ecx传递，而非通过栈顶传递。而且thiscall并不属于关键字，它是C++中成员函数特有的调用方式，在C语言中是没有这种调用方式的。由于在C++环境下，thiscall不属于关键字，因此函数无法显式声明为thiscall调用方式，而类的成员函数默认为thiscall调用方式。所以，在分析过程中，如果看到某函数使用ecx传递参数，且ecx中保留了对象的this指针以及在函数实现代码内，存在this指针参与的寄存器相对间接访问方式，如[reg+8]，即可怀疑此函数为成员函数。因为64位程序本来就使用rcx传递参数，所以无此特征。</p>\n<p>使用thiscall调用方式的成员函数要点分析如下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lea ecx, [mem] ; 取对象首地址并存入ecx，要注意观察内存</span><br><span class=\"line\">call FUN_ADDRESS ; 调用成员函数</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">; 在函数调用内，ecx 尚未重新赋值之前</span><br><span class=\"line\">mov XXX, ecx ; 发现函数内使用ecx中的数据，说明函数调用前对ecx的赋值，实际上是在传递参数</span><br><span class=\"line\">; 其后 ecx 中的内容会传递给其他寄存器</span><br><span class=\"line\">mov [reg+i], XXX ; 发现了寄存器相对间接寻址方式，如果能排除数组访问，说明reg中保存的是结构体或者类对象的首地址</span><br></pre></td></tr></table></figure>\n\n<p>符合以上特点，基本可判定这是调用类的成员函数。通过分析函数代码中访问ecx的方式，再结合内存窗口，以ecx中的值为地址观察其数据，可以进一步分析并还原对象中的各数据成员。</p>\n<h2 id=\"静态数据成员\"><a href=\"#静态数据成员\" class=\"headerlink\" title=\"静态数据成员\"></a>静态数据成员</h2><p>当类中的数据成员被修饰为静态时，对象的长度计算又会发生变化。虽然静态数据成员是在类中被定义的，但它与局部静态变量类似，存放的位置和全局变量一致。只是编译器增加了作用域的检查，在作用域之外不可见。同类对象将共同享有静态数据成员的空间。</p>\n<p>当对象为全局对象时，其内存布局与局部对象相同，只是所在内存地址以及构造函数和析构函数的触发时机不同。全局对象所在的内存地址空间为全局数据区，而局部对象的内存地址空间在栈中。</p>\n<p>因为静态数据成员和静态变量原理相同（都是含有作用域的特殊全局变量），所以该静态数据成员的初值会被写入编译链接后的执行文件。当程序被加载时，操作系统将执行文件中的数据读到对应的内存单元里，静态数据成员已经存在，而这时类并没有实例对象。静态数据成员和对象之间的生命周期不同，并且静态数据成员也不属于某一对象，与对象之间是一对多的关系。静态数据成员仅仅和类相关，和对象无关，多个对象可以拥有同一个静态数据成员。</p>\n<p>因为静态数据成员有此特性，所以在计算类和对象的长度时，静态数据成员属于特殊的独立个体，不被计算在其中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Static</span> &#123; <span class=\"comment\">//类CStatic的定义</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> staticNum; <span class=\"comment\">//静态数据成员</span></span><br><span class=\"line\"><span class=\"type\">int</span> num; <span class=\"comment\">//普通数据成员</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> Static::staticNum = <span class=\"number\">0</span>; <span class=\"comment\">//静态数据成员初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">Static obj;</span><br><span class=\"line\"><span class=\"type\">int</span> size = <span class=\"built_in\">sizeof</span>(obj); <span class=\"comment\">//计算对象长度</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Static : %d\\n&quot;</span>, size); <span class=\"comment\">//显示对象长度</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/post/GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/%E5%91%98/%E6%9C%89%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97.png\" alt=\"有静态成员的类大小计算\"></p>\n<p>通过sizeof获得对象obj占用的内存长度为4。静态数据成员staticNum没有参与对象obj的长度计算。staticNum为静态数据成员，num为普通数据成员，两者所属的内存地址空间不同，这也是静态数据成员不参与长度计算的原因之一，两者对比如下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printf(&quot;0x%08x\\n&quot;, &amp;obj.staticNum); //使用对象直接调用静态数据成员</span><br><span class=\"line\">push 0A2A2D4h //静态成员所在地址为0x0A2A2D4</span><br><span class=\"line\">//部分printf代码分析略</span><br><span class=\"line\">printf(&quot;0x%08x\\n&quot;, &amp;obj.num); //获取普通数据成员地址</span><br><span class=\"line\">//获取对象的首地址并存入ecx，得到数据成员num的地址</span><br><span class=\"line\">lea eax,[ebp-0Ch]</span><br><span class=\"line\">//部分printf代码分析略</span><br></pre></td></tr></table></figure>\n\n<p>在以上代码分析中，静态数据成员所在的地址为0x0A2A2D4，而普通数据成员的地址在ebp-0Ch中，是一个栈空间地址。在使用的过程中，静态数据成员是常量地址，可通过立即数间接寻址的方式访问。普通数据成员只有在类对象产生后才出现，地址值无法确定，只能以寄存器相对间接寻址的方式进行访问。在成员函数中使用这两种数据成员时，因为静态数据成员属于全局变量，并且不属于任何对象，所以访问时无须this指针。而普通的数据成员属于对象所有，访问时需要使用this指针</p>\n<h3 id=\"在成员函数中使用静态数据成员与普通数据成员\"><a href=\"#在成员函数中使用静态数据成员与普通数据成员\" class=\"headerlink\" title=\"在成员函数中使用静态数据成员与普通数据成员\"></a>在成员函数中使用静态数据成员与普通数据成员</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> count; <span class=\"comment\">//静态数据成员</span></span><br><span class=\"line\"><span class=\"type\">int</span> age; <span class=\"comment\">//普通数据成员</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> Person::count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Person::show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;age = %d , count = %d&quot;</span>, age, count);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">Person person;</span><br><span class=\"line\">person.age = <span class=\"number\">1</span>;</span><br><span class=\"line\">person.count = <span class=\"number\">2</span>;</span><br><span class=\"line\">person.<span class=\"built_in\">show</span>();</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ida汇编及伪代码视图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//main函数</span><br><span class=\"line\">.text:004010B0 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:004010B0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:004010B0</span><br><span class=\"line\">.text:004010B0 var_8           = dword ptr -8</span><br><span class=\"line\">.text:004010B0 var_4           = dword ptr -4</span><br><span class=\"line\">.text:004010B0 argc            = dword ptr  8</span><br><span class=\"line\">.text:004010B0 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:004010B0 envp            = dword ptr  10h</span><br><span class=\"line\">.text:004010B0</span><br><span class=\"line\">.text:004010B0                 push    ebp</span><br><span class=\"line\">.text:004010B1                 mov     ebp, esp</span><br><span class=\"line\">.text:004010B3                 sub     esp, 8</span><br><span class=\"line\">.text:004010B6                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:004010BB                 xor     eax, ebp</span><br><span class=\"line\">.text:004010BD                 mov     [ebp-4], eax</span><br><span class=\"line\">.text:004010C0                 mov     dword ptr [ebp-8], 1 ; person.age=1，普通数据成员赋值</span><br><span class=\"line\">.text:004010C7                 mov     dword ptr unk_403378, 2 ; person.count=2，静态数据成员赋值</span><br><span class=\"line\">.text:004010D1                 lea     ecx, [ebp-8]    ; 传递this指针</span><br><span class=\"line\">.text:004010D4                 call    sub_401080      ; 调用show成员函数</span><br><span class=\"line\">.text:004010D9                 xor     eax, eax</span><br><span class=\"line\">.text:004010DB                 mov     ecx, [ebp-4]</span><br><span class=\"line\">.text:004010DE                 xor     ecx, ebp        ; StackCookie</span><br><span class=\"line\">.text:004010E0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class=\"line\">.text:004010E5                 mov     esp, ebp</span><br><span class=\"line\">.text:004010E7                 pop     ebp</span><br><span class=\"line\">.text:004010E8                 retn</span><br><span class=\"line\">.text:004010E8 _main           endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  int v4; // [esp+0h] [ebp-8h] BYREF</span><br><span class=\"line\"></span><br><span class=\"line\">  v4 = 1;</span><br><span class=\"line\">  unk_403378 = 2;</span><br><span class=\"line\">  ((void (__thiscall *)(int *))sub_401080)(&amp;v4);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//show成员函数</span><br><span class=\"line\">.text:00401080 ; int __thiscall sub_401080(_DWORD *this)</span><br><span class=\"line\">.text:00401080 sub_401080      proc near               ; CODE XREF: _main+24↓p</span><br><span class=\"line\">.text:00401080</span><br><span class=\"line\">.text:00401080 var_4           = dword ptr -4</span><br><span class=\"line\">.text:00401080</span><br><span class=\"line\">.text:00401080                 push    ebp</span><br><span class=\"line\">.text:00401081                 mov     ebp, esp</span><br><span class=\"line\">.text:00401083                 push    ecx</span><br><span class=\"line\">.text:00401084                 mov     [ebp-4], ecx    ; 获取this指针</span><br><span class=\"line\">.text:00401087                 mov     eax, dword ptr unk_403378 ; 直接访问静态数据成员count</span><br><span class=\"line\">.text:0040108C                 push    eax</span><br><span class=\"line\">.text:0040108D                 mov     ecx, [ebp-4]    ; 获取this指针</span><br><span class=\"line\">.text:00401090                 mov     edx, [ecx]      ; 通过this指针访问数据成员age</span><br><span class=\"line\">.text:00401092                 push    edx             ; char</span><br><span class=\"line\">.text:00401093                 push    offset Format   ; &quot;age = %d , count = %d&quot;</span><br><span class=\"line\">.text:00401098                 call    sub_401040      ; 调用printf函数</span><br><span class=\"line\">.text:0040109D                 add     esp, 0Ch</span><br><span class=\"line\">.text:004010A0                 mov     esp, ebp</span><br><span class=\"line\">.text:004010A2                 pop     ebp</span><br><span class=\"line\">.text:004010A3                 retn</span><br><span class=\"line\">.text:004010A3 sub_401080      endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __thiscall sub_401080(_DWORD *this)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return sub_401040(&quot;age = %d , count = %d&quot;, *this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int sub_401040(char *Format, ...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  FILE *v1; // eax</span><br><span class=\"line\">  va_list va; // [esp+14h] [ebp+Ch] BYREF</span><br><span class=\"line\"></span><br><span class=\"line\">  va_start(va, Format);</span><br><span class=\"line\">  v1 = _acrt_iob_func(1u);</span><br><span class=\"line\">  return sub_401010(v1, Format, 0, va);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int __cdecl sub_401010(FILE *Stream, char *Format, _locale_t Locale, va_list ArgList)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  unsigned __int64 *v4; // eax</span><br><span class=\"line\"></span><br><span class=\"line\">  v4 = (unsigned __int64 *)sub_401000();</span><br><span class=\"line\">  return _stdio_common_vfprintf(*v4, Stream, Format, Locale, ArgList);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>静态数据成员在反汇编代码中很难被识别，这是因为其展示形态与全局变量相同，很难被还原成对应的高级代码。可参考其代码的功能，酌情处理。</p>\n<h2 id=\"对象作为函数参数\"><a href=\"#对象作为函数参数\" class=\"headerlink\" title=\"对象作为函数参数\"></a>对象作为函数参数</h2><p>对象作为函数的参数时，其传递过程较为复杂，传递方式也比较独特。对象的传参过程与数组不同，数组变量的名称代表数组的首地址，而<strong>对象的变量名称却不能代表对象的首地址</strong>。传参时不会像数组那样以首地址作为参数传递，而是<strong>先将对象中的所有数据进行备份（复制），将备份的数据作为形参传递到调用函数中使用。</strong></p>\n<h3 id=\"对象作为函数的参数\"><a href=\"#对象作为函数的参数\" class=\"headerlink\" title=\"对象作为函数的参数\"></a>对象作为函数的参数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> age;</span><br><span class=\"line\">\t<span class=\"type\">int</span> height;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">(Person person)</span> </span>&#123; <span class=\"comment\">//参数为类Person的对象</span></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;age = %d , height = %d\\n&quot;</span>, person.age,</span><br><span class=\"line\">\t\tperson.height);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\tPerson person;</span><br><span class=\"line\">\tperson.age = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tperson.height = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">show</span>(person);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ida汇编及伪代码视图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//main函数</span><br><span class=\"line\">.text:004010A0 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:004010A0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:004010A0</span><br><span class=\"line\">.text:004010A0 var_8           = dword ptr -8</span><br><span class=\"line\">.text:004010A0 var_4           = dword ptr -4</span><br><span class=\"line\">.text:004010A0 argc            = dword ptr  8</span><br><span class=\"line\">.text:004010A0 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:004010A0 envp            = dword ptr  10h</span><br><span class=\"line\">.text:004010A0</span><br><span class=\"line\">.text:004010A0                 push    ebp</span><br><span class=\"line\">.text:004010A1                 mov     ebp, esp</span><br><span class=\"line\">.text:004010A3                 sub     esp, 8</span><br><span class=\"line\">.text:004010A6                 mov     dword ptr [ebp-8], 1 ; person.age=1，对象首地址为ebp-8</span><br><span class=\"line\">.text:004010AD                 mov     dword ptr [ebp-4], 2 ; person.height=2</span><br><span class=\"line\">.text:004010B4                 mov     eax, [ebp-4]</span><br><span class=\"line\">.text:004010B7                 push    eax             ; 传递参数2，person.height</span><br><span class=\"line\">.text:004010B8                 mov     ecx, [ebp-8]</span><br><span class=\"line\">.text:004010BB                 push    ecx             ; 传递参数1，person.age</span><br><span class=\"line\">.text:004010BC                 call    sub_401080      ; 调用show函数</span><br><span class=\"line\">.text:004010C1                 add     esp, 8</span><br><span class=\"line\">.text:004010C4                 xor     eax, eax</span><br><span class=\"line\">.text:004010C6                 mov     esp, ebp</span><br><span class=\"line\">.text:004010C8                 pop     ebp</span><br><span class=\"line\">.text:004010C9                 retn</span><br><span class=\"line\">.text:004010C9 _main           endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  sub_401080(1, 2);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//show函数</span><br><span class=\"line\">.text:00401080 ; int __cdecl sub_401080(char)</span><br><span class=\"line\">.text:00401080 sub_401080      proc near               ; CODE XREF: _main+1C↓p</span><br><span class=\"line\">.text:00401080</span><br><span class=\"line\">.text:00401080 arg_0           = byte ptr  8</span><br><span class=\"line\">.text:00401080 arg_4           = dword ptr  0Ch</span><br><span class=\"line\">.text:00401080</span><br><span class=\"line\">.text:00401080                 push    ebp</span><br><span class=\"line\">.text:00401081                 mov     ebp, esp</span><br><span class=\"line\">.text:00401083                 mov     eax, [ebp+0Ch]  ; person.height</span><br><span class=\"line\">.text:00401086                 push    eax</span><br><span class=\"line\">.text:00401087                 mov     ecx, [ebp+8]    ; person.age，对象首地址为ebp+8</span><br><span class=\"line\">.text:0040108A                 push    ecx             ; char</span><br><span class=\"line\">.text:0040108B                 push    offset Format   ; &quot;age = %d , height = %d\\n&quot;</span><br><span class=\"line\">.text:00401090                 call    sub_401040      ; 调用printf函数</span><br><span class=\"line\">.text:00401095                 add     esp, 0Ch</span><br><span class=\"line\">.text:00401098                 pop     ebp</span><br><span class=\"line\">.text:00401099                 retn</span><br><span class=\"line\">.text:00401099 sub_401080      endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl sub_401080(char a1)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  return sub_401040(&quot;age = %d , height = %d\\n&quot;, a1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中的类Person的体积不大，只有两个数据成员，编译器在调用函数传参的过程中分别将对象的两个成员依次压栈，也就是直接将两个数据成员当成两个int类型数据，并将它们当作printf函数的参数。64位程序中直接使用一个寄存器存储类的两个数据成员。同理，它们也是一份复制数据，除数据相同外，与对象中的两个数据成员没有关系。</p>\n<p>类对象中数据成员的传参顺序为最先定义的数据成员最后压栈，最后定义的数据成员最先压栈。</p>\n<h3 id=\"含有数组数据成员的对象传参\"><a href=\"#含有数组数据成员的对象传参\" class=\"headerlink\" title=\"含有数组数据成员的对象传参\"></a>含有数组数据成员的对象传参</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> age;</span><br><span class=\"line\">\t<span class=\"type\">int</span> height;</span><br><span class=\"line\">\t<span class=\"type\">char</span> name[<span class=\"number\">32</span>]; <span class=\"comment\">//定义数组类型的数据成员</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">(Person person)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;age = %d , height = %d name:%s\\n&quot;</span>, person.age,</span><br><span class=\"line\">\t\tperson.height, person.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\tPerson person;</span><br><span class=\"line\">\tperson.age = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tperson.height = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(person.name, <span class=\"string\">&quot;tom&quot;</span>); <span class=\"comment\">//赋值数据成员数组</span></span><br><span class=\"line\">\t<span class=\"built_in\">show</span>(person);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ida汇编及伪代码视图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:004010A0 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:004010A0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:004010A0</span><br><span class=\"line\">.text:004010A0 var_2C          = dword ptr -2Ch</span><br><span class=\"line\">.text:004010A0 var_28          = dword ptr -28h</span><br><span class=\"line\">.text:004010A0 var_24          = dword ptr -24h</span><br><span class=\"line\">.text:004010A0 var_4           = dword ptr -4</span><br><span class=\"line\">.text:004010A0 argc            = dword ptr  8</span><br><span class=\"line\">.text:004010A0 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:004010A0 envp            = dword ptr  10h</span><br><span class=\"line\">.text:004010A0</span><br><span class=\"line\">.text:004010A0                 push    ebp</span><br><span class=\"line\">.text:004010A1                 mov     ebp, esp</span><br><span class=\"line\">.text:004010A3                 sub     esp, 2Ch</span><br><span class=\"line\">.text:004010A6                 mov     eax, ___security_cookie</span><br><span class=\"line\">.text:004010AB                 xor     eax, ebp</span><br><span class=\"line\">.text:004010AD                 mov     [ebp-4], eax</span><br><span class=\"line\">.text:004010B0                 push    esi</span><br><span class=\"line\">.text:004010B1                 push    edi</span><br><span class=\"line\">.text:004010B2                 mov     dword ptr [ebp-2Ch], 1 ; person.age=1，对象首地址ebp-2Ch</span><br><span class=\"line\">.text:004010B9                 mov     dword ptr [ebp-28h], 2 ; person.height=2</span><br><span class=\"line\">.text:004010C0                 mov     eax, ds:dword_402120 ; &quot;tom&quot;</span><br><span class=\"line\">.text:004010C5                 mov     [ebp-24h], eax  ; eax=person.name地址</span><br><span class=\"line\">.text:004010C8                 sub     esp, 28h        ；调整栈顶</span><br><span class=\"line\">.text:004010CB                 mov     ecx, 0Ah        ; 设置循环次数为10</span><br><span class=\"line\">.text:004010D0                 lea     esi, [ebp-2Ch]  ; 获取对象的首地址并保存到esi</span><br><span class=\"line\">.text:004010D3                 mov     edi, esp        ; 设置edi为当前栈顶</span><br><span class=\"line\">.text:004010D5                 rep movsd               ; 执行10次4字节内存复制，将esi所指向的数据复制到edi中，类似memcpy的内联方式</span><br><span class=\"line\">.text:004010D7                 call    sub_401080      ; 调用show函数</span><br><span class=\"line\">.text:004010DC                 add     esp, 28h</span><br><span class=\"line\">.text:004010DF                 xor     eax, eax</span><br><span class=\"line\">.text:004010E1                 pop     edi</span><br><span class=\"line\">.text:004010E2                 pop     esi</span><br><span class=\"line\">.text:004010E3                 mov     ecx, [ebp-4]</span><br><span class=\"line\">.text:004010E6                 xor     ecx, ebp        ; StackCookie</span><br><span class=\"line\">.text:004010E8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class=\"line\">.text:004010ED                 mov     esp, ebp</span><br><span class=\"line\">.text:004010EF                 pop     ebp</span><br><span class=\"line\">.text:004010F0                 retn</span><br><span class=\"line\">.text:004010F0 _main           endp</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  _DWORD v4[10]; // [esp-28h] [ebp-5Ch] BYREF</span><br><span class=\"line\">  int v5[10]; // [esp+8h] [ebp-2Ch] BYREF</span><br><span class=\"line\"></span><br><span class=\"line\">  v5[0] = 1;</span><br><span class=\"line\">  v5[1] = 2;</span><br><span class=\"line\">  v5[2] = &#x27;mot&#x27;;</span><br><span class=\"line\">  qmemcpy(v4, v5, sizeof(v4));</span><br><span class=\"line\">  sub_401080(v4[0], v4[1], v4[2]);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在传递类对象的过程中调整栈顶指针esp，（参数变量在传递时，需要向低地址调整栈顶指针esp）</p>\n<h3 id=\"深拷贝数据\"><a href=\"#深拷贝数据\" class=\"headerlink\" title=\"深拷贝数据\"></a>深拷贝数据</h3><p>在复制对象时，编译器会调用一次该类的复制构造函数，给编码者一次机会。深拷贝利用这次机会原对象的数据成员保存的资源信息制作一份副本。这样，当销毁复制对象时，销毁的资源是复制对象在复制构造函数中制作的副本，而非原对象中保存的资源信息。</p>\n<h3 id=\"设置引用计数\"><a href=\"#设置引用计数\" class=\"headerlink\" title=\"设置引用计数\"></a>设置引用计数</h3><p>在进入复制构造函数时，记录类对象被复制引用的次数。当对象被销毁时，检查这个引用计数中保存的引用复制次数是否为0。如果是，则释放申请的资源，否则引用计数减1。当参数为对象的指针类型时，则不存在这种错误。传递的数据是指针类型，在函数内的操作都是针对原对象的，不存在对象被复制的问题。因为没有副本，所以在函数进入和退出时不会调用构造函数和析构函数，也就不存在资源释放的错误隐患。在使用类对象作为参数时，如无特殊需求，应尽量使用指针或引用。这样做不但可以避免资源释放的错误隐患，还可以在函数调用过程中避免复制对象的过程，提升程序运行的效率</p>\n<h2 id=\"对象作为返回值\"><a href=\"#对象作为返回值\" class=\"headerlink\" title=\"对象作为返回值\"></a>对象作为返回值</h2><p>对象作为返回值与对象作为参数的处理方式非常相似。对象作为参数时，进入函数前预先保留对象使用的栈空间并将实参对象中的数据复制到栈空间中。该栈空间作为函数参数，用于函数内部使用。同理，对象作为返回值时，进入函数后将申请返回对象使用的栈空间，在退出函数时，将返回对象中的数据复制到临时的栈空间中，以这个临时栈空间的首地址作为返回值。</p>\n<h3 id=\"对象作为返回值-1\"><a href=\"#对象作为返回值-1\" class=\"headerlink\" title=\"对象作为返回值\"></a>对象作为返回值</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> <span class=\"keyword\">warning</span>(disable : 4996)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"type\">int</span> count;</span><br><span class=\"line\">\t<span class=\"type\">int</span> buffer[<span class=\"number\">10</span>]; <span class=\"comment\">//定义两个数据成员，该类的大小为44字节</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\">Person <span class=\"title\">getPerson</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tPerson person;</span><br><span class=\"line\">\tperson.count = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">\t\tperson.buffer[i] = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> person;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">\tPerson person;</span><br><span class=\"line\">\tperson = <span class=\"built_in\">getPerson</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d %d&quot;</span>, person.count, person.buffer[<span class=\"number\">0</span>],</span><br><span class=\"line\">\t\tperson.buffer[<span class=\"number\">9</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ida汇编及伪代码视图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:004010D0 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">.text:004010D0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p</span><br><span class=\"line\">.text:004010D0</span><br><span class=\"line\">.text:004010D0 var_84          = byte ptr -84h</span><br><span class=\"line\">.text:004010D0 var_58          = byte ptr -58h</span><br><span class=\"line\">.text:004010D0 var_2C          = byte ptr -2Ch</span><br><span class=\"line\">.text:004010D0 var_28          = dword ptr -28h</span><br><span class=\"line\">.text:004010D0 argc            = dword ptr  8</span><br><span class=\"line\">.text:004010D0 argv            = dword ptr  0Ch</span><br><span class=\"line\">.text:004010D0 envp            = dword ptr  10h</span><br><span class=\"line\">.text:004010D0</span><br><span class=\"line\">.text:004010D0                 push    ebp</span><br><span class=\"line\">.text:004010D1                 mov     ebp, esp</span><br><span class=\"line\">.text:004010D3                 sub     esp, 84h        ; 预留返回对象的栈空间</span><br><span class=\"line\">.text:004010D9                 push    esi</span><br><span class=\"line\">.text:004010DA                 push    edi</span><br><span class=\"line\">.text:004010DB                 lea     eax, [ebp-84h]  ; 获取返回对象的栈空间首地址</span><br><span class=\"line\">.text:004010E1                 push    eax             ; 将返回对象的首地址压入栈中，用于保存返回对象的数据</span><br><span class=\"line\">.text:004010E2                 call    sub_401080      ; 调用getPerson函数</span><br><span class=\"line\">.text:004010E7                 add     esp, 4          ; 函数调用结束后，eax中保存着地址ebp-84h，即返回对象的首地址</span><br><span class=\"line\">.text:004010EA                 mov     ecx, 0Bh        ; 设置循环次数</span><br><span class=\"line\">.text:004010EF                 mov     esi, eax        ; 将返回对象的首地址存入esi中</span><br><span class=\"line\">.text:004010F1                 lea     edi, [ebp-58h]  ; 获取临时对象的首地址</span><br><span class=\"line\">.text:004010F4                 rep movsd               ; 每次从返回对象中复制4字节数据到临时对象的地址中，共复制11次</span><br><span class=\"line\">.text:004010F6                 mov     ecx, 0Bh        ; 重新设置复制次数</span><br><span class=\"line\">.text:004010FB                 lea     esi, [ebp-58h]  ; 获取临时对象的首地址</span><br><span class=\"line\">.text:004010FE                 lea     edi, [ebp-2Ch]  ; 获取对象person的首地址</span><br><span class=\"line\">.text:00401101                 rep movsd               ; 将数据复制到对象person中</span><br><span class=\"line\">.text:00401103                 mov     ecx, 4</span><br><span class=\"line\">.text:00401108                 imul    edx, ecx, 9</span><br><span class=\"line\">.text:0040110B                 mov     eax, [ebp+edx-28h] ; eax=[ebp-2Ch+4+9*4]</span><br><span class=\"line\">.text:0040110F                 push    eax             ; 参数4，pperson.buffer[9]</span><br><span class=\"line\">.text:00401110                 mov     ecx, 4</span><br><span class=\"line\">.text:00401115                 imul    edx, ecx, 0</span><br><span class=\"line\">.text:00401118                 mov     eax, [ebp+edx-28h] ; eax=[ebp-2Ch+4+0*4]</span><br><span class=\"line\">.text:0040111C                 push    eax             ; 参数3，pperson.buffer[0]</span><br><span class=\"line\">.text:0040111D                 mov     ecx, [ebp-2Ch]</span><br><span class=\"line\">.text:00401120                 push    ecx             ; 参数2，person.count</span><br><span class=\"line\">.text:00401121                 push    offset Format   ; &quot;%d %d %d&quot;</span><br><span class=\"line\">.text:00401126                 call    sub_401040      ; 调用printf函数</span><br><span class=\"line\">.text:0040112B                 add     esp, 10h</span><br><span class=\"line\">.text:0040112E                 xor     eax, eax</span><br><span class=\"line\">.text:00401130                 pop     edi</span><br><span class=\"line\">.text:00401131                 pop     esi</span><br><span class=\"line\">.text:00401132                 mov     esp, ebp</span><br><span class=\"line\">.text:00401134                 pop     ebp</span><br><span class=\"line\">.text:00401135                 retn</span><br><span class=\"line\">.text:00401135 _main           endp\t</span><br><span class=\"line\"></span><br><span class=\"line\">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  char v4[44]; // [esp+8h] [ebp-84h] BYREF</span><br><span class=\"line\">  char v5[44]; // [esp+34h] [ebp-58h] BYREF</span><br><span class=\"line\">  char v6[44]; // [esp+60h] [ebp-2Ch] BYREF</span><br><span class=\"line\"></span><br><span class=\"line\">  qmemcpy(v5, (const void *)sub_401080(v4), sizeof(v5));</span><br><span class=\"line\">  qmemcpy(v6, v5, sizeof(v6));</span><br><span class=\"line\">  sub_401040(&quot;%d %d %d&quot;, v6[0]);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码演示了函数返回对象的全过程。在调用getPerson前，编译器将在main()函数中申请的返回对象的首地址作为参数压栈，在函数getPerson调用结束后进行数据复制，将getPerson函数中定义的局部对象person的数据复制到这个返回对象的空间中，再将这个返回的对象复制给目标对象person，从而达到返回对象的目的。</p>\n<p>因为在这个示例中不存在函数返回后为对象的引用赋值，所以这里的返回对象是临时存在的，也就是C++中的临时对象，作用域仅限于单条语句。</p>\n<p><strong>为什么会产生这个临时对象呢？</strong></p>\n<p>因为调用返回对象的函数时，C++程序员可能采用这类写法，如getPerson().count，这只是针对返回对象的操作，而此时函数已经退出，其栈帧也被关闭了。函数退出后去操作局部对象显然不合适，因此只能由函数的调用方准备空间，建立临时对象，然后将函数中的局部对象复制给临时对象，再把这个临时对象交给调用方去操作。本例中的person &#x3D; getPerson()；是个赋值运算，因为赋值时getPerson函数已经退出，所以栈空间也关闭了。同理，person不能直接和函数内局部对象做赋值运算，因此需要临时对象记录返回值之后再参与赋值。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>当对象结构简单、体积小时，函数间的对象传递直接使用eax和edx保存对象中的内容。当对象体积过大，结构复杂时，寄存器就明显不够用了，于是编译器在开发人员不知情的情况下，偷偷给函数加上一个参数，将其作为返回值。传递参数对象时，存在一次复制过程，简单的对象直接按成员顺序执行push指令传参，复杂的对象则使用重复前缀的串操作指令rep movs，其edi被设置为栈顶。在访问对象成员时，寻址方式颇为特别，使用的是寄存器相对间接访问方式。这种访问方式可以作为识别对象的必要条件，但是还须考察成员类型。如果类型一致，则应优先考虑是数组的访问。因为在数组的下标访问时，编译器也可能采用寄存器相对间接访问方式，如a[i]，当i为常量时就会出现寄存器相对间接访问方式。当对象在栈内时，其首地址表示为ebp±n或者esp + n，其中n为立即数，而编译器计算对象成员的地址为对象首地址+成员偏移量，这个偏移量值是编译器在编译过程中确定的，视为常量值，结合上式，对象成员的地址表达为ebp ± n + offset或者esp + n + offset，其中n和offset（成员偏移量）皆为常量，符合常量折叠的优化条件，于是在编译时可计算出N &#x3D; n±offset，所以在分析的时候，我们只能看到ebp±N或者esp + N。</p>\n","text":"结构体和类在C++中，结构体和类都具有构造函数、析构函数和成员函数，两者只有一个区别：结构体的访问控制默认为public，而类的默认访问控制是private。对...","permalink":"/post/C++逆向——类","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB\"><span class=\"toc-text\">结构体和类</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">类与对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80\"><span class=\"toc-text\">对象的内存布局</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E7%B1%BB\"><span class=\"toc-text\">空类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#this%E6%8C%87%E9%92%88\"><span class=\"toc-text\">this指针</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98\"><span class=\"toc-text\">访问类对象的数据成员</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98\"><span class=\"toc-text\">静态数据成员</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E4%B8%8E%E6%99%AE%E9%80%9A%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98\"><span class=\"toc-text\">在成员函数中使用静态数据成员与普通数据成员</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">对象作为函数参数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">对象作为函数的参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%AB%E6%9C%89%E6%95%B0%E7%BB%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BC%A0%E5%8F%82\"><span class=\"toc-text\">含有数组数据成员的对象传参</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">深拷贝数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E7%BD%AE%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0\"><span class=\"toc-text\">设置引用计数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">对象作为返回值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC-1\"><span class=\"toc-text\">对象作为返回值</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol>","author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"构造函数和析构函数","uid":"da3425ec82161418a9e220cbb5402aa8","slug":"C++逆向——构造函数","date":"2023-02-08T11:47:12.000Z","updated":"2025-06-07T16:11:40.927Z","comments":true,"path":"api/articles/C++逆向——构造函数.json","keywords":null,"cover":[],"text":"构造函数与析构函数是类重要的组成部分，在类中起到至关重要的作用。构造函数常用来完成对象生成时的数据初始化工作，而析构函数则常用于在对象销毁时释放对象申请的资源。...","permalink":"/post/C++逆向——构造函数","photos":[],"count_time":{"symbolsCount":"30k","symbolsTime":"27 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"IDA添加结构体","uid":"d90627d53e222069704f901ed1b80995","slug":"IDA添加结构体","date":"2022-06-09T08:49:43.000Z","updated":"2025-06-09T10:16:41.620Z","comments":true,"path":"api/articles/IDA添加结构体.json","keywords":null,"cover":[],"text":"导入头文件方法①首先菜单栏选择File -> Load File -> Parse C Header file（Ctrl+F9）然后导入结构体文件（xxx.h）...","permalink":"/post/IDA添加结构体","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":9,"path":"api/tags/逆向.json"},{"name":"IDA使用","slug":"IDA使用","count":1,"path":"api/tags/IDA使用.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}