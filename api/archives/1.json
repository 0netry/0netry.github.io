{"total":35,"pageSize":12,"pageCount":3,"data":[{"title":"Windows动态反调试技术（一）","uid":"744ee437e256eacc7e89be203fb836fd","slug":"Windows动态反调试技术（一）","date":"2025-07-09T13:39:34.000Z","updated":"2025-06-09T21:26:29.686Z","comments":true,"path":"api/articles/Windows动态反调试技术（一）.json","keywords":null,"cover":[],"text":"异常SetUnhandledExceptionFilter()进程中发生异常时，若SEH未处理或注册的SEH根本不存在，此时会调用执行系统的kernel32!U...","permalink":"/post/Windows动态反调试技术（一）","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":14,"path":"api/tags/逆向.json"},{"name":"Windows动态反调试技术","slug":"Windows动态反调试技术","count":2,"path":"api/tags/Windows动态反调试技术.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"Windows动态反调试技术（二）","uid":"bd414604d17df76b597f4081d3f02f14","slug":"Windows动态反调试技术（二）","date":"2025-06-11T13:05:26.000Z","updated":"2025-06-09T21:26:58.273Z","comments":true,"path":"api/articles/Windows动态反调试技术（二）.json","keywords":null,"cover":[],"text":"单步执行TF值设置为1时，CPU将进入单步执行（Single Step）模式。单步执行模式中，CPU执行1条指令后即触发1个EXCEPTION_SINGLE_S...","permalink":"/post/Windows动态反调试技术（二）","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":14,"path":"api/tags/逆向.json"},{"name":"Windows动态反调试技术","slug":"Windows动态反调试技术","count":2,"path":"api/tags/Windows动态反调试技术.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"某白加黑木马样本分析","uid":"d8609f7faf5edcbbc1a1648becebe73e","slug":"某白加黑木马样本分析","date":"2025-05-28T05:39:13.000Z","updated":"2025-06-05T12:27:57.863Z","comments":true,"path":"api/articles/某白加黑木马样本分析.json","keywords":null,"cover":[],"text":"一、概述样本基本信息（4个文件）样本名称：a5c0Lm.exe、ClassicExplorer32.dll、ffff.pol、ffff.lop MD5：ae10...","permalink":"/post/某白加黑木马样本分析","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"恶意样本","slug":"恶意样本","count":2,"path":"api/tags/恶意样本.json"},{"name":"白加黑技术","slug":"白加黑技术","count":1,"path":"api/tags/白加黑技术.json"},{"name":"逆向","slug":"逆向","count":14,"path":"api/tags/逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"Ubuntu安装peda、pwndbg、gef","uid":"cbeedf2045c391671dd49388aa7a121e","slug":"Ubuntu安装peda、pwndbg、gef","date":"2024-03-09T13:01:38.000Z","updated":"2025-06-09T13:10:48.873Z","comments":true,"path":"api/articles/Ubuntu安装peda、pwndbg、gef.json","keywords":null,"cover":[],"text":"pedaPEDA（Python Exploit Development Assistance for GDB）是一个强大的GDB插件。它提供了更多功能，如高亮显...","permalink":"/post/Ubuntu安装peda、pwndbg、gef","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"linux逆向工具","slug":"linux逆向工具","count":1,"path":"api/tags/linux逆向工具.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"恶意iso文件分析","uid":"0fa9719b9833354b768a1db954a5b0e7","slug":"恶意iso文件分析","date":"2023-04-08T02:22:11.000Z","updated":"2025-06-05T12:30:07.178Z","comments":true,"path":"api/articles/恶意iso文件分析.json","keywords":null,"cover":[],"text":"iso信息文件信息 文件内容 doc文档doc加密数据 WinWord.exe即Concept Note Strategic Dialog Version 30...","permalink":"/post/恶意iso文件分析","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"恶意样本","slug":"恶意样本","count":2,"path":"api/tags/恶意样本.json"},{"name":"逆向","slug":"逆向","count":14,"path":"api/tags/逆向.json"},{"name":"iso文件","slug":"iso文件","count":1,"path":"api/tags/iso文件.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"C++逆向——虚基类指针&&虚基类表 vs 虚函数指针&&虚函数表","uid":"c3ef1bdebe04666f3d364f093474c8aa","slug":"C++逆向——虚基类指针&&虚基类表 vs 虚函数指针&&虚函数表","date":"2023-03-12T11:53:28.000Z","updated":"2025-06-07T18:59:17.248Z","comments":true,"path":"api/articles/C++逆向——虚基类指针&&虚基类表 vs 虚函数指针&&虚函数表.json","keywords":null,"cover":[],"text":"一、虚继承产生的虚基类表指针和虚基类表如下代码：写一个棱形继承，父类Father，子类Son1和Son2虚继承Base，又来一个类Grandson继承Son1和...","permalink":"/post/C++逆向——虚基类指针&&虚基类表 vs 虚函数指针&&虚函数表","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"C++逆向——全局类对象","uid":"1329f4c6c2b96d3a354509a097c90b2b","slug":"C++逆向——全局类对象","date":"2023-03-09T13:44:59.000Z","updated":"2025-06-07T18:51:53.810Z","comments":true,"path":"api/articles/C++逆向——全局类对象.json","keywords":null,"cover":[],"text":"全局对象 生命周期: main 开始之前构造 ,main结束之后析构 因此在main函数之前初始化,构造属于初始化,因此在Inititem（c++) 中构造 先...","permalink":"/post/C++逆向——全局类对象","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"C++逆向——抽象类与虚继承","uid":"0eecfedfebb040c00fe24e77372fb210","slug":"C++逆向——抽象类与虚继承","date":"2023-03-03T08:12:53.000Z","updated":"2025-06-07T18:34:32.830Z","comments":true,"path":"api/articles/C++逆向——抽象类与虚继承.json","keywords":null,"cover":[],"text":"抽象类在编码过程中，抽象类的定义需要配合虚函数使用。在虚函数的声明结尾处添加“=0”，这种虚函数被称为纯虚函数。纯虚函数是一个没有实现只有声明的函数，它的存在就...","permalink":"/post/C++逆向——抽象类与虚继承","photos":[],"count_time":{"symbolsCount":"48k","symbolsTime":"44 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"C++逆向——多重继承","uid":"9301d0d9fdad61b6c1164e4bbd50c3da","slug":"C++逆向——多重继承","date":"2023-02-17T07:22:42.000Z","updated":"2025-06-07T18:30:39.668Z","comments":true,"path":"api/articles/C++逆向——多重继承.json","keywords":null,"cover":[],"text":"当子类拥有多个父类（如类C继承自类A同时也继承自类B）时，便构成了多重继承关系。在多重继承的情况下，子类继承的父类变为多个，但其结构与单一继承相似。 多重继承类...","permalink":"/post/C++逆向——多重继承","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"17 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"C++逆向——识别类和类之间的关系","uid":"d75c57bec22710c7148f63c849522585","slug":"C++逆向——识别类和类之间的关系","date":"2023-02-15T12:11:27.000Z","updated":"2025-06-07T18:22:43.367Z","comments":true,"path":"api/articles/C++逆向——识别类和类之间的关系.json","keywords":null,"cover":[],"text":"在C++的继承关系中，子类具备父类所有成员数据和成员函数。子 类 对 象 可 以 直 接 使 用 父 类 中 声 明 为 公 有 （ public ） 和 保 ...","permalink":"/post/C++逆向——识别类和类之间的关系","photos":[],"count_time":{"symbolsCount":"70k","symbolsTime":"1:04"},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"虚函数","uid":"cff45971697c57c78d8a68c46a85aef2","slug":"C++逆向——虚函数","date":"2023-02-13T06:11:19.000Z","updated":"2025-06-07T18:09:49.856Z","comments":true,"path":"api/articles/C++逆向——虚函数.json","keywords":null,"cover":[],"text":"虚函数是面向对象程序设计的关键组成部分。对于具有虚函数的类而言，构造函数和析构函数的识别过程更加简单。而且，在类中定义虚函数之后，如果没有提供构造函数，编译器会...","permalink":"/post/C++逆向——虚函数","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"C++逆向——析构函数","uid":"b0a53c23c95ed95e45a9b9b266d30456","slug":"C++逆向——析构函数","date":"2023-02-09T01:22:15.000Z","updated":"2025-06-07T18:07:06.600Z","comments":true,"path":"api/articles/C++逆向——析构函数.json","keywords":null,"cover":[],"text":"析构函数的出现时机对象何时被销毁呢？根据对象所在的作用域，当程序流程执行到作用域结束处时，会释放该作用域内的所有对象，在释放的过程中会调用对象的析构函数。析构函...","permalink":"/post/C++逆向——析构函数","photos":[],"count_time":{"symbolsCount":"36k","symbolsTime":"33 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}