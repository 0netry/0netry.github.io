{"name":"c++逆向","slug":"c-逆向","count":9,"postlist":[{"title":"C++逆向——虚基类指针&&虚基类表 vs 虚函数指针&&虚函数表","uid":"c3ef1bdebe04666f3d364f093474c8aa","slug":"C++逆向——虚基类指针&&虚基类表 vs 虚函数指针&&虚函数表","date":"2023-03-12T11:53:28.000Z","updated":"2025-06-07T18:59:17.248Z","comments":true,"path":"api/articles/C++逆向——虚基类指针&&虚基类表 vs 虚函数指针&&虚函数表.json","keywords":null,"cover":[],"text":"一、虚继承产生的虚基类表指针和虚基类表如下代码：写一个棱形继承，父类Father，子类Son1和Son2虚继承Base，又来一个类Grandson继承Son1和...","permalink":"/post/C++逆向——虚基类指针&&虚基类表 vs 虚函数指针&&虚函数表","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"C++逆向——全局类对象","uid":"1329f4c6c2b96d3a354509a097c90b2b","slug":"C++逆向——全局类对象","date":"2023-03-09T13:44:59.000Z","updated":"2025-06-07T18:51:53.810Z","comments":true,"path":"api/articles/C++逆向——全局类对象.json","keywords":null,"cover":[],"text":"全局对象 生命周期: main 开始之前构造 ,main结束之后析构 因此在main函数之前初始化,构造属于初始化,因此在Inititem（c++) 中构造 先...","permalink":"/post/C++逆向——全局类对象","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"C++逆向——抽象类与虚继承","uid":"0eecfedfebb040c00fe24e77372fb210","slug":"C++逆向——抽象类与虚继承","date":"2023-03-03T08:12:53.000Z","updated":"2025-06-07T18:34:32.830Z","comments":true,"path":"api/articles/C++逆向——抽象类与虚继承.json","keywords":null,"cover":[],"text":"抽象类在编码过程中，抽象类的定义需要配合虚函数使用。在虚函数的声明结尾处添加“=0”，这种虚函数被称为纯虚函数。纯虚函数是一个没有实现只有声明的函数，它的存在就...","permalink":"/post/C++逆向——抽象类与虚继承","photos":[],"count_time":{"symbolsCount":"48k","symbolsTime":"44 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"C++逆向——多重继承","uid":"9301d0d9fdad61b6c1164e4bbd50c3da","slug":"C++逆向——多重继承","date":"2023-02-17T07:22:42.000Z","updated":"2025-06-07T18:30:39.668Z","comments":true,"path":"api/articles/C++逆向——多重继承.json","keywords":null,"cover":[],"text":"当子类拥有多个父类（如类C继承自类A同时也继承自类B）时，便构成了多重继承关系。在多重继承的情况下，子类继承的父类变为多个，但其结构与单一继承相似。 多重继承类...","permalink":"/post/C++逆向——多重继承","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"17 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"C++逆向——识别类和类之间的关系","uid":"d75c57bec22710c7148f63c849522585","slug":"C++逆向——识别类和类之间的关系","date":"2023-02-15T12:11:27.000Z","updated":"2025-06-07T18:22:43.367Z","comments":true,"path":"api/articles/C++逆向——识别类和类之间的关系.json","keywords":null,"cover":[],"text":"在C++的继承关系中，子类具备父类所有成员数据和成员函数。子 类 对 象 可 以 直 接 使 用 父 类 中 声 明 为 公 有 （ public ） 和 保 ...","permalink":"/post/C++逆向——识别类和类之间的关系","photos":[],"count_time":{"symbolsCount":"70k","symbolsTime":"1:04"},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"虚函数","uid":"cff45971697c57c78d8a68c46a85aef2","slug":"C++逆向——虚函数","date":"2023-02-13T06:11:19.000Z","updated":"2025-06-07T18:09:49.856Z","comments":true,"path":"api/articles/C++逆向——虚函数.json","keywords":null,"cover":[],"text":"虚函数是面向对象程序设计的关键组成部分。对于具有虚函数的类而言，构造函数和析构函数的识别过程更加简单。而且，在类中定义虚函数之后，如果没有提供构造函数，编译器会...","permalink":"/post/C++逆向——虚函数","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"C++逆向——析构函数","uid":"b0a53c23c95ed95e45a9b9b266d30456","slug":"C++逆向——析构函数","date":"2023-02-09T01:22:15.000Z","updated":"2025-06-07T18:07:06.600Z","comments":true,"path":"api/articles/C++逆向——析构函数.json","keywords":null,"cover":[],"text":"析构函数的出现时机对象何时被销毁呢？根据对象所在的作用域，当程序流程执行到作用域结束处时，会释放该作用域内的所有对象，在释放的过程中会调用对象的析构函数。析构函...","permalink":"/post/C++逆向——析构函数","photos":[],"count_time":{"symbolsCount":"36k","symbolsTime":"33 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"构造函数和析构函数","uid":"da3425ec82161418a9e220cbb5402aa8","slug":"C++逆向——构造函数","date":"2023-02-08T11:47:12.000Z","updated":"2025-06-07T16:11:40.927Z","comments":true,"path":"api/articles/C++逆向——构造函数.json","keywords":null,"cover":[],"text":"构造函数与析构函数是类重要的组成部分，在类中起到至关重要的作用。构造函数常用来完成对象生成时的数据初始化工作，而析构函数则常用于在对象销毁时释放对象申请的资源。...","permalink":"/post/C++逆向——构造函数","photos":[],"count_time":{"symbolsCount":"30k","symbolsTime":"27 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"类","uid":"ad77af543ae71f35c74ef1805fcae1ac","slug":"C++逆向——类","date":"2023-02-07T05:38:12.000Z","updated":"2025-06-07T15:51:48.097Z","comments":true,"path":"api/articles/C++逆向——类.json","keywords":null,"cover":[],"text":"结构体和类在C++中，结构体和类都具有构造函数、析构函数和成员函数，两者只有一个区别：结构体的访问控制默认为public，而类的默认访问控制是private。对...","permalink":"/post/C++逆向——类","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}