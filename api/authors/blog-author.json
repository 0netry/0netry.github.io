{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}},"post_list":[{"title":"某白加黑木马样本分析","uid":"d8609f7faf5edcbbc1a1648becebe73e","slug":"某白加黑木马样本分析","date":"2025-05-28T05:39:13.000Z","updated":"2025-06-05T12:27:57.863Z","comments":true,"path":"api/articles/某白加黑木马样本分析.json","keywords":null,"cover":[],"text":"一、概述样本基本信息（4个文件）样本名称：a5c0Lm.exe、ClassicExplorer32.dll、ffff.pol、ffff.lop MD5：ae10...","permalink":"/post/某白加黑木马样本分析","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"恶意样本","slug":"恶意样本","count":2,"path":"api/tags/恶意样本.json"},{"name":"白加黑技术","slug":"白加黑技术","count":1,"path":"api/tags/白加黑技术.json"},{"name":"逆向","slug":"逆向","count":9,"path":"api/tags/逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"恶意iso文件分析","uid":"0fa9719b9833354b768a1db954a5b0e7","slug":"恶意iso文件分析","date":"2023-04-08T02:22:11.000Z","updated":"2025-06-05T12:30:07.178Z","comments":true,"path":"api/articles/恶意iso文件分析.json","keywords":null,"cover":[],"text":"iso信息文件信息 文件内容 doc文档doc加密数据 WinWord.exe即Concept Note Strategic Dialog Version 30...","permalink":"/post/恶意iso文件分析","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"恶意样本","slug":"恶意样本","count":2,"path":"api/tags/恶意样本.json"},{"name":"逆向","slug":"逆向","count":9,"path":"api/tags/逆向.json"},{"name":"iso文件","slug":"iso文件","count":1,"path":"api/tags/iso文件.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"C++逆向——虚基类指针&&虚基类表 vs 虚函数指针&&虚函数表","uid":"c3ef1bdebe04666f3d364f093474c8aa","slug":"C++逆向——虚基类指针&&虚基类表 vs 虚函数指针&&虚函数表","date":"2023-03-12T11:53:28.000Z","updated":"2025-06-07T18:59:17.248Z","comments":true,"path":"api/articles/C++逆向——虚基类指针&&虚基类表 vs 虚函数指针&&虚函数表.json","keywords":null,"cover":[],"text":"一、虚继承产生的虚基类表指针和虚基类表如下代码：写一个棱形继承，父类Father，子类Son1和Son2虚继承Base，又来一个类Grandson继承Son1和...","permalink":"/post/C++逆向——虚基类指针&&虚基类表 vs 虚函数指针&&虚函数表","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"C++逆向——全局类对象","uid":"1329f4c6c2b96d3a354509a097c90b2b","slug":"C++逆向——全局类对象","date":"2023-03-09T13:44:59.000Z","updated":"2025-06-07T18:51:53.810Z","comments":true,"path":"api/articles/C++逆向——全局类对象.json","keywords":null,"cover":[],"text":"全局对象 生命周期: main 开始之前构造 ,main结束之后析构 因此在main函数之前初始化,构造属于初始化,因此在Inititem（c++) 中构造 先...","permalink":"/post/C++逆向——全局类对象","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"C++逆向——抽象类与虚继承","uid":"0eecfedfebb040c00fe24e77372fb210","slug":"C++逆向——抽象类与虚继承","date":"2023-03-03T08:12:53.000Z","updated":"2025-06-07T18:34:32.830Z","comments":true,"path":"api/articles/C++逆向——抽象类与虚继承.json","keywords":null,"cover":[],"text":"抽象类在编码过程中，抽象类的定义需要配合虚函数使用。在虚函数的声明结尾处添加“=0”，这种虚函数被称为纯虚函数。纯虚函数是一个没有实现只有声明的函数，它的存在就...","permalink":"/post/C++逆向——抽象类与虚继承","photos":[],"count_time":{"symbolsCount":"48k","symbolsTime":"44 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"C++逆向——多重继承","uid":"9301d0d9fdad61b6c1164e4bbd50c3da","slug":"C++逆向——多重继承","date":"2023-02-17T07:22:42.000Z","updated":"2025-06-07T18:30:39.668Z","comments":true,"path":"api/articles/C++逆向——多重继承.json","keywords":null,"cover":[],"text":"当子类拥有多个父类（如类C继承自类A同时也继承自类B）时，便构成了多重继承关系。在多重继承的情况下，子类继承的父类变为多个，但其结构与单一继承相似。 多重继承类...","permalink":"/post/C++逆向——多重继承","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"17 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"C++逆向——识别类和类之间的关系","uid":"d75c57bec22710c7148f63c849522585","slug":"C++逆向——识别类和类之间的关系","date":"2023-02-15T12:11:27.000Z","updated":"2025-06-07T18:22:43.367Z","comments":true,"path":"api/articles/C++逆向——识别类和类之间的关系.json","keywords":null,"cover":[],"text":"在C++的继承关系中，子类具备父类所有成员数据和成员函数。子 类 对 象 可 以 直 接 使 用 父 类 中 声 明 为 公 有 （ public ） 和 保 ...","permalink":"/post/C++逆向——识别类和类之间的关系","photos":[],"count_time":{"symbolsCount":"70k","symbolsTime":"1:04"},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"虚函数","uid":"cff45971697c57c78d8a68c46a85aef2","slug":"C++逆向——虚函数","date":"2023-02-13T06:11:19.000Z","updated":"2025-06-07T18:09:49.856Z","comments":true,"path":"api/articles/C++逆向——虚函数.json","keywords":null,"cover":[],"text":"虚函数是面向对象程序设计的关键组成部分。对于具有虚函数的类而言，构造函数和析构函数的识别过程更加简单。而且，在类中定义虚函数之后，如果没有提供构造函数，编译器会...","permalink":"/post/C++逆向——虚函数","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"C++逆向——析构函数","uid":"b0a53c23c95ed95e45a9b9b266d30456","slug":"C++逆向——析构函数","date":"2023-02-09T01:22:15.000Z","updated":"2025-06-07T18:07:06.600Z","comments":true,"path":"api/articles/C++逆向——析构函数.json","keywords":null,"cover":[],"text":"析构函数的出现时机对象何时被销毁呢？根据对象所在的作用域，当程序流程执行到作用域结束处时，会释放该作用域内的所有对象，在释放的过程中会调用对象的析构函数。析构函...","permalink":"/post/C++逆向——析构函数","photos":[],"count_time":{"symbolsCount":"36k","symbolsTime":"33 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"构造函数和析构函数","uid":"da3425ec82161418a9e220cbb5402aa8","slug":"C++逆向——构造函数","date":"2023-02-08T11:47:12.000Z","updated":"2025-06-07T16:11:40.927Z","comments":true,"path":"api/articles/C++逆向——构造函数.json","keywords":null,"cover":[],"text":"构造函数与析构函数是类重要的组成部分，在类中起到至关重要的作用。构造函数常用来完成对象生成时的数据初始化工作，而析构函数则常用于在对象销毁时释放对象申请的资源。...","permalink":"/post/C++逆向——构造函数","photos":[],"count_time":{"symbolsCount":"30k","symbolsTime":"27 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"类","uid":"ad77af543ae71f35c74ef1805fcae1ac","slug":"C++逆向——类","date":"2023-02-07T05:38:12.000Z","updated":"2025-06-07T15:51:48.097Z","comments":true,"path":"api/articles/C++逆向——类.json","keywords":null,"cover":[],"text":"结构体和类在C++中，结构体和类都具有构造函数、析构函数和成员函数，两者只有一个区别：结构体的访问控制默认为public，而类的默认访问控制是private。对...","permalink":"/post/C++逆向——类","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[],"tags":[{"name":"c++逆向","slug":"c-逆向","count":9,"path":"api/tags/c-逆向.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"IDA添加结构体","uid":"d90627d53e222069704f901ed1b80995","slug":"IDA添加结构体","date":"2022-06-09T08:49:43.000Z","updated":"2025-06-09T10:16:41.620Z","comments":true,"path":"api/articles/IDA添加结构体.json","keywords":null,"cover":[],"text":"导入头文件方法①首先菜单栏选择File -> Load File -> Parse C Header file（Ctrl+F9）然后导入结构体文件（xxx.h）...","permalink":"/post/IDA添加结构体","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":9,"path":"api/tags/逆向.json"},{"name":"IDA使用","slug":"IDA使用","count":1,"path":"api/tags/IDA使用.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"UPX脱壳实战——结合逆向工程核心原理","uid":"d804751ae060ee6bddee780d4be7bc78","slug":"UPX脱壳实战——结合逆向工程核心原理","date":"2022-05-11T03:23:55.000Z","updated":"2025-06-05T15:24:37.476Z","comments":true,"path":"api/articles/UPX脱壳实战——结合逆向工程核心原理.json","keywords":null,"cover":[],"text":"用《逆向工程核心原理》这本书中的notepad_upx.exe来实验 未加壳的oep 单步跟踪法脱壳的方法有很多，先来讲脱壳方法中最基础的单步跟踪法。单步跟踪法...","permalink":"/post/UPX脱壳实战——结合逆向工程核心原理","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"逆向工程核心原理","slug":"逆向工程核心原理","count":7,"path":"api/tags/逆向工程核心原理.json"},{"name":"加壳与脱壳","slug":"加壳与脱壳","count":1,"path":"api/tags/加壳与脱壳.json"},{"name":"iat修复","slug":"iat修复","count":1,"path":"api/tags/iat修复.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"PE文件——基址重定位","uid":"79cf73108f662b9d6b8f237086d2463b","slug":"PE文件——基址重定位","date":"2022-05-03T14:33:53.000Z","updated":"2025-06-09T08:38:09.203Z","comments":true,"path":"api/articles/PE文件——基址重定位.json","keywords":null,"cover":[],"text":"当链接器生成一个PE文件时，会假设这个文件在执行时被装载到默认的基地址处，并把code和data的相关地址都写入PE文件。如果载入时将默认的值作为基地址载入，则...","permalink":"/post/PE文件——基址重定位","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":9,"path":"api/tags/逆向.json"},{"name":"PE文件","slug":"PE文件","count":3,"path":"api/tags/PE文件.json"},{"name":"基址重定位","slug":"基址重定位","count":1,"path":"api/tags/基址重定位.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"编译器扩展的SEH","uid":"aa231c03641d31bfb6874bcdc873cd1e","slug":"编译器扩展的SEH","date":"2022-04-25T13:28:03.000Z","updated":"2025-06-08T15:42:15.590Z","comments":true,"path":"api/articles/编译器扩展的SEH.json","keywords":null,"cover":[],"text":"注：vc6++的异常处理函数为except_handler3，visual stdio的异常处理函数为except_handler4（具体见基于Visual S...","permalink":"/post/编译器扩展的SEH","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"24 mins."},"categories":[],"tags":[{"name":"Windows异常处理机制","slug":"Windows异常处理机制","count":2,"path":"api/tags/Windows异常处理机制.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"SEH","uid":"b42df1b10b510ae71ca0bc4d234a8f72","slug":"SEH","date":"2022-04-20T08:19:17.000Z","updated":"2025-06-08T15:26:30.339Z","comments":true,"path":"api/articles/SEH.json","keywords":null,"cover":[],"text":"SEH是Windows操作系统提供的异常处理机制，在程序源代码中使用__try、__except、__finally关键字来具体实现。 初识SEH下面将通过一个...","permalink":"/post/SEH","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[],"tags":[{"name":"Windows异常处理机制","slug":"Windows异常处理机制","count":2,"path":"api/tags/Windows异常处理机制.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"TLS回调函数","uid":"66da80b7dfd28e13d279b8154dbcb5eb","slug":"TLS回调函数","date":"2022-04-15T07:23:02.000Z","updated":"2025-06-08T15:26:19.727Z","comments":true,"path":"api/articles/TLS回调函数.json","keywords":null,"cover":[],"text":"TLS回调函数TLS（Thread Local Storage，线程局部存储）回调函数常用于反调试 TLSTLS是各线程的独立的数据存储空间。使用TLS技术可在...","permalink":"/post/TLS回调函数","photos":[],"count_time":{"symbolsCount":"8.5k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":9,"path":"api/tags/逆向.json"},{"name":"TLS回调函数","slug":"TLS回调函数","count":1,"path":"api/tags/TLS回调函数.json"},{"name":"PE结构","slug":"PE结构","count":1,"path":"api/tags/PE结构.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"认识PEB","uid":"716452a8f7139876fcd7d9fc7c5bbc0e","slug":"认识PEB","date":"2022-04-09T14:10:54.000Z","updated":"2025-06-08T15:18:01.815Z","comments":true,"path":"api/articles/认识PEB.json","keywords":null,"cover":[],"text":"PEB（Process Environment Block，进程环境块） PEB存放进程信息的结构体。 PEB 结构体的定义PEB结构体成员使用Windbg调试...","permalink":"/post/认识PEB","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":9,"path":"api/tags/逆向.json"},{"name":"PEB","slug":"PEB","count":1,"path":"api/tags/PEB.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"认识TEB","uid":"cd812a002a8157c55aad5231f6135034","slug":"认识TEB","date":"2022-04-08T11:55:04.000Z","updated":"2025-06-08T15:09:36.776Z","comments":true,"path":"api/articles/认识TEB.json","keywords":null,"cover":[],"text":"TEB（Threat Environment Block，线程环境块） TEB指线程环境块，该结构体包含进程中运行线程的各种信息，进程中的每个线程都对应一个TE...","permalink":"/post/认识TEB","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":9,"path":"api/tags/逆向.json"},{"name":"TEB","slug":"TEB","count":1,"path":"api/tags/TEB.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"HotFix Hook","uid":"d3476856058b1cb70ed747b50ca39e21","slug":"HotFix Hook","date":"2022-03-28T03:12:13.000Z","updated":"2025-06-05T12:13:51.065Z","comments":true,"path":"api/articles/HotFix Hook.json","keywords":null,"cover":[],"text":"API代码修改技术的问题对于全局API钩取——基于Win10的隐藏notepad.exe练习——stealth2.cpp——NewCreateProcessA(...","permalink":"/post/HotFix Hook","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[],"tags":[{"name":"hook技术","slug":"hook技术","count":6,"path":"api/tags/hook技术.json"},{"name":"逆向工程核心原理","slug":"逆向工程核心原理","count":7,"path":"api/tags/逆向工程核心原理.json"},{"name":"API hook","slug":"API-hook","count":5,"path":"api/tags/API-hook.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"IRP Hook","uid":"ba14c8c55e36720dc30bd604d682a355","slug":"IRP Hook","date":"2022-03-27T07:18:13.000Z","updated":"2025-06-05T15:26:12.964Z","comments":true,"path":"api/articles/IRP Hook.json","keywords":null,"cover":[],"text":"3环与0环通信（常规方式）本篇介绍一下3环与0环通信的原理（常规方式），介绍与之相关的结构体，对象等，最后代码实现并模拟操作系统进行3环和0环的通信。 设备对象...","permalink":"/post/IRP Hook","photos":[],"count_time":{"symbolsCount":"34k","symbolsTime":"31 mins."},"categories":[],"tags":[{"name":"hook技术","slug":"hook技术","count":6,"path":"api/tags/hook技术.json"},{"name":"逆向工程核心原理","slug":"逆向工程核心原理","count":7,"path":"api/tags/逆向工程核心原理.json"},{"name":"API hook","slug":"API-hook","count":5,"path":"api/tags/API-hook.json"},{"name":"IRP","slug":"IRP","count":1,"path":"api/tags/IRP.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"SSDT Hook","uid":"6b2dac661e4ecb3d25144597b91ee96f","slug":"SSDT Hook","date":"2022-03-26T11:33:07.000Z","updated":"2025-06-05T15:27:05.221Z","comments":true,"path":"api/articles/SSDT Hook.json","keywords":null,"cover":[],"text":"内核态代码只能被用户态的SYSCALL、SYSENTER或INT 0x2E指令来访问 程序进入0环后，有一个保存现场的过程，会将3环的各种寄存器都保存到一个叫做...","permalink":"/post/SSDT Hook","photos":[],"count_time":{"symbolsCount":"28k","symbolsTime":"25 mins."},"categories":[],"tags":[{"name":"hook技术","slug":"hook技术","count":6,"path":"api/tags/hook技术.json"},{"name":"逆向工程核心原理","slug":"逆向工程核心原理","count":7,"path":"api/tags/逆向工程核心原理.json"},{"name":"API hook","slug":"API-hook","count":5,"path":"api/tags/API-hook.json"},{"name":"SSDT","slug":"SSDT","count":1,"path":"api/tags/SSDT.json"},{"name":"系统调用","slug":"系统调用","count":1,"path":"api/tags/系统调用.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"IAT Hook","uid":"0f25dc3ea7a3ffec9ce07cef8295e4e2","slug":"IAT Hook","date":"2022-03-25T02:23:09.000Z","updated":"2025-06-05T12:20:03.574Z","comments":true,"path":"api/articles/IAT Hook.json","keywords":null,"cover":[],"text":"IAT Hook前置知识通过注入DLL文件来钩取某个API，DLL文件注入目标进程后，修改IAT来更改进程中调用的特定API功能。 API功能 kernel32...","permalink":"/post/IAT Hook","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"hook技术","slug":"hook技术","count":6,"path":"api/tags/hook技术.json"},{"name":"逆向工程核心原理","slug":"逆向工程核心原理","count":7,"path":"api/tags/逆向工程核心原理.json"},{"name":"API hook","slug":"API-hook","count":5,"path":"api/tags/API-hook.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"inline Hook","uid":"ef0903e74e5233a2be57edee3f37a5dc","slug":"inline-Hook","date":"2022-03-24T09:39:13.000Z","updated":"2025-06-04T08:36:57.256Z","comments":true,"path":"api/articles/inline-Hook.json","keywords":null,"cover":null,"text":"原理程序在编译链接后成了二进制代码，我们可以找到需要Hook的函数的地址，然后把这个函数在内存中的二进制代码改为一个JMP指令，令其跳转到执行我们自己构造的函数...","permalink":"/post/inline-Hook","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"24 mins."},"categories":[],"tags":[{"name":"hook技术","slug":"hook技术","count":6,"path":"api/tags/hook技术.json"},{"name":"逆向工程核心原理","slug":"逆向工程核心原理","count":7,"path":"api/tags/逆向工程核心原理.json"},{"name":"API hook","slug":"API-hook","count":5,"path":"api/tags/API-hook.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"消息Hook","uid":"f1607dee380ae8a16588d94dd0edba33","slug":"消息Hook","date":"2022-03-20T05:39:13.000Z","updated":"2025-06-05T12:25:59.568Z","comments":true,"path":"api/articles/消息Hook.json","keywords":null,"cover":[],"text":"概念Windows操作系统向用户提供GUI，它以事件驱动方式工作。在操作系统中借助键盘、鼠标，选择菜单、按钮，以及移动鼠标、改变窗口大小与位置等都是事件。发生这...","permalink":"/post/消息Hook","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"hook技术","slug":"hook技术","count":6,"path":"api/tags/hook技术.json"},{"name":"逆向工程核心原理","slug":"逆向工程核心原理","count":7,"path":"api/tags/逆向工程核心原理.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"VBScript教程","uid":"28df775ed85d265dbcba7f21d8f65afc","slug":"VBScript教程","date":"2022-03-15T14:05:53.000Z","updated":"2025-03-24T07:31:35.191Z","comments":true,"path":"api/articles/VBScript教程.json","keywords":null,"cover":null,"text":"VBScript 变量VBScript 变量VBScript 变量用于保存值或表达式。 变量可以有一个短的名称，如 x，或一个更具描述性的名称，如 carnam...","permalink":"/post/VBScript教程","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"编程","slug":"编程","count":1,"path":"api/categories/编程.json"}],"tags":[{"name":"编程","slug":"编程","count":1,"path":"api/tags/编程.json"},{"name":"VBScript","slug":"VBScript","count":1,"path":"api/tags/VBScript.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"GitHub搭建自己的博客","uid":"f48f1848e82a474528d06090473058c1","slug":"GitHub搭建自己的博客","date":"2022-02-15T15:24:16.000Z","updated":"2025-06-04T10:15:10.501Z","comments":true,"path":"api/articles/GitHub搭建自己的博客.json","keywords":null,"cover":"/img/bigball.jpg","text":"安装Node.js根据自己的电脑安装对应的版本，安装选项全部默认，一路点击Next。 安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，...","permalink":"/post/GitHub搭建自己的博客","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"搭建博客","slug":"搭建博客","count":1,"path":"api/tags/搭建博客.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"PE解析——IAT","uid":"72108d70d9a862b742fe8e97b0c6b415","slug":"PE解析——IAT","date":"2021-12-23T11:51:51.000Z","updated":"2025-06-08T15:10:02.038Z","comments":true,"path":"api/articles/PE解析——IAT.json","keywords":null,"cover":[],"text":"IAT全称Import Address Table，即导入地址表 IMAGE_IMPORT_DESCRIPTOR结构体123456789101112131415...","permalink":"/post/PE解析——IAT","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":9,"path":"api/tags/逆向.json"},{"name":"PE文件","slug":"PE文件","count":3,"path":"api/tags/PE文件.json"},{"name":"IAT","slug":"IAT","count":1,"path":"api/tags/IAT.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"PE文件格式","uid":"cb93d0cd82726110c8a724aa5589f118","slug":"PE文件格式","date":"2021-12-21T12:42:30.000Z","updated":"2025-06-08T15:10:20.465Z","comments":true,"path":"api/articles/PE文件格式.json","keywords":null,"cover":[],"text":"PE文件种类 种类 主扩展名 可执行系列 EXE、SRC 库系列 DLL、OCX、CPL、DRV 驱动程序系列 SYS、VXD 对象文件系列 OBJ 严格来说，...","permalink":"/post/PE文件格式","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"逆向","slug":"逆向","count":9,"path":"api/tags/逆向.json"},{"name":"PE文件","slug":"PE文件","count":3,"path":"api/tags/PE文件.json"}],"author":{"name":"0netry","slug":"blog-author","avatar":"/img/tree.png","link":"/","description":"0与1只在一念之间","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}],"categories":1,"tags":2,"word_count":"514k","post_count":29}